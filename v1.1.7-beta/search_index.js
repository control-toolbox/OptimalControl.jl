var documenterSearchIndex = {"docs":
[{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<img width=\"800\" alt=\"juliaopt2024\" src=\"./assets/juliacon2024.jpg\">","category":"section"},{"location":"juliacon2024.html#Trajectory-optimisation-in-space-mechanics-with-Julia","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"","category":"section"},{"location":"juliacon2024.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Alesia-Herasimenka](https://www.uni.lu/snt-en/people/alesia-herasimenka)","page":"Trajectory optimisation in space mechanics with Julia","title":"Jean-Baptiste Caillau, Olivier Cots, Alesia Herasimenka","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil-lux.jpg\">","category":"section"},{"location":"juliacon2024.html#What-it's-about","page":"Trajectory optimisation in space mechanics with Julia","title":"What it's about","text":"Nonlinear optimal control of ODEs:\n\ng(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min\n\nsubject to\n\ndotx(t) = f(x(t) u(t))quad t in t_0 t_f\n\nplus boundary conditions, control and state constraints\n\nOur core interests: numerical & geometrical methods in control, applications","category":"section"},{"location":"juliacon2024.html#OptimalControl.jl-for-trajectory-optimisation","page":"Trajectory optimisation in space mechanics with Julia","title":"OptimalControl.jl for trajectory optimisation","text":"Basic example\nGoddard problem\nOrbit transfer","category":"section"},{"location":"juliacon2024.html#Wrap-up","page":"Trajectory optimisation in space mechanics with Julia","title":"Wrap up","text":"High level modelling of optimal control problems\nEfficient numerical resolution coupling direct and indirect methods\nCollection of examples","category":"section"},{"location":"juliacon2024.html#Future","page":"Trajectory optimisation in space mechanics with Julia","title":"Future","text":"New applications (biology, space mechanics, quantum mechanics and more)\nAdditional solvers: direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions!","category":"section"},{"location":"juliacon2024.html#control-toolbox.org","page":"Trajectory optimisation in space mechanics with Julia","title":"control-toolbox.org","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl\n\n<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"section"},{"location":"juliacon2024.html#Credits-(not-exhaustive!)","page":"Trajectory optimisation in space mechanics with Julia","title":"Credits (not exhaustive!)","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nMLStyle.jl","category":"section"},{"location":"juliacon2024.html#Acknowledgements","page":"Trajectory optimisation in space mechanics with Julia","title":"Acknowledgements","text":"Jean-Baptiste Caillau is partially funded by a France 2030 support managed by the Agence Nationale de la Recherche, under the reference ANR-23-PEIA-0004 (PDE-AI project).\n\n<img width=\"200\" alt=\"affiliations\" src=\"./assets/france-2030.png\">\n\n","category":"section"},{"location":"manual-model.html#manual-model","page":"Problem characteristics","title":"The optimal control problem object: structure and usage","text":"In this manual, we'll first recall the main functionalities you can use when working with an optimal control problem (OCP). This includes essential operations like:\n\nSolving an OCP: How to find the optimal solution for your defined problem.\nComputing flows from an OCP: Understanding the dynamics and trajectories derived from the optimal solution.\nPrinting an OCP: How to display a summary of your problem's definition.\n\nAfter covering these core functionalities, we'll delve into the structure of an OCP. Since an OCP is structured as a Model struct, we'll first explain how to access its underlying attributes, such as the problem's dynamics, costs, and constraints. Following this, we'll shift our focus to the simple properties inherent to an OCP, learning how to determine aspects like whether the problem:\n\nIs autonomous: Does its dynamics depend explicitly on time?\nHas a fixed or free initial/final time: Is the duration of the control problem predetermined or not?\n\n\n\nContent\n\nMain functionalities\nModel struct\nAttributes and properties\n\n","category":"section"},{"location":"manual-model.html#manual-model-main-functionalities","page":"Problem characteristics","title":"Main functionalities","text":"Let's define a basic optimal control problem.\n\nusing OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    x(t0) == x0\n    x(tf) == [0, 0]\n    ẋ(t)  == [v(t), u(t)]\n    0.5∫( u(t)^2 ) → min\nend\nnothing # hide\n\nTo print it, simply:\n\nocp\n\nWe can now solve the problem (for more details, visit the solve manual):\n\nusing NLPModelsIpopt\nsolve(ocp)\nnothing # hide\n\nYou can also compute flows (for more details, see the flow manual) from the optimal control problem, providing a control law in feedback form. The pseudo-Hamiltonian of this problem is\n\n    H(x p u) = p_q v + p_v u + p^0 u^2 2\n\nwhere p^0 = -1 since we are in the normal case. From the Pontryagin maximum principle, the maximising control is given in feedback form by\n\nu(x p) = p_v\n\nsince partial^2_uu H = p^0 = - 1  0. \n\nu = (x, p) -> p[2]          # control law in feedback form\n\nusing OrdinaryDiffEq        # needed to import numerical integrators\nf = Flow(ocp, u)            # compute the Hamiltonian flow function\n\np0 = [12, 6]                # initial covector solution\nxf, pf = f(t0, x0, p0, tf)  # flow from (x0, p0) at time t0 to tf\nxf                          # should be (0, 0)\n\nnote: Note\nA more advanced feature allows for the discretization of the optimal control problem. From the discretized version, you can obtain a Nonlinear Programming problem (or optimization problem) and solve it using any appropriate NLP solver. For more details, visit the NLP manipulation tutorial.","category":"section"},{"location":"manual-model.html#manual-model-struct","page":"Problem characteristics","title":"Model struct","text":"The optimal control problem ocp is a Model struct. \n\nEach field can be accessed directly (ocp.times, etc) or by a getter:\n\ntimes\nstate\ncontrol\nvariable\ndynamics\nobjective\nconstraints\ndefinition\nget_build_examodel\n\nFor instance, we can retrieve the times and definition values.\n\ntimes(ocp)\n\ndefinition(ocp)\n\nnote: Note\nWe refer to the CTModels documentation for more details about this struct and its fields.","category":"section"},{"location":"manual-model.html#manual-model-attributes","page":"Problem characteristics","title":"Attributes and properties","text":"Numerous attributes can be retrieved. To illustrate this, a more complex optimal control problem is defined.\n\nocp = @def begin\n    v = (w, tf) ∈ R²,   variable\n    s ∈ [0, tf],        time\n    q = (x, y) ∈ R²,    state\n    u ∈ R,              control\n    0 ≤ tf ≤ 2,         (1)\n    u(s) ≥ 0,           (cons_u)\n    x(s) + u(s) ≤ 10,   (cons_mixed)\n    w == 0\n    x(0) == -1\n    y(0) - tf == 0,     (cons_bound)\n    q(tf) == [0, 0]\n    q̇(s) == [y(s)+w, u(s)]\n    0.5∫( u(s)^2 ) → min\nend\nnothing # hide","category":"section"},{"location":"manual-model.html#Control,-state-and-variable","page":"Problem characteristics","title":"Control, state and variable","text":"You can access the name of the control, state, and variable, along with the names of their components and their dimensions.\n\nusing DataFrames\ndata = DataFrame(\n    Data=Vector{Symbol}(),\n    Name=Vector{String}(),\n    Components=Vector{Vector{String}}(), \n    Dimension=Vector{Int}(),\n)\n\n# control\npush!(data,(\n    :control,\n    control_name(ocp),\n    control_components(ocp),\n    control_dimension(ocp),\n))\n\n# state\npush!(data,(\n    :state,\n    state_name(ocp),\n    state_components(ocp),\n    state_dimension(ocp),\n))\n\n# variable\npush!(data,(\n    :variable,\n    variable_name(ocp),\n    variable_components(ocp),\n    variable_dimension(ocp),\n))\n\nnote: Note\nThe names of the components are used for instance when plotting the solution. See the plot manual.","category":"section"},{"location":"manual-model.html#Constraints","page":"Problem characteristics","title":"Constraints","text":"You can retrieve labelled constraints with the constraint function. The constraint(ocp, label) method returns a tuple of the form (type, f, lb, ub). The signature of the function f depends on the symbol type. For :boundary and :variable constraints, the signature is f(x0, xf, v) where x0 is the initial state, xf the final state and v the variable. For other constraints, the signature is f(t, x, u, v). Here, t represents time, x the state, u the control, and v the variable.\n\n(type, f, lb, ub) = constraint(ocp, :eq1)\nprintln(\"type: \", type)\nx0 = [0, 1]\nxf = [2, 3]\nv  = [1, 4]\nprintln(\"val: \", f(x0, xf, v))\nprintln(\"lb: \", lb)\nprintln(\"ub: \", ub)\n\n(type, f, lb, ub) = constraint(ocp, :cons_bound)\nprintln(\"type: \", type)\nprintln(\"val: \", f(x0, xf, v))\nprintln(\"lb: \", lb)\nprintln(\"ub: \", ub)\n\n(type, f, lb, ub) = constraint(ocp, :cons_u)\nprintln(\"type: \", type)\nt = 0\nx = [1, 2]\nu = 3\nprintln(\"val: \", f(t, x, u, v))\nprintln(\"lb: \", lb)\nprintln(\"ub: \", ub)\n\n(type, f, lb, ub) = constraint(ocp, :cons_mixed)\nprintln(\"type: \", type)\nprintln(\"val: \", f(t, x, u, v))\nprintln(\"lb: \", lb)\nprintln(\"ub: \", ub)\n\nnote: Note\nTo get the dual variable (or Lagrange multiplier) associated to the constraint, use the dual method.","category":"section"},{"location":"manual-model.html#Dynamics","page":"Problem characteristics","title":"Dynamics","text":"The dynamics stored in ocp are an in-place function (the first argument is mutated upon call) of the form f!(dx, t, x, u, v). Here, t represents time, x the state, u the control, and v the variable, with dx being the output value.\n\nf! = dynamics(ocp)\nt = 0\nx = [0., 1]\nu = 2\nv = [1, 4]\ndx = similar(x)\nf!(dx, t, x, u, v)\ndx","category":"section"},{"location":"manual-model.html#Criterion-and-objective","page":"Problem characteristics","title":"Criterion and objective","text":"The criterion can be :min or :max.\n\ncriterion(ocp)\n\nThe objective function is either in Mayer, Lagrange or Bolza form. \n\nMayer:\n\ng(x(t_0) x(t_f) v) to min\n\nLagrange:\n\nint_t_0^t_f f^0(t x(t) u(t) v) mathrmdt to min\n\nBolza:\n\ng(x(t_0) x(t_f) v) + int_t_0^t_f f^0(t x(t) u(t) v) mathrmdt to min\n\nThe objective of problem ocp is 0.5∫( u(t)^2 ) → min, hence, in Lagrange form. The signature of the Mayer part of the objective is g(x0, xf, v) but in our case, the method mayer will return an error.\n\ng = mayer(ocp)\n\nThe signature of the Lagrange part of the objective is f⁰(t, x, u, v).\n\nf⁰ = lagrange(ocp)\nf⁰(t, x, u, v)\n\nTo avoid having to capture exceptions, you can check the form of the objective:\n\nprintln(\"Mayer: \", has_mayer_cost(ocp))\nprintln(\"Lagrange: \", has_lagrange_cost(ocp))","category":"section"},{"location":"manual-model.html#Times","page":"Problem characteristics","title":"Times","text":"The time variable is not named t but s in ocp.\n\ntime_name(ocp)\n\nThe initial time is 0.\n\ninitial_time(ocp)\n\nSince the initial time has the value 0, its name is string(0). \n\ninitial_time_name(ocp)\n\nIn contrast, the final time is tf, since in ocp we have s ∈ [0, tf].\n\nfinal_time_name(ocp)\n\nTo get the value of the final time, since it is part of the variable v = (w, tf) of ocp, we need to provide a variable to the function final_time. \n\nv = [1, 2]\ntf = final_time(ocp, v)\n\nfinal_time(ocp)\n\nTo check whether the initial or final time is fixed or free (i.e., part of the variable), you can use the following functions:\n\nprintln(\"Fixed initial time: \", has_fixed_initial_time(ocp))\nprintln(\"Fixed final time: \", has_fixed_final_time(ocp))\n\nOr, similarly:\n\nprintln(\"Free initial time: \", has_free_initial_time(ocp))\nprintln(\"Free final time: \", has_free_final_time(ocp))","category":"section"},{"location":"manual-model.html#manual-model-time-dependence","page":"Problem characteristics","title":"Time dependence","text":"Optimal control problems can be autonomous or non-autonomous. In an autonomous problem, neither the dynamics nor the Lagrange cost explicitly depends on the time variable.\n\nThe following problem is autonomous.\n\nocp = @def begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R, state\n    u ∈ R, control\n    ẋ(t)  == u(t)                       # no explicit dependence on t\n    x(1) + 0.5∫( u(t)^2 ) → min         # no explicit dependence on t\nend\nis_autonomous(ocp)\n\nThe following problem is non-autonomous since the dynamics depends on t.\n\nocp = @def begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R, state\n    u ∈ R, control\n    ẋ(t)  == u(t) + t                   # explicit dependence on t\n    x(1) + 0.5∫( u(t)^2 ) → min\nend\nis_autonomous(ocp)\n\nFinally, this last problem is non-autonomous because the Lagrange part of the cost depends on t.\n\nocp = @def begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R, state\n    u ∈ R, control\n    ẋ(t)  == u(t)\n    x(1) + 0.5∫( t + u(t)^2 ) → min     # explicit dependence on t\nend\nis_autonomous(ocp)\n\n","category":"section"},{"location":"manual-model.html#CTModels.Model-manual-model","page":"Problem characteristics","title":"CTModels.Model","text":"struct Model{TD<:CTModels.TimeDependence, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:CTModels.AbstractConstraintsModel, BuildExaModelType<:Union{Nothing, Function}} <: CTModels.AbstractModel\n\nFields\n\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ndynamics::Function\nobjective::CTModels.AbstractObjectiveModel\nconstraints::CTModels.AbstractConstraintsModel\ndefinition::Expr\nbuild_examodel::Union{Nothing, Function}\n\n\n\n\n\n","category":"type"},{"location":"manual-solve.html#manual-solve","page":"Solve a problem","title":"The solve function","text":"In this manual, we explain the solve function from OptimalControl.jl package.","category":"section"},{"location":"manual-solve.html#Basic-usage","page":"Solve a problem","title":"Basic usage","text":"Let us define a basic optimal control problem.\n\nusing OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    x(t0) == x0\n    x(tf) == [0, 0]\n    ẋ(t)  == [v(t), u(t)]\n    0.5∫( u(t)^2 ) → min\nend\nnothing # hide\n\nWe can now solve the problem:\n\nusing NLPModelsIpopt\nsolve(ocp)\nnothing # hide\n\nNote that we must import NLPModelsIpopt.jl before calling solve.   This is because the default method uses a direct approach, which transforms the optimal control problem into a nonlinear program (NLP) of the form:\n\ntextminimizequad F(y) quadtextsubject to the constraintsquad g(y) le 0 quad h(y) = 0 \n\nwarning: Warning\nCalling solve without loading a NLP solver package first will notify the user:julia> solve(ocp)\nERROR: ExtensionError. Please make: julia> using NLPModelsIpopt","category":"section"},{"location":"manual-solve.html#manual-solve-methods","page":"Solve a problem","title":"Resolution methods and algorithms","text":"OptimalControl.jl offers a list of methods. To get it, simply call available_methods.\n\navailable_methods()\n\nEach line is a method, with priority going from top to bottom. This means that \n\nsolve(ocp)\n\nis equivalent to \n\nsolve(ocp, :direct, :adnlp, :ipopt)\n\nThe first symbol refers to the general class of method. The only possible value is:\n:direct: currently, only the so-called direct approach is implemented. Direct methods discretise the original optimal control problem and solve the resulting NLP. In this case, the main solve method redirects to CTDirect.solve.\nThe second symbol refers to the NLP modeler. The possible values are:\n:adnlp: the NLP problem is modeled by a ADNLPModels.ADNLPModel. It provides automatic differentiation (AD)-based models that follow the NLPModels.jl API.\n:exa: the NLP problem is modeled by a ExaModels.ExaModel. It provides automatic differentiation and SIMD abstraction.\nThe third symbol specifies the NLP solver. Possible values are:\n:ipopt: calls NLPModelsIpopt.ipopt to solve the NLP problem.\n:madnlp: creates a MadNLP.MadNLPSolver instance from the NLP problem and solve it. MadNLP.jl is an open-source solver in Julia implementing a filter line-search interior-point algorithm like Ipopt.\n:knitro: uses the Knitro solver (license required).\n\nwarning: Warning\nWhen using :exa for more performance (in particular to solve on GPU), there are limitations on the syntax:  dynamics must be declared coordinate by coordinate (not globally as a vector valued expression)\nnonlinear constraints (boundary, variable, control, state, mixed ones, see Constraints must also be scalar expressions (linear constraints aka. ranges, on the other hand, can be vectors)\nall expressions must only involve algebraic operations that are known to ExaModels (check the documentation), although one can provide additional user defined functions through registration (check ExaModels API) \n\nnote: Note\nMadNLP is shipped only with two linear solvers (Umfpack and Lapack), which are not adapted is some cases. We recommend to use MadNLPMumps to solve your optimal control problem with MUMPS linear solver.\n\nFor instance, let us try MadNLPMumps solver with ExaModel modeller.\n\nusing MadNLPMumps\n\nocp = @def begin\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    x(t0) == x0\n    x(tf) == [0, 0]\n    ∂(q)(t) == v(t)\n    ∂(v)(t) == u(t)\n    0.5∫( u(t)^2 ) → min\nend\n\nsolve(ocp, :exa, :madnlp; disc_method=:trapeze)\nnothing # hide\n\nNote that you can provide a partial description. If multiple full descriptions contain it, priority is given to the first one in the list. Hence, all of the following calls are equivalent:\n\nsolve(ocp)\nsolve(ocp, :direct                )\nsolve(ocp,          :adnlp        )\nsolve(ocp,                  :ipopt)\nsolve(ocp, :direct, :adnlp        )\nsolve(ocp, :direct,         :ipopt)\nsolve(ocp, :direct, :adnlp, :ipopt)","category":"section"},{"location":"manual-solve.html#manual-solve-direct-method","page":"Solve a problem","title":"Direct method and options","text":"The main options for the direct method, with their [default] values, are:\n\ndisplay ([true], false): setting display = false disables output.\ninit: information for the initial guess. It can be given as numerical values, functions, or an existing solution. See how to set an initial guess.\ngrid_size ([250]): number of time steps in the (uniform) time discretization grid.   More precisely, if N = grid_size and the initial and final times are t0 and tf, then the step length Δt = (tf - t0) / N.\ntime_grid ([nothing]): explicit time grid (can be non-uniform).   If time_grid = nothing, a uniform grid of length grid_size is used.\ndisc_method (:trapeze, [:midpoint], :euler, :euler_implicit, :gauss_legendre_2, :gauss_legendre_3): the discretisation scheme to transform the dynamics into nonlinear equations. See the discretization method tutorial for more details.\nadnlp_backend ([:optimized], :manual, :default): backend used for automatic differentiation to create the ADNLPModels.ADNLPModel.\n\nFor advanced usage, see:\n\ndiscrete continuation tutorial,\nNLP manipulation tutorial.\n\nnote: Note\nThe main solve method from OptimalControl.jl simply redirects to CTDirect.solve in that case.","category":"section"},{"location":"manual-solve.html#manual-solve-solvers-specific-options","page":"Solve a problem","title":"NLP solvers specific options","text":"In addition to these options, any remaining keyword arguments passed to solve are forwarded to the NLP solver.\n\nwarning: Warning\nThe option names and accepted values depend on the chosen solver. For example, in Ipopt, print_level expects an integer, whereas in MadNLP it must be a MadNLP.LogLevels value (valid options: MadNLP.{TRACE, DEBUG, INFO, NOTICE, WARN, ERROR}). Moreover, some options are solver-specific: for instance, mu_strategy exists in Ipopt but not in MadNLP.\n\nPlease refer to the Ipopt options list and the NLPModelsIpopt.jl documentation.  \n\nsol = solve(ocp; max_iter=0, tol=1e-6, print_level=0)\niterations(sol)\n\nLikewise, see the MadNLP.jl options and the MadNLP.jl documentation.  \n\nsol = solve(ocp, :madnlp; max_iter=0, tol=1e-6, print_level=MadNLP.ERROR)\niterations(sol)\n\n","category":"section"},{"location":"manual-solve.html#CommonSolve.solve-Tuple{Model, Vararg{Symbol}}-manual-solve","page":"Solve a problem","title":"CommonSolve.solve","text":"solve(\n    ocp::Model,\n    description::Symbol...;\n    display,\n    kwargs...\n) -> Solution{TimeGridModelType, TimesModelType, StateModelType, ControlModelType, VariableModelType, CostateModelType, Float64, DualModelType, CTModels.SolverInfos{Dict{Symbol, Any}}, ModelType} where {TimeGridModelType<:CTModels.TimeGridModel, TimesModelType<:CTModels.TimesModel, StateModelType<:Union{CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#84#85\", CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#86#87\"}, ControlModelType<:Union{CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#88#89\", CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#90#91\"}, VariableModelType<:Union{CTModels.VariableModelSolution{Vector{Float64}}, CTModels.VariableModelSolution{Float64}}, CostateModelType<:Union{CTModels.var\"#92#93\", CTModels.var\"#94#95\"}, DualModelType<:(CTModels.DualModel{PC_Dual, Vector{Float64}, SC_LB_Dual, SC_UB_Dual, CC_LB_Dual, CC_UB_Dual, Vector{Float64}, Vector{Float64}} where {PC_Dual<:Union{CTModels.var\"#100#101\"{CTModels.var\"#96#97\"}, CTModels.var\"#98#99\"{CTModels.var\"#96#97\"}}, SC_LB_Dual<:Union{CTModels.var\"#104#105\"{CTModels.var\"#102#103\"}, CTModels.var\"#106#107\"{CTModels.var\"#102#103\"}}, SC_UB_Dual<:Union{CTModels.var\"#110#111\"{CTModels.var\"#108#109\"}, CTModels.var\"#112#113\"{CTModels.var\"#108#109\"}}, CC_LB_Dual<:Union{CTModels.var\"#116#117\"{CTModels.var\"#114#115\"}, CTModels.var\"#118#119\"{CTModels.var\"#114#115\"}}, CC_UB_Dual<:Union{CTModels.var\"#122#123\"{CTModels.var\"#120#121\"}, CTModels.var\"#124#125\"{CTModels.var\"#120#121\"}}}), ModelType<:(Model{<:CTModels.TimeDependence, T} where T<:CTModels.TimesModel)}\n\n\nSolve the optimal control problem ocp by the method given by the (optional) description. The get the list of available methods:\n\njulia> available_methods()\n\nThe higher in the list, the higher is the priority. The keyword arguments are specific to the chosen method and represent the options of the solver.\n\nArguments\n\nocp::OptimalControlModel: the optimal control problem to solve.\ndescription::Symbol...: the description of the method used to solve the problem.\nkwargs...: the options of the method.\n\nExamples\n\nThe simplest way to solve the optimal control problem is to call the function without any argument.\n\njulia> sol = solve(ocp)\n\nThe method description is a list of Symbols. The default is\n\njulia> sol = solve(ocp, :direct, :adnlp, :ipopt)\n\nYou can provide a partial description, the function will find the best match.\n\njulia> sol = solve(ocp, :direct)\n\nnote: Note\nSee the resolution methods section for more details about the available methods.\n\nThe keyword arguments are specific to the chosen method and correspond to the options of the different solvers. For example, the keyword max_iter is an Ipopt option that may be used to set the maximum number of iterations.\n\njulia> sol = solve(ocp, :direct, :ipopt, max_iter=100)\n\nnote: Note\nSee the direct method section for more details about associated options. These options also detailed in the CTDirect.solve documentation. This main solve method redirects to CTDirect.solve when the :direct Symbol is given in the description. See also the NLP solvers section for more details about Ipopt or MadNLP options.\n\nTo help the solve converge, an initial guess can be provided within the keyword init. You can provide the initial guess for the state, control, and variable.\n\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5))\n\nnote: Note\nSee how to set an initial guess for more details.\n\n\n\n\n\n","category":"method"},{"location":"manual-solve-gpu.html#manual-solve-gpu","page":"Solve on GPU","title":"Solve on GPU","text":"In this manual, we explain how to use the solve function from OptimalControl.jl on GPU. We rely on ExaModels.jl and MadNLPGPU.jl and currently only provide support for NVIDIA thanks to CUDA.jl. Consider the following simple Lagrange optimal control problem:\n\nusing OptimalControl\nusing MadNLPGPU\nusing CUDA\n\nocp = @def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    v ∈ R, variable\n    x(0) == [0, 1]\n    x(1) == [0, -1]\n    ∂(x₁)(t) == x₂(t)\n    ∂(x₂)(t) == u(t)\n    0 ≤ x₁(t) + v^2 ≤ 1.1\n    -10 ≤ u(t) ≤ 10\n    1 ≤ v ≤ 2\n    ∫(u(t)^2 + v) → min\nend\n\nnote: Note\nWe have used MadNLPGPU instead of MadNLP, that is able to solve on GPU (leveraging CUDSS.jl) optimisation problems modelled with ExaModels.jl. As a direct transcription towards an ExaModels.ExaModel is performed (:exa keyword below), there are limitations on the syntax (check the Solve section).\n\nComputation on GPU is currently only tested with CUDA, and the associated backend must be passed to ExaModels as is done below (also note the :exa keyword to indicate the modeller, and :madnlp for the solver):\n\nsol = solve(ocp, :exa, :madnlp; exa_backend=CUDABackend())\n\n▫ This is OptimalControl version v1.1.2 running with: direct, exa, madnlp.\n\n▫ The optimal control problem is solved with CTDirect version v0.17.2.\n\n   ┌─ The NLP is modelled with ExaModels and solved with MadNLPMumps.\n   │\n   ├─ Number of time steps⋅: 250\n   └─ Discretisation scheme: midpoint\n\n▫ This is MadNLP version v0.8.12, running with cuDSS v0.6.0\n\nNumber of nonzeros in constraint Jacobian............:     2256\nNumber of nonzeros in Lagrangian Hessian.............:     1251\n\nTotal number of variables............................:      754\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:      252\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:      504\nTotal number of inequality constraints...............:      251\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:      251\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du inf_compl lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  1.0200000e+00 1.10e+00 1.00e+00 1.01e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.0199978e+00 1.10e+00 1.45e+00 8.73e-02  -1.0 1.97e+02    -  5.05e-03 4.00e-07h  1\n   ...\n  27  9.8891249e+00 2.22e-16 7.11e-15 1.60e-09  -9.0 2.36e-04    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 27\n\n                                   (scaled)                 (unscaled)\nObjective...............:   9.8891248915014458e+00    9.8891248915014458e+00\nDual infeasibility......:   7.1054273576010019e-15    7.1054273576010019e-15\nConstraint violation....:   2.2204460492503131e-16    2.2204460492503131e-16\nComplementarity.........:   1.5999963912421547e-09    1.5999963912421547e-09\nOverall NLP error.......:   1.5999963912421547e-09    1.5999963912421547e-09\n\nNumber of objective function evaluations             = 28\nNumber of objective gradient evaluations             = 28\nNumber of constraint evaluations                     = 28\nNumber of constraint Jacobian evaluations            = 28\nNumber of Lagrangian Hessian evaluations             = 27\nTotal wall-clock secs in solver (w/o fun. eval./lin. alg.)  =  0.126\nTotal wall-clock secs in linear solver                      =  0.103\nTotal wall-clock secs in NLP function evaluations           =  0.022\nTotal wall-clock secs                                       =  0.251\n\nEXIT: Optimal Solution Found (tol = 1.0e-08).\n\n","category":"section"},{"location":"api-ctbase.html#CTBase.jl","page":"CTBase.jl","title":"CTBase.jl","text":"The CTBase.jl package is part of the control-toolbox ecosystem.\n\nflowchart TD\nB(<a href='api-ctbase.html'>CTBase</a>)\nM(<a href='api-ctmodels.html'>CTModels</a>)\nP(<a href='api-ctparser.html'>CTParser</a>)\nO(<a href='api-optimalcontrol-dev.html'>OptimalControl</a>)\nD(<a href='api-ctdirect.html'>CTDirect</a>)\nF(<a href='api-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle B fill:#FBF275\n\nOptimalControl heavily relies on CTBase. We refer to CTBase API for more details.\n\n","category":"section"},{"location":"api-ctdirect.html#CTDirect.jl","page":"CTDirect.jl","title":"CTDirect.jl","text":"The CTDirect.jl package is part of the control-toolbox ecosystem.\n\nflowchart TD\nB(<a href='api-ctbase.html'>CTBase</a>)\nM(<a href='api-ctmodels.html'>CTModels</a>)\nP(<a href='api-ctparser.html'>CTParser</a>)\nO(<a href='api-optimalcontrol-dev.html'>OptimalControl</a>)\nD(<a href='api-ctdirect.html'>CTDirect</a>)\nF(<a href='api-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle D fill:#FBF275\n\nOptimalControl heavily relies on CTDirect. We refer to CTDirect API for more details.\n\n","category":"section"},{"location":"juliacon-paris-2025.html","page":"Solving optimal control problems on GPU with Julia","title":"Solving optimal control problems on GPU with Julia","text":"<img width=\"800\" alt=\"jlesc17\" src=\"./assets/juliacon-paris-2025.jpg\">","category":"section"},{"location":"juliacon-paris-2025.html#Solving-optimal-control-problems-on-GPU-with-Julia","page":"Solving optimal control problems on GPU with Julia","title":"Solving optimal control problems on GPU with Julia","text":"","category":"section"},{"location":"juliacon-paris-2025.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://github.com/joseph-gergaud),-[Pierre-Martinon](https://github.com/PierreMartinon),-[Sophia-Sed](https://sed-sam-blog.gitlabpages.inria.fr)","page":"Solving optimal control problems on GPU with Julia","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"section"},{"location":"juliacon-paris-2025.html#What-it's-about","page":"Solving optimal control problems on GPU with Julia","title":"What it's about","text":"Nonlinear optimal control of ODEs:\n\ng(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min\n\nsubject to\n\ndotx(t) = f(x(t) u(t))quad t in t_0 t_f\n\nplus boundary, control and state constraints\n\nOur core interests: numerical & geometrical methods in control, applications\nWhy Julia: fast (+ JIT), strongly typed, high-level (AD, macros), fast optimisation and ODE solvers available, rapidly growing community","category":"section"},{"location":"juliacon-paris-2025.html#Discretise-then-solve-strategy-(*aka*-direct-methods)","page":"Solving optimal control problems on GPU with Julia","title":"Discretise then solve strategy (aka direct methods)","text":"Discretising an OCP into an NLP: h_i = t_i+1-t_i,\n\ng(X_0X_N) + sum_i=0^N h_i f^0(X_iU_i) to min\n\nsubject to \n\nX_i+1 - X_i - h_i f(X_i U_i) = 0quad i = 0dotsN-1\n\nplus other constraints on X = (X_i)_i=0N and U = (U_i)_i=0N such as boundary and path (state and / or control) constraints :\n\nb(t_0 X_0 t_N X_N) = 0\n\nc(X_i U_i) leq 0quad i = 0dotsN\n\nSIMD parallelism (f_0, f, g) + sparsity: Kernels for GPU (KernelAbstraction.jl) and sparse linear algebra (CUDSS.jl)\nModelling and optimising for GPU: ExaModels.jl  + MadNLP.jl, with built-in AD\nSimple example, DSL\nCompile into an ExaModel (one pass compiler, syntax + semantics)\n\n<details><summary>Simple example, generated code</summary>\n\nbegin\n    #= /data/caillau/CTParser.jl/src/onepass.jl:1003 =#\n    function (; scheme = :trapezoidal, grid_size = 200, backend = nothing, init = (0.1, 0.1, 0.1), base_type = Float64)\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1003 =#\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1004 =#\n        LineNumberNode(0, \"box constraints: variable\")\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1005 =#\n        begin\n            LineNumberNode(0, \"box constraints: state\")\n            begin\n                var\"##235\" = -Inf * ones(3)\n                #= /data/caillau/CTParser.jl/src/onepass.jl:461 =#\n                var\"##236\" = Inf * ones(3)\n            end\n        end\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1006 =#\n        begin\n            LineNumberNode(0, \"box constraints: control\")\n            begin\n                var\"##237\" = -Inf * ones(1)\n                #= /data/caillau/CTParser.jl/src/onepass.jl:512 =#\n                var\"##238\" = Inf * ones(1)\n            end\n        end\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1007 =#\n        var\"##230\" = ExaModels.ExaCore(base_type; backend = backend)\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1008 =#\n        begin\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:23 =#\n            var\"##232\" = begin\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                    local ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                    try\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                        (1 - 0) / grid_size\n                    catch ex\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                        println(\"Line \", 1, \": \", \"(t ∈ [0, 1], time)\")\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                        throw(ex)\n                    end\n                end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:24 =#\n            x = begin\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                    local ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                    try\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                        ExaModels.variable(var\"##230\", 3, 0:grid_size; lvar = [var\"##235\"[i] for (i, j) = Base.product(1:3, 0:grid_size)], uvar = [var\"##236\"[i] for (i, j) = Base.product(1:3, 0:grid_size)], start = init[2])\n                    catch ex\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                        println(\"Line \", 2, \": \", \"(x ∈ R ^ 3, state)\")\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                        throw(ex)\n                    end\n                end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:25 =#\n            var\"u##239\" = begin\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                    local ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                    try\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                        ExaModels.variable(var\"##230\", 1, 0:grid_size; lvar = [var\"##237\"[i] for (i, j) = Base.product(1:1, 0:grid_size)], uvar = [var\"##238\"[i] for (i, j) = Base.product(1:1, 0:grid_size)], start = init[3])\n                    catch ex\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                        println(\"Line \", 3, \": \", \"(u ∈ R, control)\")\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                        throw(ex)\n                    end\n                end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:26 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    ExaModels.constraint(var\"##230\", (x[i, 0] for i = 1:3); lcon = [-1, 0, 0], ucon = [-1, 0, 0])\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 4, \": \", \"x(0) == [-1, 0, 0]\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:27 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    ExaModels.constraint(var\"##230\", (x[i, grid_size] for i = 1:2); lcon = [0, 0], ucon = [0, 0])\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 5, \": \", \"(x[1:2])(1) == [0, 0]\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:28 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    begin\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:735 =#\n                        if scheme == :trapezoidal\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:736 =#\n                            ExaModels.constraint(var\"##230\", ((x[1, j + 1] - x[1, j]) - (var\"##232\" * (x[2, j] + x[2, j + 1])) / 2 for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:737 =# scheme == :euler\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:738 =#\n                            ExaModels.constraint(var\"##230\", ((x[1, j + 1] - x[1, j]) - var\"##232\" * x[2, j] for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:739 =# scheme == :euler_b\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:740 =#\n                            ExaModels.constraint(var\"##230\", ((x[1, j + 1] - x[1, j]) - var\"##232\" * x[2, j + 1] for j = 0:grid_size - 1))\n                        else\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:742 =#\n                            throw(\"unknown numerical scheme\")\n                        end\n                    end\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 6, \": \", \"(∂(x₁))(t) == x₂(t)\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:29 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    begin\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:735 =#\n                        if scheme == :trapezoidal\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:736 =#\n                            ExaModels.constraint(var\"##230\", ((x[2, j + 1] - x[2, j]) - (var\"##232\" * (var\"u##239\"[1, j] + var\"u##239\"[1, j + 1])) / 2 for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:737 =# scheme == :euler\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:738 =#\n                            ExaModels.constraint(var\"##230\", ((x[2, j + 1] - x[2, j]) - var\"##232\" * var\"u##239\"[1, j] for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:739 =# scheme == :euler_b\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:740 =#\n                            ExaModels.constraint(var\"##230\", ((x[2, j + 1] - x[2, j]) - var\"##232\" * var\"u##239\"[1, j + 1] for j = 0:grid_size - 1))\n                        else\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:742 =#\n                            throw(\"unknown numerical scheme\")\n                        end\n                    end\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 7, \": \", \"(∂(x₂))(t) == u(t)\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:30 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    begin\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:735 =#\n                        if scheme == :trapezoidal\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:736 =#\n                            ExaModels.constraint(var\"##230\", ((x[3, j + 1] - x[3, j]) - (var\"##232\" * (0.5 * var\"u##239\"[1, j] ^ 2 + 0.5 * var\"u##239\"[1, j + 1] ^ 2)) / 2 for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:737 =# scheme == :euler\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:738 =#\n                            ExaModels.constraint(var\"##230\", ((x[3, j + 1] - x[3, j]) - var\"##232\" * (0.5 * var\"u##239\"[1, j] ^ 2) for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:739 =# scheme == :euler_b\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:740 =#\n                            ExaModels.constraint(var\"##230\", ((x[3, j + 1] - x[3, j]) - var\"##232\" * (0.5 * var\"u##239\"[1, j + 1] ^ 2) for j = 0:grid_size - 1))\n                        else\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:742 =#\n                            throw(\"unknown numerical scheme\")\n                        end\n                    end\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 8, \": \", \"(∂(x₃))(t) == 0.5 * u(t) ^ 2\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:31 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    ExaModels.objective(var\"##230\", x[3, grid_size])\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 9, \": \", \"x₃(1) → min\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n        end\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1009 =#\n        begin\n            #= /data/caillau/CTParser.jl/src/onepass.jl:994 =#\n            !(isempty([1, 2, 3])) || throw(CTBase.ParsingError(\"dynamics not defined\"))\n            #= /data/caillau/CTParser.jl/src/onepass.jl:995 =#\n            sort([1, 2, 3]) == 1:3 || throw(CTBase.ParsingError(\"some coordinates of dynamics undefined\"))\n        end\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1010 =#\n        return ExaModels.ExaModel(var\"##230\")\n    end\nend\n\n</details>\n\nSolving (MadNLP + CUDSS)\n\nThis is MadNLP version v0.8.7, running with cuDSS v0.4.0\n\nNumber of nonzeros in constraint Jacobian............:    12005\nNumber of nonzeros in Lagrangian Hessian.............:     9000\n\nTotal number of variables............................:     4004\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:        0\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     3005\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  1.0000000e-01 1.10e+00 1.00e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.0001760e-01 1.10e+00 3.84e-03  -1.0 6.88e+02  -4.0 1.00e+00 2.00e-07h  2\n   2 -5.2365072e-03 1.89e-02 1.79e-07  -1.0 6.16e+00  -4.5 1.00e+00 1.00e+00h  1\n   3  5.9939621e+00 2.28e-03 1.66e-04  -3.8 6.00e+00  -5.0 9.99e-01 1.00e+00h  1\n   4  5.9996210e+00 2.94e-06 8.38e-07  -3.8 7.70e-02    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 4\n\n                                   (scaled)                 (unscaled)\nObjective...............:   5.9996210189633494e+00    5.9996210189633494e+00\nDual infeasibility......:   8.3756005011360529e-07    8.3756005011360529e-07\nConstraint violation....:   2.9426923277963834e-06    2.9426923277963834e-06\nComplementarity.........:   2.0007459547789288e-06    2.0007459547789288e-06\nOverall NLP error.......:   2.9426923277963834e-06    2.9426923277963834e-06\n\nNumber of objective function evaluations             = 6\nNumber of objective gradient evaluations             = 5\nNumber of constraint evaluations                     = 6\nNumber of constraint Jacobian evaluations            = 5\nNumber of Lagrangian Hessian evaluations             = 4\nTotal wall-clock secs in solver (w/o fun. eval./lin. alg.)  =  0.072\nTotal wall-clock secs in linear solver                      =  0.008\nTotal wall-clock secs in NLP function evaluations           =  0.003\nTotal wall-clock secs                                       =  0.083","category":"section"},{"location":"juliacon-paris-2025.html#Mini-benchmark:-[Goddard](https://control-toolbox.org/Tutorials.jl/stable/tutorial-goddard.html)-and-[Quadrotor](https://github.com/control-toolbox/CTParser.jl/blob/211042b061be17b3f7fdff41cb53701d30b128db/test/test_onepass_exa.jl#L926)-problems","page":"Solving optimal control problems on GPU with Julia","title":"Mini-benchmark: Goddard and Quadrotor problems","text":"Goddard, A100 run\n\n<img width=\"400\" alt=\"goddard-a100\" src=\"./assets/goddard-a100.jpg\">\n\nGoddard, H100 run             \n\n<img width=\"400\" alt=\"goddard-h100\" src=\"./assets/goddard-h100.jpg\">\n\nQuadrotor, A100 run    \n\n<img width=\"400\" alt=\"quadrotor-a100\" src=\"./assets/quadrotor-a100.jpg\">\n\nQuadrotor, H100 run             \n\n<img width=\"400\" alt=\"quadrotor-h100\" src=\"./assets/quadrotor-h100.jpg\">","category":"section"},{"location":"juliacon-paris-2025.html#Wrap-up","page":"Solving optimal control problems on GPU with Julia","title":"Wrap up","text":"High level modelling of optimal control problems\nSolving on CPU and GPU","category":"section"},{"location":"juliacon-paris-2025.html#What's-next","page":"Solving optimal control problems on GPU with Julia","title":"What's next","text":"New applications (space mechanics, biology, quantum mechanics and more) -> check David's talk\nCollection of problems: OptimalControlProblems.jl\n... and open to contributions! Give it a try, give it a star ⭐️\n\n<a href=\"https://github.com/control-toolbox/OptimalControl.jl\"><img width=\"800\" alt=\"OptimalControl.jl\" src=\"./assets/star.jpg\"></a>","category":"section"},{"location":"juliacon-paris-2025.html#control-toolbox.org","page":"Solving optimal control problems on GPU with Julia","title":"control-toolbox.org","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl\n\n<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"section"},{"location":"juliacon-paris-2025.html#Credits-(not-exhaustive!)","page":"Solving optimal control problems on GPU with Julia","title":"Credits (not exhaustive!)","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nExaModels.jl\nIpopt.jl\nMadNLP.jl\nMLStyle.jl","category":"section"},{"location":"juliacon-paris-2025.html#Acknowledgements","page":"Solving optimal control problems on GPU with Julia","title":"Acknowledgements","text":"Jean-Baptiste Caillau is partially funded by a France 2030 support managed by the Agence Nationale de la Recherche, under the reference ANR-23-PEIA-0004 (PDE-AI project).\n\n<img width=\"150\" alt=\"affiliations\" src=\"./assets/france-2030.png\">\n\n","category":"section"},{"location":"manual-initial-guess.html#manual-initial-guess","page":"Set an initial guess","title":"Initial guess (or iterate) for the resolution","text":"We present the different possibilities to provide an initial guess to solve an  optimal control problem with the OptimalControl.jl package. \n\nFirst, we need to import OptimalControl.jl to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import Plots.jl to plot solutions.\n\nusing OptimalControl\nusing NLPModelsIpopt\nusing Plots\n\nFor the illustrations, we define the following optimal control problem.\n\nt0 = 0\ntf = 10\nα  = 5\n\nocp = @def begin\n    t ∈ [t0, tf], time\n    v ∈ R, variable\n    x ∈ R², state\n    u ∈ R, control\n    x(t0) == [ -1, 0 ]\n    x₁(tf) == 0\n    ẋ(t) == [ x₂(t), x₁(t) + α*x₁(t)^2 + u(t) ]\n    x₂(tf)^2 + ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"section"},{"location":"manual-initial-guess.html#Default-initial-guess","page":"Set an initial guess","title":"Default initial guess","text":"We first solve the problem without giving an initial guess. This will default to initialize all variables to 0.1.\n\n# solve the optimal control problem without initial guess\nsol = solve(ocp; display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide\n\nLet us plot the solution of the optimal control problem.\n\nplot(sol; size=(600, 450))\n\nNote that the following formulations are equivalent to not giving an initial guess.\n\nsol = solve(ocp; init=nothing, display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\nsol = solve(ocp; init=(), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide\n\ntip: Interactions with an optimal control solution\nTo get the number of iterations of the solver, check the iterations function.\n\nTo reduce the number of iterations and improve the convergence, we can give an initial guess to the solver.  This initial guess can be built from constant values, interpolated vectors, functions, or existing solutions. Except when initializing from a solution, the arguments are to be passed as a named tuple init=(state=..., control=..., variable=...) whose fields are optional. Missing fields will revert to default initialization (ie constant 0.1).","category":"section"},{"location":"manual-initial-guess.html#Constant-initial-guess","page":"Set an initial guess","title":"Constant initial guess","text":"We first illustrate the constant initial guess, using vectors or scalars according to the dimension.\n\n# solve the optimal control problem with initial guess with constant values\nsol = solve(ocp; init=(state=[-0.2, 0.1], control=-0.2, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide\n\nPartial initializations are also valid, as shown below. Note the ending comma when a single argument is passed, since it must be a tuple.\n\n# initialisation only on the state\nsol = solve(ocp; init=(state=[-0.2, 0.1],), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\n# initialisation only on the control\nsol = solve(ocp; init=(control=-0.2,), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\n# initialisation only on the state and the variable\nsol = solve(ocp; init=(state=[-0.2, 0.1], variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"section"},{"location":"manual-initial-guess.html#Functional-initial-guess","page":"Set an initial guess","title":"Functional initial guess","text":"For the state and control, we can also provide functions of time as initial guess.\n\n# initial guess as functions of time\nx(t) = [ -0.2t, 0.1t ]\nu(t) = -0.2t\n\nsol = solve(ocp; init=(state=x, control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"section"},{"location":"manual-initial-guess.html#Vector-initial-guess-(interpolated)","page":"Set an initial guess","title":"Vector initial guess (interpolated)","text":"Initialization can also be provided with vectors / matrices to be interpolated along a given time grid.  In this case the time steps must be given through an additional argument time, which can be a vector or line/column matrix. For the values to be interpolated both matrices and vectors of vectors are allowed, but the shape should be number of time steps x variable dimension. Simple vectors are also allowed for variables of dimension 1.\n\n# initial guess as vector of points\nt_vec = LinRange(t0,tf,4)\nx_vec = [[0, 0], [-0.1, 0.3], [-0.15,0.4], [-0.3, 0.5]]\nu_vec = [0, -0.8,  -0.3, 0]\n\nsol = solve(ocp; init=(time=t_vec, state=x_vec, control=u_vec, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide\n\nNote: in the free final time case, the given time grid should be consistent with the initial guess provided for the final time (in the optimization variables).","category":"section"},{"location":"manual-initial-guess.html#Mixed-initial-guess","page":"Set an initial guess","title":"Mixed initial guess","text":"The constant, functional and vector initializations can be mixed, for instance as\n\n# we can mix constant values with functions of time\nsol = solve(ocp; init=(state=[-0.2, 0.1], control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\n# wa can mix every possibility\nsol = solve(ocp; init=(time=t_vec, state=x_vec, control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"section"},{"location":"manual-initial-guess.html#Solution-as-initial-guess-(warm-start)","page":"Set an initial guess","title":"Solution as initial guess (warm start)","text":"Finally, we can use an existing solution to provide the initial guess.  The dimensions of the state, control and optimization variable must coincide. This particular feature allows an easy implementation of discrete continuations.\n\n# generate the initial solution\nsol_init = solve(ocp; display=false)\n\n# solve the problem using solution as initial guess\nsol = solve(ocp; init=sol_init, display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide\n\nNote that you can also manually pick and choose which data to reuse from a solution, by recovering the  functions state(sol), control(sol) and the values variable(sol). For instance the following formulation is equivalent to the init=sol one.\n\n# use a previous solution to initialise picking data\nsol = solve(ocp; \n    init = (\n        state    = state(sol), \n        control  = control(sol), \n        variable = variable(sol)\n    ), \n    display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide\n\ntip: Interactions with an optimal control solution\nPlease check state, costate, control and variable to get data from the solution. The functions state, costate and control return functions of time and variable returns a vector.","category":"section"},{"location":"manual-initial-guess.html#Costate-/-multipliers","page":"Set an initial guess","title":"Costate / multipliers","text":"For the moment there is no option to provide an initial guess for the costate / multipliers.\n\n","category":"section"},{"location":"example-double-integrator-energy.html#example-double-integrator-energy","page":"Energy minimisation","title":"Double integrator: energy minimisation","text":"Let us consider a wagon moving along a rail, whose acceleration can be controlled by a force u. We denote by x = (x_1 x_2) the state of the wagon, where x_1 is the position and x_2 the velocity.\n\n<img src=\"./assets/chariot.svg\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"400px\">\n\nWe assume that the mass is constant and equal to one, and that there is no friction. The dynamics are given by\n\n    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t)quad u(t) in R\n\nwhich is simply the double integrator system. Let us consider a transfer starting at time t_0 = 0 and ending at time t_f = 1, for which we want to minimise the transfer energy\n\n    frac12int_0^1 u^2(t)  mathrmdt\n\nstarting from x(0) = (-1 0) and aiming to reach the target x(1) = (0 0).\n\nFirst, we need to import the OptimalControl.jl package to define the optimal control problem, NLPModelsIpopt.jl to solve it, and Plots.jl to visualise the solution.\n\nusing OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"section"},{"location":"example-double-integrator-energy.html#Optimal-control-problem","page":"Energy minimisation","title":"Optimal control problem","text":"Let us define the problem with the @def macro:\n\n<div class=\"responsive-columns-left-priority\">\n<div>\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\nxf = [0, 0]\nocp = @def begin\n    t ∈ [t0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x(t0) == x0\n    x(tf) == xf\n    ẋ(t) == [x₂(t), u(t)]\n    0.5∫( u(t)^2 ) → min\nend\nnothing # hide\n\n</div>\n<div>","category":"section"},{"location":"example-double-integrator-energy.html#Mathematical-formulation","page":"Energy minimisation","title":"Mathematical formulation","text":"    beginaligned\n         textMinimise  frac12int_0^1 u^2(t) mathrmdt \n         textsubject to \n          dotx_1(t) = x_2(t) 05em\n          dotx_2(t) = u(t) 10em\n          x(0) = (-10) 05em \n          x(1) = (00)\n    endaligned\n\n</div>\n</div>\n\nnote: Nota bene\nFor a comprehensive introduction to the syntax used above to define the optimal control problem, see this abstract syntax tutorial. In particular, non-Unicode alternatives are available for derivatives, integrals, etc.","category":"section"},{"location":"example-double-integrator-energy.html#example-double-integrator-energy-solve-plot","page":"Energy minimisation","title":"Solve and plot","text":"","category":"section"},{"location":"example-double-integrator-energy.html#Direct-method","page":"Energy minimisation","title":"Direct method","text":"We can solve it simply with:\n\nsol = solve(ocp)\nnothing # hide\n\nAnd plot the solution with:\n\nplot(sol)\n\nnote: Nota bene\nThe solve function has options, see the solve tutorial. You can customise the plot, see the plot tutorial.","category":"section"},{"location":"example-double-integrator-energy.html#Indirect-method","page":"Energy minimisation","title":"Indirect method","text":"The first solution was obtained using the so-called direct method.[1] Another approach is to use an indirect simple shooting method. We begin by importing the necessary packages.\n\nusing OrdinaryDiffEq # Ordinary Differential Equations (ODE) solver\nusing NonlinearSolve # Nonlinear Equations (NLE) solver\n\nTo define the shooting function, we must provide the maximising control in feedback form:\n\n# maximising control, H(x, p, u) = p₁x₂ + p₂u - u²/2\nu(x, p) = p[2]\n\n# Hamiltonian flow\nf = Flow(ocp, u)\n\n# state projection, p being the costate\nπ((x, p)) = x\n\n# shooting function\nS(p0) = π( f(t0, x0, p0, tf) ) - xf\nnothing # hide\n\nWe are now ready to solve the shooting equations.\n\n# auxiliary in-place NLE function\nnle!(s, p0, λ) = s[:] = S(p0)\n\n# initial guess for the Newton solver\np0_guess = [1, 1]\n\n# NLE problem with initial guess\nprob = NonlinearProblem(nle!, p0_guess)\n\n# resolution of S(p0) = 0\nsol = solve(prob; show_trace=Val(true))\np0_sol = sol.u # costate solution\n\n# print the costate solution and the shooting function evaluation\nprintln(\"\\ncostate: p0 = \", p0_sol)\nprintln(\"shoot: S(p0) = \", S(p0_sol), \"\\n\")\n\nTo plot the solution obtained by the indirect method, we need to build the solution of the optimal control problem. This is done using the costate solution and the flow function.\n\nsol = f((t0, tf), x0, p0_sol; saveat=range(t0, tf, 100))\nplot(sol)\n\n[1]: J. T. Betts. Practical methods for optimal control using nonlinear programming. Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, 2001.\n\nnote: Note\nYou can use MINPACK.jl instead of NonlinearSolve.jl.\nFor more details about the flow construction, visit the Compute flows from optimal control problems page.\nIn this simple example, we have set an arbitrary initial guess. It can be helpful to use the solution of the direct method to initialise the shooting method. See the Goddard tutorial for such a concrete application.","category":"section"},{"location":"example-double-integrator-energy.html#State-constraint","page":"Energy minimisation","title":"State constraint","text":"","category":"section"},{"location":"example-double-integrator-energy.html#Direct-method:-constrained-case","page":"Energy minimisation","title":"Direct method: constrained case","text":"We add the path constraint\n\n    x_2(t) le 12\n\nLet us model, solve and plot the optimal control problem with this constraint.\n\n# the upper bound for x₂\na = 1.2\n\n# the optimal control problem\nocp = @def begin\n    t ∈ [t0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x₂(t) ≤ a\n    x(t0) == x0\n    x(tf) == xf\n    ẋ(t) == [x₂(t), u(t)]\n    0.5∫( u(t)^2 ) → min\nend\n\n# solve with a direct method using default settings\nsol = solve(ocp)\n\n# plot the solution\nplt = plot(sol; label=\"Direct\", size=(800, 600))","category":"section"},{"location":"example-double-integrator-energy.html#Indirect-method:-constrained-case","page":"Energy minimisation","title":"Indirect method: constrained case","text":"The pseudo-Hamiltonian is (considering the normal case):\n\nH(x p u mu) = p_1 x_2 + p_2 u - fracu^22 + mu c(x)\n\nwith c(x) = x_2 - a. Along a boundary arc we have c(x(t)) = 0. Differentiating, we obtain:\n\n    fracmathrmdmathrmdtc(x(t)) = dotx_2(t) = u(t) = 0\n\nThe zero control is maximising; hence, p_2(t) = 0 along the boundary arc.\n\n    dotp_2(t) = -p_1(t) - mu(t) quad Rightarrow mu(t) = -p_1(t)\n\nSince the adjoint vector is continuous at the entry time t_1 and the exit time t_2, we have four unknowns: the initial costate p_0 in mathbbR^2 and the times t_1 and t_2. We need four equations: the target condition provides two, reaching the constraint at time t_1 gives c(x(t_1)) = 0, and finally p_2(t_1) = 0.\n\n# flow for unconstrained extremals\nf = Flow(ocp, (x, p) -> p[2])\n\nub = 0          # boundary control\nc(x) = x[2]-a   # constraint: c(x) ≥ 0\nμ(p) = -p[1]    # dual variable\n\n# flow for boundary extremals\ng = Flow(ocp, (x, p) -> ub, (x, u) -> c(x), (x, p) -> μ(p))\n\n# shooting function\nfunction shoot!(s, p0, t1, t2)\n    x_t0, p_t0 = x0, p0\n    x_t1, p_t1 = f(t0, x_t0, p_t0, t1)\n    x_t2, p_t2 = g(t1, x_t1, p_t1, t2)\n    x_tf, p_tf = f(t2, x_t2, p_t2, tf)\n    s[1:2] = x_tf - xf\n    s[3] = c(x_t1)\n    s[4] = p_t1[2]\nend\nnothing # hide\n\nWe are now ready to solve the shooting equations.\n\n# auxiliary in-place NLE function\nnle!(s, ξ, λ) = shoot!(s, ξ[1:2], ξ[3], ξ[4])\n\n# initial guess for the Newton solver\nξ_guess = [40, 10, 0.25, 0.75]\n\n# NLE problem with initial guess\nprob = NonlinearProblem(nle!, ξ_guess)\n\n# resolution of the shooting equations\nsol = solve(prob; show_trace=Val(true))\np0, t1, t2 = sol.u[1:2], sol.u[3], sol.u[4]\n\n# print the costate solution and the entry and exit times\nprintln(\"\\np0 = \", p0, \"\\nt1 = \", t1, \"\\nt2 = \", t2)\n\nTo reconstruct the trajectory obtained with the state constraint, we concatenate the flows: one unconstrained arc up to the entry time t_1, a boundary arc between t_1 and t_2, and finally another unconstrained arc up to t_f.   This concatenation allows us to compute the complete solution — state, costate, and control — which we can then plot together with the direct solution for comparison.\n\n# concatenation of the flows\nφ = f * (t1, g) * (t2, f)\n\n# compute the solution: state, costate, control...\nflow_sol = φ((t0, tf), x0, p0; saveat=range(t0, tf, 100))      \n\n# plot the solution on the previous plot\nplot!(plt, flow_sol; label=\"Indirect\", color=2, linestyle=:dash)\n\n","category":"section"},{"location":"example-double-integrator-time.html#example-double-integrator-time","page":"Time mininimisation","title":"Double integrator: time minimisation","text":"The problem consists in minimising the final time t_f for the double integrator system\n\n    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) quad u(t) in -11\n\nand the limit conditions\n\n    x(0) = (-10) quad x(t_f) = (00)\n\nThis problem can be interpreted as a simple model for a wagon with constant mass moving along a line without friction.\n\n<img src=\"./assets/chariot.svg\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"400px\">\n\nFirst, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.\n\nusing OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"section"},{"location":"example-double-integrator-time.html#Optimal-control-problem","page":"Time mininimisation","title":"Optimal control problem","text":"Let us define the problem:\n\n<div class=\"responsive-columns-left-priority\">\n<div>\n\nocp = @def begin\n\n    tf ∈ R,          variable\n    t ∈ [0, tf],     time\n    x = (q, v) ∈ R², state\n    u ∈ R,           control\n\n    -1 ≤ u(t) ≤ 1\n\n    q(0)  == -1\n    v(0)  == 0\n    q(tf) == 0\n    v(tf) == 0\n\n    ẋ(t) == [v(t), u(t)]\n\n    tf → min\n\nend\nnothing # hide\n\n</div>\n<div>","category":"section"},{"location":"example-double-integrator-time.html#Mathematical-formulation","page":"Time mininimisation","title":"Mathematical formulation","text":"    beginaligned\n         textMinimise  t_f 05em\n         textsubject to 05em\n          dot q(t) = v(t) \n          dot v(t) = u(t) 05em\n          -1 le u(t) le 1 05em\n          q(0) = -1 05em\n          v(0) = 0 05em\n          q(t_f) = 0 05em\n          v(t_f) = 0\n    endaligned\n\n  </div>\n</div>\n\nnote: Nota bene\nFor a comprehensive introduction to the syntax used above to define the optimal control problem, see this abstract syntax tutorial. In particular, non-Unicode alternatives are available for derivatives, integrals, etc.","category":"section"},{"location":"example-double-integrator-time.html#Solve-and-plot","page":"Time mininimisation","title":"Solve and plot","text":"","category":"section"},{"location":"example-double-integrator-time.html#Direct-method","page":"Time mininimisation","title":"Direct method","text":"Let us solve it with a direct method (we set the number of time steps to 200):\n\nsol = solve(ocp; grid_size=200)\nnothing # hide\n\nand plot the solution:\n\nplt = plot(sol; label=\"Direct\", size=(800, 600))\n\nnote: Nota bene\nThe solve function has options, see the solve tutorial. You can customise the plot, see the plot tutorial.","category":"section"},{"location":"example-double-integrator-time.html#Indirect-method","page":"Time mininimisation","title":"Indirect method","text":"We now turn to the indirect method, which relies on Pontryagin’s Maximum Principle.  The pseudo-Hamiltonian is given by\n\nH(x p u) = p_1 v + p_2 u - 1\n\nwhere p = (p_1 p_2) is the costate vector. The optimal control is of bang–bang type:\n\nu(t) = mathrmsign(p_2(t))\n\nwith one switch from u=+1 to u=-1 at one single time denoted t_1. Let us implement this approach. First, we import the necessary packages:\n\nusing OrdinaryDiffEq\nusing NonlinearSolve\n\nDefine the bang–bang control and Hamiltonian flow:\n\n# pseudo-Hamiltonian\nH(x, p, u) = p[1]*x[2] + p[2]*u - 1\n\n# bang–bang control\nu_max = +1\nu_min = -1\n\n# Hamiltonian flow\nf_max = Flow(ocp, (x, p, tf) -> u_max)\nf_min = Flow(ocp, (x, p, tf) -> u_min)\nnothing # hide\n\nThe shooting function enforces the conditions:\n\nt0 = 0\nx0 = [-1, 0]\nxf = [ 0, 0]\nfunction shoot!(s, p0, t1, tf) \n    x_t0, p_t0 = x0, p0\n    x_t1, p_t1 = f_max(t0, x_t0, p_t0, t1)\n    x_tf, p_tf = f_min(t1, x_t1, p_t1, tf)\n    s[1:2] = x_tf - xf                          # target conditions\n    s[3] = p_t1[2]                              # switching condition\n    s[4] = H(x_tf, p_tf, -1)                    # free final time\nend\nnothing # hide\n\nWe are now ready to solve the shooting equations:\n\n# in-place shooting function\nnle!(s, ξ, λ) = shoot!(s, ξ[1:2], ξ[3], ξ[4]) \n\n# initial guess: costate and final time\nξ_guess = [0.1, 0.1, 0.5, 1]\n\n# NLE problem\nprob = NonlinearProblem(nle!, ξ_guess)\n\n# resolution of the shooting equations\nsol = solve(prob; show_trace=Val(true))\np0, t1, tf = sol.u[1:2], sol.u[3], sol.u[4]\n\n# print the solution\nprintln(\"\\np0 = \", p0, \"\\nt1 = \", t1, \"\\ntf = \", tf)\n\nFinally, we reconstruct and plot the solution obtained by the indirect method:\n\n# concatenation of the flows\nφ = f_max * (t1, f_min)\n\n# compute the solution: state, costate, control...\nflow_sol = φ((t0, tf), x0, p0; saveat=range(t0, tf, 200))\n\n# plot the solution on the previous plot\nplot!(plt, flow_sol; label=\"Indirect\", color=2, linestyle=:dash)\n\nnote: Note\nYou can use MINPACK.jl instead of NonlinearSolve.jl.\nFor more details about the flow construction, visit the Compute flows from optimal control problems page.\nIn this simple example, we have set an arbitrary initial guess. It can be helpful to use the solution of the direct method to initialise the shooting method. See the Goddard tutorial for such a concrete application.\n\n","category":"section"},{"location":"manual-flow-api.html#manual-flow-api","page":"Flow API","title":"API of the Flow function","text":"","category":"section"},{"location":"manual-flow-api.html#CTFlows.Flow-manual-flow-api","page":"Flow API","title":"CTFlows.Flow","text":"Flow(\n    vf::VectorField;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.VectorFieldFlow\n\n\nConstructs a flow object for a classical (non-Hamiltonian) vector field.\n\nThis creates a VectorFieldFlow that integrates the ODE system dx/dt = vf(t, x, v) using DifferentialEquations.jl. It handles both fixed and parametric dynamics, as well as jump discontinuities and event stopping.\n\nKeyword Arguments\n\nalg, abstol, reltol, saveat, internalnorm: Solver options.\nkwargs_Flow...: Additional arguments passed to the solver configuration.\n\nExample\n\njulia> vf(t, x, v) = -v * x\njulia> flow = CTFlows.Flow(CTFlows.VectorField(vf))\njulia> x1 = flow(0.0, 1.0, 1.0)\n\n\n\n\n\nFlow(\n    h::CTFlows.AbstractHamiltonian;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.HamiltonianFlow\n\n\nConstructs a Hamiltonian flow from a scalar Hamiltonian.\n\nThis method builds a numerical integrator that simulates the evolution of a Hamiltonian system given a Hamiltonian function h(t, x, p, l) or h(x, p).\n\nInternally, it computes the right-hand side of Hamilton’s equations via automatic differentiation and returns a HamiltonianFlow object.\n\nKeyword Arguments\n\nalg, abstol, reltol, saveat, internalnorm: solver options.\nkwargs_Flow...: forwarded to the solver.\n\nExample\n\njulia> H(x, p) = dot(p, p) + dot(x, x)\njulia> flow = CTFlows.Flow(CTFlows.Hamiltonian(H))\njulia> xf, pf = flow(0.0, x0, p0, 1.0)\n\n\n\n\n\nFlow(\n    hv::HamiltonianVectorField;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.HamiltonianFlow\n\n\nConstructs a Hamiltonian flow from a precomputed Hamiltonian vector field.\n\nThis method assumes you already provide the Hamiltonian vector field (dx/dt, dp/dt) instead of deriving it from a scalar Hamiltonian.\n\nReturns a HamiltonianFlow object that integrates the given system.\n\nKeyword Arguments\n\nalg, abstol, reltol, saveat, internalnorm: solver options.\nkwargs_Flow...: forwarded to the solver.\n\nExample\n\njulia> hv(t, x, p, l) = (∇ₚH, -∇ₓH)\njulia> flow = CTFlows.Flow(CTFlows.HamiltonianVectorField(hv))\njulia> xf, pf = flow(0.0, x0, p0, 1.0, l)\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::CTFlows.ControlLaw;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> Union{CTFlowsODE.OptimalControlFlow{CTFlows.Fixed}, CTFlowsODE.OptimalControlFlow{CTFlows.NonFixed}}\n\n\nConstruct a flow for an optimal control problem using a given control law.\n\nThis method builds the Hamiltonian system associated with the optimal control problem (ocp) and integrates the corresponding state–costate dynamics using the specified control law u.\n\nArguments\n\nocp::CTModels.Model: An optimal control problem defined using CTModels.\nu::CTFlows.ControlLaw: A feedback control law generated by ControlLaw(...) or similar.\nalg: Integration algorithm (default inferred).\nabstol: Absolute tolerance for the ODE solver.\nreltol: Relative tolerance for the ODE solver.\nsaveat: Time points at which to save the solution.\ninternalnorm: Optional norm function used by the integrator.\nkwargs_Flow: Additional keyword arguments passed to the solver.\n\nReturns\n\nA flow object f such that:\n\nf(t0, x0, p0, tf) integrates the state and costate from t0 to tf.\nf((t0, tf), x0, p0) returns the full trajectory over the interval.\n\nExample\n\njulia> u = (x, p) -> p\njulia> f = Flow(ocp, ControlLaw(u))\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::Function;\n    autonomous,\n    variable,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> Union{CTFlowsODE.OptimalControlFlow{CTFlows.Fixed}, CTFlowsODE.OptimalControlFlow{CTFlows.NonFixed}}\n\n\nConstruct a flow for an optimal control problem using a control function in feedback form.\n\nThis method constructs the Hamiltonian and integrates the associated state–costate dynamics using a raw function u. It automatically wraps u as a control law.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem.\nu::Function: A feedback control function:\nIf ocp is autonomous: u(x, p)\nIf non-autonomous: u(t, x, p)\nautonomous::Bool: Whether the control law depends on time.\nvariable::Bool: Whether the OCP involves variable time (e.g., free final time).\nalg, abstol, reltol, saveat, internalnorm: ODE solver parameters.\nkwargs_Flow: Additional options.\n\nReturns\n\nA Flow object compatible with function call interfaces for state propagation.\n\nExample\n\njulia> u = (t, x, p) -> t + p\njulia> f = Flow(ocp, u)\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::Union{CTFlows.ControlLaw{<:Function, T, V}, CTFlows.FeedbackControl{<:Function, T, V}},\n    g::Union{CTFlows.MixedConstraint{<:Function, T, V}, CTFlows.StateConstraint{<:Function, T, V}},\n    μ::CTFlows.Multiplier{<:Function, T, V};\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> Union{CTFlowsODE.OptimalControlFlow{CTFlows.Fixed}, CTFlowsODE.OptimalControlFlow{CTFlows.NonFixed}}\n\n\nConstruct a flow for an optimal control problem with control and constraint multipliers in feedback form.\n\nThis variant constructs a Hamiltonian system incorporating both the control law and a multiplier law (e.g., for enforcing state or mixed constraints). All inputs must be consistent in time dependence.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem.\nu::ControlLaw or FeedbackControl: Feedback control.\ng::StateConstraint or MixedConstraint: Constraint function.\nμ::Multiplier: Multiplier function.\nalg, abstol, reltol, saveat, internalnorm: Solver settings.\nkwargs_Flow: Additional options.\n\nReturns\n\nA Flow object that integrates the constrained Hamiltonian dynamics.\n\nExample\n\njulia> f = Flow(ocp, (x, p) -> p[1], (x, u) -> x[1] - 1, (x, p) -> x[1]+p[1])\n\nFor non-autonomous cases:\n\njulia> f = Flow(ocp, (t, x, p) -> t + p, (t, x, u) -> x - 1, (t, x, p) -> x+p)\n\nwarning: Warning\nAll input functions must match the autonomous/non-autonomous nature of the problem.\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::Function,\n    g::Function,\n    μ::Function;\n    autonomous,\n    variable,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> Union{CTFlowsODE.OptimalControlFlow{CTFlows.Fixed}, CTFlowsODE.OptimalControlFlow{CTFlows.NonFixed}}\n\n\nConstruct a flow from a raw feedback control, constraint, and multiplier.\n\nThis version is for defining flows directly from user functions without wrapping them into ControlLaw, Constraint, or Multiplier types. Automatically wraps and adapts them based on time dependence.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem.\nu::Function: Control law.\ng::Function: Constraint.\nμ::Function: Multiplier.\nautonomous::Bool: Whether the system is autonomous.\nvariable::Bool: Whether time is a free variable.\nalg, abstol, reltol, saveat, internalnorm: Solver parameters.\nkwargs_Flow: Additional options.\n\nReturns\n\nA Flow object ready for trajectory integration.\n\n\n\n\n\nFlow(\n    dyn::Function;\n    autonomous,\n    variable,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.ODEFlow\n\n\nConstructs a Flow from a user-defined dynamical system given as a Julia function.\n\nThis high-level interface handles:\n\nautonomous and non-autonomous systems,\npresence or absence of additional variables (v),\nselection of ODE solvers and tolerances,\nand integrates with the CTFlows event system (e.g., jumps, callbacks).\n\nArguments\n\ndyn: A function defining the vector field. Its signature must match the values of autonomous and variable.\nautonomous: Whether the dynamics are time-independent (false by default).\nvariable: Whether the dynamics depend on a control or parameter v.\nalg, abstol, reltol, saveat, internalnorm: Solver settings passed to OrdinaryDiffEq.solve.\nkwargs_Flow: Additional keyword arguments passed to the solver.\n\nReturns\n\nAn ODEFlow object, wrapping both the full solver and its right-hand side (RHS).\n\nSupported Function Signatures for dyn\n\nDepending on the (autonomous, variable) flags:\n\n(false, false): dyn(x)\n(false, true):  dyn(x, v)\n(true, false):  dyn(t, x)\n(true, true):   dyn(t, x, v)\n\nExample\n\njulia> dyn(t, x, v) = [-x[1] + v[1] * sin(t)]\njulia> flow = CTFlows.Flow(dyn; autonomous=true, variable=true)\njulia> xT = flow((0.0, 1.0), [1.0], [0.1])\n\n\n\n\n\n","category":"function"},{"location":"manual-plot.html#manual-plot","page":"Plot a solution","title":"How to plot a solution","text":"In this tutorial, we explain the different options for plotting the solution of an optimal control problem using the plot and plot! functions, which are extensions of the Plots.jl package. Use plot to create a new plot object, and plot! to add to an existing one:\n\nplot(args...; kw...)           # creates a new Plot, and set it to be the `current`\nplot!(args...; kw...)          # modifies Plot `current()`\nplot!(plt, args...; kw...)     # modifies Plot `plt`\n\nMore precisely, the signature of plot, to plot a solution, is as follows.","category":"section"},{"location":"manual-plot.html#Argument-Overview","page":"Plot a solution","title":"Argument Overview","text":"The table below summarizes the main plotting arguments and links to the corresponding documentation sections for detailed explanations:\n\nSection Relevant Arguments\nBasic concepts size, state_style, costate_style, control_style, time_style, kwargs...\nSplit vs. group layout layout\nPlotting control norm control\nNormalised time time\nConstraints state_bounds_style, control_bounds_style, path_style, path_bounds_style, dual_style\nWhat to plot description...\n\nYou can plot solutions obtained from the solve function or from a flow computed using an optimal control problem and a control law. See the Basic Concepts and From Flow function sections for details.\n\nTo overlay a new plot on an existing one, use the plot! function (see Add a plot).\n\nIf you prefer full control over the visualisation, you can extract the state, costate, and control to create your own plots. Refer to the Custom plot section for guidance. You can also access the subplots.","category":"section"},{"location":"manual-plot.html#The-problem-and-the-solution","page":"Plot a solution","title":"The problem and the solution","text":"Let us start by importing the packages needed to define and solve the problem.\n\nusing OptimalControl\nusing NLPModelsIpopt\n\nWe consider the simple optimal control problem from the basic example page.\n\nt0 = 0          # initial time\ntf = 1          # final time\nx0 = [-1, 0]    # initial condition\nxf = [ 0, 0]    # final condition\n\nocp = @def begin\n    t ∈ [t0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x(t0) == x0\n    x(tf) == xf\n    ẋ(t) == [x₂(t), u(t)]\n    ∫( 0.5u(t)^2 ) → min\nend\n\nsol = solve(ocp, display=false)\nnothing # hide","category":"section"},{"location":"manual-plot.html#manual-plot-basic","page":"Plot a solution","title":"Basic concepts","text":"The simplest way to plot the solution is to use the plot function with the solution as the only argument.\n\ncaveat: Caveat\nThe plot function for a solution of an optimal control problem extends the plot function from Plots.jl. Therefore, you need to import this package in order to plot a solution.\n\nusing Plots\nplot(sol)\n\nIn the figure above, we have a grid of subplots: the left column displays the state component trajectories, the right column shows the costate component trajectories, and the bottom row contains the control component trajectory.\n\nAs in Plots.jl, input data is passed positionally (for example, sol in plot(sol)), and attributes are passed as keyword arguments (for example, plot(sol; color = :blue)). After executing using Plots in the REPL, you can use the plotattr() function to print a list of all available attributes for series, plots, subplots, or axes.\n\n# Valid Operations\nplotattr(:Plot)\nplotattr(:Series)\nplotattr(:Subplot)\nplotattr(:Axis)\n\nOnce you have the list of attributes, you can either use the aliases of a specific attribute or inspect a specific attribute to display its aliases and description.\n\nplotattr(\"color\") # Specific Attribute Example\n\nwarning: Warning\nSome attributes have different default values in OptimalControl.jl compared to Plots.jl. For instance, the default figure size is 600x400 in Plots.jl, while in OptimalControl.jl, it depends on the number of states and controls.\n\nYou can also visit the Plot documentation online to get the descriptions of the attributes:\n\nTo pass attributes to the plot, see the attributes plot documentation. For instance, you can specify the size of the figure.\n\n<details style=\"margin-left:3em\"><summary>List of plot attributes.</summary>\n\nfor a in Plots.attributes(:Plot) # hide\n    println(a) # hide\nend # hide\n\n</details>\n\nYou can pass attributes to all subplots at once by referring to the attributes subplot documentation. For example, you can specify the location of the legends.\n\n<details style=\"margin-left:3em\"><summary>List of subplot attributes.</summary>\n\nfor a in Plots.attributes(:Subplot) # hide\n    println(a) # hide\nend # hide\n\n</details>\n\nSimilarly, you can pass axis attributes to all subplots. See the attributes axis documentation. For example, you can remove the grid from every subplot.\n\n<details style=\"margin-left:3em\"><summary>List of axis attributes.</summary>\n\nfor a in Plots.attributes(:Axis) # hide\n    println(a) # hide\nend # hide\n\n</details>\n\nFinally, you can pass series attributes to all subplots. Refer to the attributes series documentation. For instance, you can set the width of the curves using linewidth.\n\n<details style=\"margin-left:3em\"><summary>List of series attributes.</summary>\n\nfor a in Plots.attributes(:Series) # hide\n    println(a) # hide\nend # hide\n\n</details>\n</br>\n\nplot(sol, size=(700, 450), label=\"sol\", legend=:bottomright, grid=false, linewidth=2)\n\nTo specify series attributes for a specific group of subplots (state, costate or control), you can use the optional keyword arguments state_style, costate_style, and control_style, which correspond to the state, costate, and control trajectories, respectively.\n\nplot(sol; \n     state_style   = (color=:blue,),                  # style: state trajectory\n     costate_style = (color=:black, linestyle=:dash), # style: costate trajectory\n     control_style = (color=:red, linewidth=2))       # style: control trajectory\n\nVertical axes at the initial and final times are automatically plotted. The style can me modified with the time_style keyword argument.  Additionally, you can choose not to display for instance the state and the costate trajectories by setting their styles to :none. You can set to :none any style.\n\nplot(sol; \n     state_style    = :none,             # do not plot the state\n     costate_style  = :none,             # do not plot the costate\n     control_style  = (color = :red,),   # plot the control in red\n     time_style     = (color = :green,)) # vertical axes at initial and final times in green\n\nTo select what to display, you can also use the description argument by providing a list of symbols such as :state, :costate, and :control.\n\nplot(sol, :state, :control)  # plot the state and the control\n\nnote: Select what to plot\nFor more details on how to choose what to plot, see the What to plot section.","category":"section"},{"location":"manual-plot.html#manual-plot-flow","page":"Plot a solution","title":"From Flow function","text":"The previous solution of the optimal control problem was obtained using the solve function. If you prefer using an indirect shooting method and solving shooting equations, you may also want to plot the associated solution. To do this, you need to use the Flow function to reconstruct the solution. See the manual on how to compute flows for more details. In our case, you must provide the maximizing control (x p) mapsto p_2 along with the optimal control problem. For an introduction to simple indirect shooting, see the indirect simple shooting tutorial for an example.\n\ntip: Interactions with an optimal control solution\nPlease check state, costate, control, and variable to retrieve data from the solution. The functions state, costate, and control return functions of time, while variable returns a vector.\n\nusing OrdinaryDiffEq\n\np  = costate(sol)                # costate as a function of time\np0 = p(t0)                       # costate solution at the initial time\nf  = Flow(ocp, (x, p) -> p[2])   # flow from an ocp and a control law in feedback form\n\nsol_flow = f((t0, tf), x0, p0)   # compute the solution\nplot(sol_flow)                   # plot the solution from a flow\n\nWe may notice that the time grid contains very few points. This is evident from the subplot of x_2, or by retrieving the time grid directly from the solution.\n\ntime_grid(sol_flow)\n\nTo improve visualisation (without changing the accuracy), you can provide a finer grid.\n\nfine_grid = range(t0, tf, 100)\nsol_flow = f((t0, tf), x0, p0; saveat=fine_grid)\nplot(sol_flow)","category":"section"},{"location":"manual-plot.html#manual-plot-layout","page":"Plot a solution","title":"Split vs. group layout","text":"If you prefer to get a more compact figure, you can use the layout optional keyword argument with :group value. It will group the state, costate and control trajectories in one subplot for each.\n\nplot(sol; layout=:group)\n\nThe default layout value is :split which corresponds to the grid of subplots presented above.\n\nplot(sol; layout=:split)","category":"section"},{"location":"manual-plot.html#manual-plot-add","page":"Plot a solution","title":"Add a plot","text":"You can plot the solution of a second optimal control problem on the same figure if it has the same number of states, costates and controls. For instance, consider the same optimal control problem but with a different initial condition.\n\nocp = @def begin\n    t ∈ [t0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x(t0) == [-0.5, -0.5]\n    x(tf) == xf\n    ẋ(t) == [x₂(t), u(t)]\n    ∫( 0.5u(t)^2 ) → min\nend\nsol2 = solve(ocp; display=false)\nnothing # hide\n\nWe first plot the solution of the first optimal control problem, then, we plot the solution of the second optimal control problem on the same figure, but with dashed lines.\n\nplt = plot(sol; label=\"sol1\", size=(700, 500))\nplot!(plt, sol2; label=\"sol2\", linestyle=:dash)\n\nYou can also, implicitly, use the current plot.\n\nplot(sol; label=\"sol1\", size=(700, 500))\nplot!(sol2; label=\"sol2\", linestyle=:dash)","category":"section"},{"location":"manual-plot.html#manual-plot-control","page":"Plot a solution","title":"Plotting the control norm","text":"For some problem, it is interesting to plot the (Euclidean) norm of the control. You can do it by using the control optional keyword argument with :norm value.\n\nplot(sol; control=:norm, size=(800, 300), layout=:group)\n\nThe default value is :components.\n\nplot(sol; control=:components, size=(800, 300), layout=:group)\n\nYou can also plot the control and its norm.\n\nplot(sol; control=:all, layout=:group)","category":"section"},{"location":"manual-plot.html#manual-plot-custom","page":"Plot a solution","title":"Custom plot and subplots","text":"You can, of course, create your own plots by extracting the state, costate, and control from the optimal control solution. For instance, let us plot the norm of the control.\n\nusing LinearAlgebra\nt = time_grid(sol)\nu = control(sol)\nplot(t, norm∘u; label=\"‖u‖\", xlabel=\"t\") \n\nYou can also get access to the subplots. The order is as follows: state, costate, control, path constraints (if any) and their dual variables.\n\nplt = plot(sol)\nplot(plt[1]) # x₁\n\nplt = plot(sol)\nplot(plt[2]) # x₂\n\nplt = plot(sol)\nplot(plt[3]) # p₁\n\nplot(plt[4]) # p₂\n\nplot(plt[5]) # u","category":"section"},{"location":"manual-plot.html#manual-plot-time","page":"Plot a solution","title":"Normalised time","text":"We consider a LQR example and solve the problem for different values of the final time tf. Then, we plot the solutions on the same figure using a normalised time s = (t - t_0)  (t_f - t_0), enabled by the keyword argument time = :normalize (or :normalise) in the plot function.\n\n# definition of the problem, parameterised by the final time\nfunction lqr(tf)\n\n    ocp = @def begin\n        t ∈ [0, tf], time\n        x ∈ R², state\n        u ∈ R, control\n        x(0) == [0, 1]\n        ẋ(t) == [x₂(t), - x₁(t) + u(t)]\n        ∫( 0.5(x₁(t)^2 + x₂(t)^2 + u(t)^2) ) → min\n    end\n\n    return ocp\nend\n\n# solve the problems and store them\nsolutions = []\ntfs = [3, 5, 30]\nfor tf ∈ tfs\n    solution = solve(lqr(tf); display=false)\n    push!(solutions, solution)\nend\n\n# create plots\nplt = plot()\nfor (tf, sol) ∈ zip(tfs, solutions)\n    plot!(plt, sol; time=:normalize, label=\"tf = $tf\", xlabel=\"s\")\nend\n\n# make a custom plot: keep only state and control\npx1 = plot(plt[1]; legend=false) # x₁\npx2 = plot(plt[2]; legend=true)  # x₂\npu  = plot(plt[5]; legend=false) # u    \n\nusing Plots.PlotMeasures # for leftmargin, bottommargin\nplot(px1, px2, pu; layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"section"},{"location":"manual-plot.html#manual-plot-constraints","page":"Plot a solution","title":"Constraints","text":"We define an optimal control problem with constraints, solve it and plot the solution.\n\nocp = @def begin\n    tf ∈ R,          variable\n    t ∈ [0, tf],     time\n    x = (q, v) ∈ R², state\n    u ∈ R,           control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q(0)  == -1\n    v(0)  == 0\n    q(tf) == 0\n    v(tf) == 0\n    1 ≤ v(t)+1 ≤ 1.8, (1)\n    ẋ(t) == [v(t), u(t)]\n    tf → min\nend\nsol = solve(ocp)\nplot(sol)\n\nOn the plot, you can see the lower and upper bounds of the path constraint. Additionally, the dual variable associated with the path constraint is displayed alongside it.\n\nYou can customise the plot styles. For style options related to the state, costate, and control, refer to the Basic Concepts section.\n\nplot(sol; \n     state_bounds_style = (linestyle = :dash,),\n     control_bounds_style = (linestyle = :dash,),\n     path_style = (color = :green,),\n     path_bounds_style = (linestyle = :dash,),\n     dual_style = (color = :red,),\n     time_style = :none, # do not plot axes at t0 and tf\n)","category":"section"},{"location":"manual-plot.html#manual-plot-select","page":"Plot a solution","title":"What to plot","text":"You can choose what to plot using the description argument. To plot only one subgroup:\n\nplot(sol, :state)   # plot only the state\nplot(sol, :costate) # plot only the costate\nplot(sol, :control) # plot only the control\nplot(sol, :path)    # plot only the path constraint\nplot(sol, :dual)    # plot only the path constraint dual variable\n\nYou can combine elements to plot exactly what you need:\n\nplot(sol, :state, :control, :path)\n\nSimilarly, you can choose what not to plot passing :none to the corresponding style.\n\nplot(sol; state_style=:none)   # do not plot the state\nplot(sol; costate_style=:none) # do not plot the costate\nplot(sol; control_style=:none) # do not plot the control\nplot(sol; path_style=:none)    # do not plot the path constraint\nplot(sol; dual_style=:none)    # do not plot the path constraint dual variable\n\nFor instance, let's plot everything except the dual variable associated with the path constraint.\n\nplot(sol; dual_style=:none)\n\n","category":"section"},{"location":"manual-plot.html#RecipesBase.plot-Tuple{Solution, Vararg{Symbol}}-manual-plot","page":"Plot a solution","title":"RecipesBase.plot","text":"plot(\n    sol::Solution,\n    description::Symbol...;\n    layout,\n    control,\n    time,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    time_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    size,\n    color,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot the components of an optimal control solution.\n\nThis is the main user-facing function to visualise the solution of an optimal control problem solved with the control-toolbox ecosystem.\n\nIt generates a set of subplots showing the evolution of the state, control, costate, path constraints, and dual variables over time, depending on the problem and the user’s choices.\n\nArguments\n\nsol::CTModels.Solution: The optimal control solution to visualise.\ndescription::Symbol...: A variable number of symbols indicating which components to include in the plot. Common values include:\n:state – plot the state.\n:costate – plot the costate (adjoint).\n:control – plot the control.\n:path – plot the path constraints.\n:dual – plot the dual variables (or Lagrange multipliers) associated with path constraints.\n\nIf no symbols are provided, a default set is used based on the problem and styles.\n\nKeyword Arguments (Optional)\n\nlayout::Symbol = :group: Specifies how to arrange plots.\n:group: Fewer plots, grouping similar variables together (e.g., all states in one subplot).\n:split: One plot per variable component, stacked in a layout.\ncontrol::Symbol = :components: Defines how to represent control inputs.\n:components: One curve per control component.\n:norm: Single curve showing the Euclidean norm ‖u(t)‖.\n:all: Plot both components and norm.\ntime::Symbol = :default: Time normalisation for plots.\n:default: Real time scale.\n:normalize or :normalise: Normalised to the interval [0, 1].\ncolor: set the color of the all the graphs.\n\nStyle Options (Optional)\n\nAll style-related keyword arguments can be either a NamedTuple of plotting attributes or the Symbol :none referring to not plot the associated element. These allow you to customise color, line style, markers, etc.\n\ntime_style: Style for vertical lines at initial and final times.\nstate_style: Style for state components.\ncostate_style: Style for costate components.\ncontrol_style: Style for control components.\npath_style: Style for path constraint values.\ndual_style: Style for dual variables.\n\nBounds Decorations (Optional)\n\nUse these options to customise bounds on the plots if applicable and defined in the model. Set to :none to hide.\n\nstate_bounds_style: Style for state bounds.\ncontrol_bounds_style: Style for control bounds.\npath_bounds_style: Style for path constraint bounds.\n\nReturns\n\nA Plots.Plot object, which can be displayed, saved, or further customised.\n\nExample\n\n# basic plot\njulia> plot(sol)\n\n# plot only the state and control\njulia> plot(sol, :state, :control)\n\n# customise layout and styles, no costate\njulia> plot(sol;\n       layout = :group,\n       control = :all,\n       state_style = (color=:blue, linestyle=:solid),\n       control_style = (color=:red, linestyle=:dash),\n       costate_style = :none)       \n\n\n\n\n\n","category":"method"},{"location":"manual-plot.html#RecipesBase.plot!-Tuple{Solution, Vararg{Symbol}}-manual-plot","page":"Plot a solution","title":"RecipesBase.plot!","text":"plot!(\n    sol::Solution,\n    description::Symbol...;\n    layout,\n    control,\n    time,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    time_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    color,\n    kwargs...\n) -> Any\n\n\nModify Plot current() with the optimal control solution sol.\n\nSee plot for full behavior and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"manual-plot.html#RecipesBase.plot!-Tuple{Plots.Plot, Solution, Vararg{Symbol}}-manual-plot","page":"Plot a solution","title":"RecipesBase.plot!","text":"plot!(\n    p::Plots.Plot,\n    sol::Solution,\n    description::Symbol...;\n    layout,\n    control,\n    time,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    time_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    color,\n    kwargs...\n) -> Plots.Plot\n\n\nModify Plot p with the optimal control solution sol.\n\nSee plot for full behavior and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"manual-abstract.html#manual-abstract-syntax","page":"Define a problem","title":"The syntax to define an optimal control problem","text":"The full grammar of OptimalControl.jl small Domain Specific Language is given below. The idea is to use a syntax that is\n\npure Julia (and, as such, effortlessly analysed by the standard Julia parser),\nas close as possible to the mathematical description of an optimal control problem. \n\nWhile the syntax will be transparent to those users familiar with Julia expressions (Expr's), we provide examples for every case that should be widely understandable. We rely heavily on MLStyle.jl and its pattern matching abilities 👍🏽 both for the syntactic and semantic pass. Abstract definitions use the macro @def.","category":"section"},{"location":"manual-abstract.html#manual-abstract-variable","page":"Define a problem","title":"Variable","text":":( $v ∈ R^$q, variable ) \n:( $v ∈ R   , variable ) \n\nA variable (only one is allowed) is a finite dimensional vector or reals that will be optimised along with state and control values. To define an (almost empty!) optimal control problem, named ocp, having a dimension two variable named v, do the following:\n\n@def begin\n    v ∈ R², variable\n    ...\nend\n\nwarning: Warning\nNote that the full code of the definition above is not provided (hence the ...) The same is true for most examples below (only those without ... are indeed complete). Also note that problem definitions must at least include definitions for time, state, control, dynamics and cost.\n\nAliases v₁, v₂ (and v1, v2) are automatically defined and can be used in subsequent expressions instead of v[1] and v[2]. The user can also define her own aliases for the components (one alias per dimension):\n\n@def begin\n    v = (a, b) ∈ R², variable\n    ...\nend\n\nA one dimensional variable can be declared according to\n\n@def begin\n    v ∈ R, variable\n    ...\nend\n\nwarning: Warning\nAliases during definition of variable, state or control are only allowed for multidimensional (dimension two or more) cases. Something like u = T ∈ R, control is not allowed... and useless (directly write T ∈ R, control).","category":"section"},{"location":"manual-abstract.html#Time","page":"Define a problem","title":"Time","text":":( $t ∈ [$t0, $tf], time ) \n\nThe independent variable or time is a scalar bound to a given interval. Its name is arbitrary.\n\nt0 = 1\ntf = 5\n@def begin\n    t ∈ [t0, tf], time\n    ...\nend\n\nOne (or even the two bounds) can be variable, typically for minimum time problems (see Mayer cost section):\n\n@def begin\n    v = (T, λ) ∈ R², variable\n    t ∈ [0, T], time\n    ...\nend","category":"section"},{"location":"manual-abstract.html#manual-abstract-state","page":"Define a problem","title":"State","text":":( $x ∈ R^$n, state ) \n:( $x ∈ R   , state ) \n\nThe state declaration defines the name and the dimension of the state:\n\n@def begin\n    x ∈ R⁴, state\n    ...\nend\n\nAs for the variable, there are automatic aliases (x₁ and x1 for x[1], etc.) and the user can define her own aliases (one per scalar component of the state):\n\n@def begin\n    x = (q₁, q₂, v₁, v₂) ∈ R⁴, state\n    ...\nend","category":"section"},{"location":"manual-abstract.html#manual-abstract-control","page":"Define a problem","title":"Control","text":":( $u ∈ R^$m, control ) \n:( $u ∈ R   , control ) \n\nThe control declaration defines the name and the dimension of the control:\n\n@def begin\n    u ∈ R², control\n    ...\nend\n\nAs before, there are automatic aliases (u₁ and u1 for u[1], etc.) and the user can define her own aliases (one per scalar component of the state):\n\n@def begin\n    u = (α, β) ∈ R², control\n    ...\nend\n\nnote: Note\nOne dimensional variable, state or control are treated as scalars (Real), not vectors (Vector). In Julia, for x::Real, it is possible to write x[1] (and x[1][1]...) so it is OK (though useless) to write x₁, x1 or x[1] instead of simply x to access the corresponding value. Conversely it is not OK to use such an x as a vector, for instance as in ...f(x)... where f(x::Vector{T}) where {T <: Real}.","category":"section"},{"location":"manual-abstract.html#manual-abstract-dynamics","page":"Define a problem","title":"Dynamics","text":":( ∂($x)($t) == $e1 ) \n\nThe dynamics is given in the standard vectorial ODE form:\n\n    dotx(t) = f(t x(t) u(t) v)\n\ndepending on whether it is autonomous / with a variable or not (the parser will detect time and variable dependences, which entails that time, state and variable must be declared prior to dynamics - an error will be issued otherwise). The symbol ∂, or the dotted state name (ẋ), or the keyword derivative can be used:\n\n@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    ∂(x)(t) == [x₂(t), u(t)]\n    ...\nend\n\nor\n\n@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    ẋ(t) == [x₂(t), u(t)]\n    ...\nend\n\nor\n\n@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    derivative(x)(t) == [x₂(t), u(t)]\n    ...\nend\n\nAny Julia code can be used, so the following is also OK: \n\nocp = @def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    ẋ(t) == F₀(x(t)) + u(t) * F₁(x(t))\n    ...\nend\n\nF₀(x) = [x[2], 0]\nF₁(x) = [0, 1]\n\nnote: Note\nThe vector fields F₀ and F₁ can be defined afterwards, as they only need to be available when the dynamics will be evaluated.\n\nWhile it is also possible to declare the dynamics component after component (see below), one may equivalently use aliases (check the relevant aliases section below):\n\n@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    q̇ = v(t)\n    v̇ = u(t) - c(t)\n    ẋ(t) == [q̇, v̇]\n    ...\nend","category":"section"},{"location":"manual-abstract.html#manual-abstract-dynamics-coord","page":"Define a problem","title":"Dynamics (coordinatewise)","text":":( ∂($x[$i])($t) == $e1 ) \n\nThe dynamics can also be declared coordinate by coordinate. The previous example can be written as\n\n@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    ∂(q)(t) == v(t)\n    ∂(v)(t) == u(t) - c(t)\n    ...\nend\n\nwarning: Warning\nDeclaring the dynamics coordinate by coordinate is compulsory when solving with the option :exa to rely on the ExaModels modeller (check the solve section), for instance to solve on GPU.","category":"section"},{"location":"manual-abstract.html#manual-abstract-constraints","page":"Define a problem","title":"Constraints","text":":( $e1 == $e2        ) \n:( $e1 ≤  $e2 ≤  $e3 ) \n:(        $e2 ≤  $e3 ) \n:( $e3 ≥  $e2 ≥  $e1 ) \n:( $e2 ≥  $e1        ) \n\nAdmissible constraints can be\n\nof five types: boundary, variable, control, state, mixed (the last three ones are path constraints, that is constraints evaluated all times)\nlinear (ranges) or nonlinear (not ranges),\nequalities or (one or two-sided) inequalities.\n\nBoundary conditions are detected when the expression contains evaluations of the state at initial and / or final time bounds (e.g., x(0)), and may not involve the control. Conversely control, state or mixed constraints will involve control, state or both evaluated at the declared time (e.g., x(t) + u(t)).  Other combinations should be detected as incorrect by the parser 🤞🏾. The variable may be involved in any of the four previous constraints. Constraints involving the variable only are variable constraints, either linear or nonlinear. In the example below, there are\n\ntwo linear boundary constraints,\none linear variable constraint,\none linear state constraint,\none (two-sided) nonlinear control constraint.\n\n@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(tf) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    tf ≥ 0 \n    x₂(t) ≤ 1\n    0.1 ≤ u(t)^2 ≤ 1\n    ...\nend\n\nnote: Note\nSymbols like <= or >= are also authorised:\n\n@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(tf) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    tf >= 0 \n    x₂(t) <= 1\n    0.1 ≤ u(t)^2 <= 1\n    ...\nend\n\nwarning: Warning\nWrite either u(t)^2 or (u^2)(t), not u^2(t) since in Julia the latter means u^(2t). Moreover, in the case of equalities or of one-sided inequalities, the control and / or the state must belong to the left-hand side. The following will error:\n\n@def begin\n    t ∈ [0, 2], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(2) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    1 ≤ x₂(t)\n    -1 ≤ u(t) ≤ 1\nend\n\nwarning: Warning\nConstraint bounds must be effective, that is must not depend on a variable. For instance, instead of\n\no = @def begin\n    v ∈ R, variable\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    -1 ≤ v ≤ 1\n    x₁(0) == -1\n    x₂(0) == v # wrong: the bound is not effective (as it depends on the variable)\n    x(1) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    ∫( 0.5u(t)^2 ) → min\nend\n\nwrite\n\no = @def begin\n    v ∈ R, variable\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    -1 ≤ v ≤ 1\n    x₁(0) == -1\n    x₂(0) - v == 0 # OK: the boundary constraint may involve the variable\n    x(1) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    ∫( 0.5u(t)^2 ) → min\nend\n\nwarning: Warning\nWhen solving with the option :exa to rely on the ExaModels modeller (check the solve section), for instance to solve on GPU, it is compulsory that nonlinear constraints (not ranges) are scalar, whatever the type (boundary, variable, control, state, mixed).","category":"section"},{"location":"manual-abstract.html#manual-abstract-mayer","page":"Define a problem","title":"Mayer cost","text":":( $e1 → min ) \n:( $e1 → max ) \n\nMayer costs are defined in a similar way to boundary conditions and follow the same rules. The symbol → is used to denote minimisation or maximisation, the latter being treated by minimising the opposite cost. (The symbol => can also be used.)\n\n@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5\n   -2 ≤ v(t) ≤ 3\n    ẋ(t) == [v(t), u(t)]\n    tf → min\nend","category":"section"},{"location":"manual-abstract.html#Lagrange-cost","page":"Define a problem","title":"Lagrange cost","text":":(       ∫($e1) → min ) \n:(     - ∫($e1) → min ) \n:( $e1 * ∫($e2) → min ) \n:(       ∫($e1) → max ) \n:(     - ∫($e1) → max ) \n:( $e1 * ∫($e2) → max ) \n\nLagrange (integral) costs are defined used the symbol ∫, with parentheses. The keyword integral can also be used:\n\n@def begin\n    t ∈ [0, 1], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    0.5∫(q(t) + u(t)^2) → min\n    ...\nend\n\nor\n\n@def begin\n    t ∈ [0, 1], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    0.5integral(q(t) + u(t)^2) → min\n    ...\nend\n\nThe integration range is implicitly equal to the time range, so the cost above is to be understood as\n\nfrac12 int_0^1 left( q(t) + u^2(t) right) mathrmdt to min\n\nAs for the dynamics, the parser will detect whether the integrand depends or not on time (autonomous / non-autonomous case).","category":"section"},{"location":"manual-abstract.html#Bolza-cost","page":"Define a problem","title":"Bolza cost","text":":( $e1 +       ∫($e2)       → min ) \n:( $e1 + $e2 * ∫($e3)       → min ) \n:( $e1 -       ∫($e2)       → min ) \n:( $e1 - $e2 * ∫($e3)       → min ) \n:( $e1 +       ∫($e2)       → max ) \n:( $e1 + $e2 * ∫($e3)       → max ) \n:( $e1 -       ∫($e2)       → max ) \n:( $e1 - $e2 * ∫($e3)       → max ) \n:(             ∫($e2) + $e1 → min ) \n:(       $e2 * ∫($e3) + $e1 → min ) \n:(             ∫($e2) - $e1 → min ) \n:(       $e2 * ∫($e3) - $e1 → min ) \n:(             ∫($e2) + $e1 → max ) \n:(       $e2 * ∫($e3) + $e1 → max ) \n:(             ∫($e2) - $e1 → max ) \n:(       $e2 * ∫($e3) - $e1 → max ) \n\nQuite readily, Mayer and Lagrange costs can be combined into general Bolza costs. For instance as follows:\n\n@def begin\n    p = (t0, tf) ∈ R², variable\n    t ∈ [t0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R², control\n    (tf - t0) + 0.5∫(c(t) * u(t)^2) → min\n    ...\nend\n\nwarning: Warning\nThe expression must be the sum of two terms (plus, possibly, a scalar factor before the integral), not more, so mind the parentheses. For instance, the following errors:\n\n@def begin\n    p = (t0, tf) ∈ R², variable\n    t ∈ [t0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R², control\n    (tf - t0) + q(tf) + 0.5∫( c(t) * u(t)^2 ) → min\n    ...\nend\n\nThe correct syntax is\n\n@def begin\n    p = (t0, tf) ∈ R², variable\n    t ∈ [t0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R², control\n    ((tf - t0) + q(tf)) + 0.5∫( c(t) * u(t)^2 ) → min\n    ...\nend","category":"section"},{"location":"manual-abstract.html#manual-abstract-aliases","page":"Define a problem","title":"Aliases","text":":( $a = $e1 )\n\nThe single = symbol is used to define not a constraint but an alias, that is a purely syntactic replacement. There are some automatic aliases, e.g. x₁ and x1 for x[1] if x is the state (same for variable and control, for indices comprised between 1 and 9), and we have also seen that the user can define her own aliases when declaring the variable, state and control. Arbitrary aliases can be further defined, as below (compare with previous examples in the dynamics section):\n\n@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    F₀ = [x₂(t), 0]\n    F₁ = [0, 1]\n    ẋ(t) == F₀ + u(t) * F₁\n    ...\nend\n\nwarning: Warning\nSuch aliases do not define any additional function and are just replaced textually by the parser. In particular, they cannot be used outside the @def begin ... end block. Conversely, constants and functions used within the @def block must be defined outside and before this block.\n\nhint: Hint\nYou can rely on a trace mode for the macro @def to look at your code after expansions of the aliases using the @def ocp ... syntax and adding true after your begin ... end block:\n\n@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    q̇ = v(t)\n    v̇ = u(t) - c(t)\n    ẋ(t) == [q̇, v̇]\nend true;\n\nwarning: Warning\nThe dynamics of an OCP is indeed a particular constraint, be careful to use == and not a single = that would try to define an alias:\n\ndouble_integrator = @def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    q̇ = v\n    v̇ = u\n    ẋ(t) = [q̇, v̇]\nend","category":"section"},{"location":"manual-abstract.html#Misc","page":"Define a problem","title":"Misc","text":"Declarations (of variable - if any -, time, state and control) must be done first. Then, dynamics, constraints and cost can be introduced in an arbitrary order.\nIt is possible to provide numbers / labels (as in math equations) for the constraints to improve readability (this is mostly for future use, typically to retrieve the Lagrange multiplier associated with the discretisation of a given constraint):\n\n@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    tf ≥ 0, (1)\n    q(0) == 2, (♡)\n    q̇ = v(t)\n    v̇ = u(t) - c(t)\n    ẋ(t) == [q̇, v̇]\n    x(t).^2  ≤ [1, 2], (state_con) \n    ...\nend\n\nParsing errors should be explicit enough (with line number in the @def begin ... end block indicated) 🤞🏾\nCheck tutorials and applications in the documentation for further use.","category":"section"},{"location":"manual-abstract.html#manual-abstract-known-issues","page":"Define a problem","title":"Known issues","text":"Reverse over forward AD issues with ADNLP\n\n","category":"section"},{"location":"jlesc17.html","page":"Solving optimal control problems on GPU with Julia","title":"Solving optimal control problems on GPU with Julia","text":"<img width=\"800\" alt=\"jlesc17\" src=\"./assets/jlesc17.jpg\">","category":"section"},{"location":"jlesc17.html#Solving-optimal-control-problems-on-GPU-with-Julia","page":"Solving optimal control problems on GPU with Julia","title":"Solving optimal control problems on GPU with Julia","text":"","category":"section"},{"location":"jlesc17.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://github.com/joseph-gergaud),-[Pierre-Martinon](https://github.com/PierreMartinon),-[Sophia-Sed](https://sed-sam-blog.gitlabpages.inria.fr)","page":"Solving optimal control problems on GPU with Julia","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"section"},{"location":"jlesc17.html#What-it's-about","page":"Solving optimal control problems on GPU with Julia","title":"What it's about","text":"Nonlinear optimal control of ODEs:\n\ng(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min\n\nsubject to\n\ndotx(t) = f(x(t) u(t))quad t in t_0 t_f\n\nplus boundary, control and state constraints\n\nOur core interests: numerical & geometrical methods in control, applications\nWhy Julia: fast (+ JIT), strongly typed, high-level (AD, macros), fast optimisation and ODE solvers available, rapidly growing community\n\n<img width=\"800\" alt=\"juliacon2025\" src=\"./assets/juliacon2025.jpg\">","category":"section"},{"location":"jlesc17.html#Discretise-then-solve-strategy-(*aka*-direct-methods)","page":"Solving optimal control problems on GPU with Julia","title":"Discretise then solve strategy (aka direct methods)","text":"Discretising an OCP into an NLP: h_i = t_i+1-t_i,\n\ng(X_0X_N) + sum_i=0^N h_i f^0(X_iU_i) to min\n\nsubject to \n\nX_i+1 - X_i - h_i f(X_i U_i) = 0quad i = 0dotsN-1\n\nplus other constraints on X = (X_i)_i=0N and U = (U_i)_i=0N such as boundary and path (state and / or control) constraints :\n\nb(t_0 X_0 t_N X_N) = 0\n\nc(X_i U_i) = 0quad i = 0dotsN\n\nSIMD parallelism (f_0, f, g) + sparsity: Kernels for GPU (KernelAbstraction.jl) and sparse linear algebra (CUDSS.jl)\nModelling and optimising for GPU: ExaModels.jl  + MadNLP.jl, with built-in AD\nSimple example, DSL\nCompile into an ExaModel (one pass compiler, syntax + semantics)\n\n<details><summary>Simple example, generated code</summary>\n\nbegin\n    #= /data/caillau/CTParser.jl/src/onepass.jl:1003 =#\n    function (; scheme = :trapezoidal, grid_size = 200, backend = nothing, init = (0.1, 0.1, 0.1), base_type = Float64)\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1003 =#\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1004 =#\n        LineNumberNode(0, \"box constraints: variable\")\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1005 =#\n        begin\n            LineNumberNode(0, \"box constraints: state\")\n            begin\n                var\"##235\" = -Inf * ones(3)\n                #= /data/caillau/CTParser.jl/src/onepass.jl:461 =#\n                var\"##236\" = Inf * ones(3)\n            end\n        end\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1006 =#\n        begin\n            LineNumberNode(0, \"box constraints: control\")\n            begin\n                var\"##237\" = -Inf * ones(1)\n                #= /data/caillau/CTParser.jl/src/onepass.jl:512 =#\n                var\"##238\" = Inf * ones(1)\n            end\n        end\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1007 =#\n        var\"##230\" = ExaModels.ExaCore(base_type; backend = backend)\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1008 =#\n        begin\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:23 =#\n            var\"##232\" = begin\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                    local ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                    try\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                        (1 - 0) / grid_size\n                    catch ex\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                        println(\"Line \", 1, \": \", \"(t ∈ [0, 1], time)\")\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                        throw(ex)\n                    end\n                end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:24 =#\n            x = begin\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                    local ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                    try\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                        ExaModels.variable(var\"##230\", 3, 0:grid_size; lvar = [var\"##235\"[i] for (i, j) = Base.product(1:3, 0:grid_size)], uvar = [var\"##236\"[i] for (i, j) = Base.product(1:3, 0:grid_size)], start = init[2])\n                    catch ex\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                        println(\"Line \", 2, \": \", \"(x ∈ R ^ 3, state)\")\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                        throw(ex)\n                    end\n                end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:25 =#\n            var\"u##239\" = begin\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                    local ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                    try\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                        ExaModels.variable(var\"##230\", 1, 0:grid_size; lvar = [var\"##237\"[i] for (i, j) = Base.product(1:1, 0:grid_size)], uvar = [var\"##238\"[i] for (i, j) = Base.product(1:1, 0:grid_size)], start = init[3])\n                    catch ex\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                        println(\"Line \", 3, \": \", \"(u ∈ R, control)\")\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                        throw(ex)\n                    end\n                end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:26 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    ExaModels.constraint(var\"##230\", (x[i, 0] for i = 1:3); lcon = [-1, 0, 0], ucon = [-1, 0, 0])\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 4, \": \", \"x(0) == [-1, 0, 0]\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:27 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    ExaModels.constraint(var\"##230\", (x[i, grid_size] for i = 1:2); lcon = [0, 0], ucon = [0, 0])\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 5, \": \", \"(x[1:2])(1) == [0, 0]\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:28 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    begin\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:735 =#\n                        if scheme == :trapezoidal\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:736 =#\n                            ExaModels.constraint(var\"##230\", ((x[1, j + 1] - x[1, j]) - (var\"##232\" * (x[2, j] + x[2, j + 1])) / 2 for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:737 =# scheme == :euler\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:738 =#\n                            ExaModels.constraint(var\"##230\", ((x[1, j + 1] - x[1, j]) - var\"##232\" * x[2, j] for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:739 =# scheme == :euler_b\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:740 =#\n                            ExaModels.constraint(var\"##230\", ((x[1, j + 1] - x[1, j]) - var\"##232\" * x[2, j + 1] for j = 0:grid_size - 1))\n                        else\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:742 =#\n                            throw(\"unknown numerical scheme\")\n                        end\n                    end\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 6, \": \", \"(∂(x₁))(t) == x₂(t)\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:29 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    begin\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:735 =#\n                        if scheme == :trapezoidal\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:736 =#\n                            ExaModels.constraint(var\"##230\", ((x[2, j + 1] - x[2, j]) - (var\"##232\" * (var\"u##239\"[1, j] + var\"u##239\"[1, j + 1])) / 2 for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:737 =# scheme == :euler\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:738 =#\n                            ExaModels.constraint(var\"##230\", ((x[2, j + 1] - x[2, j]) - var\"##232\" * var\"u##239\"[1, j] for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:739 =# scheme == :euler_b\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:740 =#\n                            ExaModels.constraint(var\"##230\", ((x[2, j + 1] - x[2, j]) - var\"##232\" * var\"u##239\"[1, j + 1] for j = 0:grid_size - 1))\n                        else\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:742 =#\n                            throw(\"unknown numerical scheme\")\n                        end\n                    end\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 7, \": \", \"(∂(x₂))(t) == u(t)\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:30 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    begin\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:735 =#\n                        if scheme == :trapezoidal\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:736 =#\n                            ExaModels.constraint(var\"##230\", ((x[3, j + 1] - x[3, j]) - (var\"##232\" * (0.5 * var\"u##239\"[1, j] ^ 2 + 0.5 * var\"u##239\"[1, j + 1] ^ 2)) / 2 for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:737 =# scheme == :euler\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:738 =#\n                            ExaModels.constraint(var\"##230\", ((x[3, j + 1] - x[3, j]) - var\"##232\" * (0.5 * var\"u##239\"[1, j] ^ 2) for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:739 =# scheme == :euler_b\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:740 =#\n                            ExaModels.constraint(var\"##230\", ((x[3, j + 1] - x[3, j]) - var\"##232\" * (0.5 * var\"u##239\"[1, j + 1] ^ 2) for j = 0:grid_size - 1))\n                        else\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:742 =#\n                            throw(\"unknown numerical scheme\")\n                        end\n                    end\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 8, \": \", \"(∂(x₃))(t) == 0.5 * u(t) ^ 2\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:31 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    ExaModels.objective(var\"##230\", x[3, grid_size])\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 9, \": \", \"x₃(1) → min\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n        end\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1009 =#\n        begin\n            #= /data/caillau/CTParser.jl/src/onepass.jl:994 =#\n            !(isempty([1, 2, 3])) || throw(CTBase.ParsingError(\"dynamics not defined\"))\n            #= /data/caillau/CTParser.jl/src/onepass.jl:995 =#\n            sort([1, 2, 3]) == 1:3 || throw(CTBase.ParsingError(\"some coordinates of dynamics undefined\"))\n        end\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1010 =#\n        return ExaModels.ExaModel(var\"##230\")\n    end\nend\n\n</details>\n\nSolving (MadNLP + CUDSS)\n\nThis is MadNLP version v0.8.7, running with cuDSS v0.4.0\n\nNumber of nonzeros in constraint Jacobian............:    12005\nNumber of nonzeros in Lagrangian Hessian.............:     9000\n\nTotal number of variables............................:     4004\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:        0\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     3005\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  1.0000000e-01 1.10e+00 1.00e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.0001760e-01 1.10e+00 3.84e-03  -1.0 6.88e+02  -4.0 1.00e+00 2.00e-07h  2\n   2 -5.2365072e-03 1.89e-02 1.79e-07  -1.0 6.16e+00  -4.5 1.00e+00 1.00e+00h  1\n   3  5.9939621e+00 2.28e-03 1.66e-04  -3.8 6.00e+00  -5.0 9.99e-01 1.00e+00h  1\n   4  5.9996210e+00 2.94e-06 8.38e-07  -3.8 7.70e-02    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 4\n\n                                   (scaled)                 (unscaled)\nObjective...............:   5.9996210189633494e+00    5.9996210189633494e+00\nDual infeasibility......:   8.3756005011360529e-07    8.3756005011360529e-07\nConstraint violation....:   2.9426923277963834e-06    2.9426923277963834e-06\nComplementarity.........:   2.0007459547789288e-06    2.0007459547789288e-06\nOverall NLP error.......:   2.9426923277963834e-06    2.9426923277963834e-06\n\nNumber of objective function evaluations             = 6\nNumber of objective gradient evaluations             = 5\nNumber of constraint evaluations                     = 6\nNumber of constraint Jacobian evaluations            = 5\nNumber of Lagrangian Hessian evaluations             = 4\nTotal wall-clock secs in solver (w/o fun. eval./lin. alg.)  =  0.072\nTotal wall-clock secs in linear solver                      =  0.008\nTotal wall-clock secs in NLP function evaluations           =  0.003\nTotal wall-clock secs                                       =  0.083\n\nGoddard problem\n\nThis is MadNLP version v0.8.4, running with cuDSS v0.3.0\n\nNumber of nonzeros in constraint Jacobian............:   135017\nNumber of nonzeros in Lagrangian Hessian.............:   130008\n\nTotal number of variables............................:    35008\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:        0\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:    30007\nTotal number of inequality constraints...............:    15004\n        inequality constraints with only lower bounds:     5002\n   inequality constraints with lower and upper bounds:    10002\n        inequality constraints with only upper bounds:        0\n\n[...]\n\nNumber of Iterations....: 35\n\n                                   (scaled)                 (unscaled)\nObjective...............:  -1.0142336978192805e+00   -1.0142336978192805e+00\nDual infeasibility......:   4.7384318691001681e-13    4.7384318691001681e-13\nConstraint violation....:   1.4068322357215250e-09    1.4068322357215250e-09\nComplementarity.........:   9.0909295306344959e-09    9.0909295306344959e-09\nOverall NLP error.......:   9.0909295306344959e-09    9.0909295306344959e-09\n\nNumber of objective function evaluations             = 36\nNumber of objective gradient evaluations             = 36\nNumber of constraint evaluations                     = 36\nNumber of constraint Jacobian evaluations            = 36\nNumber of Lagrangian Hessian evaluations             = 35\nTotal wall-clock secs in solver (w/o fun. eval./lin. alg.)  =  0.911\nTotal wall-clock secs in linear solver                      =  0.227\nTotal wall-clock secs in NLP function evaluations           =  0.059\nTotal wall-clock secs                                       =  1.198","category":"section"},{"location":"jlesc17.html#Wrap-up","page":"Solving optimal control problems on GPU with Julia","title":"Wrap up","text":"High level modelling of optimal control problems\nSolving on CPU and GPU","category":"section"},{"location":"jlesc17.html#Future","page":"Solving optimal control problems on GPU with Julia","title":"Future","text":"New applications (space mechanics, biology, quantum mechanics and more)\nAdditional solvers: benchmarking on CPU / GPU for optimisation, Hamiltonian shooting and pathfollowing\nImproved AD: collab between Argonne and Inria, JLESC Shared Infra AD project...\n... and open to contributions! If you like the package, please give us a star ⭐️\n\n<a href=\"https://github.com/control-toolbox/OptimalControl.jl\"><img width=\"800\" alt=\"OptimalControl.jl\" src=\"./assets/star.jpg\"></a>","category":"section"},{"location":"jlesc17.html#control-toolbox.org","page":"Solving optimal control problems on GPU with Julia","title":"control-toolbox.org","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl\n\n<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"section"},{"location":"jlesc17.html#Credits-(not-exhaustive!)","page":"Solving optimal control problems on GPU with Julia","title":"Credits (not exhaustive!)","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nExaModels.jl\nIpopt.jl\nMadNLP.jl\nMLStyle.jl","category":"section"},{"location":"jlesc17.html#Acknowledgements","page":"Solving optimal control problems on GPU with Julia","title":"Acknowledgements","text":"Jean-Baptiste Caillau is partially funded by a France 2030 support managed by the Agence Nationale de la Recherche, under the reference ANR-23-PEIA-0004 (PDE-AI project).\n\n<img width=\"150\" alt=\"affiliations\" src=\"./assets/france-2030.png\">\n\n","category":"section"},{"location":"manual-flow-ocp.html#manual-flow-ocp","page":"From optimal control problems","title":"How to compute flows from optimal control problems","text":"In this tutorial, we explain the Flow function, in particular to compute flows from an optimal control problem.","category":"section"},{"location":"manual-flow-ocp.html#Basic-usage","page":"From optimal control problems","title":"Basic usage","text":"Les us define a basic optimal control problem.\n\nusing OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == [0, 0]\n    ẋ(t)  == [v(t), u(t)]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nnothing # hide\n\nThe pseudo-Hamiltonian of this problem is\n\n    H(x p u) = p_q v + p_v u + p^0 u^2 2\n\nwhere p^0 = -1 since we are in the normal case. From the Pontryagin maximum principle, the maximising control is given in feedback form by\n\nu(x p) = p_v\n\nsince partial^2_uu H = p^0 = - 1  0. \n\nu(x, p) = p[2]\nnothing # hide\n\nActually, if (x u) is a solution of the optimal control problem,  then, the Pontryagin maximum principle tells us that there exists a costate p such that u(t) = u(x(t) p(t)) and such that the pair (x p) satisfies:\n\nbeginarrayl\n    dotx(t) = displaystylephantom-nabla_p H(x(t) p(t) u(x(t) p(t))) 05em\n    dotp(t) = displaystyle         - nabla_x H(x(t) p(t) u(x(t) p(t)))\nendarray\n\nThe Flow function aims to compute t mapsto (x(t) p(t)) from the optimal control problem ocp and the control in feedback form u(x, p).\n\nnote: Nota bene\nActually, writing z = (x p), then the pair (x p) is also solution of    dotz(t) = vecmathbfH(z(t))where mathbfH(z) = H(z u(z)) and vecmathbfH = (nabla_p mathbfH -nabla_x mathbfH). This is what is actually computed by Flow.\n\nLet us try to get the associated flow:\n\njulia> f = Flow(ocp, u)\nERROR: ExtensionError. Please make: julia> using OrdinaryDiffEq\n\nAs you can see, an error occurred since we need the package OrdinaryDiffEq.jl. This package provides numerical integrators to compute solutions of the ordinary differential equation  dotz(t) = vecmathbfH(z(t)).\n\nnote: OrdinaryDiffEq.jl\nThe package OrdinaryDiffEq.jl is part of DifferentialEquations.jl. You can either use one or the other.\n\nusing OrdinaryDiffEq\nf = Flow(ocp, u)\nnothing # hide\n\nNow we have the flow of the associated Hamiltonian vector field, we can use it. Some simple calculations shows that the initial covector p(0) solution of the Pontryagin maximum principle is 12 6. Let us check that integrating the flow from (t_0 x_0 p_0) = (0 -1 0 12 6) to the final time t_f we reach the target x_f = 0 0.\n\np0 = [12, 6]\nxf, pf = f(t0, x0, p0, tf)\nxf\n\nIf you prefer to get the state, costate and control trajectories at any time, you can call the flow like this:\n\nsol = f((t0, tf), x0, p0)\nnothing # hide\n\nIn this case, you obtain a data that you can plot exactly like when solving the optimal control problem  with the function solve. See for instance the basic example or the  plot tutorial.\n\nusing Plots\nplot(sol)\n\nYou can notice from the graph of v that the integrator has made very few steps:\n\ntime_grid(sol)\n\nnote: Time grid\nThe function time_grid returns the discretised time grid returned by the solver. In this case, the solution has been computed by numerical integration with an adaptive step-length Runge-Kutta scheme.\n\nTo have a better visualisation (the accuracy won't change), you can provide a fine grid.\n\nsol = f((t0, tf), x0, p0; saveat=range(t0, tf, 100))\nplot(sol)\n\nThe argument saveat is an option from OrdinaryDiffEq.jl. Please check the  list of common options. For instance, one can change the integrator with the keyword argument alg or the absolute tolerance with  abstol. Note that you can set an option when declaring the flow or set an option in a particular call of the flow.  In the following example, the integrator will be BS5() and the absolute tolerance will be abstol=1e-8.\n\nf = Flow(ocp, u; alg=BS5(), abstol=1)   # alg=BS5(), abstol=1\nxf, pf = f(t0, x0, p0, tf; abstol=1e-8) # alg=BS5(), abstol=1e-8","category":"section"},{"location":"manual-flow-ocp.html#Non-autonomous-case","page":"From optimal control problems","title":"Non-autonomous case","text":"Let us consider the following optimal control problem:\n\nt0 = 0\ntf = π/4\nx0 = 0\nxf = tan(π/4) - 2log(√(2)/2)\n\nocp = @def begin\n\n    t ∈ [t0, tf], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == xf\n    ẋ(t) == u(t) * (1 + tan(t)) # The dynamics depend explicitly on t\n\n    0.5∫( u(t)^2 ) → min\n\nend\nnothing # hide\n\nThe pseudo-Hamiltonian of this problem is\n\n    H(t x p u) = p u (1+tan t) + p^0 u^2 2\n\nwhere p^0 = -1 since we are in the normal case. We can notice that the pseudo-Hamiltonian is non-autonomous since it explicitly depends on the time t. \n\nis_autonomous(ocp)\n\nFrom the Pontryagin maximum principle, the maximising control is given in feedback form by\n\nu(t x p) = p (1+tan t)\n\nsince partial^2_uu H = p^0 = - 1  0. \n\nu(t, x, p) = p * (1 + tan(t))\nnothing # hide\n\nAs before, the Flow function aims to compute (x p) from the optimal control problem ocp and the control in feedback form u(t, x, p).  Since the problem is non-autonomous, we must provide a control law that depends on time.\n\nf = Flow(ocp, u)\nnothing # hide\n\nNow we have the flow of the associated Hamiltonian vector field, we can use it. Some simple calculations shows that the initial covector p(0) solution of the Pontryagin maximum principle is 1. Let us check that integrating the flow from (t_0 x_0) = (0 0) to the final time t_f = pi4 we reach the target x_f = tan(pi4) - 2 log(sqrt22).\n\np0 = 1\nxf, pf = f(t0, x0, p0, tf)\nxf - (tan(π/4) - 2log(√(2)/2))","category":"section"},{"location":"manual-flow-ocp.html#Variable","page":"From optimal control problems","title":"Variable","text":"Let us consider an optimal control problem with a (decision / optimisation) variable.\n\nt0 = 0\nx0 = 0\n\nocp = @def begin\n\n    tf ∈ R, variable # the optimisation variable is tf\n    t ∈ [t0, tf], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == 1\n    ẋ(t) == tf * u(t)\n\n    tf + 0.5∫(u(t)^2) → min\n\nend\nnothing # hide\n\nAs you can see, the variable is the final time tf. Note that the dynamics depends on tf. From the Pontryagin maximum principle, the solution is given by:\n\ntf = (3/2)^(1/4)\np0 = 2tf/3\nnothing # hide\n\nThe input arguments of the maximising control are now the state x, the costate p and the variable tf.\n\nu(x, p, tf) = tf * p\nnothing # hide\n\nLet us check that the final condition x(tf) = 1 is satisfied.\n\nf = Flow(ocp, u)\nxf, pf = f(t0, x0, p0, tf, tf)\n\nThe usage of the flow f is the following: f(t0, x0, p0, tf, v) where v is the variable. If one wants to compute the state at time t1 = 0.5, then, one must write:\n\nt1 = 0.5\nx1, p1 = f(t0, x0, p0, t1, tf)\n\nnote: Free times\nIn the particular cases: the initial time t0 is the only variable, the final time tf is the only variable, or the initial and final times t0 and tf are the only variables and are in order v=(t0, tf), the times do not need to be repeated in the call of the flow:xf, pf = f(t0, x0, p0, tf)\n\nSince the variable is the final time, we can make the time-reparameterisation t = s t_f to normalise the time s in 0 1.\n\nocp = @def begin\n\n    tf ∈ R, variable\n    s ∈ [0, 1], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(0) == 0\n    x(1) == 1\n    ẋ(s) == tf^2 * u(s)\n\n    tf + (0.5*tf)*∫(u(s)^2) → min\n\nend\n\nf = Flow(ocp, u)\nxf, pf = f(0, x0, p0, 1, tf)\n\nAnother possibility is to add a new state variable t_f(s). The problem has no variable anymore.\n\nocp = @def begin\n\n    s ∈ [0, 1], time\n    y = (x, tf) ∈ R², state\n    u ∈ R, control\n\n    x(0) == 0\n    x(1) == 1\n    dx = tf(s)^2 * u(s)\n    dtf = 0 * u(s) # 0\n    ẏ(s) == [dx, dtf]\n\n    tf(1) + 0.5∫(tf(s) * u(s)^2) → min\n\nend\n\nu(y, q) = y[2] * q[1]\n\nf = Flow(ocp, u)\nyf, pf = f(0, [x0, tf], [p0, 0], 1)\n\ndanger: Bug\nNote that in the previous optimal control problem, we have dtf = 0 * u(s) instead of dtf = 0. The latter does not work.\n\nnote: Goddard problem\nIn the Goddard problem, you may find other constructions of flows, especially for singular and boundary arcs.","category":"section"},{"location":"manual-flow-ocp.html#Concatenation-of-arcs","page":"From optimal control problems","title":"Concatenation of arcs","text":"In this part, we present how to concatenate several flows. Let us consider the following problem.\n\nt0 =  0\ntf =  1\nx0 = -1\nxf =  0\n\n@def ocp begin\n\n    t ∈ [ t0, tf ], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == xf\n    -1 ≤ u(t) ≤ 1\n    ẋ(t) == -x(t) + u(t)\n\n    ∫( abs(u(t)) ) → min\n\nend\nnothing # hide\n\nFrom the Pontryagin maximum principle, the optimal control is a concatenation of an off arc (u=0) followed by a  positive bang arc (u=1). The initial costate is \n\np_0 = frac1x_0 - (x_f-1) e^t_f\n\nand the switching time is t_1 = -ln(p_0).\n\np0 = 1/( x0 - (xf-1) * exp(tf) )\nt1 = -log(p0)\nnothing  # hide\n\nLet us define the two flows and the concatenation. Note that the concatenation of two flows is a flow.\n\nf0 = Flow(ocp, (x, p) -> 0)     # off arc: u = 0\nf1 = Flow(ocp, (x, p) -> 1)     # positive bang arc: u = 1\n\nf = f0 * (t1, f1)               # f0 followed by f1 whenever t ≥ t1\nnothing # hide\n\nNow, we can check that the state reach the target.\n\nsol = f((t0, tf), x0, p0)\nplot(sol)\n\nnote: Goddard problem\nIn the Goddard problem, you may find more complex concatenations.\n\nFor the moment, this concatenation is not equivalent to an exact concatenation.\n\nf = Flow(x ->  x)\ng = Flow(x -> -x)\n\nx0 = 1\nφ(t) = (f * (t/2, g))(0, x0, t)\nψ(t) = g(t/2, f(0, x0, t/2), t)\n\nprintln(\"φ(t) = \", abs(φ(1)-x0))\nprintln(\"ψ(t) = \", abs(ψ(1)-x0))\n\nt = range(1, 5e2, 201)\n\nplt = plot(yaxis=:log, legend=:bottomright, title=\"Comparison of concatenations\", xlabel=\"t\")\nplot!(plt, t, t->abs(φ(t)-x0), label=\"OptimalControl\")\nplot!(plt, t, t->abs(ψ(t)-x0), label=\"Classical\")","category":"section"},{"location":"manual-flow-ocp.html#State-constraints","page":"From optimal control problems","title":"State constraints","text":"We consider an optimal control problem with a state constraints of order 1.[1] \n\n[1]: B. Bonnard, L. Faubourg, G. Launay & E. Trélat, Optimal Control With State Constraints And The Space Shuttle Re-entry Problem, J. Dyn. Control Syst., 9 (2003), no. 2, 155–199.\n\nt0 = 0\ntf = 2\nx0 = 1\nxf = 1/2\nlb = 0.1\n\nocp = @def begin\n\n    t ∈ [t0, tf], time\n    x ∈ R, state\n    u ∈ R, control\n\n    -1 ≤ u(t) ≤ 1\n    x(t0) == x0\n    x(tf) == xf\n    x(t) - lb ≥ 0 # state constraint\n    ẋ(t) == u(t)\n\n    ∫( x(t)^2 ) → min\n\nend\nnothing # hide\n\nThe pseudo-Hamiltonian of this problem is\n\n    H(x p u mu) = p u + p^0 x^2 + mu c(x)\n\nwhere $ p^0 = -1 $ since we are in the normal case, and where c(x) = x - l_b. Along a boundary arc, when c(x(t)) = 0, we have x(t) = l_b, so $ x(\\cdot) $ is constant. Differentiating, we obtain dotx(t) = u(t) = 0. Hence, along a boundary arc, the control in feedback form is:\n\nu(x) = 0\n\nFrom the maximisation condition, along a boundary arc, we have p(t) = 0. Differentiating, we obtain dotp(t) = 2 x(t) - mu(t) = 0. Hence, along a boundary arc, the dual variable mu is given in feedback form by:\n\nmu(x) = 2x\n\nnote: Note\nWithin OptimalControl.jl, the constraint must be given in the form:c([t, ]x, u[, v])the control law in feedback form must be given as:u([t, ]x, p[, v])and the dual variable:μ([t, ]x, p[, v])The time t must be provided when the problem is non-autonomous and the variable v must be given when the optimal control problem contains a variable to optimise.\n\nThe optimal control is a concatenation of 3 arcs: a negative bang arc followed by a boundary arc, followed by a positive bang arc. The initial covector is approximately p(0)=-0982237546583301, the first switching time is t_1 = 09, and the exit time of the boundary is t_2 = 16. Let us check this by concatenating the three flows.\n\nu(x) = 0     # boundary control\nc(x) = x-lb  # constraint\nμ(x) = 2x    # dual variable\n\nf1 = Flow(ocp, (x, p) -> -1)\nf2 = Flow(ocp, (x, p) -> u(x), (x, u) -> c(x), (x, p) -> μ(x))\nf3 = Flow(ocp, (x, p) -> +1)\n\nt1 = 0.9\nt2 = 1.6\nf = f1 * (t1, f2) * (t2, f3)\n\np0 = -0.982237546583301\nxf, pf = f(t0, x0, p0, tf)\nxf","category":"section"},{"location":"manual-flow-ocp.html#Jump-on-the-costate","page":"From optimal control problems","title":"Jump on the costate","text":"Let consider the following problem:\n\nt0=0\ntf=1\nx0=[0, 1]\nl = 1/9\n@def ocp begin\n    t ∈ [ t0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    x(t0) == x0\n    x(tf) == [0, -1]\n    x₁(t) ≤ l,                      (x_con)\n    ẋ(t) == [x₂(t), u(t)]\n    0.5∫(u(t)^2) → min\nend\nnothing # hide\n\nThe pseudo-Hamiltonian of this problem is\n\n    H(x p u mu) = p_1 x_2 + p_2 u + 05 p^0 u^2 + mu c(x)\n\nwhere $ p^0 = -1 $ since we are in the normal case, and where the constraint is c(x) = l - x_1 ge 0. Along a boundary arc, when c(x(t)) = 0, we have x_1(t) = l, so dotx_1(t) = x_2(t) = 0. Differentiating again, we obtain dotx_2(t) = u(t) = 0 (the constraint is of order 2). Hence, along a boundary arc, the control in feedback form is:\n\nu(x p) = 0\n\nFrom the maximisation condition, along a boundary arc, we have p_2(t) = 0. Differentiating, we obtain dotp_2(t) = -p_1(t) = 0. Differentiating again, we obtain dotp_1(t) = mu(t) = 0. Hence, along a boundary arc, the Lagrange multiplier mu is given in feedback form by:\n\nmu(x p) = 0\n\nOutside a boundary arc, the maximisation condition gives u(x p) = p_2. A deeper analysis of the problem shows that the optimal solution has 3 arcs, the first and the third ones are interior to the constraint. The second arc is a boundary arc, that is x_1(t) = l along the second arc. We denote by t_1 and t_2 the two switching times. We have t_1 = 3l = 13 and t_2 = 1 - 3l = 23, since l=19. The initial costate solution is p(0) = -18 -6.\n\ndanger: Important\nThe costate is discontinuous at t_1 and t_2 with a jump of 18.\n\nLet us compute the solution concatenating the flows with the jumps.\n\nt1 = 3l\nt2 = 1 - 3l\np0 = [-18, -6]\n\nfs = Flow(ocp, \n    (x, p) -> p[2]      # control along regular arc\n    )\nfc = Flow(ocp, \n    (x, p) -> 0,        # control along boundary arc\n    (x, u) -> l-x[1],   # state constraint\n    (x, p) -> 0         # Lagrange multiplier\n    )\n\nν = 18  # jump value of p1 at t1 and t2\n\nf = fs * (t1, [ν, 0], fc) * (t2, [ν, 0], fs)\n\nxf, pf = f(t0, x0, p0, tf) # xf should be [0, -1]\n\nLet us solve the problem with a direct method to compare with the solution from the flow.\n\nusing NLPModelsIpopt\n\ndirect_sol = solve(ocp)\nplot(direct_sol; label=\"direct\", size=(800, 700))\n\nflow_sol = f((t0, tf), x0, p0; saveat=range(t0, tf, 100))\nplot!(flow_sol; label=\"flow\", state_style=(color=3,), linestyle=:dash)\n\n","category":"section"},{"location":"rdnopa-2025.html","page":"RDNOPA 2025","title":"RDNOPA 2025","text":"<img width=\"800\" alt=\"rdnopa\" src=\"./assets/rdnopa-2025.jpg\">","category":"section"},{"location":"rdnopa-2025.html#Numerical-developments-to-solve-optimal-control-problems-in-Julia","page":"RDNOPA 2025","title":"Numerical developments to solve optimal control problems in Julia","text":"","category":"section"},{"location":"rdnopa-2025.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://github.com/joseph-gergaud),-[Pierre-Martinon](https://github.com/PierreMartinon),-[Sophia-Sed](https://sed-sam-blog.gitlabpages.inria.fr)","page":"RDNOPA 2025","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"section"},{"location":"rdnopa-2025.html#What-it's-about","page":"RDNOPA 2025","title":"What it's about","text":"Nonlinear optimal control of ODEs:\n\ng(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min\n\nsubject to\n\ndotx(t) = f(x(t) u(t))quad t in t_0 t_f\n\nplus boundary, control and state constraints\n\nOur core interests: numerical & geometrical methods in control, applications\nWhy Julia: fast (+ JIT), strongly typed, high-level (AD, macros), fast optimisation and ODE solvers available, rapidly growing community\n\nWhat is important to solve such a problem numerically?","category":"section"},{"location":"rdnopa-2025.html#Syntax-matters","page":"RDNOPA 2025","title":"Syntax matters","text":"Simple example\nUse LLM\n\n<details><summary>Do more...</summary>\n\nrewrite in OptimalControl.jl DSL the free time problem below as a problem with fixed final time using:\n- a change time from t to s = t / tf\n- tf as an additional state variable subject to dtf / ds = 0\nocp = @def begin\n    tf ∈ R,          variable\n    t ∈ [0, tf],     time\n    x = (q, v) ∈ R², state\n    u ∈ R,           control\n    -1 ≤ u(t) ≤ 1\n    q(0)  == -1\n    v(0)  == 0\n    q(tf) == 0\n    v(tf) == 0\n    ẋ(t) == [v(t), u(t)]\n    tf → min\nend\n\nocp_fixed = @def begin\n    # Fixed time domain\n    s ∈ [0, 1], time\n    \n    # Augmented state: (position, velocity, final_time)\n    y = (q, v, tf) ∈ R³, state\n    \n    # Control\n    u ∈ R, control\n    \n    # Transformed dynamics (multiply by tf due to ds = dt/tf)\n    ∂(q)(s)  == tf(s) * v(s)\n    ∂(v)(s)  == tf(s) * u(s)\n    ∂(tf)(s) == 0\n    \n    # Initial conditions\n    q(0)  == -1\n    v(0)  == 0\n    # tf(0) is free (no initial condition needed)\n    \n    # Final conditions\n    q(1)  == 0\n    v(1)  == 0\n    # tf(1) is what we minimize\n    \n    # Control constraints\n    -1 ≤ u(s) ≤ 1\n    \n    # Cost: minimize final time\n    tf(1) → min\nend\n\n</details>","category":"section"},{"location":"rdnopa-2025.html#Performance-matters","page":"RDNOPA 2025","title":"Performance matters","text":"Discretising an OCP into an NLP: h_i = t_i+1-t_i,\n\ng(X_0X_N) + sum_i=0^N h_i f^0(X_iU_i) to min\n\nsubject to \n\nX_i+1 - X_i - h_i f(X_i U_i) = 0quad i = 0dotsN-1\n\nplus other constraints on X = (X_i)_i=0N and U = (U_i)_i=0N such as boundary and path (state and / or control) constraints :\n\nb(t_0 X_0 t_N X_N) = 0\n\nc(X_i U_i) leq 0quad i = 0dotsN\n\nSIMD parallelism (f_0, f, g) + sparsity: Kernels for GPU (KernelAbstraction.jl) and sparse linear algebra (CUDSS.jl)\nModelling and optimising for GPU: ExaModels.jl  + MadNLP.jl, with built-in AD\nCompile into an ExaModel (one pass compiler, syntax + semantics)\n\n<details><summary>Solving (MadNLP + CUDSS)</summary>\n\nThis is MadNLP version v0.8.7, running with cuDSS v0.4.0\n\nNumber of nonzeros in constraint Jacobian............:    12005\nNumber of nonzeros in Lagrangian Hessian.............:     9000\n\nTotal number of variables............................:     4004\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:        0\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     3005\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  1.0000000e-01 1.10e+00 1.00e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.0001760e-01 1.10e+00 3.84e-03  -1.0 6.88e+02  -4.0 1.00e+00 2.00e-07h  2\n   2 -5.2365072e-03 1.89e-02 1.79e-07  -1.0 6.16e+00  -4.5 1.00e+00 1.00e+00h  1\n   3  5.9939621e+00 2.28e-03 1.66e-04  -3.8 6.00e+00  -5.0 9.99e-01 1.00e+00h  1\n   4  5.9996210e+00 2.94e-06 8.38e-07  -3.8 7.70e-02    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 4\n\n                                   (scaled)                 (unscaled)\nObjective...............:   5.9996210189633494e+00    5.9996210189633494e+00\nDual infeasibility......:   8.3756005011360529e-07    8.3756005011360529e-07\nConstraint violation....:   2.9426923277963834e-06    2.9426923277963834e-06\nComplementarity.........:   2.0007459547789288e-06    2.0007459547789288e-06\nOverall NLP error.......:   2.9426923277963834e-06    2.9426923277963834e-06\n\nNumber of objective function evaluations             = 6\nNumber of objective gradient evaluations             = 5\nNumber of constraint evaluations                     = 6\nNumber of constraint Jacobian evaluations            = 5\nNumber of Lagrangian Hessian evaluations             = 4\nTotal wall-clock secs in solver (w/o fun. eval./lin. alg.)  =  0.072\nTotal wall-clock secs in linear solver                      =  0.008\nTotal wall-clock secs in NLP function evaluations           =  0.003\nTotal wall-clock secs                                       =  0.083\n\nMini-benchmark: Goddard and Quadrotor problems\nGoddard, H100 run             \n\n<img width=\"400\" alt=\"goddard-h100\" src=\"./assets/goddard-h100.jpg\">\n\nQuadrotor, H100 run             \n\n<img width=\"400\" alt=\"quadrotor-h100\" src=\"./assets/quadrotor-h100.jpg\">\n\n</details>","category":"section"},{"location":"rdnopa-2025.html#Maths-matters","page":"RDNOPA 2025","title":"Maths matters","text":"Coupling direct and indirect (aka shooting methods)\nEasy access to differential-geometric tools with AD\nGoddard tutorial","category":"section"},{"location":"rdnopa-2025.html#Applications-matter","page":"RDNOPA 2025","title":"Applications matter","text":"Use case approach: aerospace engineering, quantum mechanics, biology, environment...\nMagnetic Resonance Imaging","category":"section"},{"location":"rdnopa-2025.html#Wrap-up","page":"RDNOPA 2025","title":"Wrap up","text":"High level modelling of optimal control problems\nHigh performance solving both on CPU and GPU\nDriven by applications","category":"section"},{"location":"rdnopa-2025.html#control-toolbox.org","page":"RDNOPA 2025","title":"control-toolbox.org","text":"Collection of Julia Packages rooted at OptimalControl.jl\n\n<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>\n\nOpen to contributions! Give it a try, give it a star ⭐️\nCollection of problems: OptimalControlProblems.jl\n\n<img width=\"120\" alt=\"ct-qr\" src=\"./assets/ct-qr-code.svg\">","category":"section"},{"location":"rdnopa-2025.html#Credits-(not-exhaustive!)","page":"RDNOPA 2025","title":"Credits (not exhaustive!)","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nExaModels.jl\nIpopt.jl\nMadNLP.jl\nMLStyle.jl","category":"section"},{"location":"rdnopa-2025.html#Acknowledgements","page":"RDNOPA 2025","title":"Acknowledgements","text":"Jean-Baptiste Caillau is partially funded by a France 2030 support managed by the Agence Nationale de la Recherche, under the reference ANR-23-PEIA-0004 (PDE-AI project).\n\n<img width=\"150\" alt=\"affiliations\" src=\"./assets/france-2030.png\">\n\n","category":"section"},{"location":"api-optimalcontrol-user.html#OptimalControl.jl","page":"OptimalControl.jl - User","title":"OptimalControl.jl","text":"OptimalControl.jl is the core package of the control-toolbox ecosystem. Below, we group together the documentation of all the functions and types exported by OptimalControl.\n\ntip: Beware!\nEven if the following functions are prefixed by another package, such as CTFlows.Lift, they can all be used with OptimalControl. In fact, all functions prefixed with another package are simply reexported. For example, Lift is defined in CTFlows but accessible from OptimalControl.julia> using OptimalControl\njulia> F(x) = 2x\njulia> H = Lift(F)\njulia> x = 1\njulia> p = 2\njulia> H(x, p)\n4","category":"section"},{"location":"api-optimalcontrol-user.html#Exported-functions-and-types","page":"OptimalControl.jl - User","title":"Exported functions and types","text":"","category":"section"},{"location":"api-optimalcontrol-user.html#Documentation","page":"OptimalControl.jl - User","title":"Documentation","text":"","category":"section"},{"location":"api-optimalcontrol-user.html#OptimalControl.OptimalControl","page":"OptimalControl.jl - User","title":"OptimalControl.OptimalControl","text":"OptimalControl module.\n\nList of all the exported names:\n\n*\nAmbiguousDescription\nCTException\nExtensionError\nFlow\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\nIncorrectArgument\nIncorrectMethod\nIncorrectOutput\n@Lie\nLie\nLift\nModel\nNotImplemented\nParsingError\nPoisson\nSolution\nUnauthorizedCall\nVectorField\navailable_methods\nbuild_OCP_solution\nconstraint\nconstraints\nconstraints_violation\ncontrol\ncontrol_components\ncontrol_dimension\ncontrol_name\ncostate\ncriterion\n@def\ndefinition\ndirect_transcription\ndual\ndynamics\nexport_ocp_solution\nfinal_time\nfinal_time_name\nget_build_examodel\nhas_fixed_final_time\nhas_fixed_initial_time\nhas_free_final_time\nhas_free_initial_time\nhas_lagrange_cost\nhas_mayer_cost\nimport_ocp_solution\ninfos\ninitial_time\ninitial_time_name\nis_autonomous\niterations\nlagrange\nmayer\nmessage\nnlp_model\nobjective\nocp_model\nplot\nset_initial_guess\nsolve\nstate\nstate_components\nstate_dimension\nstate_name\nstatus\nsuccessful\ntime_grid\ntime_name\ntimes\nvariable\nvariable_components\nvariable_dimension\nvariable_name\n⋅\n\n\n\n\n\n","category":"module"},{"location":"api-optimalcontrol-user.html#Base.:*-Tuple{CTFlowsODE.AbstractFlow}","page":"OptimalControl.jl - User","title":"Base.:*","text":"*(x, y...)\n\nMultiplication operator.\n\nInfix x*y*z*... calls this function with all arguments, i.e. *(x, y, z, ...), which by default then calls (x*y) * z * ... starting from the left.\n\nJuxtaposition such as 2pi also calls *(2, pi). Note that this operation has higher precedence than a literal *. Note also that juxtaposition \"0x...\" (integer zero times a variable whose name starts with x) is forbidden as it clashes with unsigned integer literals: 0x01 isa UInt8.\n\nNote that overflow is possible for most integer types, including the default Int, when multiplying large numbers.\n\nExamples\n\njulia> 2 * 7 * 8\n112\n\njulia> *(2, 7, 8)\n112\n\njulia> [2 0; 0 3] * [1, 10]  # matrix * vector\n2-element Vector{Int64}:\n  2\n 30\n\njulia> 1/2pi, 1/2*pi  # juxtaposition has higher precedence\n(0.15915494309189535, 1.5707963267948966)\n\njulia> x = [1, 2]; x'x  # adjoint vector * vector\n5\n\n\n\n\n\n*(\n    F::CTFlowsODE.AbstractFlow,\n    g::Tuple{Real, TF<:CTFlowsODE.AbstractFlow}\n) -> Any\n\n\nShorthand for concatenate(F, g) when g is a tuple (t_switch, G).\n\nArguments\n\nF::AbstractFlow: The first flow.\ng::Tuple{ctNumber, AbstractFlow}: Tuple containing the switching time and second flow.\n\nReturns\n\nA new flow that switches from F to G at t_switch.\n\nExample\n\njulia> F * (1.0, G)\n\n\n\n\n\n*(\n    F::CTFlowsODE.AbstractFlow,\n    g::Tuple{Real, Any, TF<:CTFlowsODE.AbstractFlow}\n) -> Any\n\n\nShorthand for concatenate(F, g) when g is a tuple (t_switch, η_switch, G) including a jump.\n\nArguments\n\nF::AbstractFlow: The first flow.\ng::Tuple{ctNumber, Any, AbstractFlow}: Tuple with switching time, jump value, and second flow.\n\nReturns\n\nA flow with a jump at t_switch and a switch from F to G.\n\nExample\n\njulia> F * (1.0, η, G)\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-user.html#CTBase.AmbiguousDescription","page":"OptimalControl.jl - User","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTException\n\nException thrown when a description is ambiguous or does not match any known descriptions.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}: The ambiguous or incorrect description tuple that caused the error.\n\nExample\n\njulia> complete(:f; descriptions=((:a, :b), (:a, :b, :c)))\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\nThis error is useful to signal when a user provides a description that cannot be matched to any known valid descriptions.\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTBase.CTException","page":"OptimalControl.jl - User","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract supertype for all custom exceptions in this module.\n\nUse this as the common ancestor for all domain-specific errors to allow catching all exceptions of this family via catch e::CTException.\n\nNo fields.\n\nExample\n\njulia> try\n           throw(IncorrectArgument(\"invalid input\"))\n       catch e::CTException\n           println(\"Caught a domain-specific exception: \", e)\n       end\nCaught a domain-specific exception: IncorrectArgument: invalid input\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTBase.ExtensionError","page":"OptimalControl.jl - User","title":"CTBase.ExtensionError","text":"struct ExtensionError <: CTException\n\nException thrown when an extension or optional dependency is not loaded but a function requiring it is called.\n\nFields\n\nweakdeps::Tuple{Vararg{Symbol}}: The tuple of symbols representing the missing dependencies.\n\nConstructor\n\nThrows UnauthorizedCall if no weak dependencies are provided.\n\nExample\n\njulia> throw(ExtensionError(:MyExtension))\nERROR: ExtensionError. Please make: julia> using MyExtension\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTFlows.Flow","page":"OptimalControl.jl - User","title":"CTFlows.Flow","text":"Flow(\n    vf::VectorField;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.VectorFieldFlow\n\n\nConstructs a flow object for a classical (non-Hamiltonian) vector field.\n\nThis creates a VectorFieldFlow that integrates the ODE system dx/dt = vf(t, x, v) using DifferentialEquations.jl. It handles both fixed and parametric dynamics, as well as jump discontinuities and event stopping.\n\nKeyword Arguments\n\nalg, abstol, reltol, saveat, internalnorm: Solver options.\nkwargs_Flow...: Additional arguments passed to the solver configuration.\n\nExample\n\njulia> vf(t, x, v) = -v * x\njulia> flow = CTFlows.Flow(CTFlows.VectorField(vf))\njulia> x1 = flow(0.0, 1.0, 1.0)\n\n\n\n\n\nFlow(\n    h::CTFlows.AbstractHamiltonian;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.HamiltonianFlow\n\n\nConstructs a Hamiltonian flow from a scalar Hamiltonian.\n\nThis method builds a numerical integrator that simulates the evolution of a Hamiltonian system given a Hamiltonian function h(t, x, p, l) or h(x, p).\n\nInternally, it computes the right-hand side of Hamilton’s equations via automatic differentiation and returns a HamiltonianFlow object.\n\nKeyword Arguments\n\nalg, abstol, reltol, saveat, internalnorm: solver options.\nkwargs_Flow...: forwarded to the solver.\n\nExample\n\njulia> H(x, p) = dot(p, p) + dot(x, x)\njulia> flow = CTFlows.Flow(CTFlows.Hamiltonian(H))\njulia> xf, pf = flow(0.0, x0, p0, 1.0)\n\n\n\n\n\nFlow(\n    hv::HamiltonianVectorField;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.HamiltonianFlow\n\n\nConstructs a Hamiltonian flow from a precomputed Hamiltonian vector field.\n\nThis method assumes you already provide the Hamiltonian vector field (dx/dt, dp/dt) instead of deriving it from a scalar Hamiltonian.\n\nReturns a HamiltonianFlow object that integrates the given system.\n\nKeyword Arguments\n\nalg, abstol, reltol, saveat, internalnorm: solver options.\nkwargs_Flow...: forwarded to the solver.\n\nExample\n\njulia> hv(t, x, p, l) = (∇ₚH, -∇ₓH)\njulia> flow = CTFlows.Flow(CTFlows.HamiltonianVectorField(hv))\njulia> xf, pf = flow(0.0, x0, p0, 1.0, l)\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::CTFlows.ControlLaw;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> Union{CTFlowsODE.OptimalControlFlow{CTFlows.Fixed}, CTFlowsODE.OptimalControlFlow{CTFlows.NonFixed}}\n\n\nConstruct a flow for an optimal control problem using a given control law.\n\nThis method builds the Hamiltonian system associated with the optimal control problem (ocp) and integrates the corresponding state–costate dynamics using the specified control law u.\n\nArguments\n\nocp::CTModels.Model: An optimal control problem defined using CTModels.\nu::CTFlows.ControlLaw: A feedback control law generated by ControlLaw(...) or similar.\nalg: Integration algorithm (default inferred).\nabstol: Absolute tolerance for the ODE solver.\nreltol: Relative tolerance for the ODE solver.\nsaveat: Time points at which to save the solution.\ninternalnorm: Optional norm function used by the integrator.\nkwargs_Flow: Additional keyword arguments passed to the solver.\n\nReturns\n\nA flow object f such that:\n\nf(t0, x0, p0, tf) integrates the state and costate from t0 to tf.\nf((t0, tf), x0, p0) returns the full trajectory over the interval.\n\nExample\n\njulia> u = (x, p) -> p\njulia> f = Flow(ocp, ControlLaw(u))\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::Function;\n    autonomous,\n    variable,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> Union{CTFlowsODE.OptimalControlFlow{CTFlows.Fixed}, CTFlowsODE.OptimalControlFlow{CTFlows.NonFixed}}\n\n\nConstruct a flow for an optimal control problem using a control function in feedback form.\n\nThis method constructs the Hamiltonian and integrates the associated state–costate dynamics using a raw function u. It automatically wraps u as a control law.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem.\nu::Function: A feedback control function:\nIf ocp is autonomous: u(x, p)\nIf non-autonomous: u(t, x, p)\nautonomous::Bool: Whether the control law depends on time.\nvariable::Bool: Whether the OCP involves variable time (e.g., free final time).\nalg, abstol, reltol, saveat, internalnorm: ODE solver parameters.\nkwargs_Flow: Additional options.\n\nReturns\n\nA Flow object compatible with function call interfaces for state propagation.\n\nExample\n\njulia> u = (t, x, p) -> t + p\njulia> f = Flow(ocp, u)\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::Union{CTFlows.ControlLaw{<:Function, T, V}, CTFlows.FeedbackControl{<:Function, T, V}},\n    g::Union{CTFlows.MixedConstraint{<:Function, T, V}, CTFlows.StateConstraint{<:Function, T, V}},\n    μ::CTFlows.Multiplier{<:Function, T, V};\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> Union{CTFlowsODE.OptimalControlFlow{CTFlows.Fixed}, CTFlowsODE.OptimalControlFlow{CTFlows.NonFixed}}\n\n\nConstruct a flow for an optimal control problem with control and constraint multipliers in feedback form.\n\nThis variant constructs a Hamiltonian system incorporating both the control law and a multiplier law (e.g., for enforcing state or mixed constraints). All inputs must be consistent in time dependence.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem.\nu::ControlLaw or FeedbackControl: Feedback control.\ng::StateConstraint or MixedConstraint: Constraint function.\nμ::Multiplier: Multiplier function.\nalg, abstol, reltol, saveat, internalnorm: Solver settings.\nkwargs_Flow: Additional options.\n\nReturns\n\nA Flow object that integrates the constrained Hamiltonian dynamics.\n\nExample\n\njulia> f = Flow(ocp, (x, p) -> p[1], (x, u) -> x[1] - 1, (x, p) -> x[1]+p[1])\n\nFor non-autonomous cases:\n\njulia> f = Flow(ocp, (t, x, p) -> t + p, (t, x, u) -> x - 1, (t, x, p) -> x+p)\n\nwarning: Warning\nAll input functions must match the autonomous/non-autonomous nature of the problem.\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::Function,\n    g::Function,\n    μ::Function;\n    autonomous,\n    variable,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> Union{CTFlowsODE.OptimalControlFlow{CTFlows.Fixed}, CTFlowsODE.OptimalControlFlow{CTFlows.NonFixed}}\n\n\nConstruct a flow from a raw feedback control, constraint, and multiplier.\n\nThis version is for defining flows directly from user functions without wrapping them into ControlLaw, Constraint, or Multiplier types. Automatically wraps and adapts them based on time dependence.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem.\nu::Function: Control law.\ng::Function: Constraint.\nμ::Function: Multiplier.\nautonomous::Bool: Whether the system is autonomous.\nvariable::Bool: Whether time is a free variable.\nalg, abstol, reltol, saveat, internalnorm: Solver parameters.\nkwargs_Flow: Additional options.\n\nReturns\n\nA Flow object ready for trajectory integration.\n\n\n\n\n\nFlow(\n    dyn::Function;\n    autonomous,\n    variable,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.ODEFlow\n\n\nConstructs a Flow from a user-defined dynamical system given as a Julia function.\n\nThis high-level interface handles:\n\nautonomous and non-autonomous systems,\npresence or absence of additional variables (v),\nselection of ODE solvers and tolerances,\nand integrates with the CTFlows event system (e.g., jumps, callbacks).\n\nArguments\n\ndyn: A function defining the vector field. Its signature must match the values of autonomous and variable.\nautonomous: Whether the dynamics are time-independent (false by default).\nvariable: Whether the dynamics depend on a control or parameter v.\nalg, abstol, reltol, saveat, internalnorm: Solver settings passed to OrdinaryDiffEq.solve.\nkwargs_Flow: Additional keyword arguments passed to the solver.\n\nReturns\n\nAn ODEFlow object, wrapping both the full solver and its right-hand side (RHS).\n\nSupported Function Signatures for dyn\n\nDepending on the (autonomous, variable) flags:\n\n(false, false): dyn(x)\n(false, true):  dyn(x, v)\n(true, false):  dyn(t, x)\n(true, true):   dyn(t, x, v)\n\nExample\n\njulia> dyn(t, x, v) = [-x[1] + v[1] * sin(t)]\njulia> flow = CTFlows.Flow(dyn; autonomous=true, variable=true)\njulia> xT = flow((0.0, 1.0), [1.0], [0.1])\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTFlows.Hamiltonian","page":"OptimalControl.jl - User","title":"CTFlows.Hamiltonian","text":"struct Hamiltonian{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence} <: CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nEncodes the Hamiltonian function H = ⟨p, f⟩ + L in optimal control.\n\nFields\n\nf: a callable of the form:\nf(x, p)\nf(t, x, p)\nf(x, p, v)\nf(t, x, p, v)\n\nType Parameters\n\nTD: Autonomous or NonAutonomous\nVD: Fixed or NonFixed\n\nExample\n\njulia> Hf(x, p) = dot(p, [x[2], -x[1]])\njulia> H = Hamiltonian{typeof(Hf), Autonomous, Fixed}(Hf)\njulia> H([1.0, 0.0], [1.0, 1.0])\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTFlows.HamiltonianLift","page":"OptimalControl.jl - User","title":"CTFlows.HamiltonianLift","text":"struct HamiltonianLift{TV<:VectorField, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence} <: CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nLifts a vector field X into a Hamiltonian function using the canonical symplectic structure.\n\nThis is useful to convert a vector field into a Hamiltonian via the identity: H(x, p) = ⟨p, X(x)⟩.\n\nConstructor\n\nUse HamiltonianLift(X::VectorField) where X is a VectorField{...}.\n\nExample\n\nf(x) = [x[2], -x[1]]\njulia> X = VectorField{typeof(f), Autonomous, Fixed}(f)\njulia> H = HamiltonianLift(X)\njulia> H([1.0, 0.0], [0.5, 0.5])\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTFlows.HamiltonianVectorField","page":"OptimalControl.jl - User","title":"CTFlows.HamiltonianVectorField","text":"struct HamiltonianVectorField{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence} <: CTFlows.AbstractVectorField{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nRepresents the Hamiltonian vector field associated to a Hamiltonian function, typically defined as (∂H/∂p, -∂H/∂x).\n\nFields\n\nf: a callable implementing the Hamiltonian vector field.\n\nExample\n\njulia> f(x, p) = [p[2], -p[1], -x[1], -x[2]]\njulia> XH = HamiltonianVectorField{typeof(f), Autonomous, Fixed}(f)\njulia> XH([1.0, 0.0], [0.5, 0.5])\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTBase.IncorrectArgument","page":"OptimalControl.jl - User","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTException\n\nException thrown when an argument passed to a function or constructor is inconsistent, invalid, or does not satisfy preconditions.\n\nFields\n\nvar::String: A descriptive message explaining the nature of the incorrect argument.\n\nExample\n\njulia> throw(IncorrectArgument(\"the argument must be a non-empty tuple\"))\nERROR: IncorrectArgument: the argument must be a non-empty tuple\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTBase.IncorrectMethod","page":"OptimalControl.jl - User","title":"CTBase.IncorrectMethod","text":"struct IncorrectMethod <: CTException\n\nException thrown when a specified method name or function symbol does not exist.\n\nFields\n\nvar::Symbol: The method or function symbol that was expected but not found.\n\nExample\n\njulia> throw(IncorrectMethod(:nonexistent_func))\nERROR: IncorrectMethod: nonexistent_func is not an existing method\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTBase.IncorrectOutput","page":"OptimalControl.jl - User","title":"CTBase.IncorrectOutput","text":"struct IncorrectOutput <: CTException\n\nException thrown when the output produced by a function is incorrect or inconsistent with expected results.\n\nFields\n\nvar::String: A descriptive message explaining the incorrect output.\n\nExample\n\njulia> throw(IncorrectOutput(\"the function returned NaN\"))\nERROR: IncorrectOutput: the function returned NaN\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTFlows.@Lie","page":"OptimalControl.jl - User","title":"CTFlows.@Lie","text":"Compute Lie or Poisson brackets.\n\nThis macro provides a unified notation to define recursively nested Lie brackets (for vector fields) or Poisson brackets (for Hamiltonians).\n\nSyntax\n\n@Lie [F, G]: computes the Lie bracket [F, G] of two vector fields.\n@Lie [[F, G], H]: supports arbitrarily nested Lie brackets.\n@Lie {H, K}: computes the Poisson bracket {H, K} of two Hamiltonians.\n@Lie {{H, K}, L}: supports arbitrarily nested Poisson brackets.\n@Lie expr autonomous = false: specifies a non-autonomous system.\n@Lie expr variable = true: indicates presence of an auxiliary variable v.\n\nKeyword-like arguments can be provided to control the evaluation context for Poisson brackets with raw functions:\n\nautonomous = Bool: whether the system is time-independent (default: true).\nvariable = Bool: whether the system depends on an extra variable v (default: false).\n\nBracket type detection\n\nSquare brackets [...] denote Lie brackets between VectorField objects.\nCurly brackets {...} denote Poisson brackets between Hamiltonian objects or between raw functions.\nThe macro automatically dispatches to Lie or Poisson depending on the input pattern.\n\nReturn\n\nA callable object representing the specified Lie or Poisson bracket expression. The returned function can be evaluated like any other vector field or Hamiltonian.\n\n\n\nExamples\n\n■ Lie brackets with VectorField (autonomous)\n\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> F2 = VectorField(x -> [x[3], 0, -x[1]])\njulia> L = @Lie [F1, F2]\njulia> L([1.0, 2.0, 3.0])\n3-element Vector{Float64}:\n  2.0\n -1.0\n  0.0\n\n■ Lie brackets with VectorField (non-autonomous, with auxiliary variable)\n\njulia> F1 = VectorField((t, x, v) -> [0, -x[3], x[2]]; autonomous=false, variable=true)\njulia> F2 = VectorField((t, x, v) -> [x[3], 0, -x[1]]; autonomous=false, variable=true)\njulia> L = @Lie [F1, F2]\njulia> L(0.0, [1.0, 2.0, 3.0], 1.0)\n3-element Vector{Float64}:\n  2.0\n -1.0\n  0.0\n\n■ Poisson brackets with Hamiltonian (autonomous)\n\njulia> H1 = Hamiltonian((x, p) -> x[1]^2 + p[2]^2)\njulia> H2 = Hamiltonian((x, p) -> x[2]^2 + p[1]^2)\njulia> P = @Lie {H1, H2}\njulia> P([1.0, 1.0], [3.0, 2.0])\n-4.0\n\n■ Poisson brackets with Hamiltonian (non-autonomous, with variable)\n\njulia> H1 = Hamiltonian((t, x, p, v) -> x[1]^2 + p[2]^2 + v; autonomous=false, variable=true)\njulia> H2 = Hamiltonian((t, x, p, v) -> x[2]^2 + p[1]^2 + v; autonomous=false, variable=true)\njulia> P = @Lie {H1, H2}\njulia> P(1.0, [1.0, 3.0], [4.0, 2.0], 3.0)\n8.0\n\n■ Poisson brackets from raw functions\n\njulia> H1 = (x, p) -> x[1]^2 + p[2]^2\njulia> H2 = (x, p) -> x[2]^2 + p[1]^2\njulia> P = @Lie {H1, H2}\njulia> P([1.0, 1.0], [3.0, 2.0])\n-4.0\n\n■ Poisson bracket with non-autonomous raw functions\n\njulia> H1 = (t, x, p) -> x[1]^2 + p[2]^2 + t\njulia> H2 = (t, x, p) -> x[2]^2 + p[1]^2 + t\njulia> P = @Lie {H1, H2} autonomous = false\njulia> P(3.0, [1.0, 2.0], [4.0, 1.0])\n-8.0\n\n■ Nested brackets\n\njulia> F = VectorField(x -> [-x[1], x[2], x[3]])\njulia> G = VectorField(x -> [x[3], -x[2], 0])\njulia> H = VectorField(x -> [0, 0, -x[1]])\njulia> nested = @Lie [[F, G], H]\njulia> nested([1.0, 2.0, 3.0])\n3-element Vector{Float64}:\n  2.0\n  0.0\n -6.0\n\njulia> H1 = (x, p) -> x[2]*x[1]^2 + p[1]^2\njulia> H2 = (x, p) -> x[1]*p[2]^2\njulia> H3 = (x, p) -> x[1]*p[2] + x[2]*p[1]\njulia> nested_poisson = @Lie {{H1, H2}, H3}\njulia> nested_poisson([1.0, 2.0], [0.5, 1.0])\n14.0\n\n■ Mixed expressions with arithmetic\n\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> F2 = VectorField(x -> [x[3], 0, -x[1]])\njulia> x = [1.0, 2.0, 3.0]\njulia> @Lie [F1, F2](x) + 3 * [F1, F2](x)\n3-element Vector{Float64}:\n  8.0\n -4.0\n  0.0\n\njulia> H1 = (x, p) -> x[1]^2\njulia> H2 = (x, p) -> p[1]^2\njulia> H3 = (x, p) -> x[1]*p[1]\njulia> x = [1.0, 2.0, 3.0]\njulia> p = [3.0, 2.0, 1.0]\njulia> @Lie {H1, H2}(x, p) + 2 * {H2, H3}(x, p)\n24.0\n\n\n\n\n\n","category":"macro"},{"location":"api-optimalcontrol-user.html#CTFlows.Lie","page":"OptimalControl.jl - User","title":"CTFlows.Lie","text":"Lie derivative of a scalar function along a vector field.\n\nExample:\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\nLie derivative of a scalar function along a function with specified dependencies.\n\nExample:\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\nLie bracket of two vector fields in the autonomous case.\n\nExample:\n\njulia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]\n\n\n\n\n\nLie bracket of two vector fields in the nonautonomous case.\n\nExample:\n\njulia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7, 12]\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTFlows.Lift","page":"OptimalControl.jl - User","title":"CTFlows.Lift","text":"Lift(\n    X::VectorField\n) -> HamiltonianLift{VectorField{TF, TD, VD}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\n\nConstruct the Hamiltonian lift of a VectorField.\n\nArguments\n\nX::VectorField: The vector field to lift. Its signature determines if it is autonomous and/or variable.\n\nReturns\n\nA HamiltonianLift callable object representing the Hamiltonian lift of X.\n\nExamples\n\njulia> HL = Lift(VectorField(x -> [x[1]^2, x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])  # returns 0\n\njulia> HL2 = Lift(VectorField((t, x, v) -> [t + x[1]^2, x[2]^2 + v], autonomous=false, variable=true))\njulia> HL2(1, [1, 0], [0, 1], 1)  # returns 1\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)  # returns 2\n\njulia> H2 = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H2(1, 1, 1, 1)  # returns 2\n\n# Alternative syntax using symbols for autonomy and variability\njulia> H3 = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H3(1, 1, 1, 1)  # returns 2\n\n\n\n\n\nLift(\n    X::Function;\n    autonomous,\n    variable\n) -> CTFlows.var\"#21#22\"{<:Function}\n\n\nConstruct the Hamiltonian lift of a function.\n\nArguments\n\nX::Function: The function representing the vector field.\nautonomous::Bool=true: Whether the function is autonomous (time-independent).\nvariable::Bool=false: Whether the function depends on an additional variable argument.\n\nReturns\n\nA callable function computing the Hamiltonian lift, \n\n(and variants depending on autonomous and variable).\n\nDetails\n\nDepending on the autonomous and variable flags, the returned function has one of the following call signatures:\n\n(x, p) if autonomous=true and variable=false\n(x, p, v) if autonomous=true and variable=true\n(t, x, p) if autonomous=false and variable=false\n(t, x, p, v) if autonomous=false and variable=true\n\nExamples\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)  # returns 2\n\njulia> H2 = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H2(1, 1, 1, 1)  # returns 2\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.Model","page":"OptimalControl.jl - User","title":"CTModels.Model","text":"struct Model{TD<:CTModels.TimeDependence, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:CTModels.AbstractConstraintsModel, BuildExaModelType<:Union{Nothing, Function}} <: CTModels.AbstractModel\n\nFields\n\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ndynamics::Function\nobjective::CTModels.AbstractObjectiveModel\nconstraints::CTModels.AbstractConstraintsModel\ndefinition::Expr\nbuild_examodel::Union{Nothing, Function}\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTBase.NotImplemented","page":"OptimalControl.jl - User","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTException\n\nException thrown when a method or function has not been implemented yet.\n\nFields\n\nvar::String: A message indicating what functionality is not yet implemented.\n\nExample\n\njulia> throw(NotImplemented(\"feature X is not implemented\"))\nERROR: NotImplemented: feature X is not implemented\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTBase.ParsingError","page":"OptimalControl.jl - User","title":"CTBase.ParsingError","text":"struct ParsingError <: CTException\n\nException thrown during parsing when a syntax error or invalid structure is detected.\n\nFields\n\nvar::String: A message describing the parsing error.\n\nExample\n\njulia> throw(ParsingError(\"unexpected token\"))\nERROR: ParsingError: unexpected token\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTFlows.Poisson","page":"OptimalControl.jl - User","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V<:CTFlows.VariableDependence},\n    g::CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian). Autonomous case.\n\nReturns a Hamiltonian representing the Poisson bracket {f, g} of two autonomous Hamiltonian functions f and g.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])     # -20\njulia> Poisson(f, G)([1, 2], [2, 1])     # -20\njulia> Poisson(F, g)([1, 2], [2, 1])     # -20\n\n\n\n\n\nPoisson(\n    f::CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V<:CTFlows.VariableDependence},\n    g::CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions. Non-autonomous case.\n\nReturns a Hamiltonian representing {f, g} where f and g are time-dependent.\n\nExample\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])     # -76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])     # -76\n\n\n\n\n\nPoisson(\n    f::HamiltonianLift{T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence},\n    g::HamiltonianLift{T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence}\n)\n\n\nPoisson bracket of two HamiltonianLift vector fields.\n\nReturns the HamiltonianLift corresponding to the Lie bracket of vector fields f.X and g.X.\n\nExample\n\njulia> f = x -> [x[1]^2 + x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2] - x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])     # -64\n\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 - x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])     # 100\n\n\n\n\n\nPoisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n\n\nPoisson bracket of two functions. The time and variable dependence are specified with keyword arguments.\n\nReturns a Hamiltonian computed from the functions promoted as Hamiltonians.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])     # -20\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])     # -76\n\n\n\n\n\nPoisson(\n    f::Function,\n    g::CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n) -> Hamiltonian\n\n\nPoisson bracket of a function and a Hamiltonian.\n\nReturns a Hamiltonian representing {f, g} where g is already a Hamiltonian.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)\njulia> Poisson(f, G)([1, 2], [2, 1])     # -20\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])     # -76\n\n\n\n\n\nPoisson(\n    f::CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence},\n    g::Function\n) -> Hamiltonian\n\n\nPoisson bracket of a Hamiltonian and a function.\n\nReturns a Hamiltonian representing {f, g} where f is already a Hamiltonian.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])     # -20\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])     # -76\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.Solution","page":"OptimalControl.jl - User","title":"CTModels.Solution","text":"struct Solution{TimeGridModelType<:CTModels.AbstractTimeGridModel, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, CostateModelType<:Function, ObjectiveValueType<:Real, DualModelType<:CTModels.AbstractDualModel, SolverInfosType<:CTModels.AbstractSolverInfos, ModelType<:CTModels.AbstractModel} <: CTModels.AbstractSolution\n\nFields\n\ntime_grid::CTModels.AbstractTimeGridModel\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ncostate::Function\nobjective::Real\ndual::CTModels.AbstractDualModel\nsolver_infos::CTModels.AbstractSolverInfos\nmodel::CTModels.AbstractModel\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTFlows.VectorField","page":"OptimalControl.jl - User","title":"CTFlows.VectorField","text":"struct VectorField{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence} <: CTFlows.AbstractVectorField{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nRepresents a dynamical system dx/dt = f(...) as a vector field.\n\nFields\n\nf: a callable of the form:\nf(x)\nf(t, x)\nf(x, v)\nf(t, x, v)\n\nExample\n\nf(x) = [x[2], -x[1]]\nvf = VectorField{typeof(f), Autonomous, Fixed}(f)\nvf([1.0, 0.0])\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTBase.UnauthorizedCall","page":"OptimalControl.jl - User","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTException\n\nException thrown when a function call is not authorized in the current context or with the given arguments.\n\nFields\n\nvar::String: A message explaining why the call is unauthorized.\n\nExample\n\njulia> throw(UnauthorizedCall(\"user does not have permission\"))\nERROR: UnauthorizedCall: user does not have permission\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#OptimalControl.available_methods","page":"OptimalControl.jl - User","title":"OptimalControl.available_methods","text":"available_methods(\n\n) -> Tuple{Vararg{Tuple{Symbol, Symbol, Symbol}}}\n\n\nReturn the list of available methods that can be used to solve optimal control problems.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTDirect.build_OCP_solution","page":"OptimalControl.jl - User","title":"CTDirect.build_OCP_solution","text":"build_OCP_solution(\n    docp::CTDirect.DOCP,\n    nlp_solution::SolverCore.AbstractExecutionStats\n) -> Solution{TimeGridModelType, TimesModelType, StateModelType, ControlModelType, VariableModelType, CostateModelType, Float64, DualModelType, CTModels.SolverInfos{Dict{Symbol, Any}}, ModelType} where {TimeGridModelType<:CTModels.TimeGridModel, TimesModelType<:CTModels.TimesModel, StateModelType<:Union{CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#84#85\", CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#86#87\"}, ControlModelType<:Union{CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#88#89\", CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#90#91\"}, VariableModelType<:Union{CTModels.VariableModelSolution{Vector{Float64}}, CTModels.VariableModelSolution{Float64}}, CostateModelType<:Union{CTModels.var\"#92#93\", CTModels.var\"#94#95\"}, DualModelType<:(CTModels.DualModel{PC_Dual, Vector{Float64}, SC_LB_Dual, SC_UB_Dual, CC_LB_Dual, CC_UB_Dual, Vector{Float64}, Vector{Float64}} where {PC_Dual<:Union{CTModels.var\"#100#101\"{CTModels.var\"#96#97\"}, CTModels.var\"#98#99\"{CTModels.var\"#96#97\"}}, SC_LB_Dual<:Union{CTModels.var\"#104#105\"{CTModels.var\"#102#103\"}, CTModels.var\"#106#107\"{CTModels.var\"#102#103\"}}, SC_UB_Dual<:Union{CTModels.var\"#110#111\"{CTModels.var\"#108#109\"}, CTModels.var\"#112#113\"{CTModels.var\"#108#109\"}}, CC_LB_Dual<:Union{CTModels.var\"#116#117\"{CTModels.var\"#114#115\"}, CTModels.var\"#118#119\"{CTModels.var\"#114#115\"}}, CC_UB_Dual<:Union{CTModels.var\"#122#123\"{CTModels.var\"#120#121\"}, CTModels.var\"#124#125\"{CTModels.var\"#120#121\"}}}), ModelType<:(Model{<:CTModels.TimeDependence, T} where T<:CTModels.TimesModel)}\n\n\nBuild an OCP functional solution from a DOCP discrete solution given as a SolverCore.AbstractExecutionStats object.\n\nArguments\n\ndocp: The discretized optimal control problem (DOCP).\nnlp_solution: A solver execution statistics object.\n\nReturns\n\nsolution::CTModels.Solution: A functional OCP solution containing trajectories, multipliers, and solver information.\n\nExample\n\njulia> build_OCP_solution(docp, nlp_solution)\nCTModels.Solution(...)\n\n\n\n\n\nbuild_OCP_solution(\n    docp;\n    primal,\n    dual,\n    multipliers_L,\n    multipliers_U,\n    nlp_model_backend,\n    nlp_solution\n)\n\n\nBuild an OCP functional solution from a DOCP discrete solution, given explicit primal variables, and optionally dual variables and bound multipliers.\n\nArguments\n\ndocp: The discretized optimal control problem (DOCP).\nprimal: Array of primal decision variables.\ndual: Array of dual variables (default: nothing).\nmultipliers_L: Lower bound multipliers (default: nothing).\nmultipliers_U: Upper bound multipliers (default: nothing).\nnlp_model_backend: The NLP model backend (default: ADNLPBackend()).\nnlp_solution: A solver execution statistics object.\n\nReturns\n\nsolution::CTModels.Solution: A functional OCP solution with trajectories, multipliers, and solver information.\n\nExample\n\njulia> build_OCP_solution(docp; primal=primal_vars, nlp_solution=nlp_solution)\nCTModels.Solution(...)\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#ExaModels.constraint-Tuple{Model, Symbol}","page":"OptimalControl.jl - User","title":"ExaModels.constraint","text":"constraint(\n    ocp::Model,\n    label::Symbol\n) -> Tuple{Symbol, Any, Any, Any}\n\n\nGet a labelled constraint from the model. Returns a tuple of the form (type, f, lb, ub) where type is the type of the constraint, f is the function,  lb is the lower bound and ub is the upper bound. \n\nThe function returns an exception if the label is not found in the model.\n\nArguments\n\nmodel: The model from which to retrieve the constraint.\nlabel: The label of the constraint to retrieve.\n\nReturns\n\nTuple: A tuple containing the type, function, lower bound, and upper bound of the constraint.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-user.html#CTModels.constraints","page":"OptimalControl.jl - User","title":"CTModels.constraints","text":"constraints(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, C<:CTModels.AbstractConstraintsModel}\n) -> CTModels.AbstractConstraintsModel\n\n\nReturn the constraints struct.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.constraints_violation","page":"OptimalControl.jl - User","title":"CTModels.constraints_violation","text":"constraints_violation(sol::Solution) -> Float64\n\n\nReturn the constraints violation.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.control","page":"OptimalControl.jl - User","title":"CTModels.control","text":"control(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, T<:CTModels.AbstractControlModel}\n) -> CTModels.AbstractControlModel\n\n\nReturn the control struct.\n\n\n\n\n\ncontrol(\n    sol::Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.ControlModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the control as a function of time.\n\njulia> u  = control(sol)\njulia> t0 = time_grid(sol)[1]\njulia> u0 = u(t0) # control at the initial time\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.control_components","page":"OptimalControl.jl - User","title":"CTModels.control_components","text":"control_components(ocp::Model) -> Vector{String}\n\n\nReturn the names of the components of the control.\n\n\n\n\n\ncontrol_components(sol::Solution) -> Vector{String}\n\n\nReturn the names of the components of the control.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.control_dimension","page":"OptimalControl.jl - User","title":"CTModels.control_dimension","text":"control_dimension(ocp::Model) -> Int64\n\n\nReturn the control dimension.\n\n\n\n\n\ncontrol_dimension(sol::Solution) -> Int64\n\n\nReturn the dimension of the control.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.control_name","page":"OptimalControl.jl - User","title":"CTModels.control_name","text":"control_name(ocp::Model) -> String\n\n\nReturn the name of the control.\n\n\n\n\n\ncontrol_name(sol::Solution) -> String\n\n\nReturn the name of the control.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.costate","page":"OptimalControl.jl - User","title":"CTModels.costate","text":"costate(\n    sol::Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, Co<:Function}\n) -> Function\n\n\nReturn the costate as a function of time.\n\njulia> p  = costate(sol)\njulia> t0 = time_grid(sol)[1]\njulia> p0 = p(t0) # costate at the initial time\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.criterion","page":"OptimalControl.jl - User","title":"CTModels.criterion","text":"criterion(model::CTModels.MayerObjectiveModel) -> Symbol\n\n\nReturn the criterion (:min or :max).\n\n\n\n\n\ncriterion(model::CTModels.LagrangeObjectiveModel) -> Symbol\n\n\nReturn the criterion (:min or :max).\n\n\n\n\n\ncriterion(model::CTModels.BolzaObjectiveModel) -> Symbol\n\n\nReturn the criterion (:min or :max).\n\n\n\n\n\ncriterion(ocp::Model) -> Symbol\n\n\nReturn the type of criterion (:min or :max).\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTParser.@def","page":"OptimalControl.jl - User","title":"CTParser.@def","text":"Define an optimal control problem. One pass parsing of the definition. Can be used writing either ocp = @def begin ... end or @def ocp begin ... end. In the second case, setting log to true will display the parsing steps.\n\nExample\n\nocp = @def begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend\n\n@def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend true # final boolean to show parsing log\n\n\n\n\n\n","category":"macro"},{"location":"api-optimalcontrol-user.html#CTModels.definition","page":"OptimalControl.jl - User","title":"CTModels.definition","text":"definition(ocp::Model) -> Expr\n\n\nReturn the model definition of the optimal control problem.\n\n\n\n\n\ndefinition(ocp::CTModels.PreModel) -> Union{Nothing, Expr}\n\n\nReturn the model definition of the optimal control problem or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTDirect.direct_transcription","page":"OptimalControl.jl - User","title":"CTDirect.direct_transcription","text":"direct_transcription(\n    ocp::Model,\n    description...;\n    grid_size,\n    disc_method,\n    time_grid,\n    init,\n    lagrange_to_mayer,\n    kwargs...\n) -> CTDirect.DOCP\n\n\nConvert a continuous-time optimal control problem into a discretized nonlinear programming problem.\n\nArguments\n\nocp::CTModels.Model: Continuous-time optimal control problem.\ndescription...: Symbols specifying the NLP model ([:adnlp] or :exa) and/or solver ([:ipopt], :madnlp or :knitro).\n\nKeyword Arguments (optional)\n\ngrid_size::Int: Number of discretization steps ([250]).\ndisc_method: Discretization scheme (:trapeze, :euler, :euler_implicit, [:midpoint], gauss_legendre_2, gauss_legendre_3).\ntime_grid: Explicit time grid (can be non uniform).\ninit: Initial guess values or existing solution.\nlagrange_to_mayer::Bool: Convert Lagrange cost to Mayer cost (true or false).\nkwargs...: Additional arguments passed to the NLP modeler.\n\nReturns\n\ndocp::CTDirect.DOCP: Discretized optimal control problem ready for NLP solving.\n\nExample\n\njulia> docp = direct_transcription(ocp, :adnlp, :ipopt; grid_size=100, disc_method=:trapeze)\nCTDirect.DOCP(...)\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.dual","page":"OptimalControl.jl - User","title":"CTModels.dual","text":"dual(sol::Solution, model::Model, label::Symbol) -> Any\n\n\nReturn the dual variable associated with a constraint identified by its label.\n\nSearches through all constraint types (path, boundary, state, control, and variable constraints) defined in the model and returns the corresponding dual value from the solution.\n\nArguments\n\nsol::Solution: Solution object containing dual variables.\nmodel::Model: Model containing constraint definitions.\nlabel::Symbol: Symbol corresponding to a constraint label.\n\nReturns\n\nA function of time t for time-dependent constraints, or a scalar/vector for time-invariant duals. If the label is not found, throws an IncorrectArgument exception.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.dynamics","page":"OptimalControl.jl - User","title":"CTModels.dynamics","text":"dynamics(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, D<:Function}\n) -> Function\n\n\nReturn the dynamics.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.export_ocp_solution","page":"OptimalControl.jl - User","title":"CTModels.export_ocp_solution","text":"export_ocp_solution(\n    sol::CTModels.AbstractSolution;\n    format,\n    filename\n)\n\n\nExport a solution in JLD or JSON formats. Redirect to one of the methods:\n\nexport_ocp_solution(JLD2Tag(), sol, filename=filename)\nexport_ocp_solution(JSON3Tag(), sol, filename=filename)\n\nExamples\n\njulia> using JSON3\njulia> export_ocp_solution(sol; filename=\"solution\", format=:JSON)\njulia> using JLD2\njulia> export_ocp_solution(sol; filename=\"solution\", format=:JLD)  # JLD is the default\n\n\n\n\n\nexport_ocp_solution(\n    ::CTModels.JSON3Tag,\n    sol::Solution;\n    filename\n)\n\n\nExport an optimal control solution to a .json file using the JSON3 format.\n\nThis function serializes a CTModels.Solution into a structured JSON dictionary, including all primal and dual information, which can be read by external tools.\n\nArguments\n\n::CTModels.JSON3Tag: A tag used to dispatch the export method for JSON3.\nsol::CTModels.Solution: The solution to be saved.\n\nKeyword Arguments\n\nfilename::String = \"solution\": Base filename. The .json extension is automatically appended.\n\nNotes\n\nThe exported JSON includes the time grid, state, control, costate, objective, solver info, and all constraint duals (if available).\n\nExample\n\njulia> using JSON3\njulia> export_ocp_solution(JSON3Tag(), sol; filename=\"mysolution\")\n# → creates \"mysolution.json\"\n\n\n\n\n\nexport_ocp_solution(\n    ::CTModels.JLD2Tag,\n    sol::Solution;\n    filename\n)\n\n\nExport an optimal control solution to a .jld2 file using the JLD2 format.\n\nThis function serializes and saves a CTModels.Solution object to disk, allowing it to be reloaded later.\n\nArguments\n\n::CTModels.JLD2Tag: A tag used to dispatch the export method for JLD2.\nsol::CTModels.Solution: The optimal control solution to be saved.\n\nKeyword Arguments\n\nfilename::String = \"solution\": Base name of the file. The .jld2 extension is automatically appended.\n\nExample\n\njulia> using JLD2\njulia> export_ocp_solution(JLD2Tag(), sol; filename=\"mysolution\")\n# → creates \"mysolution.jld2\"\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.final_time","page":"OptimalControl.jl - User","title":"CTModels.final_time","text":"final_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the final time from the times model, from a fixed final time model.\n\n\n\n\n\nfinal_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the final time from the times model, from a free final time model.\n\n\n\n\n\nfinal_time(ocp::CTModels.AbstractModel) -> Real\n\n\n\n\n\n\nfinal_time(\n    ocp::CTModels.AbstractModel,\n    variable::AbstractVector\n) -> Any\n\n\n\n\n\n\nfinal_time(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nReturn the final time, for a fixed final time.\n\n\n\n\n\nfinal_time(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nReturn the final time, for a free final time.\n\n\n\n\n\nfinal_time(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}},\n    variable::Real\n) -> Real\n\n\nReturn the final time, for a free final time.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.final_time_name","page":"OptimalControl.jl - User","title":"CTModels.final_time_name","text":"final_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the final time from the times model.\n\n\n\n\n\nfinal_time_name(ocp::Model) -> String\n\n\nReturn the name of the final time.\n\n\n\n\n\nfinal_time_name(sol::Solution) -> String\n\n\nReturn the name of the final time.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.get_build_examodel","page":"OptimalControl.jl - User","title":"CTModels.get_build_examodel","text":"get_build_examodel(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.AbstractConstraintsModel, BE<:Function}\n) -> Function\n\n\nReturn the build_examodel.\n\n\n\n\n\nget_build_examodel(\n    _::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.AbstractConstraintsModel, <:Nothing}\n)\n\n\nReturn an error (UnauthorizedCall) since the model is not built with the :exa backend.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.has_fixed_final_time","page":"OptimalControl.jl - User","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the final time is fixed. Return true.\n\n\n\n\n\nhas_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the final time is free. Return false.\n\n\n\n\n\nhas_fixed_final_time(ocp::Model) -> Bool\n\n\nCheck if the final time is fixed.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.has_fixed_initial_time","page":"OptimalControl.jl - User","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(\n    times::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the initial time is fixed. Return true.\n\n\n\n\n\nhas_fixed_initial_time(\n    times::CTModels.TimesModel{CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the initial time is free. Return false.\n\n\n\n\n\nhas_fixed_initial_time(ocp::Model) -> Bool\n\n\nCheck if the initial time is fixed.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.has_free_final_time","page":"OptimalControl.jl - User","title":"CTModels.has_free_final_time","text":"has_free_final_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\nhas_free_final_time(ocp::Model) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.has_free_initial_time","page":"OptimalControl.jl - User","title":"CTModels.has_free_initial_time","text":"has_free_initial_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\nhas_free_initial_time(ocp::Model) -> Bool\n\n\nCheck if the initial time is free.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.has_lagrange_cost","page":"OptimalControl.jl - User","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(_::CTModels.MayerObjectiveModel) -> Bool\n\n\nReturn false.\n\n\n\n\n\nhas_lagrange_cost(\n    _::CTModels.LagrangeObjectiveModel\n) -> Bool\n\n\nReturn true.\n\n\n\n\n\nhas_lagrange_cost(_::CTModels.BolzaObjectiveModel) -> Bool\n\n\nReturn true.\n\n\n\n\n\nhas_lagrange_cost(ocp::Model) -> Bool\n\n\nCheck if the model has a Lagrange cost.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.has_mayer_cost","page":"OptimalControl.jl - User","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(_::CTModels.MayerObjectiveModel) -> Bool\n\n\nReturn true.\n\n\n\n\n\nhas_mayer_cost(_::CTModels.LagrangeObjectiveModel) -> Bool\n\n\nReturn false.\n\n\n\n\n\nhas_mayer_cost(_::CTModels.BolzaObjectiveModel) -> Bool\n\n\nReturn true.\n\n\n\n\n\nhas_mayer_cost(ocp::Model) -> Bool\n\n\nCheck if the model has a Mayer cost.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.import_ocp_solution","page":"OptimalControl.jl - User","title":"CTModels.import_ocp_solution","text":"import_ocp_solution(\n    ocp::CTModels.AbstractModel;\n    format,\n    filename\n) -> Any\n\n\nImport a solution from a JLD or JSON file. Redirect to one of the methods:\n\nimport_ocp_solution(JLD2Tag(), ocp, filename=filename)\nimport_ocp_solution(JSON3Tag(), ocp, filename=filename)\n\nExamples\n\njulia> using JSON3\njulia> sol = import_ocp_solution(ocp; filename=\"solution\", format=:JSON)\njulia> using JLD2\njulia> sol = import_ocp_solution(ocp; filename=\"solution\", format=:JLD)  # JLD is the default\n\n\n\n\n\nimport_ocp_solution(\n    ::CTModels.JSON3Tag,\n    ocp::Model;\n    filename\n)\n\n\nImport an optimal control solution from a .json file exported with export_ocp_solution.\n\nThis function reads the JSON contents and reconstructs a CTModels.Solution object, including the discretized primal and dual trajectories.\n\nArguments\n\n::CTModels.JSON3Tag: A tag used to dispatch the import method for JSON3.\nocp::CTModels.Model: The model associated with the optimal control problem. Used to rebuild the full solution.\n\nKeyword Arguments\n\nfilename::String = \"solution\": Base filename. The .json extension is automatically appended.\n\nReturns\n\nCTModels.Solution: A reconstructed solution instance.\n\nNotes\n\nHandles both vector and matrix encodings of signals. If dual fields are missing or null, the corresponding attributes are set to nothing.\n\nExample\n\njulia> using JSON3\njulia> sol = import_ocp_solution(JSON3Tag(), model; filename=\"mysolution\")\n\n\n\n\n\nimport_ocp_solution(\n    ::CTModels.JLD2Tag,\n    ocp::Model;\n    filename\n)\n\n\nImport an optimal control solution from a .jld2 file.\n\nThis function loads a previously saved CTModels.Solution from disk.\n\nArguments\n\n::CTModels.JLD2Tag: A tag used to dispatch the import method for JLD2.\nocp::CTModels.Model: The associated model (used for dispatch consistency; not used internally).\n\nKeyword Arguments\n\nfilename::String = \"solution\": Base name of the file. The .jld2 extension is automatically appended.\n\nReturns\n\nCTModels.Solution: The loaded solution object.\n\nExample\n\njulia> using JLD2\njulia> sol = import_ocp_solution(JLD2Tag(), model; filename=\"mysolution\")\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.infos","page":"OptimalControl.jl - User","title":"CTModels.infos","text":"infos(sol::Solution) -> Dict{Symbol, Any}\n\n\nReturn a dictionary of additional infos depending on the solver or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.initial_time","page":"OptimalControl.jl - User","title":"CTModels.initial_time","text":"initial_time(\n    model::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the initial time from the times model, from a fixed initial time model.\n\n\n\n\n\ninitial_time(\n    model::CTModels.TimesModel{CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the initial time from the times model, from a free initial time model.\n\n\n\n\n\ninitial_time(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nReturn the initial time, for a fixed initial time.\n\n\n\n\n\ninitial_time(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nReturn the initial time, for a free initial time.\n\n\n\n\n\ninitial_time(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FreeTimeModel}},\n    variable::Real\n) -> Real\n\n\nReturn the initial time, for a free initial time.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.initial_time_name","page":"OptimalControl.jl - User","title":"CTModels.initial_time_name","text":"initial_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the initial time from the times model.\n\n\n\n\n\ninitial_time_name(ocp::Model) -> String\n\n\nReturn the name of the initial time.\n\n\n\n\n\ninitial_time_name(sol::Solution) -> String\n\n\nReturn the name of the initial time.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.is_autonomous-Tuple{Model{CTModels.Autonomous, <:CTModels.TimesModel}}","page":"OptimalControl.jl - User","title":"CTModels.is_autonomous","text":"is_autonomous(\n    _::Model{CTModels.Autonomous, <:CTModels.TimesModel}\n) -> Bool\n\n\nReturn true.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-user.html#CTModels.iterations","page":"OptimalControl.jl - User","title":"CTModels.iterations","text":"iterations(sol::Solution) -> Int64\n\n\nReturn the number of iterations (if solved by an iterative method).\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.lagrange","page":"OptimalControl.jl - User","title":"CTModels.lagrange","text":"lagrange(\n    model::CTModels.LagrangeObjectiveModel{L<:Function}\n) -> Function\n\n\nReturn the Lagrange function.\n\n\n\n\n\nlagrange(\n    model::CTModels.BolzaObjectiveModel{<:Function, L<:Function}\n) -> Function\n\n\nReturn the Lagrange function.\n\n\n\n\n\nlagrange(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, CTModels.LagrangeObjectiveModel{L<:Function}}\n) -> Function\n\n\nReturn the Lagrange cost.\n\n\n\n\n\nlagrange(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{<:Function, L<:Function}}\n) -> Any\n\n\nReturn the Lagrange cost.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.mayer","page":"OptimalControl.jl - User","title":"CTModels.mayer","text":"mayer(\n    model::CTModels.MayerObjectiveModel{M<:Function}\n) -> Function\n\n\nReturn the Mayer function.\n\n\n\n\n\nmayer(\n    model::CTModels.BolzaObjectiveModel{M<:Function}\n) -> Function\n\n\nReturn the Mayer function.\n\n\n\n\n\nmayer(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.MayerObjectiveModel{M<:Function}}\n) -> Any\n\n\nReturn the Mayer cost.\n\n\n\n\n\nmayer(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{M<:Function}}\n) -> Any\n\n\nReturn the Mayer cost.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.message","page":"OptimalControl.jl - User","title":"CTModels.message","text":"message(sol::Solution) -> String\n\n\nReturn the message associated to the status criterion.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTDirect.nlp_model","page":"OptimalControl.jl - User","title":"CTDirect.nlp_model","text":"nlp_model(docp::CTDirect.DOCP) -> Any\n\n\nReturn the nonlinear programming (NLP) model associated with a given discretized optimal control problem (DOCP).\n\nArguments\n\ndocp::DOCP: The discretized optimal control problem.\n\nReturns\n\nnlp::Any: The underlying NLP model stored in docp.\n\nExample\n\njulia> nlp_model(docp)\nNLPModel(...)\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#ExaModels.objective-Tuple{Model}","page":"OptimalControl.jl - User","title":"ExaModels.objective","text":"objective(ocp::Model) -> CTModels.AbstractObjectiveModel\n\n\nSee CTModels.objective.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-user.html#ExaModels.objective-Tuple{Solution}","page":"OptimalControl.jl - User","title":"ExaModels.objective","text":"objective(sol::Solution) -> Real\n\n\nReturn the objective value.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-user.html#CTDirect.ocp_model","page":"OptimalControl.jl - User","title":"CTDirect.ocp_model","text":"ocp_model(docp::CTDirect.DOCP) -> Model\n\n\nReturn the continuous-time optimal control problem (OCP) model associated with a given discretized optimal control problem (DOCP).\n\nArguments\n\ndocp::DOCP: The discretized optimal control problem.\n\nReturns\n\nocp::Any: The underlying OCP model stored in docp.\n\nExample\n\njulia> ocp_model(docp)\nOCPModel(...)\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#RecipesBase.plot-Tuple{Solution, Vararg{Symbol}}","page":"OptimalControl.jl - User","title":"RecipesBase.plot","text":"plot(\n    sol::Solution,\n    description::Symbol...;\n    layout,\n    control,\n    time,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    time_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    size,\n    color,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot the components of an optimal control solution.\n\nThis is the main user-facing function to visualise the solution of an optimal control problem solved with the control-toolbox ecosystem.\n\nIt generates a set of subplots showing the evolution of the state, control, costate, path constraints, and dual variables over time, depending on the problem and the user’s choices.\n\nArguments\n\nsol::CTModels.Solution: The optimal control solution to visualise.\ndescription::Symbol...: A variable number of symbols indicating which components to include in the plot. Common values include:\n:state – plot the state.\n:costate – plot the costate (adjoint).\n:control – plot the control.\n:path – plot the path constraints.\n:dual – plot the dual variables (or Lagrange multipliers) associated with path constraints.\n\nIf no symbols are provided, a default set is used based on the problem and styles.\n\nKeyword Arguments (Optional)\n\nlayout::Symbol = :group: Specifies how to arrange plots.\n:group: Fewer plots, grouping similar variables together (e.g., all states in one subplot).\n:split: One plot per variable component, stacked in a layout.\ncontrol::Symbol = :components: Defines how to represent control inputs.\n:components: One curve per control component.\n:norm: Single curve showing the Euclidean norm ‖u(t)‖.\n:all: Plot both components and norm.\ntime::Symbol = :default: Time normalisation for plots.\n:default: Real time scale.\n:normalize or :normalise: Normalised to the interval [0, 1].\ncolor: set the color of the all the graphs.\n\nStyle Options (Optional)\n\nAll style-related keyword arguments can be either a NamedTuple of plotting attributes or the Symbol :none referring to not plot the associated element. These allow you to customise color, line style, markers, etc.\n\ntime_style: Style for vertical lines at initial and final times.\nstate_style: Style for state components.\ncostate_style: Style for costate components.\ncontrol_style: Style for control components.\npath_style: Style for path constraint values.\ndual_style: Style for dual variables.\n\nBounds Decorations (Optional)\n\nUse these options to customise bounds on the plots if applicable and defined in the model. Set to :none to hide.\n\nstate_bounds_style: Style for state bounds.\ncontrol_bounds_style: Style for control bounds.\npath_bounds_style: Style for path constraint bounds.\n\nReturns\n\nA Plots.Plot object, which can be displayed, saved, or further customised.\n\nExample\n\n# basic plot\njulia> plot(sol)\n\n# plot only the state and control\njulia> plot(sol, :state, :control)\n\n# customise layout and styles, no costate\njulia> plot(sol;\n       layout = :group,\n       control = :all,\n       state_style = (color=:blue, linestyle=:solid),\n       control_style = (color=:red, linestyle=:dash),\n       costate_style = :none)       \n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-user.html#RecipesBase.plot!-Tuple{Plots.Plot, Solution, Vararg{Symbol}}","page":"OptimalControl.jl - User","title":"RecipesBase.plot!","text":"plot!(\n    p::Plots.Plot,\n    sol::Solution,\n    description::Symbol...;\n    layout,\n    control,\n    time,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    time_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    color,\n    kwargs...\n) -> Plots.Plot\n\n\nModify Plot p with the optimal control solution sol.\n\nSee plot for full behavior and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-user.html#CTDirect.set_initial_guess","page":"OptimalControl.jl - User","title":"CTDirect.set_initial_guess","text":"set_initial_guess(docp::CTDirect.DOCP, init) -> Any\n\n\nSet the initial guess for the decision variables in a discretized optimal control problem.\n\nArguments\n\ndocp::DOCP: The discretized optimal control problem.\ninit: Initial guess values as a named tuple or existing solution.\n\nReturns\n\nnothing\n\nExample\n\njulia> set_initial_guess(docp, init)\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CommonSolve.solve-Tuple{Model, Vararg{Symbol}}","page":"OptimalControl.jl - User","title":"CommonSolve.solve","text":"solve(\n    ocp::Model,\n    description::Symbol...;\n    display,\n    kwargs...\n) -> Solution{TimeGridModelType, TimesModelType, StateModelType, ControlModelType, VariableModelType, CostateModelType, Float64, DualModelType, CTModels.SolverInfos{Dict{Symbol, Any}}, ModelType} where {TimeGridModelType<:CTModels.TimeGridModel, TimesModelType<:CTModels.TimesModel, StateModelType<:Union{CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#84#85\", CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#86#87\"}, ControlModelType<:Union{CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#88#89\", CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#90#91\"}, VariableModelType<:Union{CTModels.VariableModelSolution{Vector{Float64}}, CTModels.VariableModelSolution{Float64}}, CostateModelType<:Union{CTModels.var\"#92#93\", CTModels.var\"#94#95\"}, DualModelType<:(CTModels.DualModel{PC_Dual, Vector{Float64}, SC_LB_Dual, SC_UB_Dual, CC_LB_Dual, CC_UB_Dual, Vector{Float64}, Vector{Float64}} where {PC_Dual<:Union{CTModels.var\"#100#101\"{CTModels.var\"#96#97\"}, CTModels.var\"#98#99\"{CTModels.var\"#96#97\"}}, SC_LB_Dual<:Union{CTModels.var\"#104#105\"{CTModels.var\"#102#103\"}, CTModels.var\"#106#107\"{CTModels.var\"#102#103\"}}, SC_UB_Dual<:Union{CTModels.var\"#110#111\"{CTModels.var\"#108#109\"}, CTModels.var\"#112#113\"{CTModels.var\"#108#109\"}}, CC_LB_Dual<:Union{CTModels.var\"#116#117\"{CTModels.var\"#114#115\"}, CTModels.var\"#118#119\"{CTModels.var\"#114#115\"}}, CC_UB_Dual<:Union{CTModels.var\"#122#123\"{CTModels.var\"#120#121\"}, CTModels.var\"#124#125\"{CTModels.var\"#120#121\"}}}), ModelType<:(Model{<:CTModels.TimeDependence, T} where T<:CTModels.TimesModel)}\n\n\nSolve the optimal control problem ocp by the method given by the (optional) description. The get the list of available methods:\n\njulia> available_methods()\n\nThe higher in the list, the higher is the priority. The keyword arguments are specific to the chosen method and represent the options of the solver.\n\nArguments\n\nocp::OptimalControlModel: the optimal control problem to solve.\ndescription::Symbol...: the description of the method used to solve the problem.\nkwargs...: the options of the method.\n\nExamples\n\nThe simplest way to solve the optimal control problem is to call the function without any argument.\n\njulia> sol = solve(ocp)\n\nThe method description is a list of Symbols. The default is\n\njulia> sol = solve(ocp, :direct, :adnlp, :ipopt)\n\nYou can provide a partial description, the function will find the best match.\n\njulia> sol = solve(ocp, :direct)\n\nnote: Note\nSee the resolution methods section for more details about the available methods.\n\nThe keyword arguments are specific to the chosen method and correspond to the options of the different solvers. For example, the keyword max_iter is an Ipopt option that may be used to set the maximum number of iterations.\n\njulia> sol = solve(ocp, :direct, :ipopt, max_iter=100)\n\nnote: Note\nSee the direct method section for more details about associated options. These options also detailed in the CTDirect.solve documentation. This main solve method redirects to CTDirect.solve when the :direct Symbol is given in the description. See also the NLP solvers section for more details about Ipopt or MadNLP options.\n\nTo help the solve converge, an initial guess can be provided within the keyword init. You can provide the initial guess for the state, control, and variable.\n\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5))\n\nnote: Note\nSee how to set an initial guess for more details.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-user.html#CTModels.state","page":"OptimalControl.jl - User","title":"CTModels.state","text":"state(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, T<:CTModels.AbstractStateModel}\n) -> CTModels.AbstractStateModel\n\n\nReturn the state struct.\n\n\n\n\n\nstate(\n    sol::Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.StateModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the state as a function of time.\n\njulia> x  = state(sol)\njulia> t0 = time_grid(sol)[1]\njulia> x0 = x(t0) # state at the initial time\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.state_components","page":"OptimalControl.jl - User","title":"CTModels.state_components","text":"state_components(ocp::Model) -> Vector{String}\n\n\nReturn the names of the components of the state.\n\n\n\n\n\nstate_components(sol::Solution) -> Vector{String}\n\n\nReturn the names of the components of the state.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.state_dimension","page":"OptimalControl.jl - User","title":"CTModels.state_dimension","text":"state_dimension(ocp::CTModels.PreModel) -> Int64\n\n\n\n\n\n\nstate_dimension(ocp::Model) -> Int64\n\n\nReturn the state dimension.\n\n\n\n\n\nstate_dimension(sol::Solution) -> Int64\n\n\nReturn the dimension of the state.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.state_name","page":"OptimalControl.jl - User","title":"CTModels.state_name","text":"state_name(ocp::Model) -> String\n\n\nReturn the name of the state.\n\n\n\n\n\nstate_name(sol::Solution) -> String\n\n\nReturn the name of the state.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.status","page":"OptimalControl.jl - User","title":"CTModels.status","text":"status(sol::Solution) -> Symbol\n\n\nReturn the status criterion (a Symbol).\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.successful","page":"OptimalControl.jl - User","title":"CTModels.successful","text":"successful(sol::Solution) -> Bool\n\n\nReturn the successful status.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.time_grid","page":"OptimalControl.jl - User","title":"CTModels.time_grid","text":"time_grid(\n    sol::Solution{<:CTModels.TimeGridModel{T<:Union{StepRangeLen, AbstractVector{<:Real}}}}\n) -> Union{StepRangeLen, AbstractVector{<:Real}}\n\n\nReturn the time grid.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.time_name","page":"OptimalControl.jl - User","title":"CTModels.time_name","text":"time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the time variable from the times model.\n\n\n\n\n\ntime_name(ocp::Model) -> String\n\n\nReturn the name of the time.\n\n\n\n\n\ntime_name(sol::Solution) -> String\n\n\nReturn the name of the time component.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.times","page":"OptimalControl.jl - User","title":"CTModels.times","text":"times(\n    ocp::Model{<:CTModels.TimeDependence, T<:CTModels.TimesModel}\n) -> CTModels.TimesModel\n\n\nReturn the times struct.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#ExaModels.variable-Tuple{Model}","page":"OptimalControl.jl - User","title":"ExaModels.variable","text":"variable(ocp::Model) -> CTModels.AbstractVariableModel\n\n\nSee CTModels.variable.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-user.html#ExaModels.variable-Tuple{Solution}","page":"OptimalControl.jl - User","title":"ExaModels.variable","text":"variable(\n    sol::Solution\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the variable or nothing.\n\njulia> v = variable(sol)\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-user.html#CTModels.variable_components","page":"OptimalControl.jl - User","title":"CTModels.variable_components","text":"variable_components(ocp::Model) -> Vector{String}\n\n\nReturn the names of the components of the variable.\n\n\n\n\n\nvariable_components(sol::Solution) -> Vector{String}\n\n\nReturn the names of the components of the variable.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.variable_dimension","page":"OptimalControl.jl - User","title":"CTModels.variable_dimension","text":"variable_dimension(ocp::Model) -> Int64\n\n\nReturn the variable dimension.\n\n\n\n\n\nvariable_dimension(sol::Solution) -> Int64\n\n\nReturn the dimension of the variable.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.variable_name","page":"OptimalControl.jl - User","title":"CTModels.variable_name","text":"variable_name(ocp::Model) -> String\n\n\nReturn the name of the variable.\n\n\n\n\n\nvariable_name(sol::Solution) -> String\n\n\nReturn the name of the variable.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTFlows.:⋅","page":"OptimalControl.jl - User","title":"CTFlows.:⋅","text":"Lie derivative of a scalar function along a vector field in the autonomous case.\n\nExample:\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0\n\n\n\n\n\nLie derivative of a scalar function along a vector field in the nonautonomous case.\n\nExample:\n\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\nLie derivative of a scalar function along a function (considered autonomous and non-variable).\n\nExample:\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError\n\n\n\n\n\n","category":"function"},{"location":"api-ctflows.html#CTFlows.jl","page":"CTFlows.jl","title":"CTFlows.jl","text":"The CTFlows.jl package is part of the control-toolbox ecosystem.\n\nflowchart TD\nB(<a href='api-ctbase.html'>CTBase</a>)\nM(<a href='api-ctmodels.html'>CTModels</a>)\nP(<a href='api-ctparser.html'>CTParser</a>)\nO(<a href='api-optimalcontrol-dev.html'>OptimalControl</a>)\nD(<a href='api-ctdirect.html'>CTDirect</a>)\nF(<a href='api-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle F fill:#FBF275\n\nOptimalControl heavily relies on CTFlows. We refer to CTFlows API for more details.\n\n","category":"section"},{"location":"api-ctparser.html#CTParser.jl","page":"CTParser.jl","title":"CTParser.jl","text":"The CTParser.jl package is part of the control-toolbox ecosystem.\n\nflowchart TD\nB(<a href='api-ctbase.html'>CTBase</a>)\nM(<a href='api-ctmodels.html'>CTModels</a>)\nP(<a href='api-ctparser.html'>CTParser</a>)\nO(<a href='api-optimalcontrol-dev.html'>OptimalControl</a>)\nD(<a href='api-ctdirect.html'>CTDirect</a>)\nF(<a href='api-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle P fill:#FBF275\n\nOptimalControl heavily relies on CTParser. We refer to CTParser API for more details.\n\n","category":"section"},{"location":"zhejiang-2025.html","page":"Solving optimal control problems in Julia: the OptimalControl.jl package","title":"Solving optimal control problems in Julia: the OptimalControl.jl package","text":"<img width=\"800\" alt=\"juliaopt2024\" src=\"./assets/zhejiang-2025.jpg\">","category":"section"},{"location":"zhejiang-2025.html#Solving-optimal-control-problems-in-Julia:-the-OptimalControl.jl-package","page":"Solving optimal control problems in Julia: the OptimalControl.jl package","title":"Solving optimal control problems in Julia: the OptimalControl.jl package","text":"","category":"section"},{"location":"zhejiang-2025.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://github.com/joseph-gergaud),-[Pierre-Martinon](https://github.com/PierreMartinon),-[Sophia-Sed](https://sed-sam-blog.gitlabpages.inria.fr)","page":"Solving optimal control problems in Julia: the OptimalControl.jl package","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"section"},{"location":"zhejiang-2025.html#What-it's-about","page":"Solving optimal control problems in Julia: the OptimalControl.jl package","title":"What it's about","text":"Nonlinear optimal control of ODEs:\n\ng(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min\n\nsubject to\n\ndotx(t) = f(x(t) u(t))quad t in t_0 t_f\n\nplus boundary, control and state constraints\n\nOur core interests: numerical & geometrical methods in control, applications","category":"section"},{"location":"zhejiang-2025.html#OptimalControl.jl-for-trajectory-optimisation","page":"Solving optimal control problems in Julia: the OptimalControl.jl package","title":"OptimalControl.jl for trajectory optimisation","text":"Basic example\nGoddard problem\nOrbit transfer","category":"section"},{"location":"zhejiang-2025.html#Wrap-up","page":"Solving optimal control problems in Julia: the OptimalControl.jl package","title":"Wrap up","text":"High level modelling of optimal control problems\nEfficient numerical resolution coupling direct and indirect methods\nCollection of examples","category":"section"},{"location":"zhejiang-2025.html#Future","page":"Solving optimal control problems in Julia: the OptimalControl.jl package","title":"Future","text":"New applications (space mechanics, biology, quantum mechanics and more)\nAdditional solvers: optimisation on GPU, direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions! If you like the package, please give us a star ⭐️\n\n<a href=\"https://github.com/control-toolbox/OptimalControl.jl\"><img width=\"800\" alt=\"OptimalControl.jl\" src=\"./assets/star.jpg\"></a>","category":"section"},{"location":"zhejiang-2025.html#control-toolbox.org","page":"Solving optimal control problems in Julia: the OptimalControl.jl package","title":"control-toolbox.org","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl\n\n<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"section"},{"location":"zhejiang-2025.html#Credits-(not-exhaustive!)","page":"Solving optimal control problems in Julia: the OptimalControl.jl package","title":"Credits (not exhaustive!)","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nIpopt.jl\nMadNLP.jl\nMLStyle.jl","category":"section"},{"location":"zhejiang-2025.html#Stand-up-for-science-2025","page":"Solving optimal control problems in Julia: the OptimalControl.jl package","title":"Stand up for science 2025","text":"<a href=\"https://standupforscience2025.org\"><img width=\"200\" alt=\"stand up for science 2025\" src=\"./assets/standup.jpg\"></a>","category":"section"},{"location":"zhejiang-2025.html#Acknowledgements","page":"Solving optimal control problems in Julia: the OptimalControl.jl package","title":"Acknowledgements","text":"Jean-Baptiste Caillau is partially funded by a France 2030 support managed by the Agence Nationale de la Recherche, under the reference ANR-23-PEIA-0004 (PDE-AI project).\n\n<img width=\"150\" alt=\"affiliations\" src=\"./assets/france-2030.png\">\n\n","category":"section"},{"location":"api-optimalcontrol-dev.html#OptimalControl.jl-(Private)","page":"OptimalControl.jl","title":"OptimalControl.jl (Private)","text":"OptimalControl.jl is the root package of the control-toolbox ecosystem.\n\nflowchart TD\nB(<a href='api-ctbase.html'>CTBase</a>)\nM(<a href='api-ctmodels.html'>CTModels</a>)\nP(<a href='api-ctparser.html'>CTParser</a>)\nO(<a href='api-optimalcontrol-dev.html'>OptimalControl</a>)\nD(<a href='api-ctdirect.html'>CTDirect</a>)\nF(<a href='api-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle O fill:#FBF275","category":"section"},{"location":"api-optimalcontrol-dev.html#Index","page":"OptimalControl.jl","title":"Index","text":"Pages   = [\"api-optimalcontrol-dev.md\"]\nModules = [OptimalControl]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"api-optimalcontrol-dev.html#Documentation","page":"OptimalControl.jl","title":"Documentation","text":"","category":"section"},{"location":"api-optimalcontrol-dev.html#ExaModels.constraint!-Tuple{CTModels.PreModel, Symbol}","page":"OptimalControl.jl","title":"ExaModels.constraint!","text":"constraint!(ocp::CTModels.PreModel, type::Symbol; kwargs...)\n\n\nSee CTModels.constraint!.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-dev.html#OptimalControl.__display-Tuple{}","page":"OptimalControl.jl","title":"OptimalControl.__display","text":"__display() -> Bool\n\n\nUsed to set the default display toggle. The default value is true.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-dev.html#OptimalControl.clean-Tuple{Tuple{Vararg{Symbol}}}","page":"OptimalControl.jl","title":"OptimalControl.clean","text":"clean(d::Tuple{Vararg{Symbol}}) -> Tuple{Vararg{Symbol}}\n\n\nWhen calling the function solve, the user can provide a description of the method to use to solve the optimal control problem. The description can be a partial description or a full description. The function solve will find the best match from the available methods, thanks to the function getFullDescription. Then, the description is cleaned by the function clean to remove the Symbols that are specific to  OptimalControl.jl and so must not be passed to the solver. For instance, the Symbol :direct is specific to OptimalControl.jl and must be removed. It must not be passed to the CTDirect.jl solver.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-dev.html#OptimalControl.version-Tuple{}","page":"OptimalControl.jl","title":"OptimalControl.version","text":"Return the version of the current module as a string.\n\nThis function returns the version number defined in the Project.toml of the package to which the current module belongs. It uses @__MODULE__ to infer the calling context.\n\nExample\n\njulia> version()   # e.g., \"1.2.3\"\n\n\n\n\n\n","category":"method"},{"location":"api-ctmodels.html#CTModels.jl","page":"CTModels.jl","title":"CTModels.jl","text":"The CTModels.jl package is part of the control-toolbox ecosystem.\n\nflowchart TD\nB(<a href='api-ctbase.html'>CTBase</a>)\nM(<a href='api-ctmodels.html'>CTModels</a>)\nP(<a href='api-ctparser.html'>CTParser</a>)\nO(<a href='api-optimalcontrol-dev.html'>OptimalControl</a>)\nD(<a href='api-ctdirect.html'>CTDirect</a>)\nF(<a href='api-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle M fill:#FBF275\n\nOptimalControl heavily relies on CTModels. We refer to CTModels API for more details.\n\n","category":"section"},{"location":"manual-flow-others.html#manual-flow-others","page":"From Hamiltonians and others","title":"How to compute Hamiltonian flows and trajectories","text":"In this tutorial, we explain the Flow function, in particular to compute flows from a Hamiltonian vector fields, but also from general vector fields.","category":"section"},{"location":"manual-flow-others.html#Introduction","page":"From Hamiltonians and others","title":"Introduction","text":"Consider the simple optimal control problem from the basic example page. The pseudo-Hamiltonian is\n\n    H(x p u) = p_q v + p_v u + p^0 u^2 2\n\nwhere x=(qv), p=(p_qp_v), p^0 = -1 since we are in the normal case. From the Pontryagin maximum principle, the maximising control is given in feedback form by\n\nu(x p) = p_v\n\nsince partial^2_uu H = p^0 = - 1  0. \n\nu(x, p) = p[2]\nnothing # hide\n\nActually, if (x u) is a solution of the optimal control problem,  then, the Pontryagin maximum principle tells us that there exists a costate p such that u(t) = u(x(t) p(t)) and such that the pair (x p) satisfies:\n\nbeginarrayl\n    dotx(t) = displaystylephantom-nabla_p H(x(t) p(t) u(x(t) p(t))) 05em\n    dotp(t) = displaystyle         - nabla_x H(x(t) p(t) u(x(t) p(t)))\nendarray\n\nnote: Nota bene\nActually, writing z = (x p), then the pair (x p) is also solution of    dotz(t) = vecmathbfH(z(t))where mathbfH(z) = H(z u(z)) and vecmathbfH = (nabla_p mathbfH -nabla_x mathbfH).\n\nLet us import the necessary packages.\n\nusing OptimalControl\nusing OrdinaryDiffEq\n\nThe package OrdinaryDiffEq.jl provides numerical integrators to compute solutions of ordinary differential equations.\n\nnote: OrdinaryDiffEq.jl\nThe package OrdinaryDiffEq.jl is part of DifferentialEquations.jl. You can either use one or the other.","category":"section"},{"location":"manual-flow-others.html#Extremals-from-the-Hamiltonian","page":"From Hamiltonians and others","title":"Extremals from the Hamiltonian","text":"The pairs (x p) solution of the Hamitonian vector field are called extremals. We can compute some constructing the flow from the optimal control problem and the control in feedback form. Another way to compute extremals is to define explicitly the Hamiltonian.\n\nH(x, p, u) = p[1] * x[2] + p[2] * u - 0.5 * u^2     # pseudo-Hamiltonian\nH(x, p) = H(x, p, u(x, p))                          # Hamiltonian\n\nz = Flow(Hamiltonian(H))\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\np0 = [12, 6]\nxf, pf = z(t0, x0, p0, tf)","category":"section"},{"location":"manual-flow-others.html#Extremals-from-the-Hamiltonian-vector-field","page":"From Hamiltonians and others","title":"Extremals from the Hamiltonian vector field","text":"You can also provide the Hamiltonian vector field.\n\nHv(x, p) = [x[2], p[2]], [0.0, -p[1]]     # Hamiltonian vector field\n\nz = Flow(HamiltonianVectorField(Hv))\nxf, pf = z(t0, x0, p0, tf)\n\nNote that if you call the flow on tspan=(t0, tf), then you obtain the output solution  from OrdinaryDiffEq.jl.\n\nsol = z((t0, tf), x0, p0)\nxf, pf = sol(tf)[1:2], sol(tf)[3:4]","category":"section"},{"location":"manual-flow-others.html#Trajectories","page":"From Hamiltonians and others","title":"Trajectories","text":"You can also compute trajectories from the control dynamics (x u) mapsto (v u) and a control law  t mapsto u(t).\n\nu(t) = 6-12t\nx = Flow((t, x) -> [x[2], u(t)]; autonomous=false) # the vector field depends on t\nx(t0, x0, tf)\n\nAgain, giving a tspan you get an output solution from OrdinaryDiffEq.jl.\n\nusing Plots\nsol = x((t0, tf), x0)\nplot(sol)\n\n","category":"section"},{"location":"manual-solution.html#manual-solution","page":"Solution characteristics","title":"The optimal control solution object: structure and usage","text":"In this manual, we'll first recall the main functionalities you can use when working with a solution of an optimal control problem (SOL). This includes essential operations like:\n\nPlotting a SOL: How to plot the optimal solution for your defined problem.\nPrinting a SOL: How to display a summary of your solution.\n\nAfter covering these core functionalities, we'll delve into the structure of a SOL. Since a SOL is structured as a Solution struct, we'll first explain how to access its underlying attributes. Following this, we'll shift our focus to the simple properties inherent to a SOL.\n\n\n\nContent\n\nMain functionalities\nSolution struct\nAttributes and properties\n\n","category":"section"},{"location":"manual-solution.html#manual-solution-main-functionalities","page":"Solution characteristics","title":"Main functionalities","text":"Let's define a basic optimal control problem.\n\nusing OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    x(t0) == x0\n    x(tf) == [0, 0]\n    ẋ(t)  == [v(t), u(t)]\n    0.5∫( u(t)^2 ) → min\nend\nnothing # hide\n\nWe can now solve the problem (for more details, visit the solve manual):\n\nusing NLPModelsIpopt\nsol = solve(ocp)\nnothing # hide\n\nnote: Note\nYou can export (or save) the solution in a Julia .jld2 data file and reload it later, and also export a discretised version of the solution in a more portable JSON format. Note that the optimal control problem is needed when loading a solution.See the two functions:import_ocp_solution,\nexport_ocp_solution.\n\nTo print sol, simply:\n\nsol\n\nFor complementary information, you can plot the solution:\n\nusing Plots\nplot(sol)\n\nnote: Note\nFor more details about plotting a solution, visit the plot manual.","category":"section"},{"location":"manual-solution.html#manual-solution-struct","page":"Solution characteristics","title":"Solution struct","text":"The solution sol is a Solution struct.\n\nEach field can be accessed directly (ocp.times, etc) but we recommend to use the sophisticated getters we provide: the state(sol::Solution) method does not return sol.state but a function of time that can be called at any time, not only on the grid time_grid.\n\n0.25 ∈ time_grid(sol)\n\nx = state(sol)\nx(0.25)","category":"section"},{"location":"manual-solution.html#manual-solution-attributes","page":"Solution characteristics","title":"Attributes and properties","text":"","category":"section"},{"location":"manual-solution.html#State,-costate,-control,-variable-and-objective-value","page":"Solution characteristics","title":"State, costate, control, variable and objective value","text":"You can access the values of the state, costate, control and variable by eponymous functions. The returned values are functions of time for the state, costate and control and a scalar or a vector for the variable.\n\nt = 0.25\nx = state(sol)\np = costate(sol)\nu = control(sol)\nnothing # hide\n\nSince the state is of dimension 2, evaluating x(t) returns a vector:\n\nx(t)\n\nIt is the same for the costate:\n\np(t)\n\nBut the control is one-dimensional:\n\nu(t)\n\nThere is no variable, hence, an empty vector is returned:\n\nv = variable(sol)\n\nThe objective value is accessed by:\n\nobjective(sol)","category":"section"},{"location":"manual-solution.html#Infos-from-the-solver","page":"Solution characteristics","title":"Infos from the solver","text":"The problem ocp is solved via a direct method (see solve manual for details). The solver stores data in sol, including the success of the optimization, the iteration count, the time grid used for discretisation, and other specific details within the solver_infos field.\n\ntime_grid(sol)\n\nconstraints_violation(sol)\n\ninfos(sol)\n\niterations(sol)\n\nmessage(sol)\n\nstatus(sol)\n\nsuccessful(sol)","category":"section"},{"location":"manual-solution.html#Dual-variables","page":"Solution characteristics","title":"Dual variables","text":"You can retrieved dual variables (or Lagrange multipliers) associated to labelled constraint. To illustrate this, we define a problem with constraints:\n\nocp = @def begin\n\n    tf ∈ R,             variable\n    t ∈ [0, tf],        time\n    x = (q, v) ∈ R²,    state\n    u ∈ R,              control\n\n    tf ≥ 0,             (eq_tf)\n    -1 ≤ u(t) ≤ 1,      (eq_u)\n    v(t) ≤ 0.75,        (eq_v)\n\n    x(0)  == [-1, 0],   (eq_x0)\n    q(tf) == 0\n    v(tf) == 0\n\n    ẋ(t) == [v(t), u(t)]\n\n    tf → min\n\nend\nsol = solve(ocp; display=false)\nnothing # hide\n\nDual variables corresponding to variable and boundary constraints are given as scalar or vectors.\n\ndual(sol, ocp, :eq_tf)\n\ndual(sol, ocp, :eq_x0)\n\nThe other type of constraints are associated to dual variables given as functions of time.\n\nμ_u = dual(sol, ocp, :eq_u)\nplot(time_grid(sol), μ_u)\n\nμ_v = dual(sol, ocp, :eq_v)\nplot(time_grid(sol), μ_v)\n\n","category":"section"},{"location":"manual-solution.html#CTModels.Solution-manual-solution","page":"Solution characteristics","title":"CTModels.Solution","text":"struct Solution{TimeGridModelType<:CTModels.AbstractTimeGridModel, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, CostateModelType<:Function, ObjectiveValueType<:Real, DualModelType<:CTModels.AbstractDualModel, SolverInfosType<:CTModels.AbstractSolverInfos, ModelType<:CTModels.AbstractModel} <: CTModels.AbstractSolution\n\nFields\n\ntime_grid::CTModels.AbstractTimeGridModel\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ncostate::Function\nobjective::Real\ndual::CTModels.AbstractDualModel\nsolver_infos::CTModels.AbstractSolverInfos\nmodel::CTModels.AbstractModel\n\n\n\n\n\n","category":"type"},{"location":"index.html#OptimalControl.jl","page":"Getting Started","title":"OptimalControl.jl","text":"The OptimalControl.jl package is the root package of the control-toolbox ecosystem. The control-toolbox ecosystem gathers Julia packages for mathematical control and applications. It aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods, both on CPU and GPU.","category":"section"},{"location":"index.html#Installation","page":"Getting Started","title":"Installation","text":"To install OptimalControl.jl, please open Julia's interactive session (known as REPL) and use the Julia package manager:\n\nusing Pkg\nPkg.add(\"OptimalControl\")\n\ntip: Tip\nIf you are new to Julia, please follow this guidelines.","category":"section"},{"location":"index.html#Basic-usage","page":"Getting Started","title":"Basic usage","text":"Let us model, solve and plot a simple optimal control problem.\n\nusing OptimalControl\nusing NLPModelsIpopt\nusing Plots\n\nocp = @def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(1) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    ∫( 0.5u(t)^2 ) → min\nend\n\nsol = solve(ocp)\nplot(sol)\n\nFor more details, see the basic example tutorial.  \nThe @def macro defines the problem. See the abstract syntax tutorial.  \nThe solve function has many options. See the solve tutorial.  \nThe plot function is flexible. See the plot tutorial.","category":"section"},{"location":"index.html#Citing-us","page":"Getting Started","title":"Citing us","text":"If you use OptimalControl.jl in your work, please cite us:\n\nCaillau, J.-B., Cots, O., Gergaud, J., Martinon, P., & Sed, S. OptimalControl.jl: a Julia package to model and solve optimal control problems with ODE's. doi.org/10.5281/zenodo.13336563\n\nor in bibtex format:\n\n@software{OptimalControl_jl,\nauthor = {Caillau, Jean-Baptiste and Cots, Olivier and Gergaud, Joseph and Martinon, Pierre and Sed, Sophia},\ndoi = {10.5281/zenodo.13336563},\nlicense = {[\"MIT\"]},\ntitle = {{OptimalControl.jl: a Julia package to model and solve optimal control problems with ODE's}},\nurl = {https://control-toolbox.org/OptimalControl.jl}\n}","category":"section"},{"location":"index.html#Contributing","page":"Getting Started","title":"Contributing","text":"If you think you found a bug or if you have a feature request / suggestion, feel free to open an issue. Before opening a pull request, please start an issue or a discussion on the topic. \n\nContributions are welcomed, check out how to contribute to a Github project. If it is your first contribution, you can also check this first contribution tutorial. You can find first good issues (if any 🙂) here. You may find other packages to contribute to at the control-toolbox organization.\n\nIf you want to ask a question, feel free to start a discussion here. This forum is for general discussion about this repository and the control-toolbox organization.\n\nnote: Note\nIf you want to add an application or a package to the control-toolbox ecosystem, please follow this set up tutorial.","category":"section"},{"location":"index.html#Reproducibility","page":"Getting Started","title":"Reproducibility","text":"_downloads_toml(\".\") # hide\n\n<details style=\"margin-bottom: 0.5em; margin-top: 1em;\"><summary>ℹ️ Version info</summary>\n\nversioninfo() # hide\n\n</details>\n\n<details style=\"margin-bottom: 0.5em;\"><summary>📦 Package status</summary>\n\nPkg.status() # hide\n\n</details>\n\n<details style=\"margin-bottom: 0.5em;\"><summary>📚 Complete manifest</summary>\n\nPkg.status(; mode = PKGMODE_MANIFEST) # hide\n\n</details>\n\n","category":"section"},{"location":"manual-ai-llm.html#manual-ai-llm","page":"Use AI","title":"Use AI","text":"Using now common models from AI, it is an elementary task to have such an agent learn the syntax of OptimalControl.jl DSL, then use the agent to translate standard math into this DSL. Here is a typical prompt, pointing to the DSL syntax:\n\nLearn the syntax of OptimalControl.jl DSL described at the link below \nto translate math into this DSL (Julia language): \nhttps://control-toolbox.org/OptimalControl.jl/stable/manual-abstract.html.\n\n<div style=\"display:flex; align-items:center; gap:8px; margin:16px 0;\">\n  <span style=\"font-weight:600; color:#666;\">Try with:</span>\n  <!-- ChatGPT -->\n  <a href=\"https://chat.openai.com/?q=Learn+the+syntax+of+OptimalControl.jl+DSL+described+at+the+link+below+to+translate+math+into+this+DSL+(Julia+language):+https://control-toolbox.org/OptimalControl.jl/stable/manual-abstract.html\" target=\"_blank\" rel=\"nofollow noreferrer noopener\" style=\"padding:4px 10px; background-color:#10A37F; color:#fff; border-radius:20px; font-size:13px; font-weight:600; text-decoration:none; transition:opacity 0.3s;\">\n    ChatGPT\n  </a>\n\n  <!-- Claude -->\n  <a href=\"https://claude.ai/new?q=Learn+the+syntax+of+OptimalControl.jl+DSL+described+at+the+link+below+to+translate+math+into+this+DSL+(Julia+language):+https://control-toolbox.org/OptimalControl.jl/stable/manual-abstract.html\" target=\"_blank\" rel=\"nofollow noreferrer noopener\" style=\"padding:4px 10px; background-color:#CC9B7A; color:#fff; border-radius:20px; font-size:13px; font-weight:600; text-decoration:none; transition:opacity 0.3s;\">\n    Claude\n  </a>\n\n  <!-- Perplexity -->\n  <a href=\"https://www.perplexity.ai/search/new?q=Learn+the+syntax+of+OptimalControl.jl+DSL+described+at+the+link+below+to+translate+math+into+this+DSL+(Julia+language):+https://control-toolbox.org/OptimalControl.jl/stable/manual-abstract.html\" target=\"_blank\" rel=\"nofollow noreferrer noopener\" style=\"padding:4px 10px; background-color:#9C4DE2; color:#fff; border-radius:20px; font-size:13px; font-weight:600; text-decoration:none; transition:opacity 0.3s;\">\n    Perplexity\n  </a>\n\n  <!-- Mistral AI -->\n  <a href=\"https://chat.mistral.ai/chat?q=Learn+the+syntax+of+OptimalControl.jl+DSL+described+at+the+link+below+to+translate+math+into+this+DSL+(Julia+language):+https://control-toolbox.org/OptimalControl.jl/stable/manual-abstract.html\" target=\"_blank\" rel=\"nofollow noreferrer noopener\" style=\"padding:4px 10px; background-color:#FF7000; color:#fff; border-radius:20px; font-size:13px; font-weight:600; text-decoration:none; transition:opacity 0.3s;\">\n    Mistral\n  </a>\n</div>\n\nNow, here is an extract of, e.g., claude.ai answer (Sonnet 4 model) to the request below:\n\nTranslate the problem below into this DSL:\n\n    minimise the final time tf \n    under the constraint q''(t) = u(t) \n    with -1 <= u(t) <= 1, \n    q(0) = 1, q'(0) = -2, q(tf) = 3, q'(tf) = 1, and q'(t) <= 1.\n\n@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    \n    # Variable constraint\n    tf ≥ 0\n    \n    # Control constraint\n    -1 ≤ u(t) ≤ 1\n    \n    # Initial conditions\n    q(0) == 1\n    v(0) == -2\n    \n    # Final conditions  \n    q(tf) == 3\n    v(tf) == 1\n    \n    # Path constraint\n    v(t) ≤ 1\n    \n    # Dynamics (q'' = u becomes first-order system)\n    ẋ(t) == [v(t), u(t)]\n    \n    # Objective: minimize final time\n    tf → min\nend\n\nThe answer is syntactically correct and can be updated, for instance according to the new request below:\n\nUse a form compatible with examodels.\n\n@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    \n    # Variable constraint\n    tf ≥ 0\n    \n    # Control constraint\n    -1 ≤ u(t) ≤ 1\n    \n    # Initial conditions\n    q(0) == 1\n    v(0) == -2\n    \n    # Final conditions  \n    q(tf) == 3\n    v(tf) == 1\n    \n    # Path constraint\n    v(t) ≤ 1\n    \n    # Dynamics (coordinate-wise for ExaModels)\n    ∂(q)(t) == v(t)\n    ∂(v)(t) == u(t)\n    \n    # Objective: minimize final time\n    tf → min\nend\n\nIt is also possible to feed the model directly with math definitions (here from a snapshot), as in the example below:\n\ntranslate the problem below into OptimalControl.jl DSL:\n\n<img src=\"./assets/rocket-def.png\" \n     alt=\"rocket-def\" \n     style=\"\n         display: block;\n         margin-left: 30px;\n         margin-right: 30px;\n         margin-top: 20px;\n         margin-bottom: 20px;\n         width: calc(100% - 60px);\n         height: auto;\n     \">\n\n\nThis prompt generates the syntactically correct code:\n\n# Parameters\nh₀ = 1\nv₀ = 0\nm₀ = 1\ng₀ = 1\nTc = 3.5\nhc = 500\nvc = 620\nmc = 0.6\n\n# Derived constants\nDc = 0.5 * vc * m₀ / g₀\nmf = mc * m₀\nc = 0.5 * sqrt(g₀ * h₀)\nTmax = Tc * m₀ * g₀\n\n# Auxiliary functions\nD(h, v) = Dc * v^2 * exp(-hc * (h - h₀) / h₀)\ng(h) = g₀ * (h₀ / h)^2\n\nrocket = @def begin\n    # Variable (free final time)\n    tf ∈ R, variable\n    \n    # Time\n    t ∈ [0, tf], time\n    \n    # State: (altitude, velocity, mass)\n    x = (h, v, m) ∈ R³, state\n    \n    # Control: thrust\n    T ∈ R, control\n    \n    # Dynamics\n    ∂(h)(t) == v(t)\n    ∂(v)(t) == (T(t) - D(h(t), v(t)) - m(t) * g(h(t))) / m(t)\n    ∂(m)(t) == -T(t) / c\n    \n    # Initial conditions\n    h(0) == h₀\n    v(0) == v₀\n    m(0) == m₀\n    \n    # Final condition\n    m(tf) == mf\n    \n    # State constraints\n    h(t) ≥ h₀\n    v(t) ≥ v₀\n    mf ≤ m(t) ≤ m₀\n    \n    # Control constraint\n    0 ≤ T(t) ≤ Tmax\n    \n    # Variable constraint\n    tf ≥ 0\n    \n    # Objective: maximize final altitude h(tf)\n    -h(tf) → min\nend\n\n","category":"section"}]
}
