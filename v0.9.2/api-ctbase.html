<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CTBase API · OptimalControl.jl</title><meta name="title" content="CTBase API · OptimalControl.jl"/><meta property="og:title" content="CTBase API · OptimalControl.jl"/><meta property="twitter:title" content="CTBase API · OptimalControl.jl"/><meta name="description" content="Documentation for OptimalControl.jl."/><meta property="og:description" content="Documentation for OptimalControl.jl."/><meta property="twitter:description" content="Documentation for OptimalControl.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://control-toolbox.org/assets/css/documentation.css" rel="stylesheet" type="text/css"/><script src="https://control-toolbox.org/assets/js/documentation.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">OptimalControl.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="tutorial-basic-example.html">Basic example</a></li><li><a class="tocitem" href="tutorial-basic-example-f.html">Basic example (functional version)</a></li><li><a class="tocitem" href="tutorial-double-integrator.html">Double integrator: time minimisation</a></li><li><a class="tocitem" href="tutorial-initial-guess.html">Initial guess options</a></li><li><a class="tocitem" href="tutorial-continuation.html">Discrete continuation</a></li><li><a class="tocitem" href="tutorial-nlp.html">NLP and DOCP manipulations</a></li><li><a class="tocitem" href="tutorial-plot.html">Plot a solution</a></li><li><a class="tocitem" href="tutorial-lqr-basic.html">LQR example</a></li><li><a class="tocitem" href="tutorial-iss.html">Indirect simple shooting</a></li><li><a class="tocitem" href="tutorial-goddard.html">Goddard problem</a></li></ul></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="application-batch.html">Batch processing</a></li><li><a class="tocitem" href="application-sail.html">Solar sail</a></li><li><a class="tocitem" href="application-surface-revolution.html">Catenoid solution</a></li></ul></li><li><a class="tocitem" href="fgs-2024.html">FGS 2024</a></li><li><a class="tocitem" href="juliacon2024.html">JuliaCon 2024</a></li><li><a class="tocitem" href="api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="api-ctbase.html">CTBase API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api-ctbase.html">CTBase API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/control-toolbox/OptimalControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/control-toolbox/OptimalControl.jl/blob/main/docs/src/api-ctbase.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CTBase-API"><a class="docs-heading-anchor" href="#CTBase-API">CTBase API</a><a id="CTBase-API-1"></a><a class="docs-heading-anchor-permalink" href="#CTBase-API" title="Permalink"></a></h1><p>This is just a dump of CTBase API documentation. For more details about <code>CTBase.jl</code> package, see the <a href="https://control-toolbox.org/CTBase.jl">documentation</a>.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="api-ctbase.html#CTBase.CTBase"><code>CTBase.CTBase</code></a></li><li><a href="api-ctbase.html#CTBase.AbstractHamiltonian"><code>CTBase.AbstractHamiltonian</code></a></li><li><a href="api-ctbase.html#CTBase.AmbiguousDescription"><code>CTBase.AmbiguousDescription</code></a></li><li><a href="api-ctbase.html#CTBase.Autonomous"><code>CTBase.Autonomous</code></a></li><li><a href="api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.BoundaryConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.BoundaryConstraint"><code>CTBase.BoundaryConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Function, Vararg{DataType}}"><code>CTBase.BoundaryConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Function}"><code>CTBase.BoundaryConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.CTCallback"><code>CTBase.CTCallback</code></a></li><li><a href="api-ctbase.html#CTBase.CTCallbacks"><code>CTBase.CTCallbacks</code></a></li><li><a href="api-ctbase.html#CTBase.CTException"><code>CTBase.CTException</code></a></li><li><a href="api-ctbase.html#CTBase.Control"><code>CTBase.Control</code></a></li><li><a href="api-ctbase.html#CTBase.ControlConstraint"><code>CTBase.ControlConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.ControlConstraint-Tuple{Function, Vararg{DataType}}"><code>CTBase.ControlConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.ControlConstraint-Tuple{Function}"><code>CTBase.ControlConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.ControlConstraint-Tuple{Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.ControlConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.ControlLaw-Tuple{Function}"><code>CTBase.ControlLaw</code></a></li><li><a href="api-ctbase.html#CTBase.ControlLaw"><code>CTBase.ControlLaw</code></a></li><li><a href="api-ctbase.html#CTBase.ControlLaw-Tuple{Function, Vararg{DataType}}"><code>CTBase.ControlLaw</code></a></li><li><a href="api-ctbase.html#CTBase.ControlLaw-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.ControlLaw</code></a></li><li><a href="api-ctbase.html#CTBase.Controls"><code>CTBase.Controls</code></a></li><li><a href="api-ctbase.html#CTBase.Costate"><code>CTBase.Costate</code></a></li><li><a href="api-ctbase.html#CTBase.Costates"><code>CTBase.Costates</code></a></li><li><a href="api-ctbase.html#CTBase.DCostate"><code>CTBase.DCostate</code></a></li><li><a href="api-ctbase.html#CTBase.DState"><code>CTBase.DState</code></a></li><li><a href="api-ctbase.html#CTBase.Description"><code>CTBase.Description</code></a></li><li><a href="api-ctbase.html#CTBase.Dimension"><code>CTBase.Dimension</code></a></li><li><a href="api-ctbase.html#CTBase.Dynamics-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.Dynamics</code></a></li><li><a href="api-ctbase.html#CTBase.Dynamics-Tuple{Function, Vararg{DataType}}"><code>CTBase.Dynamics</code></a></li><li><a href="api-ctbase.html#CTBase.Dynamics-Tuple{Function}"><code>CTBase.Dynamics</code></a></li><li><a href="api-ctbase.html#CTBase.Dynamics"><code>CTBase.Dynamics</code></a></li><li><a href="api-ctbase.html#CTBase.FeedbackControl"><code>CTBase.FeedbackControl</code></a></li><li><a href="api-ctbase.html#CTBase.FeedbackControl-Tuple{Function}"><code>CTBase.FeedbackControl</code></a></li><li><a href="api-ctbase.html#CTBase.FeedbackControl-Tuple{Function, Vararg{DataType}}"><code>CTBase.FeedbackControl</code></a></li><li><a href="api-ctbase.html#CTBase.FeedbackControl-Tuple{Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.FeedbackControl</code></a></li><li><a href="api-ctbase.html#CTBase.Fixed"><code>CTBase.Fixed</code></a></li><li><a href="api-ctbase.html#CTBase.Hamiltonian-Tuple{Function, Vararg{DataType}}"><code>CTBase.Hamiltonian</code></a></li><li><a href="api-ctbase.html#CTBase.Hamiltonian-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.Hamiltonian</code></a></li><li><a href="api-ctbase.html#CTBase.Hamiltonian"><code>CTBase.Hamiltonian</code></a></li><li><a href="api-ctbase.html#CTBase.Hamiltonian-Tuple{Function}"><code>CTBase.Hamiltonian</code></a></li><li><a href="api-ctbase.html#CTBase.HamiltonianLift-Tuple{Function, Vararg{DataType}}"><code>CTBase.HamiltonianLift</code></a></li><li><a href="api-ctbase.html#CTBase.HamiltonianLift-Tuple{Function}"><code>CTBase.HamiltonianLift</code></a></li><li><a href="api-ctbase.html#CTBase.HamiltonianLift"><code>CTBase.HamiltonianLift</code></a></li><li><a href="api-ctbase.html#CTBase.HamiltonianLift-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.HamiltonianLift</code></a></li><li><a href="api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Function}"><code>CTBase.HamiltonianVectorField</code></a></li><li><a href="api-ctbase.html#CTBase.HamiltonianVectorField"><code>CTBase.HamiltonianVectorField</code></a></li><li><a href="api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.HamiltonianVectorField</code></a></li><li><a href="api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Function, Vararg{DataType}}"><code>CTBase.HamiltonianVectorField</code></a></li><li><a href="api-ctbase.html#CTBase.IncorrectArgument"><code>CTBase.IncorrectArgument</code></a></li><li><a href="api-ctbase.html#CTBase.IncorrectMethod"><code>CTBase.IncorrectMethod</code></a></li><li><a href="api-ctbase.html#CTBase.IncorrectOutput"><code>CTBase.IncorrectOutput</code></a></li><li><a href="api-ctbase.html#CTBase.Index"><code>CTBase.Index</code></a></li><li><a href="api-ctbase.html#CTBase.Lagrange-Tuple{Function}"><code>CTBase.Lagrange</code></a></li><li><a href="api-ctbase.html#CTBase.Lagrange-Tuple{Function, Vararg{DataType}}"><code>CTBase.Lagrange</code></a></li><li><a href="api-ctbase.html#CTBase.Lagrange-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.Lagrange</code></a></li><li><a href="api-ctbase.html#CTBase.Lagrange"><code>CTBase.Lagrange</code></a></li><li><a href="api-ctbase.html#CTBase.Mayer-Tuple{Function, Vararg{DataType}}"><code>CTBase.Mayer</code></a></li><li><a href="api-ctbase.html#CTBase.Mayer-Tuple{Function}"><code>CTBase.Mayer</code></a></li><li><a href="api-ctbase.html#CTBase.Mayer"><code>CTBase.Mayer</code></a></li><li><a href="api-ctbase.html#CTBase.Mayer-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.Mayer</code></a></li><li><a href="api-ctbase.html#CTBase.MixedConstraint"><code>CTBase.MixedConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.MixedConstraint-Tuple{Function, Vararg{DataType}}"><code>CTBase.MixedConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.MixedConstraint-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.MixedConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.MixedConstraint-Tuple{Function}"><code>CTBase.MixedConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.Multiplier-Tuple{Function}"><code>CTBase.Multiplier</code></a></li><li><a href="api-ctbase.html#CTBase.Multiplier-Tuple{Function, Vararg{DataType}}"><code>CTBase.Multiplier</code></a></li><li><a href="api-ctbase.html#CTBase.Multiplier"><code>CTBase.Multiplier</code></a></li><li><a href="api-ctbase.html#CTBase.Multiplier-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.Multiplier</code></a></li><li><a href="api-ctbase.html#CTBase.NonAutonomous"><code>CTBase.NonAutonomous</code></a></li><li><a href="api-ctbase.html#CTBase.NonFixed"><code>CTBase.NonFixed</code></a></li><li><a href="api-ctbase.html#CTBase.NotImplemented"><code>CTBase.NotImplemented</code></a></li><li><a href="api-ctbase.html#CTBase.OptimalControlInit"><code>CTBase.OptimalControlInit</code></a></li><li><a href="api-ctbase.html#CTBase.OptimalControlModel"><code>CTBase.OptimalControlModel</code></a></li><li><a href="api-ctbase.html#CTBase.OptimalControlSolution"><code>CTBase.OptimalControlSolution</code></a></li><li><a href="api-ctbase.html#CTBase.ParsingError"><code>CTBase.ParsingError</code></a></li><li><a href="api-ctbase.html#CTBase.PrintCallback"><code>CTBase.PrintCallback</code></a></li><li><a href="api-ctbase.html#CTBase.PrintCallback-Tuple"><code>CTBase.PrintCallback</code></a></li><li><a href="api-ctbase.html#CTBase.State"><code>CTBase.State</code></a></li><li><a href="api-ctbase.html#CTBase.StateConstraint"><code>CTBase.StateConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.StateConstraint-Tuple{Function}"><code>CTBase.StateConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.StateConstraint-Tuple{Function, Vararg{DataType}}"><code>CTBase.StateConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.StateConstraint-Tuple{Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.StateConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.States"><code>CTBase.States</code></a></li><li><a href="api-ctbase.html#CTBase.StopCallback-Tuple"><code>CTBase.StopCallback</code></a></li><li><a href="api-ctbase.html#CTBase.StopCallback"><code>CTBase.StopCallback</code></a></li><li><a href="api-ctbase.html#CTBase.Time"><code>CTBase.Time</code></a></li><li><a href="api-ctbase.html#CTBase.TimeDependence"><code>CTBase.TimeDependence</code></a></li><li><a href="api-ctbase.html#CTBase.Times"><code>CTBase.Times</code></a></li><li><a href="api-ctbase.html#CTBase.TimesDisc"><code>CTBase.TimesDisc</code></a></li><li><a href="api-ctbase.html#CTBase.UnauthorizedCall"><code>CTBase.UnauthorizedCall</code></a></li><li><a href="api-ctbase.html#CTBase.Variable"><code>CTBase.Variable</code></a></li><li><a href="api-ctbase.html#CTBase.VariableConstraint-Tuple{Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.VariableConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.VariableConstraint"><code>CTBase.VariableConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.VariableDependence"><code>CTBase.VariableDependence</code></a></li><li><a href="api-ctbase.html#CTBase.VectorField-Tuple{Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.VectorField</code></a></li><li><a href="api-ctbase.html#CTBase.VectorField-Tuple{Function, Vararg{DataType}}"><code>CTBase.VectorField</code></a></li><li><a href="api-ctbase.html#CTBase.VectorField-Tuple{Function}"><code>CTBase.VectorField</code></a></li><li><a href="api-ctbase.html#CTBase.VectorField"><code>CTBase.VectorField</code></a></li><li><a href="api-ctbase.html#CTBase.ctNumber"><code>CTBase.ctNumber</code></a></li><li><a href="api-ctbase.html#CTBase.ctVector"><code>CTBase.ctVector</code></a></li><li><a href="api-ctbase.html#CTBase.:⋅-Tuple{Function, Function}"><code>CTBase.:⋅</code></a></li><li><a href="api-ctbase.html#CTBase.:⋅-Tuple{VectorField{Autonomous, &lt;:VariableDependence}, Function}"><code>CTBase.:⋅</code></a></li><li><a href="api-ctbase.html#CTBase.:⋅-Tuple{VectorField{NonAutonomous, &lt;:VariableDependence}, Function}"><code>CTBase.:⋅</code></a></li><li><a href="api-ctbase.html#CTBase.Lie-Tuple{Function, Function, Vararg{DataType}}"><code>CTBase.Lie</code></a></li><li><a href="api-ctbase.html#CTBase.Lie-Tuple{VectorField, Function}"><code>CTBase.Lie</code></a></li><li><a href="api-ctbase.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V&lt;:VariableDependence"><code>CTBase.Lie</code></a></li><li><a href="api-ctbase.html#CTBase.Lie-Tuple{Function, Function}"><code>CTBase.Lie</code></a></li><li><a href="api-ctbase.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V&lt;:VariableDependence"><code>CTBase.Lie</code></a></li><li><a href="api-ctbase.html#CTBase.Lift-Tuple{VectorField}"><code>CTBase.Lift</code></a></li><li><a href="api-ctbase.html#CTBase.Lift-Tuple{Function, Vararg{DataType}}"><code>CTBase.Lift</code></a></li><li><a href="api-ctbase.html#CTBase.Lift-Tuple{Function}"><code>CTBase.Lift</code></a></li><li><a href="api-ctbase.html#CTBase.Model-Tuple{Vararg{DataType}}"><code>CTBase.Model</code></a></li><li><a href="api-ctbase.html#CTBase.Model-Tuple{}"><code>CTBase.Model</code></a></li><li><a href="api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.Poisson</code></a></li><li><a href="api-ctbase.html#CTBase.Poisson-Tuple{Function, Function, Vararg{DataType}}"><code>CTBase.Poisson</code></a></li><li><a href="api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{Function, AbstractHamiltonian{T, V}}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.Poisson</code></a></li><li><a href="api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{Autonomous, V}, AbstractHamiltonian{Autonomous, V}}} where V&lt;:VariableDependence"><code>CTBase.Poisson</code></a></li><li><a href="api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{AbstractHamiltonian{T, V}, Function}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.Poisson</code></a></li><li><a href="api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{NonAutonomous, V}, AbstractHamiltonian{NonAutonomous, V}}} where V&lt;:VariableDependence"><code>CTBase.Poisson</code></a></li><li><a href="api-ctbase.html#CTBase.Poisson-Tuple{Function, Function}"><code>CTBase.Poisson</code></a></li><li><a href="api-ctbase.html#CTBase.__OCPModel-Tuple"><code>CTBase.__OCPModel</code></a></li><li><a href="api-ctbase.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}"><code>CTBase.add</code></a></li><li><a href="api-ctbase.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}"><code>CTBase.add</code></a></li><li><a href="api-ctbase.html#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.constraint</code></a></li><li><a href="api-ctbase.html#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.constraint!</code></a></li><li><a href="api-ctbase.html#CTBase.constraint_type-NTuple{7, Any}"><code>CTBase.constraint_type</code></a></li><li><a href="api-ctbase.html#CTBase.constraints_labels-Tuple{OptimalControlModel}"><code>CTBase.constraints_labels</code></a></li><li><a href="api-ctbase.html#CTBase.control!"><code>CTBase.control!</code></a></li><li><a href="api-ctbase.html#CTBase.ct_repl-Tuple{}"><code>CTBase.ct_repl</code></a></li><li><a href="api-ctbase.html#CTBase.ct_repl_update_model-Tuple{Expr}"><code>CTBase.ct_repl_update_model</code></a></li><li><a href="api-ctbase.html#CTBase.ctgradient-Tuple{Function, Any}"><code>CTBase.ctgradient</code></a></li><li><a href="api-ctbase.html#CTBase.ctgradient-Tuple{VectorField, Any}"><code>CTBase.ctgradient</code></a></li><li><a href="api-ctbase.html#CTBase.ctgradient-Tuple{Function, Real}"><code>CTBase.ctgradient</code></a></li><li><a href="api-ctbase.html#CTBase.ctindices-Tuple{Integer}"><code>CTBase.ctindices</code></a></li><li><a href="api-ctbase.html#CTBase.ctinterpolate-Tuple{Any, Any}"><code>CTBase.ctinterpolate</code></a></li><li><a href="api-ctbase.html#CTBase.ctjacobian-Tuple{Function, Real}"><code>CTBase.ctjacobian</code></a></li><li><a href="api-ctbase.html#CTBase.ctjacobian-Tuple{VectorField, Any}"><code>CTBase.ctjacobian</code></a></li><li><a href="api-ctbase.html#CTBase.ctjacobian-Tuple{Function, Any}"><code>CTBase.ctjacobian</code></a></li><li><a href="api-ctbase.html#CTBase.ctupperscripts-Tuple{Integer}"><code>CTBase.ctupperscripts</code></a></li><li><a href="api-ctbase.html#CTBase.dim_boundary_constraints-Tuple{OptimalControlModel}"><code>CTBase.dim_boundary_constraints</code></a></li><li><a href="api-ctbase.html#CTBase.dim_control_constraints-Tuple{OptimalControlModel}"><code>CTBase.dim_control_constraints</code></a></li><li><a href="api-ctbase.html#CTBase.dim_control_range-Tuple{OptimalControlModel}"><code>CTBase.dim_control_range</code></a></li><li><a href="api-ctbase.html#CTBase.dim_mixed_constraints-Tuple{OptimalControlModel}"><code>CTBase.dim_mixed_constraints</code></a></li><li><a href="api-ctbase.html#CTBase.dim_path_constraints-Tuple{OptimalControlModel}"><code>CTBase.dim_path_constraints</code></a></li><li><a href="api-ctbase.html#CTBase.dim_state_constraints-Tuple{OptimalControlModel}"><code>CTBase.dim_state_constraints</code></a></li><li><a href="api-ctbase.html#CTBase.dim_state_range-Tuple{OptimalControlModel}"><code>CTBase.dim_state_range</code></a></li><li><a href="api-ctbase.html#CTBase.dim_variable_constraints-Tuple{OptimalControlModel}"><code>CTBase.dim_variable_constraints</code></a></li><li><a href="api-ctbase.html#CTBase.dim_variable_range-Tuple{OptimalControlModel}"><code>CTBase.dim_variable_range</code></a></li><li><a href="api-ctbase.html#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.dynamics!</code></a></li><li><a href="api-ctbase.html#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}"><code>CTBase.getFullDescription</code></a></li><li><a href="api-ctbase.html#CTBase.get_priority_print_callbacks-Tuple{Tuple{Vararg{CTCallback}}}"><code>CTBase.get_priority_print_callbacks</code></a></li><li><a href="api-ctbase.html#CTBase.get_priority_stop_callbacks-Tuple{Tuple{Vararg{CTCallback}}}"><code>CTBase.get_priority_stop_callbacks</code></a></li><li><a href="api-ctbase.html#CTBase.has_free_final_time-Tuple{OptimalControlModel}"><code>CTBase.has_free_final_time</code></a></li><li><a href="api-ctbase.html#CTBase.has_free_initial_time-Tuple{OptimalControlModel}"><code>CTBase.has_free_initial_time</code></a></li><li><a href="api-ctbase.html#CTBase.has_lagrange_cost-Tuple{OptimalControlModel}"><code>CTBase.has_lagrange_cost</code></a></li><li><a href="api-ctbase.html#CTBase.has_mayer_cost-Tuple{OptimalControlModel}"><code>CTBase.has_mayer_cost</code></a></li><li><a href="api-ctbase.html#CTBase.is_autonomous-Tuple{OptimalControlModel{Autonomous}}"><code>CTBase.is_autonomous</code></a></li><li><a href="api-ctbase.html#CTBase.is_fixed-Tuple{OptimalControlModel{&lt;:TimeDependence, Fixed}}"><code>CTBase.is_fixed</code></a></li><li><a href="api-ctbase.html#CTBase.is_max-Tuple{OptimalControlModel}"><code>CTBase.is_max</code></a></li><li><a href="api-ctbase.html#CTBase.is_min-Tuple{OptimalControlModel}"><code>CTBase.is_min</code></a></li><li><a href="api-ctbase.html#CTBase.is_time_dependent-Tuple{OptimalControlModel}"><code>CTBase.is_time_dependent</code></a></li><li><a href="api-ctbase.html#CTBase.is_time_independent-Tuple{OptimalControlModel}"><code>CTBase.is_time_independent</code></a></li><li><a href="api-ctbase.html#CTBase.is_variable_dependent-Tuple{OptimalControlModel}"><code>CTBase.is_variable_dependent</code></a></li><li><a href="api-ctbase.html#CTBase.is_variable_independent-Tuple{OptimalControlModel}"><code>CTBase.is_variable_independent</code></a></li><li><a href="api-ctbase.html#CTBase.nlp_constraints!-Tuple{OptimalControlModel}"><code>CTBase.nlp_constraints!</code></a></li><li><a href="api-ctbase.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.objective!</code></a></li><li><a href="api-ctbase.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.objective!</code></a></li><li><a href="api-ctbase.html#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}"><code>CTBase.remove_constraint!</code></a></li><li><a href="api-ctbase.html#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}"><code>CTBase.replace_call</code></a></li><li><a href="api-ctbase.html#CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}"><code>CTBase.replace_call</code></a></li><li><a href="api-ctbase.html#CTBase.state!"><code>CTBase.state!</code></a></li><li><a href="api-ctbase.html#CTBase.time!-Union{Tuple{OptimalControlModel{&lt;:TimeDependence, VT}}, Tuple{VT}} where VT"><code>CTBase.time!</code></a></li><li><a href="api-ctbase.html#CTBase.variable!"><code>CTBase.variable!</code></a></li><li><a href="api-ctbase.html#CTBase.∂ₜ-Tuple{Any}"><code>CTBase.∂ₜ</code></a></li><li><a href="api-ctbase.html#CTBase.@Lie-Tuple{Expr}"><code>CTBase.@Lie</code></a></li><li><a href="api-ctbase.html#CTBase.@Lie-Tuple{Expr, Any, Any}"><code>CTBase.@Lie</code></a></li><li><a href="api-ctbase.html#CTBase.@Lie-Tuple{Expr, Any}"><code>CTBase.@Lie</code></a></li><li><a href="api-ctbase.html#CTBase.@def"><code>CTBase.@def</code></a></li></ul><h2 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.CTBase" href="#CTBase.CTBase"><code>CTBase.CTBase</code></a> — <span class="docstring-category">Module</span></header><section><div><p><a href="api-ctbase.html#CTBase.CTBase"><code>CTBase</code></a> module.</p><p>Lists all the imported modules and packages:</p><ul><li><code>Base</code></li><li><code>Core</code></li><li><code>DataStructures</code></li><li><code>DocStringExtensions</code></li><li><code>LinearAlgebra</code></li><li><code>MLStyle</code></li><li><code>Parameters</code></li><li><code>PrettyTables</code></li><li><code>Printf</code></li><li><code>ReplMaker</code></li><li><code>Unicode</code></li></ul><p>List of all the exported names:</p><ul><li><a href="api-ctbase.html#CTBase.AbstractHamiltonian"><code>AbstractHamiltonian</code></a></li><li><a href="api-ctbase.html#CTBase.AmbiguousDescription"><code>AmbiguousDescription</code></a></li><li><a href="api-ctbase.html#CTBase.Autonomous"><code>Autonomous</code></a></li><li><a href="api-ctbase.html#CTBase.BoundaryConstraint"><code>BoundaryConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.CTCallback"><code>CTCallback</code></a></li><li><a href="api-ctbase.html#CTBase.CTCallbacks"><code>CTCallbacks</code></a></li><li><a href="api-ctbase.html#CTBase.CTException"><code>CTException</code></a></li><li><a href="api-ctbase.html#CTBase.Control"><code>Control</code></a></li><li><a href="api-ctbase.html#CTBase.ControlConstraint"><code>ControlConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.ControlLaw"><code>ControlLaw</code></a></li><li><a href="api-ctbase.html#CTBase.Controls"><code>Controls</code></a></li><li><a href="api-ctbase.html#CTBase.Costate"><code>Costate</code></a></li><li><a href="api-ctbase.html#CTBase.Costates"><code>Costates</code></a></li><li><a href="api-ctbase.html#CTBase.DCostate"><code>DCostate</code></a></li><li><a href="api-ctbase.html#CTBase.DState"><code>DState</code></a></li><li><a href="api-ctbase.html#CTBase.Description"><code>Description</code></a></li><li><a href="api-ctbase.html#CTBase.Dimension"><code>Dimension</code></a></li><li><a href="api-ctbase.html#CTBase.Dynamics"><code>Dynamics</code></a></li><li><a href="api-ctbase.html#CTBase.FeedbackControl"><code>FeedbackControl</code></a></li><li><a href="api-ctbase.html#CTBase.Fixed"><code>Fixed</code></a></li><li><a href="api-ctbase.html#CTBase.Hamiltonian"><code>Hamiltonian</code></a></li><li><a href="api-ctbase.html#CTBase.HamiltonianLift"><code>HamiltonianLift</code></a></li><li><a href="api-ctbase.html#CTBase.HamiltonianVectorField"><code>HamiltonianVectorField</code></a></li><li><a href="api-ctbase.html#CTBase.IncorrectArgument"><code>IncorrectArgument</code></a></li><li><a href="api-ctbase.html#CTBase.IncorrectMethod"><code>IncorrectMethod</code></a></li><li><a href="api-ctbase.html#CTBase.IncorrectOutput"><code>IncorrectOutput</code></a></li><li><a href="api-ctbase.html#CTBase.Index"><code>Index</code></a></li><li><a href="api-ctbase.html#CTBase.Lagrange"><code>Lagrange</code></a></li><li><a href="api-ctbase.html#CTBase.@Lie-Tuple{Expr, Any, Any}"><code>@Lie</code></a></li><li><a href="api-ctbase.html#CTBase.Lie-Tuple{Function, Function, Vararg{DataType}}"><code>Lie</code></a></li><li><a href="api-ctbase.html#CTBase.Lift-Tuple{Function, Vararg{DataType}}"><code>Lift</code></a></li><li><a href="api-ctbase.html#CTBase.Mayer"><code>Mayer</code></a></li><li><a href="api-ctbase.html#CTBase.MixedConstraint"><code>MixedConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.Model-Tuple{Vararg{DataType}}"><code>Model</code></a></li><li><a href="api-ctbase.html#CTBase.Multiplier"><code>Multiplier</code></a></li><li><a href="api-ctbase.html#CTBase.NonAutonomous"><code>NonAutonomous</code></a></li><li><a href="api-ctbase.html#CTBase.NonFixed"><code>NonFixed</code></a></li><li><a href="api-ctbase.html#CTBase.NotImplemented"><code>NotImplemented</code></a></li><li><a href="api-ctbase.html#CTBase.OptimalControlInit"><code>OptimalControlInit</code></a></li><li><a href="api-ctbase.html#CTBase.OptimalControlModel"><code>OptimalControlModel</code></a></li><li><a href="api-ctbase.html#CTBase.OptimalControlSolution"><code>OptimalControlSolution</code></a></li><li><a href="api-ctbase.html#CTBase.ParsingError"><code>ParsingError</code></a></li><li><a href="api-ctbase.html#CTBase.Poisson-Tuple{Function, Function, Vararg{DataType}}"><code>Poisson</code></a></li><li><a href="api-ctbase.html#CTBase.PrintCallback"><code>PrintCallback</code></a></li><li><a href="api-ctbase.html#CTBase.State"><code>State</code></a></li><li><a href="api-ctbase.html#CTBase.StateConstraint"><code>StateConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.States"><code>States</code></a></li><li><a href="api-ctbase.html#CTBase.StopCallback"><code>StopCallback</code></a></li><li><a href="api-ctbase.html#CTBase.Time"><code>Time</code></a></li><li><a href="api-ctbase.html#CTBase.TimeDependence"><code>TimeDependence</code></a></li><li><a href="api-ctbase.html#CTBase.Times"><code>Times</code></a></li><li><a href="api-ctbase.html#CTBase.TimesDisc"><code>TimesDisc</code></a></li><li><a href="api-ctbase.html#CTBase.UnauthorizedCall"><code>UnauthorizedCall</code></a></li><li><a href="api-ctbase.html#CTBase.Variable"><code>Variable</code></a></li><li><a href="api-ctbase.html#CTBase.VariableConstraint"><code>VariableConstraint</code></a></li><li><a href="api-ctbase.html#CTBase.VariableDependence"><code>VariableDependence</code></a></li><li><a href="api-ctbase.html#CTBase.VectorField"><code>VectorField</code></a></li><li><a href="api-ctbase.html#CTBase.__OCPModel-Tuple"><code>__OCPModel</code></a></li><li><a href="api-ctbase.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}"><code>add</code></a></li><li><a href="api-ctbase.html#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>constraint</code></a></li><li><a href="api-ctbase.html#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>constraint!</code></a></li><li><a href="api-ctbase.html#CTBase.constraint_type-NTuple{7, Any}"><code>constraint_type</code></a></li><li><a href="api-ctbase.html#CTBase.constraints_labels-Tuple{OptimalControlModel}"><code>constraints_labels</code></a></li><li><a href="api-ctbase.html#CTBase.control!"><code>control!</code></a></li><li><a href="api-ctbase.html#CTBase.ctNumber"><code>ctNumber</code></a></li><li><a href="api-ctbase.html#CTBase.ctVector"><code>ctVector</code></a></li><li><a href="api-ctbase.html#CTBase.ct_repl-Tuple{}"><code>ct_repl</code></a></li><li><a href="api-ctbase.html#CTBase.ct_repl_update_model-Tuple{Expr}"><code>ct_repl_update_model</code></a></li><li><a href="api-ctbase.html#CTBase.ctgradient-Tuple{Function, Any}"><code>ctgradient</code></a></li><li><a href="api-ctbase.html#CTBase.ctindices-Tuple{Integer}"><code>ctindices</code></a></li><li><a href="api-ctbase.html#CTBase.ctinterpolate-Tuple{Any, Any}"><code>ctinterpolate</code></a></li><li><a href="api-ctbase.html#CTBase.ctjacobian-Tuple{Function, Any}"><code>ctjacobian</code></a></li><li><a href="api-ctbase.html#CTBase.ctupperscripts-Tuple{Integer}"><code>ctupperscripts</code></a></li><li><a href="api-ctbase.html#CTBase.@def"><code>@def</code></a></li><li><a href="api-ctbase.html#CTBase.dim_boundary_constraints-Tuple{OptimalControlModel}"><code>dim_boundary_constraints</code></a></li><li><a href="api-ctbase.html#CTBase.dim_control_constraints-Tuple{OptimalControlModel}"><code>dim_control_constraints</code></a></li><li><a href="api-ctbase.html#CTBase.dim_control_range-Tuple{OptimalControlModel}"><code>dim_control_range</code></a></li><li><a href="api-ctbase.html#CTBase.dim_mixed_constraints-Tuple{OptimalControlModel}"><code>dim_mixed_constraints</code></a></li><li><a href="api-ctbase.html#CTBase.dim_path_constraints-Tuple{OptimalControlModel}"><code>dim_path_constraints</code></a></li><li><a href="api-ctbase.html#CTBase.dim_state_constraints-Tuple{OptimalControlModel}"><code>dim_state_constraints</code></a></li><li><a href="api-ctbase.html#CTBase.dim_state_range-Tuple{OptimalControlModel}"><code>dim_state_range</code></a></li><li><a href="api-ctbase.html#CTBase.dim_variable_constraints-Tuple{OptimalControlModel}"><code>dim_variable_constraints</code></a></li><li><a href="api-ctbase.html#CTBase.dim_variable_range-Tuple{OptimalControlModel}"><code>dim_variable_range</code></a></li><li><a href="api-ctbase.html#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>dynamics!</code></a></li><li><a href="api-ctbase.html#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}"><code>getFullDescription</code></a></li><li><a href="api-ctbase.html#CTBase.get_priority_print_callbacks-Tuple{Tuple{Vararg{CTCallback}}}"><code>get_priority_print_callbacks</code></a></li><li><a href="api-ctbase.html#CTBase.get_priority_stop_callbacks-Tuple{Tuple{Vararg{CTCallback}}}"><code>get_priority_stop_callbacks</code></a></li><li><a href="api-ctbase.html#CTBase.has_free_final_time-Tuple{OptimalControlModel}"><code>has_free_final_time</code></a></li><li><a href="api-ctbase.html#CTBase.has_free_initial_time-Tuple{OptimalControlModel}"><code>has_free_initial_time</code></a></li><li><a href="api-ctbase.html#CTBase.has_lagrange_cost-Tuple{OptimalControlModel}"><code>has_lagrange_cost</code></a></li><li><a href="api-ctbase.html#CTBase.has_mayer_cost-Tuple{OptimalControlModel}"><code>has_mayer_cost</code></a></li><li><a href="api-ctbase.html#CTBase.is_autonomous-Tuple{OptimalControlModel{Autonomous}}"><code>is_autonomous</code></a></li><li><a href="api-ctbase.html#CTBase.is_fixed-Tuple{OptimalControlModel{&lt;:TimeDependence, Fixed}}"><code>is_fixed</code></a></li><li><a href="api-ctbase.html#CTBase.is_max-Tuple{OptimalControlModel}"><code>is_max</code></a></li><li><a href="api-ctbase.html#CTBase.is_min-Tuple{OptimalControlModel}"><code>is_min</code></a></li><li><a href="api-ctbase.html#CTBase.is_time_dependent-Tuple{OptimalControlModel}"><code>is_time_dependent</code></a></li><li><a href="api-ctbase.html#CTBase.is_time_independent-Tuple{OptimalControlModel}"><code>is_time_independent</code></a></li><li><a href="api-ctbase.html#CTBase.is_variable_dependent-Tuple{OptimalControlModel}"><code>is_variable_dependent</code></a></li><li><a href="api-ctbase.html#CTBase.is_variable_independent-Tuple{OptimalControlModel}"><code>is_variable_independent</code></a></li><li><a href="api-ctbase.html#CTBase.nlp_constraints!-Tuple{OptimalControlModel}"><code>nlp_constraints!</code></a></li><li><a href="api-ctbase.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>objective!</code></a></li><li><a href="api-ctbase.html#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}"><code>remove_constraint!</code></a></li><li><a href="api-ctbase.html#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}"><code>replace_call</code></a></li><li><a href="@ref"><code>set_AD_backend</code></a></li><li><a href="api-ctbase.html#CTBase.state!"><code>state!</code></a></li><li><a href="api-ctbase.html#CTBase.time!-Union{Tuple{OptimalControlModel{&lt;:TimeDependence, VT}}, Tuple{VT}} where VT"><code>time!</code></a></li><li><a href="api-ctbase.html#CTBase.variable!"><code>variable!</code></a></li><li><a href="api-ctbase.html#CTBase.∂ₜ-Tuple{Any}"><code>∂ₜ</code></a></li><li><a href="api-ctbase.html#CTBase.:⋅-Tuple{Function, Function}"><code>⋅</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Control" href="#CTBase.Control"><code>CTBase.Control</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for a control in Rᵐ.</p><pre><code class="language- hljs">julia&gt; const Control = ctVector</code></pre><p>See also: <a href="api-ctbase.html#CTBase.ctVector"><code>ctVector</code></a>, <a href="api-ctbase.html#CTBase.State"><code>State</code></a>, <a href="api-ctbase.html#CTBase.Costate"><code>Costate</code></a>, <a href="api-ctbase.html#CTBase.Variable"><code>Variable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L108-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Costate" href="#CTBase.Costate"><code>CTBase.Costate</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for a costate in Rⁿ.</p><pre><code class="language- hljs">julia&gt; const Costate = ctVector</code></pre><p>See also: <a href="api-ctbase.html#CTBase.ctVector"><code>ctVector</code></a>, <a href="api-ctbase.html#CTBase.State"><code>State</code></a>, <a href="api-ctbase.html#CTBase.Control"><code>Control</code></a>, <a href="api-ctbase.html#CTBase.Variable"><code>Variable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L97-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.DCostate" href="#CTBase.DCostate"><code>CTBase.DCostate</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for a tangent vector to the costate space.</p><pre><code class="language- hljs">julia&gt; const DCostate = ctVector</code></pre><p>See also: <a href="api-ctbase.html#CTBase.ctVector"><code>ctVector</code></a>, <a href="api-ctbase.html#CTBase.DState"><code>DState</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L185-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.DState" href="#CTBase.DState"><code>CTBase.DState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for a tangent vector to the state space.</p><pre><code class="language- hljs">julia&gt; const DState = ctVector</code></pre><p>See also: <a href="api-ctbase.html#CTBase.ctVector"><code>ctVector</code></a>, <a href="api-ctbase.html#CTBase.DCostate"><code>DCostate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L174-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.State" href="#CTBase.State"><code>CTBase.State</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for a state in Rⁿ.</p><pre><code class="language- hljs">julia&gt; const State = ctVector</code></pre><p>See also: <a href="api-ctbase.html#CTBase.ctVector"><code>ctVector</code></a>, <a href="api-ctbase.html#CTBase.Costate"><code>Costate</code></a>, <a href="api-ctbase.html#CTBase.Control"><code>Control</code></a>, <a href="api-ctbase.html#CTBase.Variable"><code>Variable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L86-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.TimesDisc" href="#CTBase.TimesDisc"><code>CTBase.TimesDisc</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for a grid of times. This is used to define a discretization of time interval given to solvers.</p><pre><code class="language- hljs">julia&gt; const TimesDisc = Union{Times, StepRangeLen}</code></pre><p>See also: <a href="api-ctbase.html#CTBase.Time"><code>Time</code></a>, <a href="api-ctbase.html#CTBase.Times"><code>Times</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L75-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Variable" href="#CTBase.Variable"><code>CTBase.Variable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for a variable in Rᵏ.</p><pre><code class="language- hljs">julia&gt; const Variable = ctVector</code></pre><p>See also: <a href="api-ctbase.html#CTBase.ctVector"><code>ctVector</code></a>, <a href="api-ctbase.html#CTBase.State"><code>State</code></a>, <a href="api-ctbase.html#CTBase.Costate"><code>Costate</code></a>, <a href="api-ctbase.html#CTBase.Control"><code>Control</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L119-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ctVector" href="#CTBase.ctVector"><code>CTBase.ctVector</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for a vector of real numbers.</p><pre><code class="language- hljs">julia&gt; const ctVector = Union{ctNumber, AbstractVector{&lt;:ctNumber}}</code></pre><p>See also: <a href="api-ctbase.html#CTBase.ctNumber"><code>ctNumber</code></a>, <a href="api-ctbase.html#CTBase.State"><code>State</code></a>, <a href="api-ctbase.html#CTBase.Costate"><code>Costate</code></a>, <a href="api-ctbase.html#CTBase.Control"><code>Control</code></a>, <a href="api-ctbase.html#CTBase.Variable"><code>Variable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L42-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.AbstractHamiltonian" href="#CTBase.AbstractHamiltonian"><code>CTBase.AbstractHamiltonian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractHamiltonian{time_dependence, variable_dependence}</code></pre><p>Abstract type for hamiltonians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.AmbiguousDescription" href="#CTBase.AmbiguousDescription"><code>CTBase.AmbiguousDescription</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AmbiguousDescription &lt;: CTException</code></pre><p>Exception thrown when the description is ambiguous / incorrect.</p><p><strong>Fields</strong></p><ul><li><code>var::Tuple{Vararg{Symbol}}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/exception.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Autonomous" href="#CTBase.Autonomous"><code>CTBase.Autonomous</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Autonomous &lt;: TimeDependence</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L1129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.BoundaryConstraint" href="#CTBase.BoundaryConstraint"><code>CTBase.BoundaryConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BoundaryConstraint{variable_dependence}</code></pre><p><strong>Fields</strong></p><ul><li><code>f::Function</code></li></ul><p>The default value for <code>variable_dependence</code> is <code>Fixed</code>.</p><p><strong>Constructor</strong></p><p>The constructor <code>BoundaryConstraint</code> returns a <code>BoundaryConstraint</code> of a function. The function must take 2 or 3 arguments <code>(x0, xf)</code> or <code>(x0, xf, v)</code>, if the function is variable, it must be specified.  Dependencies are specified with a boolean, <code>variable</code>, <code>false</code> by default or with a <code>DataType</code>, <code>NonFixed/Fixed</code>, <code>Fixed</code> by default.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; B = BoundaryConstraint((x0, xf) -&gt; [xf[2]-x0[1], 2xf[1]+x0[2]^2])
julia&gt; B = BoundaryConstraint((x0, xf, v) -&gt; [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)
julia&gt; B = BoundaryConstraint((x0, xf, v) -&gt; [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When the state is of dimension 1, consider <code>x0</code> and <code>xf</code> as a scalar. When the constraint is dimension 1, return a scalar.</p></div></div><p><strong>Call</strong></p><p>The call returns the evaluation of the <code>BoundaryConstraint</code> for given values. If a variable is given for a non variable dependent boundary constraint, it will be ignored.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; B = BoundaryConstraint((x0, xf) -&gt; [xf[2]-x0[1], 2xf[1]+x0[2]^2])
julia&gt; B([0, 0], [1, 1])
[1, 2]
julia&gt; B = BoundaryConstraint((x0, xf) -&gt; [xf[2]-x0[1], 2xf[1]+x0[2]^2])
julia&gt; B([0, 0], [1, 1],Real[])
[1, 2]
julia&gt; B = BoundaryConstraint((x0, xf, v) -&gt; [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)
julia&gt; B([0, 0], [1, 1], [1, 2, 3])
[4, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.BoundaryConstraint-Tuple{Function, Vararg{DataType}}" href="#CTBase.BoundaryConstraint-Tuple{Function, Vararg{DataType}}"><code>CTBase.BoundaryConstraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoundaryConstraint(
    f::Function,
    dependencies::DataType...
) -&gt; BoundaryConstraint{Fixed}
</code></pre><p>Return a <code>BoundaryConstraint</code> of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.</p><pre><code class="language- hljs">julia&gt; B = BoundaryConstraint((x0, xf) -&gt; [xf[2]-x0[1], 2xf[1]+x0[2]^2])
julia&gt; B = BoundaryConstraint((x0, xf, v) -&gt; [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L20-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.BoundaryConstraint-Tuple{Function}" href="#CTBase.BoundaryConstraint-Tuple{Function}"><code>CTBase.BoundaryConstraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoundaryConstraint(
    f::Function;
    variable
) -&gt; BoundaryConstraint{Fixed}
</code></pre><p>Return a <code>BoundaryConstraint</code> of a function. Dependencies are specified with a boolean, variable, false by default.</p><pre><code class="language- hljs">julia&gt; B = BoundaryConstraint((x0, xf) -&gt; [xf[2]-x0[1], 2xf[1]+x0[2]^2])
julia&gt; B = BoundaryConstraint((x0, xf, v) -&gt; [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L2-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}" href="#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.BoundaryConstraint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the evaluation of the BoundaryConstraint.</p><pre><code class="language- hljs">julia&gt; B = BoundaryConstraint((x0, xf) -&gt; [xf[2]-x0[1], 2xf[1]+x0[2]^2])
julia&gt; B([0, 0], [1, 1])
[1, 2]
julia&gt; B = BoundaryConstraint((x0, xf) -&gt; [xf[2]-x0[1], 2xf[1]+x0[2]^2])
julia&gt; B([0, 0], [1, 1],Real[])
[1, 2]
julia&gt; B = BoundaryConstraint((x0, xf, v) -&gt; [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)
julia&gt; B([0, 0], [1, 1], [1, 2, 3])
[4, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L39-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.CTCallback" href="#CTBase.CTCallback"><code>CTBase.CTCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type CTCallback</code></pre><p>Abstract type for callbacks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/callback.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.CTCallbacks" href="#CTBase.CTCallbacks"><code>CTBase.CTCallbacks</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tuple of callbacks</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/callback.jl#L9-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.CTException" href="#CTBase.CTException"><code>CTBase.CTException</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type CTException &lt;: Exception</code></pre><p>Abstract type for exceptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/exception.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ControlConstraint" href="#CTBase.ControlConstraint"><code>CTBase.ControlConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ControlConstraint{time_dependence, variable_dependence}</code></pre><p><strong>Fields</strong></p><ul><li><code>f::Function</code></li></ul><p>Similar to <code>VectorField</code> in the usage, but the dimension of the output of the function <code>f</code> is arbitrary.</p><p>The default values for <code>time_dependence</code> and <code>variable_dependence</code> are <code>Autonomous</code> and <code>Fixed</code> respectively.</p><p><strong>Constructor</strong></p><p>The constructor <code>ControlConstraint</code> returns a <code>ControlConstraint</code> of a function. The function must take 1 to 3 arguments, <code>u</code> to <code>(t, u, v)</code>, if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :</p><ul><li>booleans, <code>autonomous</code> and <code>variable</code>, respectively <code>true</code> and <code>false</code> by default </li><li><code>DataType</code>, <code>Autonomous</code>/<code>NonAutonomous</code> and <code>NonFixed</code>/<code>Fixed</code>, respectively <code>Autonomous</code> and <code>Fixed</code> by default.</li></ul><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; IncorrectArgument ControlConstraint(u -&gt; [u[1]^2, 2u[2]], Int64)
julia&gt; IncorrectArgument ControlConstraint(u -&gt; [u[1]^2, 2u[2]], Int64)
julia&gt; C = ControlConstraint(u -&gt; [u[1]^2, 2u[2]], Autonomous, Fixed)
julia&gt; C = ControlConstraint((u, v) -&gt; [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)
julia&gt; C = ControlConstraint((t, u) -&gt; [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)
julia&gt; C = ControlConstraint((t, u, v) -&gt; [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)
julia&gt; C = ControlConstraint(u -&gt; [u[1]^2, 2u[2]], autonomous=true, variable=false)
julia&gt; C = ControlConstraint((u, v) -&gt; [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)
julia&gt; C = ControlConstraint((t, u) -&gt; [t+u[1]^2, 2u[2]], autonomous=false, variable=false)
julia&gt; C = ControlConstraint((t, u, v) -&gt; [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When the control is of dimension 1, consider <code>u</code> as a scalar.</p></div></div><p><strong>Call</strong></p><p>The call returns the evaluation of the <code>ControlConstraint</code> for given values.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; C = ControlConstraint(u -&gt; [u[1]^2, 2u[2]], autonomous=true, variable=false)
julia&gt; C([1, -1])
[1, -2]
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; C(t, [1, -1], v)
[1, -2]
julia&gt; C = ControlConstraint((u, v) -&gt; [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)
julia&gt; C([1, -1], [1, 2, 3])
[1, 1]
julia&gt; C(t, [1, -1], [1, 2, 3])
[1, 1]
julia&gt; C = ControlConstraint((t, u) -&gt; [t+u[1]^2, 2u[2]], autonomous=false, variable=false)
julia&gt; C(1, [1, -1])
[2, -2]
julia&gt; C(1, [1, -1], v)
[2, -2]
julia&gt; C = ControlConstraint((t, u, v) -&gt; [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)
julia&gt; C(1, [1, -1], [1, 2, 3])
[2, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L657">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ControlConstraint-Tuple{Function, Vararg{DataType}}" href="#CTBase.ControlConstraint-Tuple{Function, Vararg{DataType}}"><code>CTBase.ControlConstraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ControlConstraint(
    f::Function,
    dependencies::DataType...
) -&gt; ControlConstraint{Autonomous, Fixed}
</code></pre><p>Return the <code>StateConstraint</code> of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.</p><pre><code class="language- hljs">julia&gt; IncorrectArgument ControlConstraint(u -&gt; [u[1]^2, 2u[2]], Int64)
julia&gt; IncorrectArgument ControlConstraint(u -&gt; [u[1]^2, 2u[2]], Int64)
julia&gt; C = ControlConstraint(u -&gt; [u[1]^2, 2u[2]], Autonomous, Fixed)
julia&gt; C = ControlConstraint((u, v) -&gt; [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)
julia&gt; C = ControlConstraint((t, u) -&gt; [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)
julia&gt; C = ControlConstraint((t, u, v) -&gt; [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L947-L962">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ControlConstraint-Tuple{Function}" href="#CTBase.ControlConstraint-Tuple{Function}"><code>CTBase.ControlConstraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ControlConstraint(
    f::Function;
    autonomous,
    variable
) -&gt; ControlConstraint{Autonomous, Fixed}
</code></pre><p>Return the <code>ControlConstraint</code> of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.</p><pre><code class="language- hljs">julia&gt; C = ControlConstraint(u -&gt; [u[1]^2, 2u[2]], autonomous=true, variable=false)
julia&gt; C = ControlConstraint((u, v) -&gt; [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)
julia&gt; C = ControlConstraint((t, u) -&gt; [t+u[1]^2, 2u[2]], autonomous=false, variable=false)
julia&gt; C = ControlConstraint((t, u, v) -&gt; [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L926-L939">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ControlConstraint-Tuple{Union{Real, AbstractVector{&lt;:Real}}}" href="#CTBase.ControlConstraint-Tuple{Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.ControlConstraint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the value of the ControlConstraint function.</p><pre><code class="language- hljs">julia&gt; IncorrectArgument ControlConstraint(u -&gt; [u[1]^2, 2u[2]], Int64)
julia&gt; IncorrectArgument ControlConstraint(u -&gt; [u[1]^2, 2u[2]], Int64)
julia&gt; C = ControlConstraint(u -&gt; [u[1]^2, 2u[2]], autonomous=true, variable=false)
julia&gt; C([1, -1])
[1, -2]
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; C(t, [1, -1], v)
[1, -2]
julia&gt; C = ControlConstraint((u, v) -&gt; [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)
julia&gt; C([1, -1], [1, 2, 3])
[1, 1]
julia&gt; C(t, [1, -1], [1, 2, 3])
[1, 1]
julia&gt; C = ControlConstraint((t, u) -&gt; [t+u[1]^2, 2u[2]], autonomous=false, variable=false)
julia&gt; C(1, [1, -1])
[2, -2]
julia&gt; C(1, [1, -1], v)
[2, -2]
julia&gt; C = ControlConstraint((t, u, v) -&gt; [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)
julia&gt; C(1, [1, -1], [1, 2, 3])
[2, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L970-L1000">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ControlLaw" href="#CTBase.ControlLaw"><code>CTBase.ControlLaw</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ControlLaw{time_dependence, variable_dependence}</code></pre><p><strong>Fields</strong></p><ul><li><code>f::Function</code></li></ul><p>Similar to <code>Hamiltonian</code> in the usage, but the dimension of the output of the function <code>f</code> is arbitrary.</p><p>The default values for <code>time_dependence</code> and <code>variable_dependence</code> are <code>Autonomous</code> and <code>Fixed</code> respectively.</p><p><strong>Constructor</strong></p><p>The constructor <code>ControlLaw</code> returns a <code>ControlLaw</code> of a function. The function must take 2 to 4 arguments, <code>(x, p)</code> to <code>(t, x, p, v)</code>, if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :</p><ul><li>booleans, <code>autonomous</code> and <code>variable</code>, respectively <code>true</code> and <code>false</code> by default </li><li><code>DataType</code>, <code>Autonomous</code>/<code>NonAutonomous</code> and <code>NonFixed</code>/<code>Fixed</code>, respectively <code>Autonomous</code> and <code>Fixed</code> by default.</li></ul><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; ControlLaw((x, p) -&gt; x[1]^2+2p[2], Int64)
IncorrectArgument
julia&gt; ControlLaw((x, p) -&gt; x[1]^2+2p[2], Int64)
IncorrectArgument
julia&gt; u = ControlLaw((x, p) -&gt; x[1]^2+2p[2], Autonomous, Fixed)
julia&gt; u = ControlLaw((x, p, v) -&gt; x[1]^2+2p[2]+v[3], Autonomous, NonFixed)
julia&gt; u = ControlLaw((t, x, p) -&gt; t+x[1]^2+2p[2], NonAutonomous, Fixed)
julia&gt; u = ControlLaw((t, x, p, v) -&gt; t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)
julia&gt; u = ControlLaw((x, p) -&gt; x[1]^2+2p[2], autonomous=true, variable=false)
julia&gt; u = ControlLaw((x, p, v) -&gt; x[1]^2+2p[2]+v[3], autonomous=true, variable=true)
julia&gt; u = ControlLaw((t, x, p) -&gt; t+x[1]^2+2p[2], autonomous=false, variable=false)
julia&gt; u = ControlLaw((t, x, p, v) -&gt; t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When the state and costate are of dimension 1, consider <code>x</code> and <code>p</code> as scalars.</p></div></div><p><strong>Call</strong></p><p>The call returns the evaluation of the <code>ControlLaw</code> for given values.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; u = ControlLaw((x, p) -&gt; x[1]^2+2p[2], autonomous=true, variable=false)
julia&gt; u([1, 0], [0, 1])
3
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; u(t, [1, 0], [0, 1])
MethodError
julia&gt; u([1, 0], [0, 1], v)
MethodError
julia&gt; u(t, [1, 0], [0, 1], v)
3
julia&gt; u = ControlLaw((x, p, v) -&gt; x[1]^2+2p[2]+v[3], autonomous=true, variable=true)
julia&gt; u([1, 0], [0, 1], [1, 2, 3])
6
julia&gt; u(t, [1, 0], [0, 1], [1, 2, 3])
6
julia&gt; u = ControlLaw((t, x, p) -&gt; t+x[1]^2+2p[2], autonomous=false, variable=false)
julia&gt; u(1, [1, 0], [0, 1])
4
julia&gt; u(1, [1, 0], [0, 1], v)
4
julia&gt; u = ControlLaw((t, x, p, v) -&gt; t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)
julia&gt; u(1, [1, 0], [0, 1], [1, 2, 3])
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L932">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ControlLaw-Tuple{Function, Vararg{DataType}}" href="#CTBase.ControlLaw-Tuple{Function, Vararg{DataType}}"><code>CTBase.ControlLaw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ControlLaw(
    f::Function,
    dependencies::DataType...
) -&gt; ControlLaw{Autonomous, Fixed}
</code></pre><p>Return the <code>ControlLaw</code> of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.</p><pre><code class="language- hljs">julia&gt; ControlLaw((x, p) -&gt; x[1]^2+2p[2], Int64)
IncorrectArgument
julia&gt; ControlLaw((x, p) -&gt; x[1]^2+2p[2], Int64)
IncorrectArgument
julia&gt; u = ControlLaw((x, p) -&gt; x[1]^2+2p[2], Autonomous, Fixed)
julia&gt; u = ControlLaw((x, p, v) -&gt; x[1]^2+2p[2]+v[3], Autonomous, NonFixed)
julia&gt; u = ControlLaw((t, x, p) -&gt; t+x[1]^2+2p[2], NonAutonomous, Fixed)
julia&gt; u = ControlLaw((t, x, p, v) -&gt; t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L1290-L1307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ControlLaw-Tuple{Function}" href="#CTBase.ControlLaw-Tuple{Function}"><code>CTBase.ControlLaw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ControlLaw(
    f::Function;
    autonomous,
    variable
) -&gt; ControlLaw{Autonomous, Fixed}
</code></pre><p>Return the <code>ControlLaw</code> of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.</p><pre><code class="language- hljs">julia&gt; u = ControlLaw((x, p) -&gt; x[1]^2+2p[2], autonomous=true, variable=false)
julia&gt; u = ControlLaw((x, p, v) -&gt; x[1]^2+2p[2]+v[3], autonomous=true, variable=true)
julia&gt; u = ControlLaw((t, x, p) -&gt; t+x[1]^2+2p[2], autonomous=false, variable=false)
julia&gt; u = ControlLaw((t, x, p, v) -&gt; t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L1269-L1282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ControlLaw-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}" href="#CTBase.ControlLaw-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.ControlLaw</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the value of the ControlLaw function.</p><pre><code class="language- hljs">julia&gt; ControlLaw((x, p) -&gt; x[1]^2+2p[2], Int64)
IncorrectArgument
julia&gt; ControlLaw((x, p) -&gt; x[1]^2+2p[2], Int64)
IncorrectArgument
julia&gt; u = ControlLaw((x, p) -&gt; x[1]^2+2p[2], autonomous=true, variable=false)
julia&gt; u([1, 0], [0, 1])
3
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; u(t, [1, 0], [0, 1])
MethodError
julia&gt; u([1, 0], [0, 1], v)
MethodError
julia&gt; u(t, [1, 0], [0, 1], v)
3
julia&gt; u = ControlLaw((x, p, v) -&gt; x[1]^2+2p[2]+v[3], autonomous=true, variable=true)
julia&gt; u([1, 0], [0, 1], [1, 2, 3])
6
julia&gt; u(t, [1, 0], [0, 1], [1, 2, 3])
6
julia&gt; u = ControlLaw((t, x, p) -&gt; t+x[1]^2+2p[2], autonomous=false, variable=false)
julia&gt; u(1, [1, 0], [0, 1])
4
julia&gt; u(1, [1, 0], [0, 1], v)
4
julia&gt; u = ControlLaw((t, x, p, v) -&gt; t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)
julia&gt; u(1, [1, 0], [0, 1], [1, 2, 3])
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L1315-L1351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Controls" href="#CTBase.Controls"><code>CTBase.Controls</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for a vector of controls.</p><pre><code class="language- hljs">julia&gt; const Controls = AbstractVector{&lt;:Control}</code></pre><p>See also: <a href="api-ctbase.html#CTBase.Control"><code>Control</code></a>, <a href="api-ctbase.html#CTBase.States"><code>States</code></a>, <a href="api-ctbase.html#CTBase.Costates"><code>Costates</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L152-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Costates" href="#CTBase.Costates"><code>CTBase.Costates</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for a vector of costates.</p><pre><code class="language- hljs">julia&gt; const Costates = AbstractVector{&lt;:Costate}</code></pre><p>See also: <a href="api-ctbase.html#CTBase.Costate"><code>Costate</code></a>, <a href="api-ctbase.html#CTBase.States"><code>States</code></a>, <a href="api-ctbase.html#CTBase.Controls"><code>Controls</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L141-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Description" href="#CTBase.Description"><code>CTBase.Description</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A description is a tuple of symbols. <code>Description</code> is a type alias for a tuple of symbols.</p><pre><code class="language- hljs">julia&gt; const Description = Tuple{DescVarArg}</code></pre><p>See also: <a href="@ref"><code>DescVarArg</code></a>.</p><p><strong>Example</strong></p><p><a href="@ref"><code>Base.show</code></a> is overloaded for descriptions, that is tuple of descriptions are printed as follows:</p><pre><code class="language- hljs">julia&gt; display( ( (:a, :b), (:b, :c) ) )
(:a, :b)
(:b, :c)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/description.jl#L12-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Dimension" href="#CTBase.Dimension"><code>CTBase.Dimension</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for a dimension. This is used to define the dimension of the state space,  the costate space, the control space, etc.</p><pre><code class="language- hljs">julia&gt; const Dimension = Integer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L163-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Dynamics" href="#CTBase.Dynamics"><code>CTBase.Dynamics</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Dynamics{time_dependence, variable_dependence}</code></pre><p><strong>Fields</strong></p><ul><li><code>f::Function</code></li></ul><p>The default value for <code>time_dependence</code> and <code>variable_dependence</code> are <code>Autonomous</code> and <code>Fixed</code> respectively.</p><p><strong>Constructor</strong></p><p>The constructor <code>Dynamics</code> returns a <code>Dynamics</code> of a function. The function must take 2 to 4 arguments, <code>(x, u)</code> to <code>(t, x, u, v)</code>, if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :</p><ul><li>booleans, <code>autonomous</code> and <code>variable</code>, respectively <code>true</code> and <code>false</code> by default </li><li><code>DataType</code>, <code>Autonomous</code>/<code>NonAutonomous</code> and <code>NonFixed</code>/<code>Fixed</code>, respectively <code>Autonomous</code> and <code>Fixed</code> by default.</li></ul><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; Dynamics((x, u) -&gt; [2x[2]-u^2, x[1]], Int64)
IncorrectArgument
julia&gt; Dynamics((x, u) -&gt; [2x[2]-u^2, x[1]], Int64)
IncorrectArgument
julia&gt; D = Dynamics((x, u) -&gt; [2x[2]-u^2, x[1]], Autonomous, Fixed)
julia&gt; D = Dynamics((x, u, v) -&gt; [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)
julia&gt; D = Dynamics((t, x, u) -&gt; [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)
julia&gt; D = Dynamics((t, x, u, v) -&gt; [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)
julia&gt; D = Dynamics((x, u) -&gt; [2x[2]-u^2, x[1]], autonomous=true, variable=false)
julia&gt; D = Dynamics((x, u, v) -&gt; [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)
julia&gt; D = Dynamics((t, x, u) -&gt; [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)
julia&gt; D = Dynamics((t, x, u, v) -&gt; [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When the state is of dimension 1, consider <code>x</code> as a scalar. Same for the control.</p></div></div><p><strong>Call</strong></p><p>The call returns the evaluation of the <code>Dynamics</code> for given values.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; D = Dynamics((x, u) -&gt; [2x[2]-u^2, x[1]], autonomous=true, variable=false)
julia&gt; D([1, 0], 1)
[-1, 1]
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; D(t, [1, 0], 1, v)
[-1, 1]
julia&gt; D = Dynamics((x, u, v) -&gt; [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)
julia&gt; D([1, 0], 1, [1, 2, 3])
[2, 1]
julia&gt; D(t, [1, 0], 1, [1, 2, 3])
[2, 1]
julia&gt; D = Dynamics((t, x, u) -&gt; [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)
julia&gt; D(1, [1, 0], 1)
[0, 1]
julia&gt; D(1, [1, 0], 1, v)
[0, 1]
julia&gt; D = Dynamics((t, x, u, v) -&gt; [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)
julia&gt; D(1, [1, 0], 1, [1, 2, 3])
[3, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L506">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Dynamics-Tuple{Function, Vararg{DataType}}" href="#CTBase.Dynamics-Tuple{Function, Vararg{DataType}}"><code>CTBase.Dynamics</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Dynamics(
    f::Function,
    dependencies::DataType...
) -&gt; Dynamics{Autonomous, Fixed}
</code></pre><p>Return the <code>Dynamics</code> of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.</p><pre><code class="language- hljs">julia&gt; Dynamics((x, u) -&gt; [2x[2]-u^2, x[1]], Int64)
IncorrectArgument
julia&gt; Dynamics((x, u) -&gt; [2x[2]-u^2, x[1]], Int64)
IncorrectArgument
julia&gt; D = Dynamics((x, u) -&gt; [2x[2]-u^2, x[1]], Autonomous, Fixed)
julia&gt; D = Dynamics((x, u, v) -&gt; [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)
julia&gt; D = Dynamics((t, x, u) -&gt; [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)
julia&gt; D = Dynamics((t, x, u, v) -&gt; [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L734-L751">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Dynamics-Tuple{Function}" href="#CTBase.Dynamics-Tuple{Function}"><code>CTBase.Dynamics</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Dynamics(
    f::Function;
    autonomous,
    variable
) -&gt; Dynamics{Autonomous, Fixed}
</code></pre><p>Return the <code>Dynamics</code> of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.</p><pre><code class="language- hljs">julia&gt; D = Dynamics((x, u) -&gt; [2x[2]-u^2, x[1]], autonomous=true, variable=false)
julia&gt; D = Dynamics((x, u, v) -&gt; [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)
julia&gt; D = Dynamics((t, x, u) -&gt; [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)
julia&gt; D = Dynamics((t, x, u, v) -&gt; [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L713-L726">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Dynamics-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}" href="#CTBase.Dynamics-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.Dynamics</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the value of the Dynamics function.</p><pre><code class="language- hljs">julia&gt; D = Dynamics((x, u) -&gt; [2x[2]-u^2, x[1]], autonomous=true, variable=false)
julia&gt; D([1, 0], 1)
[-1, 1]
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; D(t, [1, 0], 1, v)
[-1, 1]
julia&gt; D = Dynamics((x, u, v) -&gt; [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)
julia&gt; D([1, 0], 1, [1, 2, 3])
[2, 1]
julia&gt; D(t, [1, 0], 1, [1, 2, 3])
[2, 1]
julia&gt; D = Dynamics((t, x, u) -&gt; [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)
julia&gt; D(1, [1, 0], 1)
[0, 1]
julia&gt; D(1, [1, 0], 1, v)
[0, 1]
julia&gt; D = Dynamics((t, x, u, v) -&gt; [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)
julia&gt; D(1, [1, 0], 1, [1, 2, 3])
[3, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L759-L787">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.FeedbackControl" href="#CTBase.FeedbackControl"><code>CTBase.FeedbackControl</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FeedbackControl{time_dependence, variable_dependence}</code></pre><p><strong>Fields</strong></p><ul><li><code>f::Function</code></li></ul><p>Similar to <code>VectorField</code> in the usage, but the dimension of the output of the function <code>f</code> is arbitrary.</p><p>The default values for <code>time_dependence</code> and <code>variable_dependence</code> are <code>Autonomous</code> and <code>Fixed</code> respectively.</p><p><strong>Constructor</strong></p><p>The constructor <code>FeedbackControl</code> returns a <code>FeedbackControl</code> of a function. The function must take 1 to 3 arguments, <code>x</code> to <code>(t, x, v)</code>, if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :</p><ul><li>booleans, <code>autonomous</code> and <code>variable</code>, respectively <code>true</code> and <code>false</code> by default </li><li><code>DataType</code>, <code>Autonomous</code>/<code>NonAutonomous</code> and <code>NonFixed</code>/<code>Fixed</code>, respectively <code>Autonomous</code> and <code>Fixed</code> by default.</li></ul><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; FeedbackControl(x -&gt; x[1]^2+2x[2], Int64)
IncorrectArgument
julia&gt; FeedbackControl(x -&gt; x[1]^2+2x[2], Int64)
IncorrectArgument
julia&gt; u = FeedbackControl(x -&gt; x[1]^2+2x[2], Autonomous, Fixed)
julia&gt; u = FeedbackControl((x, v) -&gt; x[1]^2+2x[2]+v[3], Autonomous, NonFixed)
julia&gt; u = FeedbackControl((t, x) -&gt; t+x[1]^2+2x[2], NonAutonomous, Fixed)
julia&gt; u = FeedbackControl((t, x, v) -&gt; t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)
julia&gt; u = FeedbackControl(x -&gt; x[1]^2+2x[2], autonomous=true, variable=false)
julia&gt; u = FeedbackControl((x, v) -&gt; x[1]^2+2x[2]+v[3], autonomous=true, variable=true)
julia&gt; u = FeedbackControl((t, x) -&gt; t+x[1]^2+2x[2], autonomous=false, variable=false)
julia&gt; u = FeedbackControl((t, x, v) -&gt; t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When the state is of dimension 1, consider <code>x</code> as a scalar.</p></div></div><p><strong>Call</strong></p><p>The call returns the evaluation of the <code>FeedbackControl</code> for given values.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; u = FeedbackControl(x -&gt; x[1]^2+2x[2], autonomous=true, variable=false)
julia&gt; u([1, 0])
1
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; u(t, [1, 0])
MethodError
julia&gt; u([1, 0], v)
MethodError
julia&gt; u(t, [1, 0], v)
1
julia&gt; u = FeedbackControl((x, v) -&gt; x[1]^2+2x[2]+v[3], autonomous=true, variable=true)
julia&gt; u([1, 0], [1, 2, 3])
4
julia&gt; u(t, [1, 0], [1, 2, 3])
4
julia&gt; u = FeedbackControl((t, x) -&gt; t+x[1]^2+2x[2], autonomous=false, variable=false)
julia&gt; u(1, [1, 0])
2
julia&gt; u(1, [1, 0], v)
2
julia&gt; u = FeedbackControl((t, x, v) -&gt; t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)
julia&gt; u(1, [1, 0], [1, 2, 3])
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L853">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.FeedbackControl-Tuple{Function, Vararg{DataType}}" href="#CTBase.FeedbackControl-Tuple{Function, Vararg{DataType}}"><code>CTBase.FeedbackControl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FeedbackControl(
    f::Function,
    dependencies::DataType...
) -&gt; FeedbackControl{Autonomous, Fixed}
</code></pre><p>Return the <code>FeedbackControl</code> of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.</p><pre><code class="language- hljs">julia&gt; FeedbackControl(x -&gt; x[1]^2+2x[2], Int64)
IncorrectArgument
julia&gt; FeedbackControl(x -&gt; x[1]^2+2x[2], Int64)
IncorrectArgument
julia&gt; u = FeedbackControl(x -&gt; x[1]^2+2x[2], Autonomous, Fixed)
julia&gt; u = FeedbackControl((x, v) -&gt; x[1]^2+2x[2]+v[3], Autonomous, NonFixed)
julia&gt; u = FeedbackControl((t, x) -&gt; t+x[1]^2+2x[2], NonAutonomous, Fixed)
julia&gt; u = FeedbackControl((t, x, v) -&gt; t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L1178-L1195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.FeedbackControl-Tuple{Function}" href="#CTBase.FeedbackControl-Tuple{Function}"><code>CTBase.FeedbackControl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FeedbackControl(
    f::Function;
    autonomous,
    variable
) -&gt; FeedbackControl{Autonomous, Fixed}
</code></pre><p>Return the <code>FeedbackControl</code> of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.</p><pre><code class="language- hljs">julia&gt; u = FeedbackControl(x -&gt; x[1]^2+2x[2], autonomous=true, variable=false)
julia&gt; u = FeedbackControl((x, v) -&gt; x[1]^2+2x[2]+v[3], autonomous=true, variable=true)
julia&gt; u = FeedbackControl((t, x) -&gt; t+x[1]^2+2x[2], autonomous=false, variable=false)
julia&gt; u = FeedbackControl((t, x, v) -&gt; t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L1157-L1170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.FeedbackControl-Tuple{Union{Real, AbstractVector{&lt;:Real}}}" href="#CTBase.FeedbackControl-Tuple{Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.FeedbackControl</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the value of the FeedbackControl function.</p><pre><code class="language- hljs">julia&gt; FeedbackControl(x -&gt; x[1]^2+2x[2], Int64)
IncorrectArgument
julia&gt; FeedbackControl(x -&gt; x[1]^2+2x[2], Int64)
IncorrectArgument
julia&gt; u = FeedbackControl(x -&gt; x[1]^2+2x[2], autonomous=true, variable=false)
julia&gt; u([1, 0])
1
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; u(t, [1, 0])
MethodError
julia&gt; u([1, 0], v)
MethodError
julia&gt; u(t, [1, 0], v)
1
julia&gt; u = FeedbackControl((x, v) -&gt; x[1]^2+2x[2]+v[3], autonomous=true, variable=true)
julia&gt; u([1, 0], [1, 2, 3])
4
julia&gt; u(t, [1, 0], [1, 2, 3])
4
julia&gt; u = FeedbackControl((t, x) -&gt; t+x[1]^2+2x[2], autonomous=false, variable=false)
julia&gt; u(1, [1, 0])
2
julia&gt; u(1, [1, 0], v)
2
julia&gt; u = FeedbackControl((t, x, v) -&gt; t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)
julia&gt; u(1, [1, 0], [1, 2, 3])
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L1203-L1239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Fixed" href="#CTBase.Fixed"><code>CTBase.Fixed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Fixed &lt;: VariableDependence</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L1145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Hamiltonian" href="#CTBase.Hamiltonian"><code>CTBase.Hamiltonian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Hamiltonian{time_dependence, variable_dependence} &lt;: AbstractHamiltonian{time_dependence, variable_dependence}</code></pre><p><strong>Fields</strong></p><ul><li><code>f::Function</code></li></ul><p>The default values for <code>time_dependence</code> and <code>variable_dependence</code> are <code>Autonomous</code> and <code>Fixed</code> respectively.</p><p><strong>Constructor</strong></p><p>The constructor <code>Hamiltonian</code> returns a <code>Hamiltonian</code> of a function. The function must take 2 to 4 arguments, <code>(x, p)</code> to <code>(t, x, p, v)</code>, if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :</p><ul><li>booleans, <code>autonomous</code> and <code>variable</code>, respectively <code>true</code> and <code>false</code> by default </li><li><code>DataType</code>, <code>Autonomous</code>/<code>NonAutonomous</code> and <code>NonFixed</code>/<code>Fixed</code>, respectively <code>Autonomous</code> and <code>Fixed</code> by default.</li></ul><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; Hamiltonian((x, p) -&gt; x + p, Int64)
IncorrectArgument 
julia&gt; Hamiltonian((x, p) -&gt; x + p, Int64)
IncorrectArgument
julia&gt; H = Hamiltonian((x, p) -&gt; x[1]^2+2p[2])
julia&gt; H = Hamiltonian((t, x, p, v) -&gt; [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)
julia&gt; H = Hamiltonian((t, x, p, v) -&gt; [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When the state and costate are of dimension 1, consider <code>x</code> and <code>p</code> as scalars.</p></div></div><p><strong>Call</strong></p><p>The call returns the evaluation of the <code>Hamiltonian</code> for given values.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; H = Hamiltonian((x, p) -&gt; [x[1]^2+2p[2]]) # autonomous=true, variable=false
julia&gt; H([1, 0], [0, 1])
MethodError # H must return a scalar
julia&gt; H = Hamiltonian((x, p) -&gt; x[1]^2+2p[2])
julia&gt; H([1, 0], [0, 1])
3
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; H(t, [1, 0], [0, 1])
MethodError
julia&gt; H([1, 0], [0, 1], v)
MethodError 
julia&gt; H(t, [1, 0], [0, 1], v)
3
julia&gt; H = Hamiltonian((x, p, v) -&gt; x[1]^2+2p[2]+v[3], variable=true)
julia&gt; H([1, 0], [0, 1], [1, 2, 3])
6
julia&gt; H(t, [1, 0], [0, 1], [1, 2, 3])
6
julia&gt; H = Hamiltonian((t, x, p) -&gt; t+x[1]^2+2p[2], autonomous=false)
julia&gt; H(1, [1, 0], [0, 1])
4
julia&gt; H(1, [1, 0], [0, 1], v)
4
julia&gt; H = Hamiltonian((t, x, p, v) -&gt; t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)
julia&gt; H(1, [1, 0], [0, 1], [1, 2, 3])
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Hamiltonian-Tuple{Function, Vararg{DataType}}" href="#CTBase.Hamiltonian-Tuple{Function, Vararg{DataType}}"><code>CTBase.Hamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Hamiltonian(
    f::Function,
    dependencies::DataType...
) -&gt; Hamiltonian{Autonomous, Fixed}
</code></pre><p>Return an <code>Hamiltonian</code> of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.</p><pre><code class="language- hljs">julia&gt; H = Hamiltonian((x, p) -&gt; x[1]^2+2p[2])
julia&gt; H = Hamiltonian((t, x, p, v) -&gt; [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L158-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Hamiltonian-Tuple{Function}" href="#CTBase.Hamiltonian-Tuple{Function}"><code>CTBase.Hamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Hamiltonian(
    f::Function;
    autonomous,
    variable
) -&gt; Hamiltonian{Autonomous, Fixed}
</code></pre><p>Return an <code>Hamiltonian</code> of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.</p><pre><code class="language- hljs">julia&gt; H = Hamiltonian((x, p) -&gt; x[1]^2+2p[2])
julia&gt; H = Hamiltonian((t, x, p, v) -&gt; [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L139-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Hamiltonian-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}" href="#CTBase.Hamiltonian-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.Hamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the value of the Hamiltonian.</p><pre><code class="language- hljs">julia&gt; Hamiltonian((x, p) -&gt; x + p, Int64)
IncorrectArgument 
julia&gt; Hamiltonian((x, p) -&gt; x + p, Int64)
IncorrectArgument
julia&gt; H = Hamiltonian((x, p) -&gt; [x[1]^2+2p[2]]) # autonomous=true, variable=false
julia&gt; H([1, 0], [0, 1])
MethodError # H must return a scalar
julia&gt; H = Hamiltonian((x, p) -&gt; x[1]^2+2p[2])
julia&gt; H([1, 0], [0, 1])
3
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; H(t, [1, 0], [0, 1])
MethodError
julia&gt; H([1, 0], [0, 1], v)
MethodError 
julia&gt; H(t, [1, 0], [0, 1], v)
3
julia&gt; H = Hamiltonian((x, p, v) -&gt; x[1]^2+2p[2]+v[3], variable=true)
julia&gt; H([1, 0], [0, 1], [1, 2, 3])
6
julia&gt; H(t, [1, 0], [0, 1], [1, 2, 3])
6
julia&gt; H = Hamiltonian((t, x, p) -&gt; t+x[1]^2+2p[2], autonomous=false)
julia&gt; H(1, [1, 0], [0, 1])
4
julia&gt; H(1, [1, 0], [0, 1], v)
4
julia&gt; H = Hamiltonian((t, x, p, v) -&gt; t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)
julia&gt; H(1, [1, 0], [0, 1], [1, 2, 3])
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L178-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.HamiltonianLift" href="#CTBase.HamiltonianLift"><code>CTBase.HamiltonianLift</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct HamiltonianLift{time_dependence, variable_dependence} &lt;: AbstractHamiltonian{time_dependence, variable_dependence}</code></pre><p><strong>Lifts</strong></p><ul><li><code>X::VectorField</code></li></ul><p>The values for <code>time_dependence</code> and <code>variable_dependence</code> are deternimed by the values of those for the VectorField.</p><p><strong>Constructor</strong></p><p>The constructor <code>HamiltonianLift</code> returns a <code>HamiltonianLift</code> of a <code>VectorField</code>.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; H = HamiltonianLift(VectorField(x -&gt; [x[1]^2, 2x[2]]))
julia&gt; H = HamiltonianLift(VectorField((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], variable=true))
julia&gt; H = HamiltonianLift(VectorField((t, x) -&gt; [t+x[1]^2, 2x[2]], autonomous=false))
julia&gt; H = HamiltonianLift(VectorField((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))
julia&gt; H = HamiltonianLift(VectorField(x -&gt; [x[1]^2, 2x[2]]))
julia&gt; H = HamiltonianLift(VectorField((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], NonFixed))
julia&gt; H = HamiltonianLift(VectorField((t, x) -&gt; [t+x[1]^2, 2x[2]], NonAutonomous))
julia&gt; H = HamiltonianLift(VectorField((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed))</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When the state and costate are of dimension 1, consider <code>x</code> and <code>p</code> as scalars.</p></div></div><p><strong>Call</strong></p><p>The call returns the evaluation of the <code>HamiltonianLift</code> for given values.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; H = HamiltonianLift(VectorField(x -&gt; [x[1]^2, 2x[2]]))
julia&gt; H([1, 2], [1, 1])
5
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; H(t, [1, 0], [0, 1])
MethodError
julia&gt; H([1, 0], [0, 1], v)
MethodError 
julia&gt; H(t, [1, 0], [0, 1], v)
5
julia&gt; H = HamiltonianLift(VectorField((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], variable=true))
julia&gt; H([1, 0], [0, 1], [1, 2, 3])
3
julia&gt; H(t, [1, 0], [0, 1], [1, 2, 3])
3
julia&gt; H = HamiltonianLift(VectorField((t, x) -&gt; [t+x[1]^2, 2x[2]], autonomous=false))
julia&gt; H(1, [1, 2], [1, 1])
6
julia&gt; H(1, [1, 0], [0, 1], v)
6
julia&gt; H = HamiltonianLift(VectorField((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))
julia&gt; H(1, [1, 0], [0, 1], [1, 2, 3])
3</code></pre><p>Alternatively, it is possible to construct the <code>HamiltonianLift</code> from a <code>Function</code> being the <code>VectorField</code>.</p><pre><code class="language- hljs">julia&gt; HL1 = HamiltonianLift((x, v) -&gt; [x[1]^2,x[2]^2+v], autonomous=true, variable=true)
julia&gt; HL2 = HamiltonianLift(VectorField((x, v) -&gt; [x[1]^2,x[2]^2+v], autonomous=true, variable=true))
julia&gt; HL1([1, 0], [0, 1], 1) == HL2([1, 0], [0, 1], 1)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.HamiltonianLift-Tuple{Function, Vararg{DataType}}" href="#CTBase.HamiltonianLift-Tuple{Function, Vararg{DataType}}"><code>CTBase.HamiltonianLift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HamiltonianLift(
    f::Function,
    dependences::DataType...
) -&gt; HamiltonianLift
</code></pre><p>Return an <code>HamiltonianLift</code> of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.</p><pre><code class="language- hljs">julia&gt; HamiltonianLift(HamiltonianLift(VectorField(x -&gt; [x[1]^2, 2x[2]], Int64))
IncorrectArgument 
julia&gt; HL = HamiltonianLift(x -&gt; [x[1]^2,x[2]^2], Autonomous, Fixed)
julia&gt; HL = HamiltonianLift((x, v) -&gt; [x[1]^2,x[2]^2+v], Autonomous, NonFixed)
julia&gt; HL = HamiltonianLift((t, x) -&gt; [t+x[1]^2,x[2]^2], NonAutonomous, Fixed)
julia&gt; HL = HamiltonianLift((t, x, v) -&gt; [t+x[1]^2,x[2]^2+v], NonAutonomous, NonFixed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L269-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.HamiltonianLift-Tuple{Function}" href="#CTBase.HamiltonianLift-Tuple{Function}"><code>CTBase.HamiltonianLift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HamiltonianLift(
    f::Function;
    autonomous,
    variable
) -&gt; HamiltonianLift
</code></pre><p>Return an <code>HamiltonianLift</code> of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.</p><pre><code class="language- hljs">julia&gt; HL = HamiltonianLift(x -&gt; [x[1]^2,x[2]^2], autonomous=true, variable=false)
julia&gt; HL = HamiltonianLift((x, v) -&gt; [x[1]^2,x[2]^2+v], autonomous=true, variable=true)
julia&gt; HL = HamiltonianLift((t, x) -&gt; [t+x[1]^2,x[2]^2], autonomous=false, variable=false)
julia&gt; HL = HamiltonianLift((t, x, v) -&gt; [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L248-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.HamiltonianLift-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}" href="#CTBase.HamiltonianLift-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.HamiltonianLift</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the value of the HamiltonianLift.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; HamiltonianLift(HamiltonianLift(VectorField(x -&gt; [x[1]^2, 2x[2]], Int64))
IncorrectArgument 
julia&gt; H = HamiltonianLift(VectorField(x -&gt; [x[1]^2, 2x[2]]))
julia&gt; H([1, 2], [1, 1])
5
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; H(t, [1, 0], [0, 1])
MethodError
julia&gt; H([1, 0], [0, 1], v)
MethodError 
julia&gt; H(t, [1, 0], [0, 1], v)
5
julia&gt; H = HamiltonianLift(VectorField((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], variable=true))
julia&gt; H([1, 0], [0, 1], [1, 2, 3])
3
julia&gt; H(t, [1, 0], [0, 1], [1, 2, 3])
3
julia&gt; H = HamiltonianLift(VectorField((t, x) -&gt; [t+x[1]^2, 2x[2]], autonomous=false))
julia&gt; H(1, [1, 2], [1, 1])
6
julia&gt; H(1, [1, 0], [0, 1], v)
6
julia&gt; H = HamiltonianLift(VectorField((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))
julia&gt; H(1, [1, 0], [0, 1], [1, 2, 3])
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L292-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.HamiltonianVectorField" href="#CTBase.HamiltonianVectorField"><code>CTBase.HamiltonianVectorField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct HamiltonianVectorField{time_dependence, variable_dependence} &lt;: CTBase.AbstractVectorField{time_dependence, variable_dependence}</code></pre><p><strong>Fields</strong></p><ul><li><code>f::Function</code></li></ul><p>The default values for <code>time_dependence</code> and <code>variable_dependence</code> are <code>Autonomous</code> and <code>Fixed</code> respectively.</p><p><strong>Constructor</strong></p><p>The constructor <code>HamiltonianVectorField</code> returns a <code>HamiltonianVectorField</code> of a function. The function must take 2 to 4 arguments, <code>(x, p)</code> to <code>(t, x, p, v)</code>, if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :</p><ul><li>booleans, <code>autonomous</code> and <code>variable</code>, respectively <code>true</code> and <code>false</code> by default </li><li><code>DataType</code>, <code>Autonomous</code>/<code>NonAutonomous</code> and <code>NonFixed</code>/<code>Fixed</code>, respectively <code>Autonomous</code> and <code>Fixed</code> by default.</li></ul><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; HamiltonianVectorField((x, p) -&gt; [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)
IncorrectArgument
julia&gt; HamiltonianVectorField((x, p) -&gt; [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)
IncorrectArgument
julia&gt; Hv = HamiltonianVectorField((x, p) -&gt; [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false
julia&gt; Hv = HamiltonianVectorField((x, p, v) -&gt; [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)
julia&gt; Hv = HamiltonianVectorField((t, x, p) -&gt; [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)
julia&gt; Hv = HamiltonianVectorField((t, x, p, v) -&gt; [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)
julia&gt; Hv = HamiltonianVectorField((x, p, v) -&gt; [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)
julia&gt; Hv = HamiltonianVectorField((t, x, p) -&gt; [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)
julia&gt; Hv = HamiltonianVectorField((t, x, p, v) -&gt; [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When the state and costate are of dimension 1, consider <code>x</code> and <code>p</code> as scalars.</p></div></div><p><strong>Call</strong></p><p>The call returns the evaluation of the <code>HamiltonianVectorField</code> for given values.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; Hv = HamiltonianVectorField((x, p) -&gt; [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false
julia&gt; Hv([1, 0], [0, 1])
[3, -3]
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; Hv(t, [1, 0], [0, 1])
MethodError
julia&gt; Hv([1, 0], [0, 1], v)
MethodError
julia&gt; Hv(t, [1, 0], [0, 1], v)
[3, -3]
julia&gt; Hv = HamiltonianVectorField((x, p, v) -&gt; [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)
julia&gt; Hv([1, 0], [0, 1], [1, 2, 3, 4])
[6, -3]
julia&gt; Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])
[6, -3]
julia&gt; Hv = HamiltonianVectorField((t, x, p) -&gt; [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)
julia&gt; Hv(1, [1, 0], [0, 1])
[4, -3]
julia&gt; Hv(1, [1, 0], [0, 1], v)
[4, -3]
julia&gt; Hv = HamiltonianVectorField((t, x, p, v) -&gt; [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)
julia&gt; Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])
[7, -3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.HamiltonianVectorField-Tuple{Function, Vararg{DataType}}" href="#CTBase.HamiltonianVectorField-Tuple{Function, Vararg{DataType}}"><code>CTBase.HamiltonianVectorField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HamiltonianVectorField(
    f::Function,
    dependencies::DataType...
) -&gt; HamiltonianVectorField{Autonomous, Fixed}
</code></pre><p>Return an <code>HamiltonianVectorField</code> of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.</p><pre><code class="language- hljs">julia&gt; HamiltonianVectorField((x, p) -&gt; [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)
IncorrectArgument
julia&gt; HamiltonianVectorField((x, p) -&gt; [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)
IncorrectArgument
julia&gt; Hv = HamiltonianVectorField((x, p) -&gt; [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false
julia&gt; Hv = HamiltonianVectorField((x, p, v) -&gt; [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)
julia&gt; Hv = HamiltonianVectorField((t, x, p) -&gt; [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)
julia&gt; Hv = HamiltonianVectorField((t, x, p, v) -&gt; [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L380-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.HamiltonianVectorField-Tuple{Function}" href="#CTBase.HamiltonianVectorField-Tuple{Function}"><code>CTBase.HamiltonianVectorField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HamiltonianVectorField(
    f::Function;
    autonomous,
    variable
) -&gt; HamiltonianVectorField{Autonomous, Fixed}
</code></pre><p>Return an <code>HamiltonianVectorField</code> of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.</p><pre><code class="language- hljs">julia&gt; Hv = HamiltonianVectorField((x, p) -&gt; [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false
julia&gt; Hv = HamiltonianVectorField((x, p, v) -&gt; [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)
julia&gt; Hv = HamiltonianVectorField((t, x, p) -&gt; [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)
julia&gt; Hv = HamiltonianVectorField((t, x, p, v) -&gt; [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L358-L372">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.HamiltonianVectorField-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}" href="#CTBase.HamiltonianVectorField-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.HamiltonianVectorField</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the value of the HamiltonianVectorField.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; HamiltonianVectorField((x, p) -&gt; [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)
IncorrectArgument
julia&gt; HamiltonianVectorField((x, p) -&gt; [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)
IncorrectArgument
julia&gt; Hv = HamiltonianVectorField((x, p) -&gt; [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false
julia&gt; Hv([1, 0], [0, 1])
[3, -3]
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; Hv(t, [1, 0], [0, 1])
MethodError
julia&gt; Hv([1, 0], [0, 1], v)
MethodError
julia&gt; Hv(t, [1, 0], [0, 1], v)
[3, -3]
julia&gt; Hv = HamiltonianVectorField((x, p, v) -&gt; [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)
julia&gt; Hv([1, 0], [0, 1], [1, 2, 3, 4])
[6, -3]
julia&gt; Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])
[6, -3]
julia&gt; Hv = HamiltonianVectorField((t, x, p) -&gt; [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)
julia&gt; Hv(1, [1, 0], [0, 1])
[4, -3]
julia&gt; Hv(1, [1, 0], [0, 1], v)
[4, -3]
julia&gt; Hv = HamiltonianVectorField((t, x, p, v) -&gt; [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)
julia&gt; Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])
[7, -3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L406-L444">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.IncorrectArgument" href="#CTBase.IncorrectArgument"><code>CTBase.IncorrectArgument</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IncorrectArgument &lt;: CTException</code></pre><p>Exception thrown when an argument is inconsistent.</p><p><strong>Fields</strong></p><ul><li><code>var::String</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/exception.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.IncorrectMethod" href="#CTBase.IncorrectMethod"><code>CTBase.IncorrectMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IncorrectMethod &lt;: CTException</code></pre><p>Exception thrown when a method is incorrect.</p><p><strong>Fields</strong></p><ul><li><code>var::Symbol</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/exception.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.IncorrectOutput" href="#CTBase.IncorrectOutput"><code>CTBase.IncorrectOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IncorrectOutput &lt;: CTException</code></pre><p>Exception thrown when the output is incorrect.</p><p><strong>Fields</strong></p><ul><li><code>var::String</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/exception.jl#L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Index" href="#CTBase.Index"><code>CTBase.Index</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Index</code></pre><p><strong>Fields</strong></p><ul><li><code>val::Integer</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L1092">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Lagrange" href="#CTBase.Lagrange"><code>CTBase.Lagrange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Lagrange{time_dependence, variable_dependence}</code></pre><p><strong>Fields</strong></p><ul><li><code>f::Function</code></li></ul><p>The default value for <code>time_dependence</code> and <code>variable_dependence</code> are <code>Autonomous</code> and <code>Fixed</code> respectively.</p><p><strong>Constructor</strong></p><p>The constructor <code>Lagrange</code> returns a <code>Lagrange</code> cost of a function. The function must take 2 to 4 arguments, <code>(x, u)</code> to <code>(t, x, u, v)</code>, if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :</p><ul><li>booleans, <code>autonomous</code> and <code>variable</code>, respectively <code>true</code> and <code>false</code> by default </li><li><code>DataType</code>, <code>Autonomous</code>/<code>NonAutonomous</code> and <code>NonFixed</code>/<code>Fixed</code>, respectively <code>Autonomous</code> and <code>Fixed</code> by default.</li></ul><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; Lagrange((x, u) -&gt; 2x[2]-u[1]^2, Int64)
IncorrectArgument
julia&gt; Lagrange((x, u) -&gt; 2x[2]-u[1]^2, Int64)
IncorrectArgument
julia&gt; L = Lagrange((x, u) -&gt; [2x[2]-u[1]^2], autonomous=true, variable=false)
julia&gt; L = Lagrange((x, u) -&gt; 2x[2]-u[1]^2, autonomous=true, variable=false)
julia&gt; L = Lagrange((x, u, v) -&gt; 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)
julia&gt; L = Lagrange((t, x, u) -&gt; t+2x[2]-u[1]^2, autonomous=false, variable=false)
julia&gt; L = Lagrange((t, x, u, v) -&gt; t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)
julia&gt; L = Lagrange((x, u) -&gt; [2x[2]-u[1]^2], Autonomous, Fixed)
julia&gt; L = Lagrange((x, u) -&gt; 2x[2]-u[1]^2, Autonomous, Fixed)
julia&gt; L = Lagrange((x, u, v) -&gt; 2x[2]-u[1]^2+v[3], Autonomous, NonFixed)
julia&gt; L = Lagrange((t, x, u) -&gt; t+2x[2]-u[1]^2, autonomous=false, Fixed)
julia&gt; L = Lagrange((t, x, u, v) -&gt; t+2x[2]-u[1]^2+v[3], autonomous=false, NonFixed)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When the state is of dimension 1, consider <code>x</code> as a scalar. Same for the control.</p></div></div><p><strong>Call</strong></p><p>The call returns the evaluation of the <code>Lagrange</code> cost for given values.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; L = Lagrange((x, u) -&gt; [2x[2]-u[1]^2], autonomous=true, variable=false)
julia&gt; L([1, 0], [1])
MethodError
julia&gt; L = Lagrange((x, u) -&gt; 2x[2]-u[1]^2, autonomous=true, variable=false)
julia&gt; L([1, 0], [1])
-1
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; L(t, [1, 0], [1])
MethodError
julia&gt; L([1, 0], [1], v)
MethodError
julia&gt; L(t, [1, 0], [1], v)
-1
julia&gt; L = Lagrange((x, u, v) -&gt; 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)
julia&gt; L([1, 0], [1], [1, 2, 3])
2
julia&gt; L(t, [1, 0], [1], [1, 2, 3])
2
julia&gt; L = Lagrange((t, x, u) -&gt; t+2x[2]-u[1]^2, autonomous=false, variable=false)
julia&gt; L(1, [1, 0], [1])
0
julia&gt; L(1, [1, 0], [1], v)
0
julia&gt; L = Lagrange((t, x, u, v) -&gt; t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)
julia&gt; L(1, [1, 0], [1], [1, 2, 3])
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L425">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Lagrange-Tuple{Function, Vararg{DataType}}" href="#CTBase.Lagrange-Tuple{Function, Vararg{DataType}}"><code>CTBase.Lagrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Lagrange(
    f::Function,
    dependencies::DataType...
) -&gt; Lagrange{Autonomous, Fixed}
</code></pre><p>Return a <code>Lagrange</code> cost of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.</p><pre><code class="language- hljs">julia&gt; Lagrange((x, u) -&gt; 2x[2]-u[1]^2, Int64)
IncorrectArgument
julia&gt; Lagrange((x, u) -&gt; 2x[2]-u[1]^2, Int64)
IncorrectArgument
julia&gt; L = Lagrange((x, u) -&gt; [2x[2]-u[1]^2], autonomous=true, variable=false)
julia&gt; L = Lagrange((x, u) -&gt; 2x[2]-u[1]^2, autonomous=true, variable=false)
julia&gt; L = Lagrange((x, u, v) -&gt; 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)
julia&gt; L = Lagrange((t, x, u) -&gt; t+2x[2]-u[1]^2, autonomous=false, variable=false)
julia&gt; L = Lagrange((t, x, u, v) -&gt; t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L614-L634">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Lagrange-Tuple{Function}" href="#CTBase.Lagrange-Tuple{Function}"><code>CTBase.Lagrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Lagrange(
    f::Function;
    autonomous,
    variable
) -&gt; Lagrange{Autonomous, Fixed}
</code></pre><p>Return a <code>Lagrange</code> cost of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.</p><pre><code class="language- hljs">julia&gt; L = Lagrange((x, u) -&gt; [2x[2]-u[1]^2], autonomous=true, variable=false)
julia&gt; L = Lagrange((x, u) -&gt; 2x[2]-u[1]^2, autonomous=true, variable=false)
julia&gt; L = Lagrange((x, u, v) -&gt; 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)
julia&gt; L = Lagrange((t, x, u) -&gt; t+2x[2]-u[1]^2, autonomous=false, variable=false)
julia&gt; L = Lagrange((t, x, u, v) -&gt; t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L590-L606">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Lagrange-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}" href="#CTBase.Lagrange-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.Lagrange</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the value of the Lagrange function.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; Lagrange((x, u) -&gt; 2x[2]-u[1]^2, Int64)
IncorrectArgument
julia&gt; Lagrange((x, u) -&gt; 2x[2]-u[1]^2, Int64)
IncorrectArgument
julia&gt; L = Lagrange((x, u) -&gt; [2x[2]-u[1]^2], autonomous=true, variable=false)
julia&gt; L([1, 0], [1])
MethodError
julia&gt; L = Lagrange((x, u) -&gt; 2x[2]-u[1]^2, autonomous=true, variable=false)
julia&gt; L([1, 0], [1])
-1
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; L(t, [1, 0], [1])
MethodError
julia&gt; L([1, 0], [1], v)
MethodError
julia&gt; L(t, [1, 0], [1], v)
-1
julia&gt; L = Lagrange((x, u, v) -&gt; 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)
julia&gt; L([1, 0], [1], [1, 2, 3])
2
julia&gt; L(t, [1, 0], [1], [1, 2, 3])
2
julia&gt; L = Lagrange((t, x, u) -&gt; t+2x[2]-u[1]^2, autonomous=false, variable=false)
julia&gt; L(1, [1, 0], [1])
0
julia&gt; L(1, [1, 0], [1], v)
0
julia&gt; L = Lagrange((t, x, u, v) -&gt; t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)
julia&gt; L(1, [1, 0], [1], [1, 2, 3])
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L642-L683">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Mayer" href="#CTBase.Mayer"><code>CTBase.Mayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Mayer{variable_dependence}</code></pre><p><strong>Fields</strong></p><ul><li><code>f::Function</code></li></ul><p>The default value for <code>variable_dependence</code> is <code>Fixed</code>.</p><p><strong>Constructor</strong></p><p>The constructor <code>Mayer</code> returns a <code>Mayer</code> cost of a function. The function must take 2 or 3 arguments <code>(x0, xf)</code> or <code>(x0, xf, v)</code>, if the function is variable, it must be specified.  Dependencies are specified with a boolean, <code>variable</code>, <code>false</code> by default or with a <code>DataType</code>, <code>NonFixed/Fixed</code>, <code>Fixed</code> by default.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; G = Mayer((x0, xf) -&gt; xf[2]-x0[1])
julia&gt; G = Mayer((x0, xf, v) -&gt; v[3]+xf[2]-x0[1], variable=true)
julia&gt; G = Mayer((x0, xf, v) -&gt; v[3]+xf[2]-x0[1], NonFixed)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When the state is of dimension 1, consider <code>x0</code> and <code>xf</code> as a scalar.</p></div></div><p><strong>Call</strong></p><p>The call returns the evaluation of the <code>Mayer</code> cost for given values. If a variable is given for a non variable dependent Mayer cost, it will be ignored.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; G = Mayer((x0, xf) -&gt; xf[2]-x0[1])
julia&gt; G([0, 0], [1, 1])
1
julia&gt; G = Mayer((x0, xf) -&gt; xf[2]-x0[1])
julia&gt; G([0, 0], [1, 1],Real[])
1
julia&gt; G = Mayer((x0, xf, v) -&gt; v[3]+xf[2]-x0[1], variable=true)
julia&gt; G([0, 0], [1, 1], [1, 2, 3])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Mayer-Tuple{Function, Vararg{DataType}}" href="#CTBase.Mayer-Tuple{Function, Vararg{DataType}}"><code>CTBase.Mayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Mayer(
    f::Function,
    dependencies::DataType...
) -&gt; Mayer{Fixed}
</code></pre><p>Return a <code>Mayer</code> cost of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.</p><pre><code class="language- hljs">julia&gt; G = Mayer((x0, xf) -&gt; xf[2]-x0[1])
julia&gt; G = Mayer((x0, xf, v) -&gt; v[3]+xf[2]-x0[1], NonFixed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L88-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Mayer-Tuple{Function}" href="#CTBase.Mayer-Tuple{Function}"><code>CTBase.Mayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Mayer(f::Function; variable) -&gt; Mayer{Fixed}
</code></pre><p>Return a <code>Mayer</code> cost of a function. Dependencies are specified with a boolean, variable, false by default.</p><pre><code class="language- hljs">julia&gt; G = Mayer((x0, xf) -&gt; xf[2]-x0[1])
julia&gt; G = Mayer((x0, xf, v) -&gt; v[3]+xf[2]-x0[1], variable=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L70-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Mayer-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}" href="#CTBase.Mayer-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.Mayer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the evaluation of the Mayer cost.</p><pre><code class="language- hljs">julia&gt; G = Mayer((x0, xf) -&gt; xf[2]-x0[1])
julia&gt; G([0, 0], [1, 1])
1
julia&gt; G = Mayer((x0, xf) -&gt; xf[2]-x0[1])
julia&gt; G([0, 0], [1, 1], Real[])
1
julia&gt; G = Mayer((x0, xf, v) -&gt; v[3]+xf[2]-x0[1], variable=true)
julia&gt; G([0, 0], [1, 1], [1, 2, 3])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L107-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.MixedConstraint" href="#CTBase.MixedConstraint"><code>CTBase.MixedConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MixedConstraint{time_dependence, variable_dependence}</code></pre><p><strong>Fields</strong></p><ul><li><code>f::Function</code></li></ul><p>Similar to <code>Lagrange</code> in the usage, but the dimension of the output of the function <code>f</code> is arbitrary.</p><p>The default value for <code>time_dependence</code> and <code>variable_dependence</code> are <code>Autonomous</code> and <code>Fixed</code> respectively.</p><p><strong>Constructor</strong></p><p>The constructor <code>MixedConstraint</code> returns a <code>MixedConstraint</code> of a function. The function must take 2 to 4 arguments, <code>(x, u)</code> to <code>(t, x, u, v)</code>, if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :</p><ul><li>booleans, <code>autonomous</code> and <code>variable</code>, respectively <code>true</code> and <code>false</code> by default </li><li><code>DataType</code>, <code>Autonomous</code>/<code>NonAutonomous</code> and <code>NonFixed</code>/<code>Fixed</code>, respectively <code>Autonomous</code> and <code>Fixed</code> by default.</li></ul><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; MixedConstraint((x, u) -&gt; [2x[2]-u^2, x[1]], Int64)
IncorrectArgument
julia&gt; MixedConstraint((x, u) -&gt; [2x[2]-u^2, x[1]], Int64)
IncorrectArgument
julia&gt; M = MixedConstraint((x, u) -&gt; [2x[2]-u^2, x[1]], Autonomous, Fixed)
julia&gt; M = MixedConstraint((x, u, v) -&gt; [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)
julia&gt; M = MixedConstraint((t, x, u) -&gt; [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)
julia&gt; M = MixedConstraint((t, x, u, v) -&gt; [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)
julia&gt; M = MixedConstraint((x, u) -&gt; [2x[2]-u^2, x[1]], autonomous=true, variable=false)
julia&gt; M = MixedConstraint((x, u, v) -&gt; [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)
julia&gt; M = MixedConstraint((t, x, u) -&gt; [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)
julia&gt; M = MixedConstraint((t, x, u, v) -&gt; [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When the state is of dimension 1, consider <code>x</code> as a scalar. Same for the control.</p></div></div><p><strong>Call</strong></p><p>The call returns the evaluation of the <code>MixedConstraint</code> for given values.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; MixedConstraint((x, u) -&gt; [2x[2]-u^2, x[1]], Int64)
IncorrectArgument
julia&gt; MixedConstraint((x, u) -&gt; [2x[2]-u^2, x[1]], Int64)
IncorrectArgument
julia&gt; M = MixedConstraint((x, u) -&gt; [2x[2]-u^2, x[1]], autonomous=true, variable=false)
julia&gt; M([1, 0], 1)
[-1, 1]
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; MethodError M(t, [1, 0], 1)
julia&gt; MethodError M([1, 0], 1, v)
julia&gt; M(t, [1, 0], 1, v)
[-1, 1]
julia&gt; M = MixedConstraint((x, u, v) -&gt; [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)
julia&gt; M([1, 0], 1, [1, 2, 3])
[2, 1]
julia&gt; M(t, [1, 0], 1, [1, 2, 3])
[2, 1]
julia&gt; M = MixedConstraint((t, x, u) -&gt; [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)
julia&gt; M(1, [1, 0], 1)
[0, 1]
julia&gt; M(1, [1, 0], 1, v)
[0, 1]
julia&gt; M = MixedConstraint((t, x, u, v) -&gt; [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)
julia&gt; M(1, [1, 0], 1, [1, 2, 3])
[3, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L730">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.MixedConstraint-Tuple{Function, Vararg{DataType}}" href="#CTBase.MixedConstraint-Tuple{Function, Vararg{DataType}}"><code>CTBase.MixedConstraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MixedConstraint(
    f::Function,
    dependencies::DataType...
) -&gt; MixedConstraint{Autonomous, Fixed}
</code></pre><p>Return the <code>MixedConstraint</code> of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.</p><pre><code class="language- hljs">julia&gt; MixedConstraint((x, u) -&gt; [2x[2]-u^2, x[1]], Int64)
IncorrectArgument
julia&gt; MixedConstraint((x, u) -&gt; [2x[2]-u^2, x[1]], Int64)
IncorrectArgument
julia&gt; M = MixedConstraint((x, u) -&gt; [2x[2]-u^2, x[1]], Autonomous, Fixed)
julia&gt; M = MixedConstraint((x, u, v) -&gt; [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)
julia&gt; M = MixedConstraint((t, x, u) -&gt; [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)
julia&gt; M = MixedConstraint((t, x, u, v) -&gt; [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L1051-L1068">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.MixedConstraint-Tuple{Function}" href="#CTBase.MixedConstraint-Tuple{Function}"><code>CTBase.MixedConstraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MixedConstraint(
    f::Function;
    autonomous,
    variable
) -&gt; MixedConstraint{Autonomous, Fixed}
</code></pre><p>Return the <code>MixedConstraint</code> of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.</p><pre><code class="language- hljs">julia&gt; M = MixedConstraint((x, u) -&gt; [2x[2]-u^2, x[1]], autonomous=true, variable=false)
julia&gt; M = MixedConstraint((x, u, v) -&gt; [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)
julia&gt; M = MixedConstraint((t, x, u) -&gt; [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)
julia&gt; M = MixedConstraint((t, x, u, v) -&gt; [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L1030-L1043">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.MixedConstraint-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}" href="#CTBase.MixedConstraint-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.MixedConstraint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the value of the MixedConstraint function.</p><pre><code class="language- hljs">julia&gt; MixedConstraint((x, u) -&gt; [2x[2]-u^2, x[1]], Int64)
IncorrectArgument
julia&gt; MixedConstraint((x, u) -&gt; [2x[2]-u^2, x[1]], Int64)
IncorrectArgument
julia&gt; M = MixedConstraint((x, u) -&gt; [2x[2]-u^2, x[1]], autonomous=true, variable=false)
julia&gt; M([1, 0], 1)
[-1, 1]
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; MethodError M(t, [1, 0], 1)
julia&gt; MethodError M([1, 0], 1, v)
julia&gt; M(t, [1, 0], 1, v)
[-1, 1]
julia&gt; M = MixedConstraint((x, u, v) -&gt; [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)
julia&gt; M([1, 0], 1, [1, 2, 3])
[2, 1]
julia&gt; M(t, [1, 0], 1, [1, 2, 3])
[2, 1]
julia&gt; M = MixedConstraint((t, x, u) -&gt; [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)
julia&gt; M(1, [1, 0], 1)
[0, 1]
julia&gt; M(1, [1, 0], 1, v)
[0, 1]
julia&gt; M = MixedConstraint((t, x, u, v) -&gt; [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)
julia&gt; M(1, [1, 0], 1, [1, 2, 3])
[3, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L1076-L1110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Multiplier" href="#CTBase.Multiplier"><code>CTBase.Multiplier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Multiplier{time_dependence, variable_dependence}</code></pre><p><strong>Fields</strong></p><ul><li><code>f::Function</code></li></ul><p>Similar to <code>ControlLaw</code> in the usage.</p><p>The default values for <code>time_dependence</code> and <code>variable_dependence</code> are <code>Autonomous</code> and <code>Fixed</code> respectively.</p><p><strong>Constructor</strong></p><p>The constructor <code>Multiplier</code> returns a <code>Multiplier</code> of a function. The function must take 2 to 4 arguments, <code>(x, p)</code> to <code>(t, x, p, v)</code>, if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :</p><ul><li>booleans, <code>autonomous</code> and <code>variable</code>, respectively <code>true</code> and <code>false</code> by default </li><li><code>DataType</code>, <code>Autonomous</code>/<code>NonAutonomous</code> and <code>NonFixed</code>/<code>Fixed</code>, respectively <code>Autonomous</code> and <code>Fixed</code> by default.</li></ul><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; Multiplier((x, p) -&gt; x[1]^2+2p[2], Int64)
IncorrectArgument
julia&gt; Multiplier((x, p) -&gt; x[1]^2+2p[2], Int64)
IncorrectArgument
julia&gt; μ = Multiplier((x, p) -&gt; x[1]^2+2p[2], Autonomous, Fixed)
julia&gt; μ = Multiplier((x, p, v) -&gt; x[1]^2+2p[2]+v[3], Autonomous, NonFixed)
julia&gt; μ = Multiplier((t, x, p) -&gt; t+x[1]^2+2p[2], NonAutonomous, Fixed)
julia&gt; μ = Multiplier((t, x, p, v) -&gt; t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)
julia&gt; μ = Multiplier((x, p) -&gt; x[1]^2+2p[2], autonomous=true, variable=false)
julia&gt; μ = Multiplier((x, p, v) -&gt; x[1]^2+2p[2]+v[3], autonomous=true, variable=true)
julia&gt; μ = Multiplier((t, x, p) -&gt; t+x[1]^2+2p[2], autonomous=false, variable=false)
julia&gt; μ = Multiplier((t, x, p, v) -&gt; t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When the state and costate are of dimension 1, consider <code>x</code> and <code>p</code> as scalars.</p></div></div><p><strong>Call</strong></p><p>The call returns the evaluation of the <code>Multiplier</code> for given values.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; μ = Multiplier((x, p) -&gt; x[1]^2+2p[2], autonomous=true, variable=false)
julia&gt; μ([1, 0], [0, 1])
3
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; μ(t, [1, 0], [0, 1])
MethodError
julia&gt; μ([1, 0], [0, 1], v)
MethodError
julia&gt; μ(t, [1, 0], [0, 1], v)
3
julia&gt; μ = Multiplier((x, p, v) -&gt; x[1]^2+2p[2]+v[3], autonomous=true, variable=true)
julia&gt; μ([1, 0], [0, 1], [1, 2, 3])
6
julia&gt; μ(t, [1, 0], [0, 1], [1, 2, 3])
6
julia&gt; μ = Multiplier((t, x, p) -&gt; t+x[1]^2+2p[2], autonomous=false, variable=false)
julia&gt; μ(1, [1, 0], [0, 1])
4
julia&gt; μ(1, [1, 0], [0, 1], v)
4
julia&gt; μ = Multiplier((t, x, p, v) -&gt; t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)
julia&gt; μ(1, [1, 0], [0, 1], [1, 2, 3])
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L1011">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Multiplier-Tuple{Function, Vararg{DataType}}" href="#CTBase.Multiplier-Tuple{Function, Vararg{DataType}}"><code>CTBase.Multiplier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Multiplier(
    f::Function,
    dependencies::DataType...
) -&gt; Multiplier{Autonomous, Fixed}
</code></pre><p>Return the <code>Multiplier</code> of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.</p><pre><code class="language- hljs">julia&gt; Multiplier((x, p) -&gt; x[1]^2+2p[2], Int64)
IncorrectArgument
julia&gt; Multiplier((x, p) -&gt; x[1]^2+2p[2], Int64)
IncorrectArgument
julia&gt; μ = Multiplier((x, p) -&gt; x[1]^2+2p[2], Autonomous, Fixed)
julia&gt; μ = Multiplier((x, p, v) -&gt; x[1]^2+2p[2]+v[3], Autonomous, NonFixed)
julia&gt; μ = Multiplier((t, x, p) -&gt; t+x[1]^2+2p[2], NonAutonomous, Fixed)
julia&gt; μ = Multiplier((t, x, p, v) -&gt; t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L1402-L1419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Multiplier-Tuple{Function}" href="#CTBase.Multiplier-Tuple{Function}"><code>CTBase.Multiplier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Multiplier(
    f::Function;
    autonomous,
    variable
) -&gt; Multiplier{Autonomous, Fixed}
</code></pre><p>Return the <code>Multiplier</code> of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.</p><pre><code class="language- hljs">julia&gt; μ = Multiplier((x, p) -&gt; x[1]^2+2p[2], autonomous=true, variable=false)
julia&gt; μ = Multiplier((x, p, v) -&gt; x[1]^2+2p[2]+v[3], autonomous=true, variable=true)
julia&gt; μ = Multiplier((t, x, p) -&gt; t+x[1]^2+2p[2], autonomous=false, variable=false)
julia&gt; μ = Multiplier((t, x, p, v) -&gt; t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L1381-L1394">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Multiplier-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}" href="#CTBase.Multiplier-Tuple{Union{Real, AbstractVector{&lt;:Real}}, Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.Multiplier</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the value of the Multiplier function.</p><pre><code class="language- hljs">julia&gt; Multiplier((x, p) -&gt; x[1]^2+2p[2], Int64)
IncorrectArgument
julia&gt; Multiplier((x, p) -&gt; x[1]^2+2p[2], Int64)
IncorrectArgument
julia&gt; μ = Multiplier((x, p) -&gt; x[1]^2+2p[2], autonomous=true, variable=false)
julia&gt; μ([1, 0], [0, 1])
3
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; μ(t, [1, 0], [0, 1])
MethodError
julia&gt; μ([1, 0], [0, 1], v)
MethodError
julia&gt; μ(t, [1, 0], [0, 1], v)
3
julia&gt; μ = Multiplier((x, p, v) -&gt; x[1]^2+2p[2]+v[3], autonomous=true, variable=true)
julia&gt; μ([1, 0], [0, 1], [1, 2, 3])
6
julia&gt; μ(t, [1, 0], [0, 1], [1, 2, 3])
6
julia&gt; μ = Multiplier((t, x, p) -&gt; t+x[1]^2+2p[2], autonomous=false, variable=false)
julia&gt; μ(1, [1, 0], [0, 1])
4
julia&gt; μ(1, [1, 0], [0, 1], v)
4
julia&gt; μ = Multiplier((t, x, p, v) -&gt; t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)
julia&gt; μ(1, [1, 0], [0, 1], [1, 2, 3])
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L1427-L1463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.NonAutonomous" href="#CTBase.NonAutonomous"><code>CTBase.NonAutonomous</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type NonAutonomous &lt;: TimeDependence</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L1133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.NonFixed" href="#CTBase.NonFixed"><code>CTBase.NonFixed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type NonFixed &lt;: VariableDependence</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L1141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.NotImplemented" href="#CTBase.NotImplemented"><code>CTBase.NotImplemented</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NotImplemented &lt;: CTException</code></pre><p>Exception thrown when a method is not implemented.</p><p><strong>Fields</strong></p><ul><li><code>var::String</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/exception.jl#L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.OptimalControlInit" href="#CTBase.OptimalControlInit"><code>CTBase.OptimalControlInit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Initial guess for OCP, contains</p><ul><li>functions of time for the state and control variables</li><li>vector for optimization variables</li></ul><p>Initialization data for each field can be left to default or: </p><ul><li>vector for optimization variables</li><li>constant / vector / function for state and control  </li><li>existing solution (&#39;warm start&#39;) for all fields</li></ul><p><strong>Constructors:</strong></p><ul><li><code>OptimalControlInit()</code>: default initialization</li><li><code>OptimalControlInit(state, control, variable, time)</code>: constant vector, function handles and / or matrices / vectors interpolated along given time grid</li><li><code>OptimalControlInit(sol)</code>: from existing solution</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; init = OptimalControlInit()
julia&gt; init = OptimalControlInit(state=[0.1, 0.2], control=0.3)
julia&gt; init = OptimalControlInit(state=[0.1, 0.2], control=0.3, variable=0.5)
julia&gt; init = OptimalControlInit(state=[0.1, 0.2], controlt=t-&gt;sin(t), variable=0.5)
julia&gt; init = OptimalControlInit(state=[[0, 0], [1, 2], [5, -1]], time=[0, .3, 1.], controlt=t-&gt;sin(t))
julia&gt; init = OptimalControlInit(sol)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/init.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.OptimalControlModel" href="#CTBase.OptimalControlModel"><code>CTBase.OptimalControlModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct OptimalControlModel{time_dependence&lt;:TimeDependence, variable_dependence&lt;:VariableDependence} &lt;: CTBase.AbstractOptimalControlModel</code></pre><p><strong>Fields</strong></p><ul><li><p><code>model_expression::Union{Nothing, Expr}</code>: Default: nothing</p></li><li><p><code>initial_time::Union{Nothing, Index, Real}</code>: Default: nothing</p></li><li><p><code>initial_time_name::Union{Nothing, String}</code>: Default: nothing</p></li><li><p><code>final_time::Union{Nothing, Index, Real}</code>: Default: nothing</p></li><li><p><code>final_time_name::Union{Nothing, String}</code>: Default: nothing</p></li><li><p><code>time_name::Union{Nothing, String}</code>: Default: nothing</p></li><li><p><code>control_dimension::Union{Nothing, Integer}</code>: Default: nothing</p></li><li><p><code>control_components_names::Union{Nothing, Vector{String}}</code>: Default: nothing</p></li><li><p><code>control_name::Union{Nothing, String}</code>: Default: nothing</p></li><li><p><code>state_dimension::Union{Nothing, Integer}</code>: Default: nothing</p></li><li><p><code>state_components_names::Union{Nothing, Vector{String}}</code>: Default: nothing</p></li><li><p><code>state_name::Union{Nothing, String}</code>: Default: nothing</p></li><li><p><code>variable_dimension::Union{Nothing, Integer}</code>: Default: nothing</p></li><li><p><code>variable_components_names::Union{Nothing, Vector{String}}</code>: Default: nothing</p></li><li><p><code>variable_name::Union{Nothing, String}</code>: Default: nothing</p></li><li><p><code>lagrange::Union{Nothing, Lagrange}</code>: Default: nothing</p></li><li><p><code>mayer::Union{Nothing, Mayer}</code>: Default: nothing</p></li><li><p><code>criterion::Union{Nothing, Symbol}</code>: Default: nothing</p></li><li><p><code>dynamics::Union{Nothing, Dynamics}</code>: Default: nothing</p></li><li><p><code>constraints::Dict{Symbol, Tuple}</code>: Default: Dict{Symbol, Tuple{Vararg{Any}}}()</p></li><li><p><code>dim_control_constraints::Union{Nothing, Integer}</code>: Default: nothing</p></li><li><p><code>dim_state_constraints::Union{Nothing, Integer}</code>: Default: nothing</p></li><li><p><code>dim_mixed_constraints::Union{Nothing, Integer}</code>: Default: nothing</p></li><li><p><code>dim_boundary_constraints::Union{Nothing, Integer}</code>: Default: nothing</p></li><li><p><code>dim_variable_constraints::Union{Nothing, Integer}</code>: Default: nothing</p></li><li><p><code>dim_control_range::Union{Nothing, Integer}</code>: Default: nothing</p></li><li><p><code>dim_state_range::Union{Nothing, Integer}</code>: Default: nothing</p></li><li><p><code>dim_variable_range::Union{Nothing, Integer}</code>: Default: nothing</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L1149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.OptimalControlSolution" href="#CTBase.OptimalControlSolution"><code>CTBase.OptimalControlSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct OptimalControlSolution &lt;: CTBase.AbstractOptimalControlSolution</code></pre><p>Type of an optimal control solution.</p><p><strong>Fields</strong></p><ul><li><p><code>times::Union{Nothing, StepRangeLen, AbstractVector{&lt;:Real}}</code>: Default: nothing</p></li><li><p><code>initial_time_name::Union{Nothing, String}</code>: Default: nothing</p></li><li><p><code>final_time_name::Union{Nothing, String}</code>: Default: nothing</p></li><li><p><code>time_name::Union{Nothing, String}</code>: Default: nothing</p></li><li><p><code>control_dimension::Union{Nothing, Integer}</code>: Default: nothing</p></li><li><p><code>control_components_names::Union{Nothing, Vector{String}}</code>: Default: nothing</p></li><li><p><code>control_name::Union{Nothing, String}</code>: Default: nothing</p></li><li><p><code>control::Union{Nothing, Function}</code>: Default: nothing</p></li><li><p><code>state_dimension::Union{Nothing, Integer}</code>: Default: nothing</p></li><li><p><code>state_components_names::Union{Nothing, Vector{String}}</code>: Default: nothing</p></li><li><p><code>state_name::Union{Nothing, String}</code>: Default: nothing</p></li><li><p><code>state::Union{Nothing, Function}</code>: Default: nothing</p></li><li><p><code>variable_dimension::Union{Nothing, Integer}</code>: Default: nothing</p></li><li><p><code>variable_components_names::Union{Nothing, Vector{String}}</code>: Default: nothing</p></li><li><p><code>variable_name::Union{Nothing, String}</code>: Default: nothing</p></li><li><p><code>variable::Union{Nothing, Real, AbstractVector{&lt;:Real}}</code>: Default: nothing</p></li><li><p><code>costate::Union{Nothing, Function}</code>: Default: nothing</p></li><li><p><code>objective::Union{Nothing, Real}</code>: Default: nothing</p></li><li><p><code>iterations::Union{Nothing, Integer}</code>: Default: nothing</p></li><li><p><code>stopping::Union{Nothing, Symbol}</code>: Default: nothing</p></li><li><p><code>message::Union{Nothing, String}</code>: Default: nothing</p></li><li><p><code>success::Union{Nothing, Bool}</code>: Default: nothing</p></li><li><p><code>infos::Dict{Symbol, Any}</code>: Default: Dict{Symbol, Any}()</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L1286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ParsingError" href="#CTBase.ParsingError"><code>CTBase.ParsingError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ParsingError &lt;: CTException</code></pre><p>Exception thrown for syntax error during abstract parsing.</p><p><strong>Fields</strong></p><ul><li><code>var::String</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/exception.jl#L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.PrintCallback" href="#CTBase.PrintCallback"><code>CTBase.PrintCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct PrintCallback &lt;: CTCallback</code></pre><p>Callback for printing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/callback.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.PrintCallback-Tuple" href="#CTBase.PrintCallback-Tuple"><code>CTBase.PrintCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Call the callback.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/callback.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.StateConstraint" href="#CTBase.StateConstraint"><code>CTBase.StateConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct StateConstraint{time_dependence, variable_dependence}</code></pre><p><strong>Fields</strong></p><ul><li><code>f::Function</code></li></ul><p>Similar to <code>VectorField</code> in the usage, but the dimension of the output of the function <code>f</code> is arbitrary.</p><p>The default values for <code>time_dependence</code> and <code>variable_dependence</code> are <code>Autonomous</code> and <code>Fixed</code> respectively.</p><p><strong>Constructor</strong></p><p>The constructor <code>StateConstraint</code> returns a <code>StateConstraint</code> of a function. The function must take 1 to 3 arguments, <code>x</code> to <code>(t, x, v)</code>, if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :</p><ul><li>booleans, <code>autonomous</code> and <code>variable</code>, respectively <code>true</code> and <code>false</code> by default </li><li><code>DataType</code>, <code>Autonomous</code>/<code>NonAutonomous</code> and <code>NonFixed</code>/<code>Fixed</code>, respectively <code>Autonomous</code> and <code>Fixed</code> by default.</li></ul><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; StateConstraint(x -&gt; [x[1]^2, 2x[2]], Int64)
IncorrectArgument
julia&gt; StateConstraint(x -&gt; [x[1]^2, 2x[2]], Int64)
IncorrectArgument
julia&gt; S = StateConstraint(x -&gt; [x[1]^2, 2x[2]], Autonomous, Fixed)
julia&gt; S = StateConstraint((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)
julia&gt; S = StateConstraint((t, x) -&gt; [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)
julia&gt; S = StateConstraint((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)
julia&gt; S = StateConstraint(x -&gt; [x[1]^2, 2x[2]], autonomous=true, variable=false)
julia&gt; S = StateConstraint((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)
julia&gt; S = StateConstraint((t, x) -&gt; [t+x[1]^2, 2x[2]], autonomous=false, variable=false)
julia&gt; S = StateConstraint((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When the state is of dimension 1, consider <code>x</code> as a scalar.</p></div></div><p><strong>Call</strong></p><p>The call returns the evaluation of the <code>StateConstraint</code> for given values.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; StateConstraint(x -&gt; [x[1]^2, 2x[2]], Int64)
IncorrectArgument
julia&gt; StateConstraint(x -&gt; [x[1]^2, 2x[2]], Int64)
IncorrectArgument
julia&gt; S = StateConstraint(x -&gt; [x[1]^2, 2x[2]], autonomous=true, variable=false)
julia&gt; S([1, -1])
[1, -2]
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; S(t, [1, -1], v)
[1, -2]
julia&gt; S = StateConstraint((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)
julia&gt; S([1, -1], [1, 2, 3])
[1, 1]
julia&gt; S(t, [1, -1], [1, 2, 3])
[1, 1]
julia&gt; S = StateConstraint((t, x) -&gt; [t+x[1]^2, 2x[2]], autonomous=false, variable=false)
julia&gt;  S(1, [1, -1])
[2, -2]
julia&gt;  S(1, [1, -1], v)
[2, -2]
julia&gt; S = StateConstraint((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)
julia&gt;  S(1, [1, -1], [1, 2, 3])
[2, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L579">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.StateConstraint-Tuple{Function, Vararg{DataType}}" href="#CTBase.StateConstraint-Tuple{Function, Vararg{DataType}}"><code>CTBase.StateConstraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StateConstraint(
    f::Function,
    dependencies::DataType...
) -&gt; StateConstraint{Autonomous, Fixed}
</code></pre><p>Return the <code>StateConstraint</code> of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.</p><pre><code class="language- hljs">julia&gt; StateConstraint(x -&gt; [x[1]^2, 2x[2]], Int64)
IncorrectArgument
julia&gt; StateConstraint(x -&gt; [x[1]^2, 2x[2]], Int64)
IncorrectArgument
julia&gt; S = StateConstraint(x -&gt; [x[1]^2, 2x[2]], Autonomous, Fixed)
julia&gt; S = StateConstraint((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)
julia&gt; S = StateConstraint((t, x) -&gt; [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)
julia&gt; S = StateConstraint((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L838-L855">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.StateConstraint-Tuple{Function}" href="#CTBase.StateConstraint-Tuple{Function}"><code>CTBase.StateConstraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StateConstraint(
    f::Function;
    autonomous,
    variable
) -&gt; StateConstraint{Autonomous, Fixed}
</code></pre><p>Return the <code>StateConstraint</code> of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.</p><pre><code class="language- hljs">julia&gt; S = StateConstraint(x -&gt; [x[1]^2, 2x[2]], autonomous=true, variable=false)
julia&gt; S = StateConstraint((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)
julia&gt; S = StateConstraint((t, x) -&gt; [t+x[1]^2, 2x[2]], autonomous=false, variable=false)
julia&gt; S = StateConstraint((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L817-L830">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.StateConstraint-Tuple{Union{Real, AbstractVector{&lt;:Real}}}" href="#CTBase.StateConstraint-Tuple{Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.StateConstraint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the value of the StateConstraint function.</p><pre><code class="language- hljs">julia&gt; StateConstraint(x -&gt; [x[1]^2, 2x[2]], Int64)
IncorrectArgument
julia&gt; StateConstraint(x -&gt; [x[1]^2, 2x[2]], Int64)
IncorrectArgument
julia&gt; S = StateConstraint(x -&gt; [x[1]^2, 2x[2]], autonomous=true, variable=false)
julia&gt; S([1, -1])
[1, -2]
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; S(t, [1, -1], v)
[1, -2]
julia&gt; S = StateConstraint((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)
julia&gt; S([1, -1], [1, 2, 3])
[1, 1]
julia&gt; S(t, [1, -1], [1, 2, 3])
[1, 1]
julia&gt; S = StateConstraint((t, x) -&gt; [t+x[1]^2, 2x[2]], autonomous=false, variable=false)
julia&gt;  S(1, [1, -1])
[2, -2]
julia&gt;  S(1, [1, -1], v)
[2, -2]
julia&gt; S = StateConstraint((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)
julia&gt;  S(1, [1, -1], [1, 2, 3])
[2, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L863-L895">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.States" href="#CTBase.States"><code>CTBase.States</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for a vector of states.</p><pre><code class="language- hljs">julia&gt; const States = AbstractVector{&lt;:State}</code></pre><p>See also: <a href="api-ctbase.html#CTBase.State"><code>State</code></a>, <a href="api-ctbase.html#CTBase.Costates"><code>Costates</code></a>, <a href="api-ctbase.html#CTBase.Controls"><code>Controls</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L130-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.StopCallback" href="#CTBase.StopCallback"><code>CTBase.StopCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Stopping callback.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/callback.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.StopCallback-Tuple" href="#CTBase.StopCallback-Tuple"><code>CTBase.StopCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Call the callback.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/callback.jl#L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Time" href="#CTBase.Time"><code>CTBase.Time</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for a time.</p><pre><code class="language- hljs">julia&gt; const Time = ctNumber</code></pre><p>See also: <a href="api-ctbase.html#CTBase.ctNumber"><code>ctNumber</code></a>, <a href="api-ctbase.html#CTBase.Times"><code>Times</code></a>, <a href="api-ctbase.html#CTBase.TimesDisc"><code>TimesDisc</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L53-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.TimeDependence" href="#CTBase.TimeDependence"><code>CTBase.TimeDependence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type TimeDependence</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L1125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Times" href="#CTBase.Times"><code>CTBase.Times</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for a vector of times.</p><pre><code class="language- hljs">julia&gt; const Times = AbstractVector{&lt;:Time}</code></pre><p>See also: <a href="api-ctbase.html#CTBase.Time"><code>Time</code></a>, <a href="api-ctbase.html#CTBase.TimesDisc"><code>TimesDisc</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L64-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.UnauthorizedCall" href="#CTBase.UnauthorizedCall"><code>CTBase.UnauthorizedCall</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UnauthorizedCall &lt;: CTException</code></pre><p>Exception thrown when a call to a function is not authorized.</p><p><strong>Fields</strong></p><ul><li><code>var::String</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/exception.jl#L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.VariableConstraint" href="#CTBase.VariableConstraint"><code>CTBase.VariableConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VariableConstraint</code></pre><p><strong>Fields</strong></p><ul><li><code>f::Function</code></li></ul><p>The default values for <code>time_dependence</code> and <code>variable_dependence</code> are <code>Autonomous</code> and <code>Fixed</code> respectively.</p><p><strong>Constructor</strong></p><p>The constructor <code>VariableConstraint</code> returns a <code>VariableConstraint</code> of a function. The function must take 1 argument, <code>v</code>.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; V = VariableConstraint(v -&gt; [v[1]^2, 2v[2]])</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When the variable is of dimension 1, consider <code>v</code> as a scalar.</p></div></div><p><strong>Call</strong></p><p>The call returns the evaluation of the <code>VariableConstraint</code> for given values.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; V = VariableConstraint(v -&gt; [v[1]^2, 2v[2]])
julia&gt; V([1, -1])
[1, -2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L811">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.VariableConstraint-Tuple{Union{Real, AbstractVector{&lt;:Real}}}" href="#CTBase.VariableConstraint-Tuple{Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.VariableConstraint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the value of the VariableConstraint function.</p><pre><code class="language- hljs">julia&gt; V = VariableConstraint(v -&gt; [v[1]^2, 2v[2]])
julia&gt; V([1, -1])
[1, -2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L1140-L1151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.VariableDependence" href="#CTBase.VariableDependence"><code>CTBase.VariableDependence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type VariableDependence</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L1137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.VectorField" href="#CTBase.VectorField"><code>CTBase.VectorField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VectorField{time_dependence, variable_dependence} &lt;: CTBase.AbstractVectorField{time_dependence, variable_dependence}</code></pre><p><strong>Fields</strong></p><ul><li><code>f::Function</code></li></ul><p>The default values for <code>time_dependence</code> and <code>variable_dependence</code> are <code>Autonomous</code> and <code>Fixed</code> respectively.</p><p><strong>Constructor</strong></p><p>The constructor <code>VectorField</code> returns a <code>VectorField</code> of a function. The function must take 1 to 3 arguments, <code>x</code> to <code>(t, x, v)</code>, if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :</p><ul><li>booleans, <code>autonomous</code> and <code>variable</code>, respectively <code>true</code> and <code>false</code> by default </li><li><code>DataType</code>, <code>Autonomous</code>/<code>NonAutonomous</code> and <code>NonFixed</code>/<code>Fixed</code>, respectively <code>Autonomous</code> and <code>Fixed</code> by default.</li></ul><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; VectorField(x -&gt; [x[1]^2, 2x[2]], Int64)
IncorrectArgument
julia&gt; VectorField(x -&gt; [x[1]^2, 2x[2]], Int64)
IncorrectArgument
julia&gt; V = VectorField(x -&gt; [x[1]^2, 2x[2]]) # autonomous=true, variable=false
julia&gt; V = VectorField((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], variable=true)
julia&gt; V = VectorField((t, x) -&gt; [t+x[1]^2, 2x[2]], autonomous=false)
julia&gt; V = VectorField((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)
julia&gt; V = VectorField((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], NonFixed)
julia&gt; V = VectorField((t, x) -&gt; [t+x[1]^2, 2x[2]], NonAutonomous)
julia&gt; V = VectorField((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When the state is of dimension 1, consider <code>x</code> as a scalar.</p></div></div><p><strong>Call</strong></p><p>The call returns the evaluation of the <code>VectorField</code> for given values.</p><p><strong><em>Examples</em></strong></p><pre><code class="language- hljs">julia&gt; V = VectorField(x -&gt; [x[1]^2, 2x[2]]) # autonomous=true, variable=false
julia&gt; V([1, -1])
[1, -2]
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; V(t, [1, -1])
MethodError
julia&gt; V([1, -1], v)
MethodError
julia&gt; V(t, [1, -1], v)
[1, -2]
julia&gt; V = VectorField((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], variable=true)
julia&gt; V([1, -1], [1, 2, 3])
[1, 1]
julia&gt; V(t, [1, -1], [1, 2, 3])
[1, 1]
julia&gt; V = VectorField((t, x) -&gt; [t+x[1]^2, 2x[2]], autonomous=false)
julia&gt; V(1, [1, -1])
[2, -2]
julia&gt; V(1, [1, -1], v)
[2, -2]
julia&gt; V = VectorField((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)
julia&gt; V(1, [1, -1], [1, 2, 3])
[2, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/types.jl#L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.VectorField-Tuple{Function, Vararg{DataType}}" href="#CTBase.VectorField-Tuple{Function, Vararg{DataType}}"><code>CTBase.VectorField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VectorField(
    f::Function,
    dependencies::DataType...
) -&gt; VectorField{Autonomous, Fixed}
</code></pre><p>Return a <code>VectorField</code> of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.</p><pre><code class="language- hljs">julia&gt; VectorField(x -&gt; [x[1]^2, 2x[2]], Int64)
IncorrectArgument
julia&gt; VectorField(x -&gt; [x[1]^2, 2x[2]], Int64)
IncorrectArgument
julia&gt; V = VectorField(x -&gt; [x[1]^2, 2x[2]]) # autonomous=true, variable=false
julia&gt; V = VectorField((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], NonFixed)
julia&gt; V = VectorField((t, x) -&gt; [t+x[1]^2, 2x[2]], NonAutonomous)
julia&gt; V = VectorField((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L496-L514">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.VectorField-Tuple{Function}" href="#CTBase.VectorField-Tuple{Function}"><code>CTBase.VectorField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VectorField(
    f::Function;
    autonomous,
    variable
) -&gt; VectorField{Autonomous, Fixed}
</code></pre><p>Return a <code>VectorField</code> of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.</p><pre><code class="language- hljs">julia&gt; V = VectorField(x -&gt; [x[1]^2, 2x[2]]) # autonomous=true, variable=false
julia&gt; V = VectorField((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], variable=true)
julia&gt; V = VectorField((t, x) -&gt; [t+x[1]^2, 2x[2]], autonomous=false)
julia&gt; V = VectorField((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L474-L488">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.VectorField-Tuple{Union{Real, AbstractVector{&lt;:Real}}}" href="#CTBase.VectorField-Tuple{Union{Real, AbstractVector{&lt;:Real}}}"><code>CTBase.VectorField</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the value of the VectorField.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; VectorField(x -&gt; [x[1]^2, 2x[2]], Int64)
IncorrectArgument
julia&gt; VectorField(x -&gt; [x[1]^2, 2x[2]], Int64)
IncorrectArgument
julia&gt; V = VectorField(x -&gt; [x[1]^2, 2x[2]]) # autonomous=true, variable=false
julia&gt; V([1, -1])
[1, -2]
julia&gt; t = 1
julia&gt; v = Real[]
julia&gt; V(t, [1, -1])
MethodError
julia&gt; V([1, -1], v)
MethodError
julia&gt; V(t, [1, -1], v)
[1, -2]
julia&gt; V = VectorField((x, v) -&gt; [x[1]^2, 2x[2]+v[3]], variable=true)
julia&gt; V([1, -1], [1, 2, 3])
[1, 1]
julia&gt; V(t, [1, -1], [1, 2, 3])
[1, 1]
julia&gt; V = VectorField((t, x) -&gt; [t+x[1]^2, 2x[2]], autonomous=false)
julia&gt; V(1, [1, -1])
[2, -2]
julia&gt; V(1, [1, -1], v)
[2, -2]
julia&gt; V = VectorField((t, x, v) -&gt; [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)
julia&gt; V(1, [1, -1], [1, 2, 3])
[2, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/functions.jl#L522-L560">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ctNumber" href="#CTBase.ctNumber"><code>CTBase.ctNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type alias for a real number.</p><pre><code class="language- hljs">julia&gt; const ctNumber = Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/CTBase.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.:⋅-Tuple{Function, Function}" href="#CTBase.:⋅-Tuple{Function, Function}"><code>CTBase.:⋅</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">⋅(X::Function, f::Function) -&gt; Function
</code></pre><p>Lie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; φ = x -&gt; [x[2], -x[1]]
julia&gt; f = x -&gt; x[1]^2 + x[2]^2
julia&gt; (φ⋅f)([1, 2])
0
julia&gt; φ = (t, x, v) -&gt; [t + x[2] + v[1], -x[1] + v[2]]
julia&gt; f = (t, x, v) -&gt; t + x[1]^2 + x[2]^2
julia&gt; (φ⋅f)(1, [1, 2], [2, 1])
MethodError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.:⋅-Tuple{VectorField{Autonomous, &lt;:VariableDependence}, Function}" href="#CTBase.:⋅-Tuple{VectorField{Autonomous, &lt;:VariableDependence}, Function}"><code>CTBase.:⋅</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">⋅(
    X::VectorField{Autonomous, &lt;:VariableDependence},
    f::Function
) -&gt; CTBase.var&quot;#97#99&quot;{VectorField{Autonomous, var&quot;#s98&quot;}, &lt;:Function} where var&quot;#s98&quot;&lt;:VariableDependence
</code></pre><p>Lie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in autonomous case</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; φ = x -&gt; [x[2], -x[1]]
julia&gt; X = VectorField(φ)
julia&gt; f = x -&gt; x[1]^2 + x[2]^2
julia&gt; (X⋅f)([1, 2])
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.:⋅-Tuple{VectorField{NonAutonomous, &lt;:VariableDependence}, Function}" href="#CTBase.:⋅-Tuple{VectorField{NonAutonomous, &lt;:VariableDependence}, Function}"><code>CTBase.:⋅</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">⋅(
    X::VectorField{NonAutonomous, &lt;:VariableDependence},
    f::Function
) -&gt; CTBase.var&quot;#101#103&quot;{VectorField{NonAutonomous, var&quot;#s98&quot;}, &lt;:Function} where var&quot;#s98&quot;&lt;:VariableDependence
</code></pre><p>Lie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in nonautonomous case</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; φ = (t, x, v) -&gt; [t + x[2] + v[1], -x[1] + v[2]]
julia&gt; X = VectorField(φ, NonAutonomous, NonFixed)
julia&gt; f = (t, x, v) -&gt; t + x[1]^2 + x[2]^2
julia&gt; (X⋅f)(1, [1, 2], [2, 1])
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Lie-Tuple{Function, Function, Vararg{DataType}}" href="#CTBase.Lie-Tuple{Function, Function, Vararg{DataType}}"><code>CTBase.Lie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Lie(
    X::Function,
    f::Function,
    dependences::DataType...
) -&gt; Function
</code></pre><p>Lie derivative of a scalar function along a vector field or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; φ = x -&gt; [x[2], -x[1]]
julia&gt; f = x -&gt; x[1]^2 + x[2]^2
julia&gt; Lie(φ,f)([1, 2])
0
julia&gt; φ = (t, x, v) -&gt; [t + x[2] + v[1], -x[1] + v[2]]
julia&gt; f = (t, x, v) -&gt; t + x[1]^2 + x[2]^2
julia&gt; Lie(φ, f, NonAutonomous, NonFixed)(1, [1, 2], [2, 1])
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Lie-Tuple{Function, Function}" href="#CTBase.Lie-Tuple{Function, Function}"><code>CTBase.Lie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Lie(
    X::Function,
    f::Function;
    autonomous,
    variable
) -&gt; Function
</code></pre><p>Lie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; φ = x -&gt; [x[2], -x[1]]
julia&gt; f = x -&gt; x[1]^2 + x[2]^2
julia&gt; Lie(φ,f)([1, 2])
0
julia&gt; φ = (t, x, v) -&gt; [t + x[2] + v[1], -x[1] + v[2]]
julia&gt; f = (t, x, v) -&gt; t + x[1]^2 + x[2]^2
julia&gt; Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Lie-Tuple{VectorField, Function}" href="#CTBase.Lie-Tuple{VectorField, Function}"><code>CTBase.Lie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Lie(X::VectorField, f::Function) -&gt; Function
</code></pre><p>Lie derivative of a scalar function along a vector field.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; φ = x -&gt; [x[2], -x[1]]
julia&gt; X = VectorField(φ)
julia&gt; f = x -&gt; x[1]^2 + x[2]^2
julia&gt; Lie(X,f)([1, 2])
0
julia&gt; φ = (t, x, v) -&gt; [t + x[2] + v[1], -x[1] + v[2]]
julia&gt; X = VectorField(φ, NonAutonomous, NonFixed)
julia&gt; f = (t, x, v) -&gt; t + x[1]^2 + x[2]^2
julia&gt; Lie(X, f)(1, [1, 2], [2, 1])
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V&lt;:VariableDependence" href="#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V&lt;:VariableDependence"><code>CTBase.Lie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Lie(
    X::VectorField{Autonomous, V&lt;:VariableDependence},
    Y::VectorField{Autonomous, V&lt;:VariableDependence}
) -&gt; VectorField
</code></pre><p>Lie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; f = x -&gt; [x[2], 2x[1]]
julia&gt; g = x -&gt; [3x[2], -x[1]]
julia&gt; X = VectorField(f)
julia&gt; Y = VectorField(g)
julia&gt; Lie(X, Y)([1, 2])
[7, -14]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V&lt;:VariableDependence" href="#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V&lt;:VariableDependence"><code>CTBase.Lie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Lie(
    X::VectorField{NonAutonomous, V&lt;:VariableDependence},
    Y::VectorField{NonAutonomous, V&lt;:VariableDependence}
) -&gt; VectorField{NonAutonomous}
</code></pre><p>Lie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; f = (t, x, v) -&gt; [t + x[2] + v, -2x[1] - v]
julia&gt; g = (t, x, v) -&gt; [t + 3x[2] + v, -x[1] - v]
julia&gt; X = VectorField(f, NonAutonomous, NonFixed)
julia&gt; Y = VectorField(g, NonAutonomous, NonFixed)
julia&gt; Lie(X, Y)(1, [1, 2], 1)
[-7,12]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Lift-Tuple{Function, Vararg{DataType}}" href="#CTBase.Lift-Tuple{Function, Vararg{DataType}}"><code>CTBase.Lift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Lift(
    X::Function,
    dependences::DataType...
) -&gt; HamiltonianLift
</code></pre><p>Return the HamiltonianLift of a VectorField or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; H = Lift(x -&gt; 2x)
julia&gt; H(1, 1)
2
julia&gt; H = Lift((t, x, v) -&gt; 2x + t - v, NonAutonomous, NonFixed)
julia&gt; H(1, 1, 1, 1)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Lift-Tuple{Function}" href="#CTBase.Lift-Tuple{Function}"><code>CTBase.Lift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Lift(X::Function; autonomous, variable) -&gt; HamiltonianLift
</code></pre><p>Return the HamiltonianLift of a function. Dependencies are specified with boolean : autonomous and variable.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; H = Lift(x -&gt; 2x)
julia&gt; H(1, 1)
2
julia&gt; H = Lift((t, x, v) -&gt; 2x + t - v, autonomous=false, variable=true)
julia&gt; H(1, 1, 1, 1)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Lift-Tuple{VectorField}" href="#CTBase.Lift-Tuple{VectorField}"><code>CTBase.Lift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Lift(X::VectorField) -&gt; HamiltonianLift
</code></pre><p>Return the HamiltonianLift of a VectorField.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; HL = Lift(VectorField(x -&gt; [x[1]^2,x[2]^2], autonomous=true, variable=false))
julia&gt; HL([1, 0], [0, 1])
0
julia&gt; HL = Lift(VectorField((t, x, v) -&gt; [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))
julia&gt; HL(1, [1, 0], [0, 1], 1)
1
julia&gt; H = Lift(x -&gt; 2x)
julia&gt; H(1, 1)
2
julia&gt; H = Lift((t, x, v) -&gt; 2x + t - v, autonomous=false, variable=true)
julia&gt; H(1, 1, 1, 1)
2
julia&gt; H = Lift((t, x, v) -&gt; 2x + t - v, NonAutonomous, NonFixed)
julia&gt; H(1, 1, 1, 1)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Model-Tuple{Vararg{DataType}}" href="#CTBase.Model-Tuple{Vararg{DataType}}"><code>CTBase.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Model(
    dependencies::DataType...
) -&gt; OptimalControlModel{Autonomous, Fixed}
</code></pre><p>Return a new <code>OptimalControlModel</code> instance, that is a model of an optimal control problem.</p><p>The model is defined by the following argument:</p><ul><li><code>dependencies</code>: either <code>Autonomous</code> or <code>NonAutonomous</code>. Default is <code>Autonomous</code>. And either <code>NonFixed</code> or <code>Fixed</code>. Default is <code>Fixed</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; ocp = Model()
julia&gt; ocp = Model(NonAutonomous)
julia&gt; ocp = Model(Autonomous, NonFixed)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li>If the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.</li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Model-Tuple{}" href="#CTBase.Model-Tuple{}"><code>CTBase.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Model(
;
    autonomous,
    variable
) -&gt; OptimalControlModel{Autonomous, Fixed}
</code></pre><p>Return a new <code>OptimalControlModel</code> instance, that is a model of an optimal control problem.</p><p>The model is defined by the following optional keyword argument:</p><ul><li><code>autonomous</code>: either <code>true</code> or <code>false</code>. Default is <code>true</code>.</li><li><code>variable</code>: either <code>true</code> or <code>false</code>. Default is <code>false</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; ocp = Model()
julia&gt; ocp = Model(autonomous=false)
julia&gt; ocp = Model(autonomous=false, variable=true)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li>If the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.</li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Poisson-Tuple{Function, Function, Vararg{DataType}}" href="#CTBase.Poisson-Tuple{Function, Function, Vararg{DataType}}"><code>CTBase.Poisson</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Poisson(
    f::Function,
    g::Function,
    dependences::DataType...
) -&gt; Hamiltonian
</code></pre><p>Poisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; f = (x, p) -&gt; x[2]^2 + 2x[1]^2 + p[1]^2
julia&gt; g = (x, p) -&gt; 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]
julia&gt; Poisson(f, g)([1, 2], [2, 1])
-20            
julia&gt; f = (t, x, p, v) -&gt; t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]
julia&gt; g = (t, x, p, v) -&gt; 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]
julia&gt; Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])
-76</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Poisson-Tuple{Function, Function}" href="#CTBase.Poisson-Tuple{Function, Function}"><code>CTBase.Poisson</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Poisson(
    f::Function,
    g::Function;
    autonomous,
    variable
) -&gt; Hamiltonian
</code></pre><p>Poisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; f = (x, p) -&gt; x[2]^2 + 2x[1]^2 + p[1]^2
julia&gt; g = (x, p) -&gt; 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]
julia&gt; Poisson(f, g)([1, 2], [2, 1])
-20            
julia&gt; f = (t, x, p, v) -&gt; t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]
julia&gt; g = (t, x, p, v) -&gt; 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]
julia&gt; Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])
-76</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{Autonomous, V}, AbstractHamiltonian{Autonomous, V}}} where V&lt;:VariableDependence" href="#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{Autonomous, V}, AbstractHamiltonian{Autonomous, V}}} where V&lt;:VariableDependence"><code>CTBase.Poisson</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Poisson(
    f::AbstractHamiltonian{Autonomous, V&lt;:VariableDependence},
    g::AbstractHamiltonian{Autonomous, V&lt;:VariableDependence}
) -&gt; HamiltonianLift
</code></pre><p>Poisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; f = (x, p) -&gt; x[2]^2 + 2x[1]^2 + p[1]^2
julia&gt; g = (x, p) -&gt; 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]
julia&gt; F = Hamiltonian(f)
julia&gt; G = Hamiltonian(g)
julia&gt; Poisson(f, g)([1, 2], [2, 1])
-20            
julia&gt; Poisson(f, G)([1, 2], [2, 1])
-20
julia&gt; Poisson(F, g)([1, 2], [2, 1])
-20</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{NonAutonomous, V}, AbstractHamiltonian{NonAutonomous, V}}} where V&lt;:VariableDependence" href="#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{NonAutonomous, V}, AbstractHamiltonian{NonAutonomous, V}}} where V&lt;:VariableDependence"><code>CTBase.Poisson</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Poisson(
    f::AbstractHamiltonian{NonAutonomous, V&lt;:VariableDependence},
    g::AbstractHamiltonian{NonAutonomous, V&lt;:VariableDependence}
) -&gt; HamiltonianLift
</code></pre><p>Poisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; f = (t, x, p, v) -&gt; t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]
julia&gt; g = (t, x, p, v) -&gt; 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]
julia&gt; F = Hamiltonian(f, autonomous=false, variable=true)
julia&gt; G = Hamiltonian(g, autonomous=false, variable=true)
julia&gt; Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])
-76
julia&gt; Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])
-76</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{AbstractHamiltonian{T, V}, Function}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}" href="#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{AbstractHamiltonian{T, V}, Function}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.Poisson</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Poisson(
    f::AbstractHamiltonian{T&lt;:TimeDependence, V&lt;:VariableDependence},
    g::Function
) -&gt; Hamiltonian
</code></pre><p>Poisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; f = (x, p) -&gt; x[2]^2 + 2x[1]^2 + p[1]^2
julia&gt; g = (x, p) -&gt; 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]
julia&gt; F = Hamiltonian(f)
julia&gt; Poisson(F, g)([1, 2], [2, 1])
-20
julia&gt; f = (t, x, p, v) -&gt; t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]
julia&gt; g = (t, x, p, v) -&gt; 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]
julia&gt; F = Hamiltonian(f, autonomous=false, variable=true)
julia&gt; Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])
-76</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L479">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{Function, AbstractHamiltonian{T, V}}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}" href="#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{Function, AbstractHamiltonian{T, V}}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.Poisson</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Poisson(
    f::Function,
    g::AbstractHamiltonian{T&lt;:TimeDependence, V&lt;:VariableDependence}
) -&gt; Hamiltonian
</code></pre><p>Poisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g)</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; f = (x, p) -&gt; x[2]^2 + 2x[1]^2 + p[1]^2
julia&gt; g = (x, p) -&gt; 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]
julia&gt; G = Hamiltonian(g)          
julia&gt; Poisson(f, G)([1, 2], [2, 1])
-20
julia&gt; f = (t, x, p, v) -&gt; t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]
julia&gt; g = (t, x, p, v) -&gt; 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]
julia&gt; G = Hamiltonian(g, autonomous=false, variable=true)
julia&gt; Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])
-76</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L456">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}" href="#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.Poisson</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Poisson(
    f::HamiltonianLift{T&lt;:TimeDependence, V&lt;:VariableDependence},
    g::HamiltonianLift{T&lt;:TimeDependence, V&lt;:VariableDependence}
) -&gt; HamiltonianLift
</code></pre><p>Poisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g)</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; f = x -&gt; [x[1]^2+x[2]^2, 2x[1]^2]
julia&gt; g = x -&gt; [3x[2]^2, x[2]-x[1]^2]
julia&gt; F = Lift(f)
julia&gt; G = Lift(g)
julia&gt; Poisson(F, G)([1, 2], [2, 1])
-64
julia&gt; f = (t, x, v) -&gt; [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]
julia&gt; g = (t, x, v) -&gt; [3x[2]^2 + -x[1]^2, t - v[2]]
julia&gt; F = Lift(f, NonAutonomous, NonFixed)
julia&gt; G = Lift(g, NonAutonomous, NonFixed)
julia&gt; Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])
100</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.__OCPModel-Tuple" href="#CTBase.__OCPModel-Tuple"><code>CTBase.__OCPModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">__OCPModel(args...; kwargs...) -&gt; OptimalControlModel
</code></pre><p>Redirection to <a href="api-ctbase.html#CTBase.Model-Tuple{Vararg{DataType}}"><code>Model</code></a> to avoid confusion with other functions Model from other packages if imported. This function is used by <a href="api-ctbase.html#CTBase.@def"><code>@def</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/onepass.jl#L433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}" href="#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}"><code>CTBase.add</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add(
    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},
    y::Tuple{Vararg{Symbol}}
) -&gt; Tuple{Tuple{Vararg{Symbol}}}
</code></pre><p>Concatenate the description <code>y</code> to the tuple of descriptions <code>x</code> if <code>x</code> does not contain <code>y</code> and return the new tuple of descriptions. Throw an error if the description <code>y</code> is already contained in <code>x</code>.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; descriptions = ()
julia&gt; descriptions = add(descriptions, (:a,))
(:a,)
julia&gt; descriptions = add(descriptions, (:b,))
(:a,)
(:b,)
julia&gt; descriptions = add(descriptions, (:b,))
ERROR: IncorrectArgument: the description (:b,) is already in ((:a,), (:b,))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/description.jl#L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}" href="#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}"><code>CTBase.add</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add(
    x::Tuple{},
    y::Tuple{Vararg{Symbol}}
) -&gt; Tuple{Tuple{Vararg{Symbol}}}
</code></pre><p>Return a tuple containing only the description <code>y</code>.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; descriptions = ()
julia&gt; descriptions = add(descriptions, (:a,))
(:a,)
julia&gt; print(descriptions)
((:a,),)
julia&gt; descriptions[1]
(:a,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/description.jl#L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}" href="#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.constraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint!(
    ocp::OptimalControlModel{T&lt;:TimeDependence, V&lt;:VariableDependence},
    type::Symbol;
    rg,
    f,
    lb,
    ub,
    label
)
</code></pre><p>Add a constraint to an optimal control problem, denoted <code>ocp</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li>The state, control and variable dimensions must be set before. Use state!, control! and variable!.</li><li>The initial and final times must be set before. Use time!.</li><li>When an element is of dimension 1, consider it as a scalar.</li></ul></div></div><p>You can add an <code>:initial</code>, <code>:final</code>, <code>:control</code>, <code>:state</code> or <code>:variable</code> box constraint (whole range). </p><p><strong>Range constraint on the state, control or variable</strong></p><p>You can add an <code>:initial</code>, <code>:final</code>, <code>:control</code>, <code>:state</code> or <code>:variable</code> box constraint on a range of it, that is only on some components. If not range is specified, then the constraint is on the whole range. We denote by <code>x</code>, <code>u</code> and <code>v</code> respectively the state, control and variable. We denote by <code>n</code>, <code>m</code> and <code>q</code> respectively the dimension of the state, control and variable. The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; constraint!(ocp, :initial; rg=1:2:5, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])
julia&gt; constraint!(ocp, :initial; rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])
julia&gt; constraint!(ocp, :final; rg=1, lb=0, ub=2)
julia&gt; constraint!(ocp, :control; rg=1, lb=0, ub=2)
julia&gt; constraint!(ocp, :state; rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])
julia&gt; constraint!(ocp, :variable; rg=1:2, lb=[ 0, 0 ], ub=[ 1, 2 ])
julia&gt; constraint!(ocp, :initial; lb=[ 0, 0, 0 ])                 # [ 0, 0, 0 ] ≤ x(t0),                          dim(x) = 3
julia&gt; constraint!(ocp, :initial; lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ]) # [ 0, 0, 0 ] ≤ x(t0) ≤ [ 1, 2, 1 ],            dim(x) = 3
julia&gt; constraint!(ocp, :final; lb=-1, ub=1)                      #          -1 ≤ x(tf) ≤ 1,                      dim(x) = 1
julia&gt; constraint!(ocp, :control; lb=0, ub=2)                     #           0 ≤ u(t)  ≤ 2,        t ∈ [t0, tf], dim(u) = 1
julia&gt; constraint!(ocp, :state; lb=[ 0, 0 ], ub=[ 1, 2 ])         #    [ 0, 0 ] ≤ x(t)  ≤ [ 1, 2 ], t ∈ [t0, tf], dim(x) = 2
julia&gt; constraint!(ocp, :variable; lb=[ 0, 0 ], ub=[ 1, 2 ])      #    [ 0, 0 ] ≤    v  ≤ [ 1, 2 ],               dim(v) = 2</code></pre><p><strong>Functional constraint</strong></p><p>You can add a <code>:boundary</code>, <code>:control</code>, <code>:state</code>, <code>:mixed</code> or <code>:variable</code> box functional constraint.</p><p><strong>Examples</strong></p><pre><code class="language- hljs"># variable independent ocp
julia&gt; constraint!(ocp, :boundary; f = (x0, xf) -&gt; x0[3]+xf[2], lb=0, ub=1)

# variable dependent ocp
julia&gt; constraint!(ocp, :boundary; f = (x0, xf, v) -&gt; x0[3]+xf[2]*v[1], lb=0, ub=1)

# time independent and variable independent ocp
julia&gt; constraint!(ocp, :control; f = u -&gt; 2u, lb=0, ub=1)
julia&gt; constraint!(ocp, :state; f = x -&gt; x-1, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])
julia&gt; constraint!(ocp, :mixed; f = (x, u) -&gt; x[1]-u, lb=0, ub=1)

# time dependent and variable independent ocp
julia&gt; constraint!(ocp, :control; f = (t, u) -&gt; 2u, lb=0, ub=1)
julia&gt; constraint!(ocp, :state; f = (t, x) -&gt; t * x, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])
julia&gt; constraint!(ocp, :mixed; f = (t, x, u) -&gt; x[1]-u, lb=0, ub=1)

# time independent and variable dependent ocp
julia&gt; constraint!(ocp, :control; f = (u, v) -&gt; 2u * v[1], lb=0, ub=1)
julia&gt; constraint!(ocp, :state; f = (x, v) -&gt; x * v[1], lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])
julia&gt; constraint!(ocp, :mixed; f = (x, u, v) -&gt; x[1]-v[2]*u, lb=0, ub=1)

# time dependent and variable dependent ocp
julia&gt; constraint!(ocp, :control; f = (t, u, v) -&gt; 2u+v[2], lb=0, ub=1)
julia&gt; constraint!(ocp, :state; f = (t, x, v) -&gt; x-t*v[1], lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])
julia&gt; constraint!(ocp, :mixed; f = (t, x, u, v) -&gt; x[1]*v[2]-u, lb=0, ub=1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L479">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}" href="#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint(
    ocp::OptimalControlModel{T&lt;:TimeDependence, V&lt;:VariableDependence},
    label::Symbol
) -&gt; Any
</code></pre><p>Retrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds).</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; constraint!(ocp, :initial, 0, :c0)
julia&gt; c = constraint(ocp, :c0)
julia&gt; c(1)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L805">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.constraint_type-NTuple{7, Any}" href="#CTBase.constraint_type-NTuple{7, Any}"><code>CTBase.constraint_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_type(
    e,
    t,
    t0,
    tf,
    x,
    u,
    v
) -&gt; Union{Symbol, Tuple{Symbol, Any}}
</code></pre><p>Return the type constraint among <code>:initial</code>, <code>:final</code>, <code>:boundary</code>, <code>:control_range</code>, <code>:control_fun</code>, <code>:state_range</code>, <code>:state_fun</code>, <code>:mixed</code>, <code>:variable_range</code>, <code>:variable_fun</code> (<code>:other</code> otherwise), together with the appropriate value (range, updated expression...) Expressions like <code>u(t0)</code> where <code>u</code> is the control and <code>t0</code> the initial time return <code>:other</code>.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v

julia&gt; constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)
:other

julia&gt; constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)
:other

julia&gt; constraint_type(:( x(0)&#39; ), t, t0, tf, x, u, v)
:boundary

julia&gt; constraint_type(:( x(t)&#39; ), t, t0, tf, x, u, v)
:state_fun

julia&gt; constraint_type(:( x(0) ), t, t0, tf, x, u, v)
(:initial, nothing)

julia&gt; constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)
(:initial, 1:2:5)

julia&gt; constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)
(:initial, 1:2)

julia&gt; constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)
(:initial, 1)

julia&gt; constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)
:boundary

julia&gt; constraint_type(:( x(tf) ), t, t0, tf, x, u, v)
(:final, nothing)
j
julia&gt; constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)
(:final, 1:2:5)

julia&gt; constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)
(:final, 1:2)

julia&gt; constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)
(:final, 1)

julia&gt; constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)
:boundary

julia&gt; constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)
:boundary

julia&gt; constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)
(:control_range, 1:2:5)

julia&gt; constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)
(:control_range, 1:2)

julia&gt; constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)
(:control_range, 1)

julia&gt; constraint_type(:( u(t) ), t, t0, tf, x, u, v)
(:control_range, nothing)

julia&gt; constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)
:control_fun

julia&gt; constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)
(:state_range, 1:2:5)

julia&gt; constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)
(:state_range, 1:2)

julia&gt; constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)
(:state_range, 1)

julia&gt; constraint_type(:( x(t) ), t, t0, tf, x, u, v)
(:state_range, nothing)

julia&gt; constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)
:state_fun

julia&gt; constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)
:mixed

julia&gt; constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)
:other

julia&gt; constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)
:other

julia&gt; constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)
:mixed

julia&gt; constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)
(:variable_range, 1:2:9)

julia&gt; constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)
(:variable_range, 1:10)

julia&gt; constraint_type(:( v[2] ), t, t0, tf, x, u, v)
(:variable_range, 2)

julia&gt; constraint_type(:( v ), t, t0, tf, x, u, v)
(:variable_range, nothing)

julia&gt; constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)
:variable_fun
julia&gt; constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)
:variable_fun</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/ctparser_utils.jl#L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.constraints_labels-Tuple{OptimalControlModel}" href="#CTBase.constraints_labels-Tuple{OptimalControlModel}"><code>CTBase.constraints_labels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraints_labels(
    ocp::OptimalControlModel
) -&gt; Base.KeySet{Symbol, Dict{Symbol, Tuple}}
</code></pre><p>Return the labels of the constraints as a <code>Base.keys</code>.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; constraints_labels(ocp)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L789">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.control!" href="#CTBase.control!"><code>CTBase.control!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">control!(ocp::OptimalControlModel, m::Integer)
control!(ocp::OptimalControlModel, m::Integer, name::String)
control!(
    ocp::OptimalControlModel,
    m::Integer,
    name::String,
    components_names::Vector{String}
)
</code></pre><p>Define the control dimension and possibly the names of each coordinate.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You must use control! only once to set the control dimension.</p></div></div><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; control!(ocp, 1)
julia&gt; ocp.control_dimension
1
julia&gt; ocp.control_components_names
[&quot;u&quot;]

julia&gt; control!(ocp, 1, &quot;v&quot;)
julia&gt; ocp.control_dimension
1
julia&gt; ocp.control_components_names
[&quot;v&quot;]

julia&gt; control!(ocp, 2)
julia&gt; ocp.control_dimension
2
julia&gt; ocp.control_components_names
[&quot;u₁&quot;, &quot;u₂&quot;]

julia&gt; control!(ocp, 2, :v)
julia&gt; ocp.control_dimension
2
julia&gt; ocp.control_components_names
[&quot;v₁&quot;, &quot;v₂&quot;]

julia&gt; control!(ocp, 2, &quot;v&quot;)
julia&gt; ocp.control_dimension
2
julia&gt; ocp.control_components_names
[&quot;v₁&quot;, &quot;v₂&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ct_repl-Tuple{}" href="#CTBase.ct_repl-Tuple{}"><code>CTBase.ct_repl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ct_repl(; debug, verbose)
</code></pre><p>Create a ct REPL.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/repl.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ct_repl_update_model-Tuple{Expr}" href="#CTBase.ct_repl_update_model-Tuple{Expr}"><code>CTBase.ct_repl_update_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ct_repl_update_model(e::Expr)
</code></pre><p>Update the model adding the expression e. It must be public since in the ct repl, this function  is quoted each time an expression is parsed and is valid. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/repl.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ctgradient-Tuple{Function, Any}" href="#CTBase.ctgradient-Tuple{Function, Any}"><code>CTBase.ctgradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ctgradient(f::Function, x; backend) -&gt; Any
</code></pre><p>Return the gradient of <code>f</code> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/utils.jl#L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ctgradient-Tuple{Function, Real}" href="#CTBase.ctgradient-Tuple{Function, Real}"><code>CTBase.ctgradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ctgradient(f::Function, x::Real; backend) -&gt; Any
</code></pre><p>Return the gradient of <code>f</code> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/utils.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ctgradient-Tuple{VectorField, Any}" href="#CTBase.ctgradient-Tuple{VectorField, Any}"><code>CTBase.ctgradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ctgradient(X::VectorField, x) -&gt; Any
</code></pre><p>Return the gradient of <code>X</code> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/utils.jl#L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ctindices-Tuple{Integer}" href="#CTBase.ctindices-Tuple{Integer}"><code>CTBase.ctindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ctindices(i::Integer) -&gt; String
</code></pre><p>Return <code>i</code> &gt; 0 as a subscript.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/utils.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ctinterpolate-Tuple{Any, Any}" href="#CTBase.ctinterpolate-Tuple{Any, Any}"><code>CTBase.ctinterpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ctinterpolate(x, f) -&gt; Any
</code></pre><p>Return the interpolation of <code>f</code> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/utils.jl#L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ctjacobian-Tuple{Function, Any}" href="#CTBase.ctjacobian-Tuple{Function, Any}"><code>CTBase.ctjacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ctjacobian(f::Function, x; backend) -&gt; Any
</code></pre><p>Return the Jacobian of <code>f</code> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/utils.jl#L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ctjacobian-Tuple{Function, Real}" href="#CTBase.ctjacobian-Tuple{Function, Real}"><code>CTBase.ctjacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ctjacobian(f::Function, x::Real; backend) -&gt; Any
</code></pre><p>Return the Jacobian of <code>f</code> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/utils.jl#L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ctjacobian-Tuple{VectorField, Any}" href="#CTBase.ctjacobian-Tuple{VectorField, Any}"><code>CTBase.ctjacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ctjacobian(X::VectorField, x) -&gt; Any
</code></pre><p>Return the Jacobian of <code>X</code> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/utils.jl#L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.ctupperscripts-Tuple{Integer}" href="#CTBase.ctupperscripts-Tuple{Integer}"><code>CTBase.ctupperscripts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ctupperscripts(i::Integer) -&gt; String
</code></pre><p>Return <code>i</code> &gt; 0 as an upperscript.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/utils.jl#L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.dim_boundary_constraints-Tuple{OptimalControlModel}" href="#CTBase.dim_boundary_constraints-Tuple{OptimalControlModel}"><code>CTBase.dim_boundary_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim_boundary_constraints(
    ocp::OptimalControlModel
) -&gt; Union{Nothing, Integer}
</code></pre><p>Return the dimension of the boundary constraints (<code>nothing</code> if not knonw). Information is updated after <code>nlp_constraints!</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L1062">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.dim_control_constraints-Tuple{OptimalControlModel}" href="#CTBase.dim_control_constraints-Tuple{OptimalControlModel}"><code>CTBase.dim_control_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim_control_constraints(
    ocp::OptimalControlModel
) -&gt; Union{Nothing, Integer}
</code></pre><p>Return the dimension of nonlinear control constraints (<code>nothing</code> if not knonw). Information is updated after <code>nlp_constraints!</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L1033">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.dim_control_range-Tuple{OptimalControlModel}" href="#CTBase.dim_control_range-Tuple{OptimalControlModel}"><code>CTBase.dim_control_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim_control_range(
    ocp::OptimalControlModel
) -&gt; Union{Nothing, Integer}
</code></pre><p>Return the dimension of range constraints on control (<code>nothing</code> if not knonw). Information is updated after <code>nlp_constraints!</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L1086">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.dim_mixed_constraints-Tuple{OptimalControlModel}" href="#CTBase.dim_mixed_constraints-Tuple{OptimalControlModel}"><code>CTBase.dim_mixed_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim_mixed_constraints(
    ocp::OptimalControlModel
) -&gt; Union{Nothing, Integer}
</code></pre><p>Return the dimension of nonlinear mixed constraints (<code>nothing</code> if not knonw). Information is updated after <code>nlp_constraints!</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L1041">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.dim_path_constraints-Tuple{OptimalControlModel}" href="#CTBase.dim_path_constraints-Tuple{OptimalControlModel}"><code>CTBase.dim_path_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim_path_constraints(ocp::OptimalControlModel) -&gt; Any
</code></pre><p>Return the dimension of nonlinear path (state + control + mixed) constraints (<code>nothing</code> if one of them is not knonw). Information is updated after <code>nlp_constraints!</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L1049">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.dim_state_constraints-Tuple{OptimalControlModel}" href="#CTBase.dim_state_constraints-Tuple{OptimalControlModel}"><code>CTBase.dim_state_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim_state_constraints(
    ocp::OptimalControlModel
) -&gt; Union{Nothing, Integer}
</code></pre><p>Return the dimension of nonlinear state constraints (<code>nothing</code> if not knonw). Information is updated after <code>nlp_constraints!</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L1025">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.dim_state_range-Tuple{OptimalControlModel}" href="#CTBase.dim_state_range-Tuple{OptimalControlModel}"><code>CTBase.dim_state_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim_state_range(
    ocp::OptimalControlModel
) -&gt; Union{Nothing, Integer}
</code></pre><p>Return the dimension of range constraints on state (<code>nothing</code> if not knonw). Information is updated after <code>nlp_constraints!</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L1078">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.dim_variable_constraints-Tuple{OptimalControlModel}" href="#CTBase.dim_variable_constraints-Tuple{OptimalControlModel}"><code>CTBase.dim_variable_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim_variable_constraints(
    ocp::OptimalControlModel
) -&gt; Union{Nothing, Integer}
</code></pre><p>Return the dimension of nonlinear variable constraints (<code>nothing</code> if not knonw). Information is updated after <code>nlp_constraints!</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L1070">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.dim_variable_range-Tuple{OptimalControlModel}" href="#CTBase.dim_variable_range-Tuple{OptimalControlModel}"><code>CTBase.dim_variable_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim_variable_range(
    ocp::OptimalControlModel
) -&gt; Union{Nothing, Integer}
</code></pre><p>Return the dimension of range constraints on variable (<code>nothing</code> if not knonw). Information is updated after <code>nlp_constraints!</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L1094">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}" href="#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.dynamics!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dynamics!(
    ocp::OptimalControlModel{T&lt;:TimeDependence, V&lt;:VariableDependence},
    f::Function
)
</code></pre><p>Set the dynamics.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can use dynamics! only once to define the dynamics.</p><ul><li>The state, control and variable dimensions must be set before. Use state!, control! and variable!.</li><li>The times must be set before. Use time!.</li><li>When an element is of dimension 1, consider it as a scalar.</li></ul></div></div><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; dynamics!(ocp, f)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L644">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}" href="#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}"><code>CTBase.getFullDescription</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getFullDescription(
    desc::Tuple{Vararg{Symbol}},
    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}
) -&gt; Tuple{Vararg{Symbol}}
</code></pre><p>Return a complete description from an incomplete description <code>desc</code> and  a list of complete descriptions <code>desc_list</code>. If several complete descriptions are possible,  then the first one is returned.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; desc_list = ((:a, :b), (:b, :c), (:a, :c))
(:a, :b)
(:b, :c)
(:a, :c)
julia&gt; getFullDescription((:a,), desc_list)
(:a, :b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/description.jl#L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.get_priority_print_callbacks-Tuple{Tuple{Vararg{CTCallback}}}" href="#CTBase.get_priority_print_callbacks-Tuple{Tuple{Vararg{CTCallback}}}"><code>CTBase.get_priority_print_callbacks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_priority_print_callbacks(
    cbs::Tuple{Vararg{CTCallback}}
) -&gt; Tuple{Vararg{CTCallback}}
</code></pre><p>Get the highest priority print callbacks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/callback.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.get_priority_stop_callbacks-Tuple{Tuple{Vararg{CTCallback}}}" href="#CTBase.get_priority_stop_callbacks-Tuple{Tuple{Vararg{CTCallback}}}"><code>CTBase.get_priority_stop_callbacks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_priority_stop_callbacks(
    cbs::Tuple{Vararg{CTCallback}}
) -&gt; Tuple{Vararg{CTCallback}}
</code></pre><p>Get the highest priority stop callbacks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/callback.jl#L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.has_free_final_time-Tuple{OptimalControlModel}" href="#CTBase.has_free_final_time-Tuple{OptimalControlModel}"><code>CTBase.has_free_final_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_free_final_time(ocp::OptimalControlModel) -&gt; Bool
</code></pre><p>Return <code>true</code> if the model has been defined with free final time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.has_free_initial_time-Tuple{OptimalControlModel}" href="#CTBase.has_free_initial_time-Tuple{OptimalControlModel}"><code>CTBase.has_free_initial_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_free_initial_time(ocp::OptimalControlModel) -&gt; Bool
</code></pre><p>Return <code>true</code> if the model has been defined with free initial time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.has_lagrange_cost-Tuple{OptimalControlModel}" href="#CTBase.has_lagrange_cost-Tuple{OptimalControlModel}"><code>CTBase.has_lagrange_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_lagrange_cost(ocp::OptimalControlModel) -&gt; Bool
</code></pre><p>Return <code>true</code> if the model has been defined with lagrange cost.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.has_mayer_cost-Tuple{OptimalControlModel}" href="#CTBase.has_mayer_cost-Tuple{OptimalControlModel}"><code>CTBase.has_mayer_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_mayer_cost(ocp::OptimalControlModel) -&gt; Bool
</code></pre><p>Return <code>true</code> if the model has been defined with mayer cost.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.is_autonomous-Tuple{OptimalControlModel{Autonomous}}" href="#CTBase.is_autonomous-Tuple{OptimalControlModel{Autonomous}}"><code>CTBase.is_autonomous</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_autonomous(ocp::OptimalControlModel{Autonomous}) -&gt; Bool
</code></pre><p>Return <code>true</code> if the model is autonomous.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.is_fixed-Tuple{OptimalControlModel{&lt;:TimeDependence, Fixed}}" href="#CTBase.is_fixed-Tuple{OptimalControlModel{&lt;:TimeDependence, Fixed}}"><code>CTBase.is_fixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_fixed(
    ocp::OptimalControlModel{&lt;:TimeDependence, Fixed}
) -&gt; Bool
</code></pre><p>Return <code>true</code> if the model is fixed (= has no variable).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.is_max-Tuple{OptimalControlModel}" href="#CTBase.is_max-Tuple{OptimalControlModel}"><code>CTBase.is_max</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_max(ocp::OptimalControlModel) -&gt; Bool
</code></pre><p>Return <code>true</code> if the criterion type of <code>ocp</code> is <code>:max</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.is_min-Tuple{OptimalControlModel}" href="#CTBase.is_min-Tuple{OptimalControlModel}"><code>CTBase.is_min</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_min(ocp::OptimalControlModel) -&gt; Bool
</code></pre><p>Return <code>true</code> if the criterion type of <code>ocp</code> is <code>:min</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.is_time_dependent-Tuple{OptimalControlModel}" href="#CTBase.is_time_dependent-Tuple{OptimalControlModel}"><code>CTBase.is_time_dependent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_time_dependent(ocp::OptimalControlModel) -&gt; Bool
</code></pre><p>Return <code>true</code> if the model has been defined as time dependent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.is_time_independent-Tuple{OptimalControlModel}" href="#CTBase.is_time_independent-Tuple{OptimalControlModel}"><code>CTBase.is_time_independent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_time_independent(ocp::OptimalControlModel) -&gt; Bool
</code></pre><p>Return <code>true</code> if the model has been defined as time independent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.is_variable_dependent-Tuple{OptimalControlModel}" href="#CTBase.is_variable_dependent-Tuple{OptimalControlModel}"><code>CTBase.is_variable_dependent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_variable_dependent(ocp::OptimalControlModel) -&gt; Bool
</code></pre><p>Return <code>true</code> if the model has been defined as variable dependent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.is_variable_independent-Tuple{OptimalControlModel}" href="#CTBase.is_variable_independent-Tuple{OptimalControlModel}"><code>CTBase.is_variable_independent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_variable_independent(ocp::OptimalControlModel) -&gt; Bool
</code></pre><p>Return <code>true</code> if the model has been defined as variable independent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.nlp_constraints!-Tuple{OptimalControlModel}" href="#CTBase.nlp_constraints!-Tuple{OptimalControlModel}"><code>CTBase.nlp_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nlp_constraints!(
    ocp::OptimalControlModel
) -&gt; Tuple{Tuple{Any, CTBase.var&quot;#ξ#91&quot;, Vector{Real}}, Tuple{Any, CTBase.var&quot;#η#92&quot;, Vector{Real}}, Tuple{Any, CTBase.var&quot;#ψ#93&quot;, Vector{Real}}, Tuple{Any, CTBase.var&quot;#ϕ#94&quot;, Vector{Real}}, Tuple{Any, CTBase.var&quot;#θ#95&quot;, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}
</code></pre><p>Return a 6-tuple of tuples:</p><ul><li><code>(ξl, ξ, ξu)</code> are control constraints</li><li><code>(ηl, η, ηu)</code> are state constraints</li><li><code>(ψl, ψ, ψu)</code> are mixed constraints</li><li><code>(ϕl, ϕ, ϕu)</code> are boundary constraints</li><li><code>(θl, θ, θu)</code> are variable constraints</li><li><code>(ul, uind, uu)</code> are control linear constraints of a subset of indices</li><li><code>(xl, xind, xu)</code> are state linear constraints of a subset of indices</li><li><code>(vl, vind, vu)</code> are variable linear constraints of a subset of indices</li></ul><p>and update information about constraints dimensions of  <code>ocp</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li>The dimensions of the state and control must be set before calling <code>nlp_constraints!</code>.</li><li>For a <code>Fixed</code> problem, dimensions associated with constraints on the variable are set to zero.</li></ul></div></div><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; (ξl, ξ, ξu), (ηl, η, ηu), (ψl, ψ, ψu), (ϕl, ϕ, ϕu), (θl, θ, θu),
    (ul, uind, uu), (xl, xind, xu), (vl, vind, vu) = nlp_constraints!(ocp)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L855">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}" href="#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.objective!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">objective!(
    ocp::OptimalControlModel{T&lt;:TimeDependence, V&lt;:VariableDependence},
    type::Symbol,
    g::Function,
    f⁰::Function
)
objective!(
    ocp::OptimalControlModel{T&lt;:TimeDependence, V&lt;:VariableDependence},
    type::Symbol,
    g::Function,
    f⁰::Function,
    criterion::Symbol
)
</code></pre><p>Set the criterion to the function <code>g</code> and <code>f⁰</code>. Type can be <code>:bolza</code>. Criterion is <code>:min</code> or <code>:max</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can use objective! only once to define the objective.</p><ul><li>The state, control and variable dimensions must be set before. Use state!, control! and variable!.</li><li>The times must be set before. Use time!.</li><li>When an element is of dimension 1, consider it as a scalar.</li></ul></div></div><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; objective!(ocp, :bolza, (x0, xf) -&gt; x0[1] + xf[2], (x, u) -&gt; x[1]^2 + u^2) # the control is of dimension 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L725">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}" href="#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T&lt;:TimeDependence, V&lt;:VariableDependence}"><code>CTBase.objective!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">objective!(
    ocp::OptimalControlModel{T&lt;:TimeDependence, V&lt;:VariableDependence},
    type::Symbol,
    f::Function
)
objective!(
    ocp::OptimalControlModel{T&lt;:TimeDependence, V&lt;:VariableDependence},
    type::Symbol,
    f::Function,
    criterion::Symbol
)
</code></pre><p>Set the criterion to the function <code>f</code>. Type can be <code>:mayer</code> or <code>:lagrange</code>. Criterion is <code>:min</code> or <code>:max</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can use objective! only once to define the objective.</p><ul><li>The state, control and variable dimensions must be set before. Use state!, control! and variable!.</li><li>The times must be set before. Use time!.</li><li>When an element is of dimension 1, consider it as a scalar.</li></ul></div></div><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; objective!(ocp, :mayer, (x0, xf) -&gt; x0[1] + xf[2])
julia&gt; objective!(ocp, :lagrange, (x, u) -&gt; x[1]^2 + u^2) # the control is of dimension 1</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If you set twice the objective, only the last one will be taken into account.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L675">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}" href="#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}"><code>CTBase.remove_constraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_constraint!(ocp::OptimalControlModel, label::Symbol)
</code></pre><p>Remove a labeled constraint.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; remove_constraint!(ocp, :con)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L769">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.replace_call-Tuple{Any, Symbol, Any, Any}" href="#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}"><code>CTBase.replace_call</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_call(e, x::Symbol, t, y) -&gt; Any
</code></pre><p>Replace calls in e of the form <code>(...x...)(t)</code> by <code>(...y...)</code>.</p><p><strong>Example</strong></p><pre><code class="language- hljs">
julia&gt; t = :t; t0 = 0; tf = :tf; x = :x; u = :u;

julia&gt; e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )
:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))

julia&gt; x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)
:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))

julia&gt; xf = Symbol(x, &quot;f&quot;); replace_call(ans, x, tf, xf)
:(x0[1] * (2xf) - xf[2] * (2x0))

julia&gt; e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)
:(A * x + B * u)

julia&gt; e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)
:(F0(x) + u * F1(x))

julia&gt; e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)
:(0.5 * u ^ 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/ctparser_utils.jl#L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}" href="#CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}"><code>CTBase.replace_call</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_call(e, x::Vector{Symbol}, t, y) -&gt; Any
</code></pre><p>Replace calls in e of the form <code>(...x1...x2...)(t)</code> by <code>(...y1...y2...)</code> for all symbols <code>x1</code>, <code>x2</code>... in the vector <code>x</code>.</p><p><strong>Example</strong></p><pre><code class="language- hljs">
julia&gt; t = :t; t0 = 0; tf = :tf; x = :x; u = :u;

julia&gt; e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])
:(xx ^ 2 + uu[1])

julia&gt; e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])
:(xx ^ 2 + uu[1])

julia&gt; e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])
:((xx ^ 2)(t0) + uu[1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/ctparser_utils.jl#L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.state!" href="#CTBase.state!"><code>CTBase.state!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">state!(ocp::OptimalControlModel, n::Integer)
state!(ocp::OptimalControlModel, n::Integer, name::String)
state!(
    ocp::OptimalControlModel,
    n::Integer,
    name::String,
    components_names::Vector{String}
)
</code></pre><p>Define the state dimension and possibly the names of each component.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You must use state! only once to set the state dimension.</p></div></div><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; state!(ocp, 1)
julia&gt; ocp.state_dimension
1
julia&gt; ocp.state_components_names
[&quot;x&quot;]

julia&gt; state!(ocp, 1, &quot;y&quot;)
julia&gt; ocp.state_dimension
1
julia&gt; ocp.state_components_names
[&quot;y&quot;]

julia&gt; state!(ocp, 2)
julia&gt; ocp.state_dimension
2
julia&gt; ocp.state_components_names
[&quot;x₁&quot;, &quot;x₂&quot;]

julia&gt; state!(ocp, 2, :y)
julia&gt; ocp.state_dimension
2
julia&gt; ocp.state_components_names
[&quot;y₁&quot;, &quot;y₂&quot;]

julia&gt; state!(ocp, 2, &quot;y&quot;)
julia&gt; ocp.state_dimension
2
julia&gt; ocp.state_components_names
[&quot;y₁&quot;, &quot;y₂&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.time!-Union{Tuple{OptimalControlModel{&lt;:TimeDependence, VT}}, Tuple{VT}} where VT" href="#CTBase.time!-Union{Tuple{OptimalControlModel{&lt;:TimeDependence, VT}}, Tuple{VT}} where VT"><code>CTBase.time!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time!(
    ocp::OptimalControlModel{&lt;:TimeDependence, VT};
    t0,
    tf,
    ind0,
    indf,
    name
)
</code></pre><p>Set the initial and final times. We denote by t0 the initial time and tf the final time. The optimal control problem is denoted ocp. When a time is free, then one must provide the corresponding index of the ocp variable.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You must use time! only once to set either the initial or the final time, or both.</p></div></div><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; time!(ocp, t0=0,   tf=1  ) # Fixed t0 and fixed tf
julia&gt; time!(ocp, t0=0,   indf=2) # Fixed t0 and free  tf
julia&gt; time!(ocp, ind0=2, tf=1  ) # Free  t0 and fixed tf
julia&gt; time!(ocp, ind0=2, indf=3) # Free  t0 and free  tf</code></pre><p>When you plot a solution of an optimal control problem, the name of the time variable appears. By default, the name is &quot;t&quot;. Consider you want to set the name of the time variable to &quot;s&quot;.</p><pre><code class="language- hljs">julia&gt; time!(ocp, t0=0, tf=1, name=&quot;s&quot;) # name is a String
# or
julia&gt; time!(ocp, t0=0, tf=1, name=:s ) # name is a Symbol  </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.variable!" href="#CTBase.variable!"><code>CTBase.variable!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">variable!(ocp::OptimalControlModel, q::Integer)
variable!(
    ocp::OptimalControlModel,
    q::Integer,
    name::String
)
variable!(
    ocp::OptimalControlModel,
    q::Integer,
    name::String,
    components_names::Vector{String}
)
</code></pre><p>Define the variable dimension and possibly the names of each component.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can use variable! once to set the variable dimension when the model is <code>NonFixed</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language- hljs">julia&gt; variable!(ocp, 1, &quot;v&quot;)
julia&gt; variable!(ocp, 2, &quot;v&quot;, [ &quot;v₁&quot;, &quot;v₂&quot; ])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/model.jl#L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.∂ₜ-Tuple{Any}" href="#CTBase.∂ₜ-Tuple{Any}"><code>CTBase.∂ₜ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂ₜ(f) -&gt; CTBase.var&quot;#106#108&quot;
</code></pre><p>Partial derivative wrt time of a function.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; ∂ₜ((t,x) -&gt; t*x)(0,8)
8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.@Lie-Tuple{Expr, Any, Any}" href="#CTBase.@Lie-Tuple{Expr, Any, Any}"><code>CTBase.@Lie</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Macros for Poisson brackets</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; H0 = (x, p) -&gt; 0.5*(x[1]^2+x[2]^2+p[1]^2)
julia&gt; H1 = (x, p) -&gt; 0.5*(x[1]^2+x[2]^2+p[2]^2)
julia&gt; @Lie {H0, H1}([1, 2, 3], [1, 0, 7]) autonomous=true variable=false
#
julia&gt; H0 = (t, x, p) -&gt; 0.5*(x[1]^2+x[2]^2+p[1]^2)
julia&gt; H1 = (t, x, p) -&gt; 0.5*(x[1]^2+x[2]^2+p[2]^2)
julia&gt; @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false variable=false
#
julia&gt; H0 = (x, p, v) -&gt; 0.5*(x[1]^2+x[2]^2+p[1]^2+v)
julia&gt; H1 = (x, p, v) -&gt; 0.5*(x[1]^2+x[2]^2+p[2]^2+v)
julia&gt; @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) autonomous=true variable=true
#
julia&gt; H0 = (t, x, p, v) -&gt; 0.5*(x[1]^2+x[2]^2+p[1]^2+v)
julia&gt; H1 = (t, x, p, v) -&gt; 0.5*(x[1]^2+x[2]^2+p[2]^2+v)
julia&gt; @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2) autonomous=false variable=true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.@Lie-Tuple{Expr, Any}" href="#CTBase.@Lie-Tuple{Expr, Any}"><code>CTBase.@Lie</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Macros for Lie and Poisson brackets</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; H0 = (t, x, p) -&gt; 0.5*(x[1]^2+x[2]^2+p[1]^2)
julia&gt; H1 = (t, x, p) -&gt; 0.5*(x[1]^2+x[2]^2+p[2]^2)
julia&gt; @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false
#
julia&gt; H0 = (x, p, v) -&gt; 0.5*(x[1]^2+x[2]^2+p[1]^2+v)
julia&gt; H1 = (x, p, v) -&gt; 0.5*(x[1]^2+x[2]^2+p[2]^2+v)
julia&gt; @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) variable=true
#</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L626">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.@Lie-Tuple{Expr}" href="#CTBase.@Lie-Tuple{Expr}"><code>CTBase.@Lie</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Macros for Lie and Poisson brackets</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; F0 = VectorField(x -&gt; [x[1], x[2], (1-x[3])])
julia&gt; F1 = VectorField(x -&gt; [0, -x[3], x[2]])
julia&gt; @Lie [F0, F1]([1, 2, 3])
[0, 5, 4]
#
julia&gt; F0 = VectorField((t, x) -&gt; [t+x[1], x[2], (1-x[3])], autonomous=false)
julia&gt; F1 = VectorField((t, x) -&gt; [t, -x[3], x[2]], autonomous=false)
julia&gt; @Lie [F0, F1](1, [1, 2, 3])
#
julia&gt; F0 = VectorField((x, v) -&gt; [x[1]+v, x[2], (1-x[3])], variable=true)
julia&gt; F1 = VectorField((x, v) -&gt; [0, -x[3]-v, x[2]], variable=true)
julia&gt; @Lie [F0, F1]([1, 2, 3], 2)
#
julia&gt; F0 = VectorField((t, x, v) -&gt; [t+x[1]+v, x[2], (1-x[3])], autonomous=false, variable=true)
julia&gt; F1 = VectorField((t, x, v) -&gt; [t, -x[3]-v, x[2]], autonomous=false, variable=true)
julia&gt; @Lie [F0, F1](1, [1, 2, 3], 2)
#
julia&gt; H0 = Hamiltonian((x, p) -&gt; 0.5*(2x[1]^2+x[2]^2+p[1]^2))
julia&gt; H1 = Hamiltonian((x, p) -&gt; 0.5*(3x[1]^2+x[2]^2+p[2]^2))
julia&gt; @Lie {H0, H1}([1, 2, 3], [1, 0, 7])
3.0
#
julia&gt; H0 = Hamiltonian((t, x, p) -&gt; 0.5*(x[1]^2+x[2]^2+p[1]^2), autonomous=false)
julia&gt; H1 = Hamiltonian((t, x, p) -&gt; 0.5*(x[1]^2+x[2]^2+p[2]^2), autonomous=false)
julia&gt; @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7])
#
julia&gt; H0 = Hamiltonian((x, p, v) -&gt; 0.5*(x[1]^2+x[2]^2+p[1]^2+v), variable=true)
julia&gt; H1 = Hamiltonian((x, p, v) -&gt; 0.5*(x[1]^2+x[2]^2+p[2]^2+v), variable=true)
julia&gt; @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2)
#
julia&gt; H0 = Hamiltonian((t, x, p, v) -&gt; 0.5*(x[1]^2+x[2]^2+p[1]^2+v), autonomous=false, variable=true)
julia&gt; H1 = Hamiltonian((t, x, p, v) -&gt; 0.5*(x[1]^2+x[2]^2+p[2]^2+v), autonomous=false, variable=true)
julia&gt; @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2)
#</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/differential_geometry.jl#L507">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CTBase.@def" href="#CTBase.@def"><code>CTBase.@def</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define an optimal control problem. One pass parsing of the definition.</p><p><strong>Example</strong></p><pre><code class="language- hljs">@def ocp begin
    tf ∈ R, variable
    t ∈ [ 0, tf ], time
    x ∈ R², state
    u ∈ R, control
    tf ≥ 0
    -1 ≤ u(t) ≤ 1
    q = x₁
    v = x₂
    q(0) == 1
    v(0) == 2
    q(tf) == 0
    v(tf) == 0
    0 ≤ q(t) ≤ 5,       (1)
    -2 ≤ v(t) ≤ 3,      (2)
    ẋ(t) == [ v(t), u(t) ]
    tf → min
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/control-toolbox/CTBase.jl/blob/v0.11.2/src/onepass.jl#L444">source</a></section></article><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Friday 12 July 2024 17:19">Friday 12 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
