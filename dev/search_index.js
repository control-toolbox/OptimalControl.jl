var documenterSearchIndex = {"docs":
[{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"<img width=\"800\" alt=\"juliaopt2024\" src=\"./assets/juliacon2024.jpg\">","category":"page"},{"location":"juliacon2024.html#Trajectory-optimisation-in-space-mechanics-with-Julia","page":"JuliaCon 2024","title":"Trajectory optimisation in space mechanics with Julia","text":"","category":"section"},{"location":"juliacon2024.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Alesia-Herasimenka](https://www.uni.lu/snt-en/people/alesia-herasimenka)","page":"JuliaCon 2024","title":"Jean-Baptiste Caillau, Olivier Cots, Alesia Herasimenka","text":"","category":"section"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil-lux.jpg\">","category":"page"},{"location":"juliacon2024.html#What-it's-about","page":"JuliaCon 2024","title":"What it's about","text":"","category":"section"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"subject to","category":"page"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"plus boundary, control and state constraints","category":"page"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"juliacon2024.html#OptimalControl.jl-for-trajectory-optimisation","page":"JuliaCon 2024","title":"OptimalControl.jl for trajectory optimisation","text":"","category":"section"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"Basic example\nGoddard problem\nOrbit transfer","category":"page"},{"location":"juliacon2024.html#Wrap-up","page":"JuliaCon 2024","title":"Wrap up","text":"","category":"section"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"High level modelling of optimal control problems\nEfficient numerical resolution coupling direct and indirect methods\nCollection of examples","category":"page"},{"location":"juliacon2024.html#Future","page":"JuliaCon 2024","title":"Future","text":"","category":"section"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"New applications (biology, space mechanics, quantum mechanics and more)\nAdditional solvers: direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions!","category":"page"},{"location":"juliacon2024.html#control-toolbox.org","page":"JuliaCon 2024","title":"control-toolbox.org","text":"","category":"section"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"juliacon2024.html#Credits-(not-exhaustive!)","page":"JuliaCon 2024","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nMLStyle.jl","category":"page"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"","category":"page"},{"location":"tutorial-basic-example.html#basic","page":"Energy min (abstract syntax)","title":"Double integrator: energy min (abstract syntax)","text":"","category":"section"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force u. We denote by x = (x_1 x_2) the state of the wagon, that is its position x_1 and its velocity x_2.","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"We assume that the mass is constant and unitary and that there is no friction. The dynamics we consider is given by","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t)quad u(t) in R","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"which is simply the double integrator system. Les us consider a transfer starting at time t_0 = 0 and ending at time t_f = 1, for which we want to minimise the transfer energy","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"    frac12int_0^1 u^2(t)  mathrmdt","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"starting from the condition x(0) = (-1 0) and with the goal to reach the target x(1) = (0 0).","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"First, we need to import the OptimalControl.jl package to define the optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"Then, we can define the problem","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"@def ocp begin\n    t âˆˆ [0, 1], time\n    x âˆˆ RÂ², state\n    u âˆˆ R, control\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n    xÌ‡(t) == [ xâ‚‚(t), u(t) ]\n    âˆ«( 0.5u(t)^2 ) â†’ min\nend\nnothing # hide","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"Solve it","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"And plot the solution","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"plot(sol)","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"For a comprehensive introduction to the syntax used above to describe the optimal control problem, check this tutorial. ","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"We can save the solution in a julia .jld2 data file and reload it later, and also export a discretised version of the solution in a more portable JSON format.","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"# load additional modules\nusing JLD2, JSON3\n\n# JLD save / load\nsave(sol, filename_prefix=\"my_solution\")\nsol_reloaded = load(\"my_solution\")\nprintln(\"Objective from loaded solution: \", sol_reloaded.objective)\n\n# JSON export / read\nexport_ocp_solution(sol, filename_prefix=\"my_solution\")\nsol_json = import_ocp_solution(\"my_solution\")\nprintln(\"Objective from JSON discrete solution: \", sol_json.objective)","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy min (abstract syntax)","title":"Energy min (abstract syntax)","text":"","category":"page"},{"location":"tutorial-lqr-basic.html#A-simple-Linearâ€“quadratic-regulator-example","page":"Linearâ€“quadratic regulator","title":"A simple Linearâ€“quadratic regulator example","text":"","category":"section"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"We consider the following Linear Quadratic Regulator (LQR) problem which consists in minimising","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"    frac12 int_0^t_f left( x_1^2(t) + x_2^2(t) + u^2(t) right)  mathrmdt ","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"subject to the constraints","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = -x_1(t) + u(t) quad u(t) in R","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"and the initial condition","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"    x(0) = (01)","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"We define A and B as","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"    A = beginpmatrix 0  1  -1  0  endpmatrix quad\n    B = beginpmatrix 0  1  endpmatrix","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"in order to get dotx = Ax + Bu and we aim to solve this optimal control problem for different values of t_f. First, we need to import the OptimalControl.jl package to define the optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solutions.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"Then, we can define the problem parameterized by the final time tf.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"x0 = [ 0\n       1 ]\n\nA  = [ 0 1\n      -1 0 ]\n\nB  = [ 0\n       1 ]\n\nfunction lqr(tf)\n\n    @def ocp begin\n        t âˆˆ [0, tf], time\n        x âˆˆ RÂ², state\n        u âˆˆ R, control\n        x(0) == x0\n        áº‹(t) == A * x(t) + B * u(t)\n        âˆ«( 0.5(xâ‚(t)^2 + xâ‚‚(t)^2 + u(t)^2) ) â†’ min\n    end\n\n    return ocp\nend;\nnothing # hide","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"We solve the problem for t_f in 3 5 30.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"solutions = []   # empty list of solutions\ntfs = [3, 5, 30]\n\nfor tf âˆˆ tfs\n    solution = solve(lqr(tf), display=false)\n    push!(solutions, solution)\nend\nnothing # hide","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"We plot the state and control variables considering a normalized time s=(t-t_0)(t_f-t_0), thanks to the keyword argument time=:normalized of the plot function.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"plt = plot(solutions[1], time=:normalized)\nfor sol âˆˆ solutions[2:end]\n    plot!(plt, sol, time=:normalized)\nend\n\n# we plot only the state and control variables and we add the legend\nN = length(tfs)\npx1 = plot(plt[1], legend=false, xlabel=\"s\", ylabel=\"xâ‚\")\npx2 = plot(plt[2], label=reshape([\"tf = $tf\" for tf âˆˆ tfs], (1, N)), xlabel=\"s\", ylabel=\"xâ‚‚\")\npu  = plot(plt[5], legend=false, xlabel=\"s\", ylabel=\"u\")\n\nusing Plots.PlotMeasures # for leftmargin, bottommargin\nplot(px1, px2, pu, layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"note: Nota bene\nWe can observe that x(t_f) converges to the origin as t_f increases.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linearâ€“quadratic regulator","title":"Linearâ€“quadratic regulator","text":"","category":"page"},{"location":"tutorial-iss.html#iss","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"In this tutorial we present the indirect simple shooting method on a simple example.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using Suppressor # to suppress warnings","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us start by importing the necessary packages.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using OptimalControl  # to define the optimal control problem and its flow\nusing OrdinaryDiffEq  # to get the Flow function from OptimalControl\nusing NonlinearSolve  # interface to NLE solvers\nusing MINPACK         # NLE solver: use to solve the shooting equation\nusing Plots           # to plot the solution","category":"page"},{"location":"tutorial-iss.html#Optimal-control-problem","page":"Indirect simple shooting","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us consider the following optimal control problem:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"left \n    beginarrayl\n        min displaystyle frac12 int_t_0^t_f u^2(t)  mathrmd t10em\n        dotx(t)  =  displaystyle -x(t)+alpha x^2(t)+u(t) quad  u(t) in R \n        quad t in t_0 t_f text ae 05em\n        x(t_0) = x_0 quad x(t_f) = x_f\n    endarray\nright","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"with t_0 = 0, t_f = 1, x_0 = -1, x_f = 0, alpha=15 and forall t in t_0 t_f, x(t) in R.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"t0 = 0\ntf = 1\nx0 = -1\nxf = 0\nÎ±  = 1.5\n@def ocp begin\n\n    t âˆˆ [t0, tf], time\n    x âˆˆ R, state\n    u âˆˆ R, control\n\n    x(t0) == x0\n    x(tf) == xf\n\n    xÌ‡(t) == -x(t) + Î± * x(t)^2 + u(t)\n\n    âˆ«( 0.5u(t)^2 ) â†’ min\n    \nend;\nnothing # hide","category":"page"},{"location":"tutorial-iss.html#Boundary-value-problem","page":"Indirect simple shooting","title":"Boundary value problem","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"The pseudo-Hamiltonian of this problem is","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    H(xpu) = p  (-x+alpha x^2+u) + p^0 u^2 2","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"where p^0 = -1 since we are in the normal case. From the Pontryagin Maximum Principle, the maximising control is given by","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"u(x p) = p","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"since partial^2_uu H = p^0 = - 1  0. Plugging this control in feedback form into the pseudo-Hamiltonian, and considering the limit conditions, we obtain the following two-points boundary value problem (BVP).","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    left \n        beginarrayl\n            dotx(t)  = phantom- nabla_p Ht = -x(t) + alpha x^2(t) + u(x(t) p(t)) \n            = -x(t) + alpha x^2(t) + p(t) 05em\n            dotp(t)  = -           nabla_x Ht = (1 - 2 alpha x(t)) p(t)    05em\n            x(t_0)        = x_0 quad x(t_f) = x_f\n        endarray\n    right","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"where t=  (x(t)p(t)u(x(t) p(t))).","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"note: Our goal\nOur goal is to solve this (BVP). Solving (BVP) consists in solving the Pontryagin Maximum Principle which provides necessary conditions of optimality.","category":"page"},{"location":"tutorial-iss.html#Shooting-function","page":"Indirect simple shooting","title":"Shooting function","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"To achive our goal, let us first introduce the pseudo-Hamiltonian vector field","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    vecH(zu) = left( nabla_p H(zu) -nabla_x H(zu) right) quad z = (xp)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"and then denote by varphi_t_0 x_0 p_0(cdot) the solution of the following Cauchy problem","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"dotz(t) = vecH(z(t) u(z(t))) quad z(t_0) = (x_0 p_0)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Our goal becomes to solve","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"pi( varphi_t_0 x_0 p_0(t_f) ) = x_f quad pi(x p) = x","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"To compute varphi with the OptimalControl package, we define the flow of the associated Hamiltonian vector field by:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"u(x, p) = p\nÏ† = Flow(ocp, u)\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We define also the projection function on the state space.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Ï€((x, p)) = x\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"note: Nota bene\nActually, varphi_t_0 x_0 p_0(cdot) is also solution of    dotz(t) = vecmathbfH(z(t)) quad z(t_0) = (x_0 p_0)where mathbfH(z) = H(z u(z)) and vecmathbfH = (nabla_p mathbfH -nabla_x mathbfH). This is what is actually computed by Flow.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Now, to solve the (BVP) we introduce the shooting function.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    beginarrayrlll\n        S colon     R     longrightarrow    R \n                     p_0     longmapsto      S(p_0) = pi( varphi_t_0 x_0 p_0(t_f) ) - x_f\n    endarray","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"S(p0) = Ï€( Ï†(t0, x0, p0, tf) ) - xf # shooting function\nnothing # hide","category":"page"},{"location":"tutorial-iss.html#Resolution-of-the-shooting-equation","page":"Indirect simple shooting","title":"Resolution of the shooting equation","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"At the end, solving (BVP) is equivalent to solve S(p_0) = 0. This is what we call the  indirect simple shooting method. We define an initial guess.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Î¾ = [ 0.0 ] # initial guess\nnothing # hide","category":"page"},{"location":"tutorial-iss.html#NonlinearSolve.jl","page":"Indirect simple shooting","title":"NonlinearSolve.jl","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We first use the NonlinearSolve.jl package to solve the shooting equation. Let us define the problem.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"nle! = (s, Î¾, Î») -> s[1] = S(Î¾[1]) # auxiliary function\nprob = NonlinearProblem(nle!, Î¾)   # NLE problem with initial guess\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us do some benchmarking.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using BenchmarkTools\n@benchmark solve(prob; show_trace=Val(false))","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"For small nonlinear systems, it could be faster to use the  SimpleNewtonRaphson() descent algorithm.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"@benchmark solve(prob, SimpleNewtonRaphson(); show_trace=Val(false))","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Now, let us solve the problem and retrieve the initial costate solution.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"global indirect_sol =                               # hide\n@suppress_err begin                                 # hide\nsolve(prob; show_trace=Val(false))                  # hide\nindirect_sol = solve(prob; show_trace=Val(true))    # resolution of S(p0) = 0  \nend                                                 # hide\np0_sol = indirect_sol.u[1]                          # costate solution\nprintln(\"\\ncostate:    p0 = \", p0_sol)\n@suppress_err begin                                 # hide\nprintln(\"shoot: |S(p0)| = \", abs(S(p0_sol)), \"\\n\")\nend                                                 # hide\nnothing                                             # hide","category":"page"},{"location":"tutorial-iss.html#MINPACK.jl","page":"Indirect simple shooting","title":"MINPACK.jl","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using MINPACK\nfunction fsolve(f, j, x; kwargs...)\n    try\n        MINPACK.fsolve(f, j, x; kwargs...)\n    catch e\n        println(\"Erreur using MINPACK\")\n        println(e)\n        println(\"hybrj not supported. Replaced by hybrd even if it is not visible on the doc.\")\n        MINPACK.fsolve(f, x; kwargs...)\n    end\nend","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Instead of the NonlinearSolve.jl package we can use the  MINPACK.jl package to solve  the shooting equation. To compute the Jacobian of the shooting function we use the  DifferentiationInterface.jl package with  ForwardDiff backend.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using DifferentiationInterface\nimport ForwardDiff\nbackend = AutoForwardDiff()\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us define the problem to solve.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"nle!  = ( s, Î¾) -> s[1] = S(Î¾[1])                              # auxiliary function\njnle! = (js, Î¾) -> jacobian!(nle!, similar(Î¾), js, backend, Î¾) # Jacobian of nle\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We are now in position to solve the problem with the hybrj solver from MINPACK through the fsolve  function, providing the Jacobian. Let us do some benchmarking.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"@benchmark fsolve(nle!, jnle!, Î¾; show_trace=false) # initial guess given to the solver","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We can also use the preparation step of DifferentiationInterface.jl.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"extras = prepare_jacobian(nle!, similar(Î¾), backend, Î¾)\njnle_prepared!(js, Î¾) = jacobian!(nle!, similar(Î¾), js, backend, Î¾, extras)\n@benchmark fsolve(nle!, jnle_prepared!, Î¾; show_trace=false)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Now, let us solve the problem and retrieve the initial costate solution.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"global indirect_sol =                                   # hide\n@suppress_err begin                                     # hide\nfsolve(nle!, jnle!, Î¾; show_trace=false)                # hide\nindirect_sol = fsolve(nle!, jnle!, Î¾; show_trace=true)  # resolution of S(p0) = 0\nend                                                     # hide\np0_sol = indirect_sol.x[1]                              # costate solution\nprintln(\"\\ncostate:    p0 = \", p0_sol)\n@suppress_err begin                                     # hide\nprintln(\"shoot: |S(p0)| = \", abs(S(p0_sol)), \"\\n\")\nend                                                     # hide\nnothing                                                 # hide","category":"page"},{"location":"tutorial-iss.html#Plot-of-the-solution","page":"Indirect simple shooting","title":"Plot of the solution","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"The solution can be plot calling first the flow.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"sol = Ï†( (t0, tf), x0, p0_sol )\nplot(sol, size=(800, 600))","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"In the indirect shooting method, the research of the optimal control is replaced by the computation of its associated extremal. This computation is equivalent to finding the initial covector solution to the shooting function.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"exp(p0; saveat=[]) = Ï†((t0, tf), x0, p0, saveat=saveat).ode_sol # hide\ntimes = range(t0, tf, length=2) # hide\np0min = -0.5 # hide\np0max = 2 # hide\nplt_flow = plot() # hide\np0s = range(p0min, p0max, length=20) # hide\nfor i âˆˆ 1:length(p0s) # hide\n    sol = exp(p0s[i]) # hide\n    x = [sol(t)[1] for t âˆˆ sol.t] # hide\n    p = [sol(t)[2] for t âˆˆ sol.t] # hide\n    label = i==1 ? \"extremals\" : false # hide\n    plot!(plt_flow, x, p, color=:blue, label=label) # hide\nend # hide\np0s = range(p0min, p0max, length=200) # hide\nxs  = zeros(length(p0s), length(times)) # hide\nps  = zeros(length(p0s), length(times)) # hide\nfor i âˆˆ 1:length(p0s) # hide\n    sol = exp(p0s[i], saveat=times) # hide\n    xs[i, :] = [z[1] for z âˆˆ sol.(times)] # hide\n    ps[i, :] = [z[2] for z âˆˆ sol.(times)] # hide\nend # hide\nfor j âˆˆ 1:length(times) # hide\n    label = j==1 ? \"flow at times\" : false # hide\n    plot!(plt_flow, xs[:, j], ps[:, j], color=:green, linewidth=2, label=label) # hide\nend # hide\nplot!(plt_flow, xlims = (-1.1, 1), ylims =  (p0min, p0max)) # hide\nplot!(plt_flow, [0, 0], [p0min, p0max], color=:black, xlabel=\"x\", ylabel=\"p\", label=\"x=xf\") # hide\nsol = exp(p0_sol) # hide\nx = [sol(t)[1] for t âˆˆ sol.t] # hide\np = [sol(t)[2] for t âˆˆ sol.t] # hide\nplot!(plt_flow, x, p, color=:red, linewidth=2, label=\"extremal solution\") # hide\nplot!(plt_flow, [x[end]], [p[end]], seriestype=:scatter, color=:green, label=false) # hide\nplt_shoot = plot(xlims=(p0min, p0max), ylims=(-2, 4), xlabel=\"pâ‚€\", ylabel=\"y\") # hide\nplot!(plt_shoot, p0s, S, linewidth=2, label=\"S(pâ‚€)\", color=:green) # hide\nplot!(plt_shoot, [p0min, p0max], [0, 0], color=:black, label=\"y=0\") # hide\nplot!(plt_shoot, [p0_sol, p0_sol], [-2, 0], color=:black, label=\"pâ‚€ solution\", linestyle=:dash) # hide\nplot!(plt_shoot, [p0_sol], [0], seriestype=:scatter, color=:green, label=false) # hide\nplot(plt_flow, plt_shoot, layout=(1,2), size=(800, 450)) # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"","category":"page"},{"location":"dev-optimalcontrol.html#dev-optimalcontrol","page":"OptimalControl.jl","title":"OptimalControl.jl private functions","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-optimalcontrol.html#Index","page":"OptimalControl.jl","title":"Index","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Pages   = [\"dev-optimalcontrol.md\"]\nModules = [OptimalControl]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-optimalcontrol.html#Documentation","page":"OptimalControl.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Modules = [OptimalControl]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"","category":"page"},{"location":"tutorial-abstract.html#abstract","page":"Abstract syntax","title":"The abstract syntax to define an optimal control problem","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The full grammar of OptimalControl.jl small Domain Specific Language is given below. The idea is to use a syntax that is","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"pure Julia (and, as such, effortlessly analysed by the standard Julia parser),\nas close as possible to the mathematical description of an optimal control problem. ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"While the syntax will be transparent to those users familiar with Julia expressions (Expr's), we provide examples for every case that should be widely understandable. We rely heavily on MLStyle.jl and its pattern matching abilities ðŸ‘ðŸ½ for the semantic pass. Abstract definitions use the macro @def.","category":"page"},{"location":"tutorial-abstract.html#variable","page":"Abstract syntax","title":"Variable","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $v âˆˆ R^$q, variable ) \n:( $v âˆˆ R   , variable ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"A variable (only one is allowed) is a finite dimensional vector or reals that will be optimised along with state and control values. To define an (almost empty!) optimal control problem, named ocp, having a dimension two variable named v, do the following:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"using OptimalControl #hide\n@def ocp begin\n    v âˆˆ RÂ², variable\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Aliases vâ‚ and vâ‚‚ are automatically defined and can be used in subsequent expressions instead of v[1] and v[2]. The user can also define her own aliases for the components (one alias per dimension):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    v = (a, b) âˆˆ RÂ², variable\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"A one dimensional variable can be declared according to","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    v âˆˆ R, variable\nend","category":"page"},{"location":"tutorial-abstract.html#Time","page":"Abstract syntax","title":"Time","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $t âˆˆ [$t0, $tf], time ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The independent variable or time is a scalar bound to a given interval. Its name is arbitrary.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"t0 = 1\ntf = 5\n@def ocp begin\n    t âˆˆ [t0, tf], time\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"One (or even the two bounds) can be variable, typically for minimum time problems (see Mayer cost section):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    v = (T, Î») âˆˆ RÂ², variable\n    t âˆˆ [0, T], time\nend","category":"page"},{"location":"tutorial-abstract.html#state","page":"Abstract syntax","title":"State","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $x âˆˆ R^$n, state ) \n:( $x âˆˆ R   , state ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The state declaration defines the name and the dimension of the state:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    x âˆˆ Râ´, state\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"As for the variable, there are automatic aliases (xâ‚ for x[1], etc.) and the user can define her own aliases (one per scalar component of the state):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    x = (qâ‚, qâ‚‚, vâ‚, vâ‚‚) âˆˆ Râ´, state\nend","category":"page"},{"location":"tutorial-abstract.html#control","page":"Abstract syntax","title":"Control","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $u âˆˆ R^$m, control ) \n:( $u âˆˆ R   , control ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The control declaration defines the name and the dimension of the control:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    u âˆˆ RÂ², control\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"As before, there are automatic aliases (uâ‚ for u[1], etc.) and the user can define her own aliases (one per scalar component of the state):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    u = (Î±, Î²) âˆˆ RÂ², control\nend","category":"page"},{"location":"tutorial-abstract.html#dynamics","page":"Abstract syntax","title":"Dynamics","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( âˆ‚($x)($t) == $e1 ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The dynamics is given in the standard vectorial ODE form:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"    dotx(t) = f(x(t) u(t)) quad textor quad dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"depending on whether it is autonomous or not (the parser will detect dependence time, which entails that time and state must be declared prior to dynamics - an error will be issued otherwise). The symbol âˆ‚ or the dotted state name (áº‹ can be used):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    t âˆˆ [0, 1], time\n    x âˆˆ RÂ², state\n    u âˆˆ R, control\n    âˆ‚(x)(t) == [xâ‚‚(t), u(t)]\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"or","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    t âˆˆ [0, 1], time\n    x âˆˆ RÂ², state\n    u âˆˆ R, control\n    áº‹(t) == [xâ‚‚(t), u(t)]\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Any Julia code can be used, so the following is also OK: ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    t âˆˆ [0, 1], time\n    x âˆˆ RÂ², state\n    u âˆˆ R, control\n    áº‹(t) == Fâ‚€(x(t)) + u(t) * Fâ‚(x(t))\nend\n\nFâ‚€(x) = [x[2], 0]\nFâ‚(x) = [0, 1]\nnothing # hide","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"note: Note\nThe vector fields Fâ‚€ and Fâ‚ can be defined afterwards, as they only need to be available when the dynamics will be evaluated.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Currently, it is not possible to declare the dynamics component after component, but a simple workaround is to use aliases (check the relevant aliases section below):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def damped_integrator begin\n    tf âˆˆ R, variable\n    t âˆˆ [0, tf], time\n    x = (q, v) âˆˆ RÂ², state\n    u âˆˆ R, control\n    qÌ‡ = v(t)\n    vÌ‡ = u(t) - c(t)\n    áº‹(t) == [qÌ‡, vÌ‡]\nend","category":"page"},{"location":"tutorial-abstract.html#Constraints","page":"Abstract syntax","title":"Constraints","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $e1 == $e2        ) \n:( $e1 â‰¤  $e2 â‰¤  $e3 ) \n:(        $e2 â‰¤  $e3 ) \n:( $e3 â‰¥  $e2 â‰¥  $e1 ) \n:( $e2 â‰¥  $e1        ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Constraints ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"can be of five types: boundary, control, state, mixed, variable,\nbe linear (ranges) or nonlinear (not ranges),\nequalities or (one or two-sided) inequalities.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Boundary conditions are detected when the expression contains evaluations of the state at initial and / or final time bounds (e.g., x(0)), and may not involve the control. Conversely control, state or mixed constraints will involve control, state or both evaluated at the declared time (e.g., x(t) + u(t)).  Other combinations should be detected as incorrect by the parser ðŸ¤žðŸ¾. The variable may be involved in any of the four previous constraints. Constraints involving the variable only are variable constraints, either linear or nonlinear. In the example below, there are","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"two linear boundary constraints,\none linear variable constraint,\none linear state constraint,\none (two-sided) nonlinear control constraint.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    tf âˆˆ R, variable\n    t âˆˆ [0, tf], time\n    x âˆˆ RÂ², state\n    u âˆˆ R, control\n    x(0) == [-1, 0]\n    x(tf) == [0, 0]\n    áº‹(t) == [xâ‚‚(t), u(t)]\n    tf â‰¥ 0 \n    xâ‚‚(t) â‰¤ 1\n    u(t)^2 â‰¤ 1\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"caveat: Caveat\nWrite either u(t)^2 or (u^2)(t), not u^2(t) since in Julia the latter is means u^(2t). Moreover, in the case of equalities or of one-sided inequalities, the control and / or the state must belong the left-hand side. The following will error:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"julia> @def ocp begin\n    t âˆˆ [0, 2], time\n    x âˆˆ RÂ², state\n    u âˆˆ R, control\n    x(0) == [-1, 0]\n    x(2) == [0, 0]\n    áº‹(t) == [xâ‚‚(t), u(t)]\n    1 â‰¤ xâ‚‚(t)\n    -1 â‰¤ u(t) â‰¤ 1\nend\nERROR: ParsingError: \nLine 7: 1 â‰¤ xâ‚‚(t)\nbad constraint declaration","category":"page"},{"location":"tutorial-abstract.html#mayer","page":"Abstract syntax","title":"Mayer cost","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $e1 â†’ min ) \n:( $e1 â†’ max ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Mayer costs are defined in a similar way to boundary conditions and follow the same rules. The symbol â†’ is used to denote minimisation of maximisation, the latter being treated by minimising the opposite cost.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    tf âˆˆ R, variable\n    t âˆˆ [0, tf], time\n    x = (q, v) âˆˆ RÂ², state\n    u âˆˆ R, control\n    tf â‰¥ 0\n    -1 â‰¤ u(t) â‰¤ 1\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 â‰¤ q(t) â‰¤ 5\n   -2 â‰¤ v(t) â‰¤ 3\n    áº‹(t) == [v(t), u(t)]\n    tf â†’ min\nend","category":"page"},{"location":"tutorial-abstract.html#Lagrange-cost","page":"Abstract syntax","title":"Lagrange cost","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":(       âˆ«($e1) â†’ min ) \n:(     - âˆ«($e1) â†’ min ) \n:( $e1 * âˆ«($e2) â†’ min ) \n:(       âˆ«($e1) â†’ max ) \n:(     - âˆ«($e1) â†’ max ) \n:( $e1 * âˆ«($e2) â†’ max ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Lagrange (integral) costs are defined used the symbol âˆ«, *with parenthesis:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    t âˆˆ [0, 1], time\n    x = (q, v) âˆˆ RÂ², state\n    u âˆˆ R, control\n    0.5âˆ«(q(t) + u(t)^2) â†’ min\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The integration range is implicitly equal to the time range, so the cost above is to be understood as","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"int_0^1 left( q(t) + u^2(t) right) mathrmdt to min","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"As for the dynamics, the parser will detect whether the integrand depends or not on time (autonomous / non-autonomous case).","category":"page"},{"location":"tutorial-abstract.html#Bolza-cost","page":"Abstract syntax","title":"Bolza cost","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $e1 +       âˆ«($e2)       â†’ min ) \n:( $e1 + $e2 * âˆ«($e3)       â†’ min ) \n:( $e1 -       âˆ«($e2)       â†’ min ) \n:( $e1 - $e2 * âˆ«($e3)       â†’ min ) \n:( $e1 +       âˆ«($e2)       â†’ max ) \n:( $e1 + $e2 * âˆ«($e3)       â†’ max ) \n:( $e1 -       âˆ«($e2)       â†’ max ) \n:( $e1 - $e2 * âˆ«($e3)       â†’ max ) \n:(             âˆ«($e2) + $e1 â†’ min ) \n:(       $e2 * âˆ«($e3) + $e1 â†’ min ) \n:(             âˆ«($e2) - $e1 â†’ min ) \n:(       $e2 * âˆ«($e3) - $e1 â†’ min ) \n:(             âˆ«($e2) + $e1 â†’ max ) \n:(       $e2 * âˆ«($e3) + $e1 â†’ max ) \n:(             âˆ«($e2) - $e1 â†’ max ) \n:(       $e2 * âˆ«($e3) - $e1 â†’ max ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Quite readily, Mayer and Lagrange costs can be combined into general Bolza costs. For instance as follows:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    p = (t0, tf) âˆˆ RÂ², variable\n    t âˆˆ [t0, tf], time\n    x = (q, v) âˆˆ RÂ², state\n    u âˆˆ RÂ², control\n    (tf - t0) + 0.5âˆ«(c(t) * u(t)^2) â†’ min\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"caveat: Caveat\nThe expression must be the sum of two terms (plus, possibly, a scalar factor before the integral), not more, so mind the parentheses. For instance, the following errors:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"julia> @def ocp begin\n           p = (t0, tf) âˆˆ RÂ², variable\n           t âˆˆ [t0, tf], time\n           x = (q, v) âˆˆ RÂ², state\n           u âˆˆ RÂ², control\n           (tf - t0) + q(tf) + 0.5âˆ«( c(t) * u(t)^2 ) â†’ min\n       end\nERROR: ParsingError: \nLine 5: (tf - t0) + q(tf) + 0.5 * âˆ«(c(t) * u(t) ^ 2) â†’ min\nbad objective declaration resulting in a Mayer term with trailing âˆ«","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The correct syntax is","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    p = (t0, tf) âˆˆ RÂ², variable\n    t âˆˆ [t0, tf], time\n    x = (q, v) âˆˆ RÂ², state\n    u âˆˆ RÂ², control\n    ( (tf - t0) + q(tf) ) + 0.5âˆ«( c(t) * u(t)^2 ) â†’ min\nend","category":"page"},{"location":"tutorial-abstract.html#aliases","page":"Abstract syntax","title":"Aliases","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $a = $e1 )","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The single = symbol is used to define not a constraint but an alias, that is a purely syntactic replacement. There are some automatic aliases, e.g. xâ‚ for x[1] if x is the state, and we have also seen that the user can define her own aliases when declaring the variable, state and control. Arbitrary aliases can be further defined, as below (compare with previous examples in the dynamics section):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def ocp begin\n    t âˆˆ [0, 1], time\n    x âˆˆ RÂ², state\n    u âˆˆ R, control\n    Fâ‚€ = [xâ‚‚(t), 0]\n    Fâ‚ = [0, 1]\n    áº‹(t) == Fâ‚€ + u(t) * Fâ‚\nend\n","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"caveat: Caveat\nSuch aliases do not define any additional function and are just replaced textually by the parser. In particular, they cannot be used outside the @def begin ... end block.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"hint: Hint\nYou can use a trace mode for the macro @def to look at your code after expansions of the aliases adding true after your begin ... end block:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"julia> @def damped_integrator begin\n           tf âˆˆ R, variable\n           t âˆˆ [0, tf], time\n           x = (q, v) âˆˆ RÂ², state\n           u âˆˆ R, control\n           qÌ‡ = v(t)\n           vÌ‡ = u(t) - c(t)\n           áº‹(t) == [qÌ‡, vÌ‡]\n       end true\n\nvariable: tf, dim: 1\ntime: t, initial time: 0, final time: tf\nstate: x, dim: 2\ncontrol: u, dim: 1\nalias: qÌ‡ = (x[2])(t)\nalias: vÌ‡ = u(t) - c(t)\ndynamics: áº‹(t) == [(x[2])(t), u(t) - c(t)]","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"caveat: Caveat\nThe dynamics of an OCP is indeed a particular constraint, be careful to use == and not a single = that would try to define an alias:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"julia> @def double_integrator begin\n       tf âˆˆ R, variable\n       t âˆˆ [0, tf], time\n       x = (q, v) âˆˆ RÂ², state\n       u âˆˆ R, control\n       qÌ‡ = v\n       vÌ‡ = u\n       áº‹(t) = [qÌ‡, vÌ‡]\n       end\nERROR: ParsingError: \nLine 7: áº‹(t) = begin\n        #= REPL[35]:8 =#\n        [qÌ‡, vÌ‡]\n    end\nforbidden alias name: (âˆ‚(x))(t)","category":"page"},{"location":"tutorial-abstract.html#Misc","page":"Abstract syntax","title":"Misc","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Declarations (of variable - if any -, time, state and control) must be done first. Then, dynamics, constraints and cost can be introduced in an arbitrary order.\nIt is possible to provide numbers / labels (as in math equations) for the constraints to improve readability (this is mostly for future use, typically to retrieve the Lagrange multiplier associated with the discretisation of a given constraint):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def damped_integrator begin\n    tf âˆˆ R, variable\n    t âˆˆ [0, tf], time\n    x = (q, v) âˆˆ RÂ², state\n    u âˆˆ R, control\n    tf â‰¥ 0, (1)\n    q(0) == 2, (â™¡)\n    qÌ‡ = v(t)\n    vÌ‡ = u(t) - c(t)\n    áº‹(t) == [qÌ‡, vÌ‡]\n    x(t).^2  â‰¤ [1, 2], (state_con) \nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Parsing errors should be explicit enough (with line number in the @def begin ... end block indicated) ðŸ¤žðŸ¾\nCheck tutorials and applications in the documentation for further use.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"","category":"page"},{"location":"api-ctbase/parser.html#api-ctbase-parser","page":"Parser","title":"Parser","text":"","category":"section"},{"location":"api-ctbase/parser.html","page":"Parser","title":"Parser","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/parser.html#Index","page":"Parser","title":"Index","text":"","category":"section"},{"location":"api-ctbase/parser.html","page":"Parser","title":"Parser","text":"Pages   = [\"parser.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/parser.html#Documentation","page":"Parser","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/parser.html","page":"Parser","title":"Parser","text":"Modules = [CTBase]\nOrder = [:module, :constant, :macro, :function]\nPages = [\"ctparser_utils.jl\", \"onepass.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/parser.html#CTBase.constraint_type-NTuple{7, Any}","page":"Parser","title":"CTBase.constraint_type","text":"constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n\n\nReturn the type constraint among :initial, :final, :boundary, :control_range, :control_fun, :state_range, :state_fun, :mixed, :variable_range, :variable_fun (:other otherwise), together with the appropriate value (range, updated expression...) Expressions like u(t0) where u is the control and t0 the initial time return :other.\n\nExample\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( yÌ‡(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( xÌ‡(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, 1)\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, 1)\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, 1)\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, 1)\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, 2)\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n:variable_fun\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n:variable_fun\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/parser.html#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}","page":"Parser","title":"CTBase.replace_call","text":"replace_call(e, x::Symbol, t, y) -> Any\n\n\nReplace calls in e of the form (...x...)(t) by (...y...).\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/parser.html#CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","page":"Parser","title":"CTBase.replace_call","text":"replace_call(e, x::Vector{Symbol}, t, y) -> Any\n\n\nReplace calls in e of the form (...x1...x2...)(t) by (...y1...y2...) for all symbols x1, x2... in the vector x.\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/parser.html#CTBase.@def","page":"Parser","title":"CTBase.@def","text":"Define an optimal control problem. One pass parsing of the definition.\n\nExample\n\n@def ocp begin\n    tf âˆˆ R, variable\n    t âˆˆ [ 0, tf ], time\n    x âˆˆ RÂ², state\n    u âˆˆ R, control\n    tf â‰¥ 0\n    -1 â‰¤ u(t) â‰¤ 1\n    q = xâ‚\n    v = xâ‚‚\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 â‰¤ q(t) â‰¤ 5,       (1)\n    -2 â‰¤ v(t) â‰¤ 3,      (2)\n    xÌ‡(t) == [ v(t), u(t) ]\n    tf â†’ min\nend\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase/parser.html#CTBase.__OCPModel-Tuple","page":"Parser","title":"CTBase.__OCPModel","text":"__OCPModel(args...; kwargs...) -> OptimalControlModel\n\n\nRedirection to Model to avoid confusion with other functions Model from other packages if imported. This function is used by @def.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/parser.html","page":"Parser","title":"Parser","text":"","category":"page"},{"location":"api-optimalcontrol.html#OptimalControl.jl","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"","category":"section"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"The OptimalControl.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"flowchart TD\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctbase.html'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctdirect.html'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctflows.html'>CTFlows</a>)\nF --> B\nD --> B\nstyle O fill:#FBF275","category":"page"},{"location":"api-optimalcontrol.html#Index","page":"OptimalControl.jl","title":"Index","text":"","category":"section"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Pages   = [\"api-optimalcontrol.md\"]\nModules = [OptimalControl]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-optimalcontrol.html#Available-methods","page":"OptimalControl.jl","title":"Available methods","text":"","category":"section"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"using OptimalControl\navailable_methods()","category":"page"},{"location":"api-optimalcontrol.html#Documentation","page":"OptimalControl.jl","title":"Documentation","text":"","category":"section"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Modules = [OptimalControl]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-optimalcontrol.html#OptimalControl.OptimalControl","page":"OptimalControl.jl","title":"OptimalControl.OptimalControl","text":"OptimalControl module.\n\nLists all the imported modules and packages:\n\nBase\nCTBase\nCTDirect\nCTFlows\nCore\nDocStringExtensions\n\nList of all the exported names:\n\n*\nAutonomous\nControlConstraint\nControlLaw\nFeedbackControl\nFixed\nFlow\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\nIndex\n@Lie\nLie\nLift\nMixedConstraint\nModel\nMultiplier\nNonAutonomous\nNonFixed\nParsingError\nPoisson\nStateConstraint\nVectorField\n__OCPModel\navailable_methods\nbuild_solution\nconstraint\nconstraint!\ncontrol!\nct_repl\n@def\ndirect_transcription\ndynamics!\nexport_ocp_solution\nimport_ocp_solution\nis_max\nis_min\nis_time_dependent\nis_time_independent\nis_variable_dependent\nis_variable_independent\nload\nobjective!\nplot\nplot!\nremove_constraint!\nsave\nset_initial_guess\nsolve\nstate!\ntime!\nvariable!\nâˆ‚â‚œ\nâ‹…\n\n\n\n\n\n","category":"module"},{"location":"api-optimalcontrol.html#CommonSolve.solve-Tuple{OptimalControlModel, Vararg{Symbol}}","page":"OptimalControl.jl","title":"CommonSolve.solve","text":"solve(\n    ocp::OptimalControlModel,\n    description::Symbol...;\n    init,\n    grid_size,\n    display,\n    print_level,\n    mu_strategy,\n    max_iter,\n    tol,\n    linear_solver,\n    time_grid,\n    kwargs...\n)\n\n\nSolve the the optimal control problem ocp by the method given by the (optional) description.\n\nThe (optional) description\n\nYou can pass a partial description. If you give a partial description, then, if several complete descriptions contains the partial one,  then, the method with the highest priority is chosen. The higher in the list,  the higher is the priority.\n\nKeyword arguments:\n\ndisplay: print or not information during the resolution\ninit: an initial condition for the solver\n\nwarning: Warning\nThere is only one available method for the moment: a direct method which transforms the optimal control problem into a nonlinear programming problem (NLP) solved by Ipopt, thanks to the package  ADNLPModels. The direct method comes from the  CTDirect package.\n\ntip: Tip\nTo see the list of available methods, simply call available_methods().\nYou can pass any other option by a pair keyword=value according to the chosen method.\n\nExamples\n\njulia> sol = solve(ocp)\njulia> sol = solve(ocp, :direct)\njulia> sol = solve(ocp, :direct, :ipopt)\njulia> sol = solve(ocp, :direct, :ipopt, display=false)\njulia> sol = solve(ocp, :direct, :ipopt, display=false, init=sol)\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2],))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5, variable=[1, 2]))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=t->6-12*t))\njulia> sol = solve(ocp, init=(state=t->[-1+t, t*(t-1)], control=0.5))\njulia> sol = solve(ocp, init=(state=t->[-1+t, t*(t-1)], control=t->6-12*t))\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol.html#OptimalControl.available_methods-Tuple{}","page":"OptimalControl.jl","title":"OptimalControl.available_methods","text":"available_methods() -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"","category":"page"},{"location":"api-ctbase.html#CTBase.jl","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"The CTBase.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"flowchart TD\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctbase.html'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctdirect.html'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctflows.html'>CTFlows</a>)\nF --> B\nD --> B\nstyle B fill:#FBF275","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"You may find in this package:","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Types: the common types and associated methods if any.\nDescription: tools to manipulate tuples.\nDifferential geometry: tools to compute Lie brackets, Poisson brackets...\nExceptions.\nModel: tools to modelise an optimal control problem in a functional manner.\nParser: tools to modelise an optimal control problem in an abstract manner.\nPlot: the plot function extended from Plots.jl and utils.\nPrint: check how an optimal control problem is displayed.\nRepl: control-toolbox repl.\nUtils: auxiliary methods.","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Here is the list of imported packages and exported functions.","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Modules = [CTBase, Base]\nOrder = [:module]\nPages = [\"CTBase.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase.html#CTBase.CTBase","page":"CTBase.jl","title":"CTBase.CTBase","text":"CTBase module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDataStructures\nDocStringExtensions\nLinearAlgebra\nMLStyle\nParameters\nPrettyTables\nPrintf\nReplMaker\nUnicode\n\nList of all the exported names:\n\nAbstractHamiltonian\nAmbiguousDescription\nAutonomous\nBoundaryConstraint\nCTCallback\nCTCallbacks\nCTException\nControl\nControlConstraint\nControlLaw\nControls\nCostate\nCostates\nDCostate\nDState\nDescription\nDimension\nDynamics\nFeedbackControl\nFixed\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\nIncorrectArgument\nIncorrectMethod\nIncorrectOutput\nIndex\nLagrange\n@Lie\nLie\nLift\nMayer\nMixedConstraint\nModel\nMultiplier\nNonAutonomous\nNonFixed\nNotImplemented\nOptimalControlInit\nOptimalControlModel\nOptimalControlSolution\nParsingError\nPoisson\nPrintCallback\nState\nStateConstraint\nStates\nStopCallback\nTime\nTimeDependence\nTimes\nTimesDisc\nUnauthorizedCall\nVariable\nVariableConstraint\nVariableDependence\nVectorField\n__OCPModel\nadd\nconstraint\nconstraint!\nconstraint_type\nconstraints_labels\ncontrol!\nctNumber\nctVector\nct_repl\nct_repl_update_model\nctgradient\nctindices\nctinterpolate\nctjacobian\nctupperscripts\n@def\ndim_boundary_constraints\ndim_control_constraints\ndim_control_range\ndim_mixed_constraints\ndim_path_constraints\ndim_state_constraints\ndim_state_range\ndim_variable_constraints\ndim_variable_range\ndynamics!\ngetFullDescription\nget_priority_print_callbacks\nget_priority_stop_callbacks\nhas_free_final_time\nhas_free_initial_time\nhas_lagrange_cost\nhas_mayer_cost\nis_autonomous\nis_fixed\nis_max\nis_min\nis_time_dependent\nis_time_independent\nis_variable_dependent\nis_variable_independent\nnlp_constraints!\nobjective!\nremove_constraint!\nreplace_call\nset_AD_backend\nstate!\ntime!\nvariable!\nâˆ‚â‚œ\nâ‹…\n\n\n\n\n\n","category":"module"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"page"},{"location":"api-ctdirect.html#CTDirect.jl","page":"CTDirect.jl","title":"CTDirect.jl","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"The CTDirect.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"flowchart TD\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctbase.html'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctdirect.html'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctflows.html'>CTFlows</a>)\nF --> B\nD --> B\nstyle D fill:#FBF275","category":"page"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-ctdirect.html#Index","page":"CTDirect.jl","title":"Index","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Pages   = [\"api-ctdirect.md\"]\nModules = [CTDirect]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-ctdirect.html#Documentation","page":"CTDirect.jl","title":"Documentation","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Modules = [CTDirect]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctdirect.html#CTDirect.DOCP","page":"CTDirect.jl","title":"CTDirect.DOCP","text":"Struct for discretized optimal control problem DOCP\n\nContains:\n\na copy of the original OCP\na NLP formulation of the DOCP\ndata required to link the two problems\n\n\n\n\n\n","category":"type"},{"location":"api-ctdirect.html#CTDirect.available_methods-Tuple{}","page":"CTDirect.jl","title":"CTDirect.available_methods","text":"available_methods() -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.build_solution-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTDirect.build_solution","text":"build_solution(\n    docp,\n    docp_solution_ipopt\n) -> Union{Nothing, OptimalControlSolution}\n\n\nBuild OCP functional solution from DOCP discrete solution (given as a GenericExecutionStats)\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.build_solution-Tuple{Any}","page":"CTDirect.jl","title":"CTDirect.build_solution","text":"build_solution(docp; primal, dual)\n\n\nBuild OCP functional solution from the DOCP discrete solution, given as a vector. Costate will be retrieved from dual variables (multipliers) if available.\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.direct_transcription-Tuple{OptimalControlModel, Vararg{Any}}","page":"CTDirect.jl","title":"CTDirect.direct_transcription","text":"direct_transcription(\n    ocp::OptimalControlModel,\n    description...;\n    init,\n    grid_size,\n    time_grid\n) -> Tuple{DOCP, ADNLPModels.ADNLPModel{Float64, Vector{Float64}, Vector{Int64}}}\n\n\nDiscretize an optimal control problem into a nonlinear optimization problem (ie direct transcription)\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.is_solvable-Tuple{Any}","page":"CTDirect.jl","title":"CTDirect.is_solvable","text":"is_solvable(ocp) -> Bool\n\n\nCheck if an OCP is solvable by the method solve.\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.set_initial_guess-Tuple{DOCP, Any, Any}","page":"CTDirect.jl","title":"CTDirect.set_initial_guess","text":"set_initial_guess(docp::DOCP, nlp, init) -> Any\n\n\nSet initial guess in the DOCP\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"","category":"page"},{"location":"api-ctbase/model.html#api-ctbase-model","page":"Model","title":"Model","text":"","category":"section"},{"location":"api-ctbase/model.html","page":"Model","title":"Model","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/model.html#Index","page":"Model","title":"Index","text":"","category":"section"},{"location":"api-ctbase/model.html","page":"Model","title":"Model","text":"Pages   = [\"model.md\"]\nModules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/model.html#Documentation","page":"Model","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/model.html","page":"Model","title":"Model","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]\nPages   = [\"model.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/model.html#CTBase.Model-Tuple{Vararg{DataType}}","page":"Model","title":"CTBase.Model","text":"Model(\n    dependencies::DataType...\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following argument:\n\ndependencies: either Autonomous or NonAutonomous. Default is Autonomous. And either NonFixed or Fixed. Default is Fixed.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(NonAutonomous)\njulia> ocp = Model(Autonomous, NonFixed)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.Model-Tuple{}","page":"Model","title":"CTBase.Model","text":"Model(\n;\n    autonomous,\n    variable\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following optional keyword argument:\n\nautonomous: either true or false. Default is true.\nvariable: either true or false. Default is false.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(autonomous=false)\njulia> ocp = Model(autonomous=false, variable=true)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol;\n    rg,\n    f,\n    lb,\n    ub,\n    label\n)\n\n\nAdd a constraint to an optimal control problem, denoted ocp.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe initial and final times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nYou can add an :initial, :final, :control, :state or :variable box constraint (whole range). \n\nRange constraint on the state, control or variable\n\nYou can add an :initial, :final, :control, :state or :variable box constraint on a range of it, that is only on some components. If not range is specified, then the constraint is on the whole range. We denote by x, u and v respectively the state, control and variable. We denote by n, m and q respectively the dimension of the state, control and variable. The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable.\n\nExamples\n\njulia> constraint!(ocp, :initial; rg=1:2:5, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :initial; rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :final; rg=1, lb=0, ub=2)\njulia> constraint!(ocp, :control; rg=1, lb=0, ub=2)\njulia> constraint!(ocp, :state; rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :variable; rg=1:2, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :initial; lb=[ 0, 0, 0 ])                 # [ 0, 0, 0 ] â‰¤ x(t0),                          dim(x) = 3\njulia> constraint!(ocp, :initial; lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ]) # [ 0, 0, 0 ] â‰¤ x(t0) â‰¤ [ 1, 2, 1 ],            dim(x) = 3\njulia> constraint!(ocp, :final; lb=-1, ub=1)                      #          -1 â‰¤ x(tf) â‰¤ 1,                      dim(x) = 1\njulia> constraint!(ocp, :control; lb=0, ub=2)                     #           0 â‰¤ u(t)  â‰¤ 2,        t âˆˆ [t0, tf], dim(u) = 1\njulia> constraint!(ocp, :state; lb=[ 0, 0 ], ub=[ 1, 2 ])         #    [ 0, 0 ] â‰¤ x(t)  â‰¤ [ 1, 2 ], t âˆˆ [t0, tf], dim(x) = 2\njulia> constraint!(ocp, :variable; lb=[ 0, 0 ], ub=[ 1, 2 ])      #    [ 0, 0 ] â‰¤    v  â‰¤ [ 1, 2 ],               dim(v) = 2\n\nFunctional constraint\n\nYou can add a :boundary, :control, :state, :mixed or :variable box functional constraint.\n\nExamples\n\n# variable independent ocp\njulia> constraint!(ocp, :boundary; f = (x0, xf) -> x0[3]+xf[2], lb=0, ub=1)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary; f = (x0, xf, v) -> x0[3]+xf[2]*v[1], lb=0, ub=1)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control; f = u -> 2u, lb=0, ub=1)\njulia> constraint!(ocp, :state; f = x -> x-1, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (x, u) -> x[1]-u, lb=0, ub=1)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control; f = (t, u) -> 2u, lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (t, x) -> t * x, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (t, x, u) -> x[1]-u, lb=0, ub=1)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control; f = (u, v) -> 2u * v[1], lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (x, v) -> x * v[1], lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (x, u, v) -> x[1]-v[2]*u, lb=0, ub=1)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control; f = (t, u, v) -> 2u+v[2], lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (t, x, v) -> x-t*v[1], lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (t, x, u, v) -> x[1]*v[2]-u, lb=0, ub=1)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.constraint","text":"constraint(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    label::Symbol\n) -> Any\n\n\nRetrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds).\n\nExample\n\njulia> constraint!(ocp, :initial, 0, :c0)\njulia> c = constraint(ocp, :c0)\njulia> c(1)\n1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.constraints_labels-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.constraints_labels","text":"constraints_labels(\n    ocp::OptimalControlModel\n) -> Base.KeySet{Symbol, Dict{Symbol, Tuple}}\n\n\nReturn the labels of the constraints as a Base.keys.\n\nExample\n\njulia> constraints_labels(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.control!","page":"Model","title":"CTBase.control!","text":"control!(ocp::OptimalControlModel, m::Integer)\ncontrol!(ocp::OptimalControlModel, m::Integer, name::String)\ncontrol!(\n    ocp::OptimalControlModel,\n    m::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the control dimension and possibly the names of each coordinate.\n\nnote: Note\nYou must use control! only once to set the control dimension.\n\nExamples\n\njulia> control!(ocp, 1)\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"uâ‚\", \"uâ‚‚\"]\n\njulia> control!(ocp, 2, :v)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"vâ‚\", \"vâ‚‚\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"vâ‚\", \"vâ‚‚\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase/model.html#CTBase.dim_boundary_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_boundary_constraints","text":"dim_boundary_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of the boundary constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_control_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_control_constraints","text":"dim_control_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear control constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_control_range-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_control_range","text":"dim_control_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of range constraints on control (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_mixed_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_mixed_constraints","text":"dim_mixed_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear mixed constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_path_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_path_constraints","text":"dim_path_constraints(ocp::OptimalControlModel) -> Any\n\n\nReturn the dimension of nonlinear path (state + control + mixed) constraints (nothing if one of them is not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_state_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_state_constraints","text":"dim_state_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear state constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_state_range-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_state_range","text":"dim_state_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of range constraints on state (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_variable_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_variable_constraints","text":"dim_variable_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear variable constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_variable_range-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_variable_range","text":"dim_variable_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of range constraints on variable (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.dynamics!","text":"dynamics!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    f::Function\n)\n\n\nSet the dynamics.\n\nnote: Note\nYou can use dynamics! only once to define the dynamics.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> dynamics!(ocp, f)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.has_free_final_time-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.has_free_final_time","text":"has_free_final_time(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with free final time.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.has_free_initial_time-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.has_free_initial_time","text":"has_free_initial_time(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with free initial time.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.has_lagrange_cost-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.has_lagrange_cost","text":"has_lagrange_cost(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with lagrange cost.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.has_mayer_cost-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.has_mayer_cost","text":"has_mayer_cost(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with mayer cost.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_autonomous-Tuple{OptimalControlModel{Autonomous}}","page":"Model","title":"CTBase.is_autonomous","text":"is_autonomous(ocp::OptimalControlModel{Autonomous}) -> Bool\n\n\nReturn true if the model is autonomous.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_fixed-Tuple{OptimalControlModel{<:TimeDependence, Fixed}}","page":"Model","title":"CTBase.is_fixed","text":"is_fixed(\n    ocp::OptimalControlModel{<:TimeDependence, Fixed}\n) -> Bool\n\n\nReturn true if the model is fixed (= has no variable).\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_max-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_max","text":"is_max(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :max.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_min-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_min","text":"is_min(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :min.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_time_dependent-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_time_dependent","text":"is_time_dependent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_time_independent-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_time_independent","text":"is_time_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as time independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_variable_dependent-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_variable_dependent","text":"is_variable_dependent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_variable_independent-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_variable_independent","text":"is_variable_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as variable independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.nlp_constraints!-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.nlp_constraints!","text":"nlp_constraints!(\n    ocp::OptimalControlModel\n) -> Tuple{Tuple{Any, CTBase.var\"#Î¾#91\", Vector{Real}}, Tuple{Any, CTBase.var\"#Î·#92\", Vector{Real}}, Tuple{Any, CTBase.var\"#Ïˆ#93\", Vector{Real}}, Tuple{Any, CTBase.var\"#Ï•#94\", Vector{Real}}, Tuple{Any, CTBase.var\"#Î¸#95\", Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}\n\n\nReturn a 6-tuple of tuples:\n\n(Î¾l, Î¾, Î¾u) are control constraints\n(Î·l, Î·, Î·u) are state constraints\n(Ïˆl, Ïˆ, Ïˆu) are mixed constraints\n(Ï•l, Ï•, Ï•u) are boundary constraints\n(Î¸l, Î¸, Î¸u) are variable constraints\n(ul, uind, uu) are control linear constraints of a subset of indices\n(xl, xind, xu) are state linear constraints of a subset of indices\n(vl, vind, vu) are variable linear constraints of a subset of indices\n\nand update information about constraints dimensions of  ocp.\n\nnote: Note\nThe dimensions of the state and control must be set before calling nlp_constraints!.\nFor a Fixed problem, dimensions associated with constraints on the variable are set to zero.\n\nExample\n\njulia> (Î¾l, Î¾, Î¾u), (Î·l, Î·, Î·u), (Ïˆl, Ïˆ, Ïˆu), (Ï•l, Ï•, Ï•u), (Î¸l, Î¸, Î¸u),\n    (ul, uind, uu), (xl, xind, xu), (vl, vind, vu) = nlp_constraints!(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    fâ°::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    fâ°::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function g and fâ°. Type can be :bolza. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> objective!(ocp, :bolza, (x0, xf) -> x0[1] + xf[2], (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function f. Type can be :mayer or :lagrange. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\njulia> objective!(ocp, :mayer, (x0, xf) -> x0[1] + xf[2])\njulia> objective!(ocp, :lagrange, (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\nwarning: Warning\nIf you set twice the objective, only the last one will be taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}","page":"Model","title":"CTBase.remove_constraint!","text":"remove_constraint!(ocp::OptimalControlModel, label::Symbol)\n\n\nRemove a labeled constraint.\n\nExample\n\njulia> remove_constraint!(ocp, :con)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.state!","page":"Model","title":"CTBase.state!","text":"state!(ocp::OptimalControlModel, n::Integer)\nstate!(ocp::OptimalControlModel, n::Integer, name::String)\nstate!(\n    ocp::OptimalControlModel,\n    n::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the state dimension and possibly the names of each component.\n\nnote: Note\nYou must use state! only once to set the state dimension.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"xâ‚\", \"xâ‚‚\"]\n\njulia> state!(ocp, 2, :y)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"yâ‚\", \"yâ‚‚\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"yâ‚\", \"yâ‚‚\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase/model.html#CTBase.time!-Union{Tuple{OptimalControlModel{<:TimeDependence, VT}}, Tuple{VT}} where VT","page":"Model","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel{<:TimeDependence, VT};\n    t0,\n    tf,\n    ind0,\n    indf,\n    name\n)\n\n\nSet the initial and final times. We denote by t0 the initial time and tf the final time. The optimal control problem is denoted ocp. When a time is free, then one must provide the corresponding index of the ocp variable.\n\nnote: Note\nYou must use time! only once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, t0=0,   tf=1  ) # Fixed t0 and fixed tf\njulia> time!(ocp, t0=0,   indf=2) # Fixed t0 and free  tf\njulia> time!(ocp, ind0=2, tf=1  ) # Free  t0 and fixed tf\njulia> time!(ocp, ind0=2, indf=3) # Free  t0 and free  tf\n\nWhen you plot a solution of an optimal control problem, the name of the time variable appears. By default, the name is \"t\". Consider you want to set the name of the time variable to \"s\".\n\njulia> time!(ocp, t0=0, tf=1, name=\"s\") # name is a String\n# or\njulia> time!(ocp, t0=0, tf=1, name=:s ) # name is a Symbol  \n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.variable!","page":"Model","title":"CTBase.variable!","text":"variable!(ocp::OptimalControlModel, q::Integer)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String\n)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the variable dimension and possibly the names of each component.\n\nnote: Note\nYou can use variable! once to set the variable dimension when the model is NonFixed.\n\nExamples\n\njulia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"vâ‚\", \"vâ‚‚\" ])\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase/model.html","page":"Model","title":"Model","text":"","category":"page"},{"location":"tutorial-nlp.html#NLP-and-DOCP-manipulations","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"We describe here some more advanced operations related to the discretized optimal control problem. When calling solve(ocp) three steps are performed internally:","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"first, the OCP is discretized into a DOCP (a nonlinear optimization problem) with direct_transcription,\nthen, this DOCP is solved (with the internal function solve_docp),\nfinally, a functional solution of the OCP is rebuilt from the solution of the discretized problem, with build_solution.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"These steps can also be done separately, for instance if you want to use your own NLP solver. ","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"Let us load the packages.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-nlp.html#Definition-of-the-optimal-control-problem","page":"NLP and DOCP manipulations","title":"Definition of the optimal control problem","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"We define a test problem","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"@def ocp begin\n\n    t âˆˆ [0, 1], time\n    x âˆˆ RÂ², state\n    u âˆˆ R, control\n\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n\n    xÌ‡(t) == [ xâ‚‚(t), u(t) ]\n\n    âˆ«( 0.5u(t)^2 ) â†’ min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html#Discretization-and-NLP-problem","page":"NLP and DOCP manipulations","title":"Discretization and NLP problem","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"We discretize the problem.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"docp, nlp = direct_transcription(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"The DOCP contains information related to the transcription, including a copy of the original OCP, and the NLP is the resulting discretized problem, in our case an ADNLPModel.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"We can now use the solver of our choice to solve it.","category":"page"},{"location":"tutorial-nlp.html#Resolution-of-the-NLP-problem","page":"NLP and DOCP manipulations","title":"Resolution of the NLP problem","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"For a first example we use the ipopt solver from NLPModelsIpopt.jl package to solve the NLP problem.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"using NLPModelsIpopt\nnlp_sol = ipopt(nlp; print_level=4, mu_strategy=\"adaptive\", tol=1e-8, sb=\"yes\")\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"Then we can rebuild and plot an optimal control problem solution (note that the multipliers are optional, but the OCP costate will not be retrieved if the multipliers are not provided).","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"sol = build_solution(docp, primal=nlp_sol.solution, dual=nlp_sol.multipliers)\nplot(sol)","category":"page"},{"location":"tutorial-nlp.html#Initial-guess","page":"NLP and DOCP manipulations","title":"Initial guess","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"An initial guess, including warm start, can be passed to direct_transcription the same way as for solve.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"docp, nlp = direct_transcription(ocp, init=sol)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"It can also be changed after the transcription is done, with  set_initial_guess.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"set_initial_guess(docp, nlp, sol)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"For a second example, we use the Percival.jl to solve the NLP problem with as initial guess the solution from the first resolution.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"using Percival\n\noutput = percival(nlp)\nprint(output)","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"","category":"page"},{"location":"tutorial-plot.html#How-to-plot-a-solution","page":"Plot a solution","title":"How to plot a solution","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In this tutorial we explain the different ways to plot a solution of an optimal control problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Let us start by importing the package to define the problem and solve it.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using OptimalControl\nusing NLPModelsIpopt","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Then, we define a simple optimal control problem and solve it.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"@def ocp begin\n\n    t âˆˆ [0, 1], time\n    x âˆˆ RÂ², state\n    u âˆˆ R, control\n\n    x(0) == [-1, 0]\n    x(1) == [0, 0]\n\n    xÌ‡(t) == [xâ‚‚(t), u(t)]\n\n    âˆ«( 0.5u(t)^2 ) â†’ min\n\nend\n\nsol = solve(ocp, display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html#First-ways-to-plot","page":"Plot a solution","title":"First ways to plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The simplest way to plot the solution is to use the plot function with only the solution as argument.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: The plot function\nThe plot function on a solution of an optimal control problem is an extension of the plot function from the package Plots.jl. Hence, we need to import this package to plot a solution.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using Plots\nplot(sol)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"As you can see, it produces a grid of subplots. The left column contains the state trajectories, the right column the costate trajectories, and at the bottom we have the control trajectory.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Attributes from Plots.jl can be passed to the plot function:","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In addition to sol you can pass attributes to the full Plot, see the attributes plot documentation from Plots.jl for more details. For instance, you can specify the size of the figure.\nYou can also pass attributes to the subplots, see the attributes subplot documentation from Plots.jl for more details. However, it will affect all the subplots. For instance, you can specify the location of the legend.\nIn the same way, you can pass axis attributes to the subplots, see the attributes axis documentation from Plots.jl for more details. It will also affect all the subplots. For instance, you can remove the grid.\nIn the same way, you can pass series attributes to the all the subplots, see the attributes series documentation from Plots.jl for more details. It will also affect all the subplots. For instance, you can set the width of the curves with linewidth.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, size=(700, 450), legend=:bottomright, grid=false, linewidth=2)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To specify series attributes to a specific subplot, you can use the optional keyword arguments state_style, costate_style and control_style which correspond respectively to the state, costate and control trajectories. See the attribute series documentation from Plots.jl for more details. For instance, you can specify the color of the state trajectories and more.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; \n     state_style   = (color=:blue,), \n     costate_style = (color=:black, linestyle=:dash),\n     control_style = (color=:red, linewidth=2))","category":"page"},{"location":"tutorial-plot.html#From-Flow","page":"Plot a solution","title":"From Flow","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The previous resolution of the optimal control problem was done with the solve function. If you use an indirect shooting method and solve shooting equations, you may want to plot the  associated solution. To do so, you need to use the Flow function to  reconstruct the solution. See the Indirect Simple Shooting tutorial for an example. In our example, you must provide the maximising control (x p) mapsto p_2 together with the  optimal control problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"t0 = 0\ntf = 1\nx0 = [ -1, 0 ]\np0 = sol.costate(t0)\nf  = Flow(ocp, (x, p) -> p[2])\nsol_flow = f( (t0, tf), x0, p0 )\nplot(sol_flow)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can notice that the time grid has very few points. To have a better visualisation (the accuracy  won't change), you can give a finer grid.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"sol_flow = f( (t0, tf), x0, p0; saveat=range(t0, tf, 100) )\nplot(sol_flow)","category":"page"},{"location":"tutorial-plot.html#Split-versus-group-layout","page":"Plot a solution","title":"Split versus group layout","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"If you prefer to get a more compact figure, you can use the layout optional keyword argument with :group value. It will group the state, costate and control trajectories in one subplot for each.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; layout=:group, size=(800, 300))","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Default layout value\nThe default layout value is :split which corresponds to the grid of subplots presented above.","category":"page"},{"location":"tutorial-plot.html#Additional-plots","page":"Plot a solution","title":"Additional plots","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can plot the solution of a second optimal control problem on the same figure if it has the same number of states, costates and controls. For instance, consider the same optimal control problem but with a different initial condition.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"@def ocp begin\n\n    t âˆˆ [0, 1], time\n    x âˆˆ RÂ², state\n    u âˆˆ R, control\n\n    x(0) == [-0.5, -0.5]\n    x(1) == [0, 0]\n\n    xÌ‡(t) == [xâ‚‚(t), u(t)]\n\n    âˆ«( 0.5u(t)^2 ) â†’ min\n\nend\nsol2 = solve(ocp; display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We first plot the solution of the first optimal control problem, then, we plot the solution of the second optimal control problem on the same figure, but with dashed lines.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"# first plot\nplt = plot(sol; solution_label=\"(sol1)\", size=(700, 500))\n\n# second plot\nplot!(plt, sol2; solution_label=\"(sol2)\", linestyle=:dash)","category":"page"},{"location":"tutorial-plot.html#Plot-the-norm-of-the-control","page":"Plot a solution","title":"Plot the norm of the control","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"For some problem, it is interesting to plot the norm of the control. You can do it by using the control optional keyword argument with :norm value. The default value is :components.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; control=:norm, size=(800, 300), layout=:group)","category":"page"},{"location":"tutorial-plot.html#Custom-plot","page":"Plot a solution","title":"Custom plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can of course create your own plots by getting the state, costate and control from the optimal control solution. For instance, let us plot the norm of the control for the orbital transfer problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using LinearAlgebra\nt = sol.times\nx = sol.state\np = sol.costate\nu = sol.control\nplot(t, normâˆ˜u; label=\"â€–uâ€–\") ","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Nota bene\nThe norm function is from LinearAlgebra.jl. \nThe âˆ˜ operator is the composition operator. Hence, normâˆ˜u is the function t -> norm(u(t)). \nThe sol.state, sol.costate and sol.control are functions that return the state, costate and control trajectories at a given time.","category":"page"},{"location":"tutorial-plot.html#Normalized-time","page":"Plot a solution","title":"Normalized time","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We consider a LQR example and solve the problem for different values of the final time tf. Then, we plot the solutions on the same figure considering a normalized time s=(t-t_0)(t_f-t_0), thanks to the keyword argument time=:normalized of the plot function.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"\n# parameters\nx0 = [ 0\n       1 ]\n\nA  = [ 0 1\n      -1 0 ]\n\nB  = [ 0\n       1 ]\n\n# definition\nfunction lqr(tf)\n\n    @def ocp begin\n        t âˆˆ [0, tf], time\n        x âˆˆ RÂ², state\n        u âˆˆ R, control\n        x(0) == x0\n        áº‹(t) == A * x(t) + B * u(t)\n        âˆ«( 0.5(xâ‚(t)^2 + xâ‚‚(t)^2 + u(t)^2) ) â†’ min\n    end\n\n    return ocp\nend;\n\n# solve\nsolutions = []\ntfs = [3, 5, 30]\nfor tf âˆˆ tfs\n    solution = solve(lqr(tf); display=false)\n    push!(solutions, solution)\nend\n\n# create plots\nplt = plot(solutions[1]; time=:normalized)\nfor sol âˆˆ solutions[2:end]\n    plot!(plt, sol; time=:normalized)\nend\n\n# make a custom plot from created plots: only state and control are plotted\nN = length(tfs)\npx1 = plot(plt[1]; legend=false, xlabel=\"s\", ylabel=\"xâ‚\")\npx2 = plot(plt[2]; label=reshape([\"tf = $tf\" for tf âˆˆ tfs], (1, N)), xlabel=\"s\", ylabel=\"xâ‚‚\")\npu  = plot(plt[5]; legend=false, xlabel=\"s\", ylabel=\"u\")\n\nusing Plots.PlotMeasures # for leftmargin, bottommargin\nplot(px1, px2, pu; layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"","category":"page"},{"location":"dev-ctdirect.html#dev-ctdirect","page":"CTDirect.jl","title":"CTDirect.jl private functions","text":"","category":"section"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-ctdirect.html#Index","page":"CTDirect.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Pages   = [\"dev-ctdirect.md\"]\nModules = [CTDirect]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctdirect.html#Documentation","page":"CTDirect.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Modules = [CTDirect]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-ctdirect.html#CTDirect.ArgsAtTimeStep","page":"CTDirect.jl","title":"CTDirect.ArgsAtTimeStep","text":"Useful values at a time step: time, state, control, dynamics...\n\n\n\n\n\n","category":"type"},{"location":"dev-ctdirect.html#CTDirect.DOCP_constraints!-Tuple{Any, Any, DOCP}","page":"CTDirect.jl","title":"CTDirect.DOCP_constraints!","text":"DOCP_constraints!(c, xu, docp::DOCP) -> Any\n\n\nCompute the constraints C for the DOCP problem (modeled as LB <= C(X) <= UB).\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_constraints_check!-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.DOCP_constraints_check!","text":"DOCP_constraints_check!(cb, constraints, docp)\n\n\nCheck the nonlinear constraints violation for the DOCP problem. \n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_initial_guess","page":"CTDirect.jl","title":"CTDirect.DOCP_initial_guess","text":"DOCP_initial_guess(docp) -> Any\nDOCP_initial_guess(docp, init::OptimalControlInit) -> Any\n\n\nBuild initial guess for discretized problem\n\n\n\n\n\n","category":"function"},{"location":"dev-ctdirect.html#CTDirect.DOCP_variables_check!-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.DOCP_variables_check!","text":"DOCP_variables_check!(vb, variables, docp)\n\n\nCheck the variables box constraints violation for the DOCP problem. \n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.constraints_bounds!-Tuple{DOCP}","page":"CTDirect.jl","title":"CTDirect.constraints_bounds!","text":"constraints_bounds!(\n    docp::DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP nonlinear constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_final_time-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTDirect.get_final_time","text":"get_final_time(xu, docp) -> Any\n\n\nRetrieve final time for OCP (may be fixed or variable)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_initial_time-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTDirect.get_initial_time","text":"get_initial_time(xu, docp) -> Any\n\n\nRetrieve initial time for OCP (may be fixed or variable)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_single_variable-Tuple{Any, Any, Int64}","page":"CTDirect.jl","title":"CTDirect.get_single_variable","text":"get_single_variable(xu, docp, i::Int64) -> Any\n\n\nRetrieve a single optimization variable (no dim check). Internal layout: [X0,U0, X1,U1, .., XN,UN,V]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_time_at_time_step-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.get_time_at_time_step","text":"get_time_at_time_step(xu, docp, i) -> Any\n\n\nGet actual (un-normalized) time at give time step\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_unnormalized_time-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.get_unnormalized_time","text":"get_unnormalized_time(xu, docp, t_normalized) -> Any\n\n\nGet actual (un-normalized) time value\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_variable-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTDirect.get_variable","text":"get_variable(xu, docp) -> Any\n\n\nRetrieve optimization variables from the NLP variables. Internal layout: [X0,U0, X1,U1, .., XN,UN,V]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.parse_DOCP_solution_primal-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTDirect.parse_DOCP_solution_primal","text":"parse_DOCP_solution_primal(\n    docp,\n    solution\n) -> Tuple{Any, Any, Any}\n\n\nRecover OCP primal variables from DOCP solution\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setPathBounds!-Tuple{DOCP, Int64, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setPathBounds!","text":"setPathBounds!(docp::DOCP, index::Int64, lb, ub) -> Int64\n\n\nSet bounds for the path constraints at given time step\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setPathConstraints!-Tuple{DOCP, Any, Int64, CTDirect.ArgsAtTimeStep, Any}","page":"CTDirect.jl","title":"CTDirect.setPathConstraints!","text":"setPathConstraints!(\n    docp::DOCP,\n    c,\n    index::Int64,\n    args::CTDirect.ArgsAtTimeStep,\n    v\n) -> Int64\n\n\nSet the path constraints at given time step\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setPointBounds!-Tuple{DOCP, Int64, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setPointBounds!","text":"setPointBounds!(docp::DOCP, index::Int64, lb, ub) -> Int64\n\n\nSet bounds for the boundary and variable constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setPointConstraints!-Tuple{DOCP, Any, Int64, CTDirect.ArgsAtTimeStep, CTDirect.ArgsAtTimeStep, Any}","page":"CTDirect.jl","title":"CTDirect.setPointConstraints!","text":"setPointConstraints!(\n    docp::DOCP,\n    c,\n    index::Int64,\n    args_0::CTDirect.ArgsAtTimeStep,\n    args_f::CTDirect.ArgsAtTimeStep,\n    v\n) -> Int64\n\n\nSet the boundary and variable constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setStateEquation!-Tuple{DOCP, Any, Int64, Any}","page":"CTDirect.jl","title":"CTDirect.setStateEquation!","text":"setStateEquation!(\n    docp::DOCP,\n    c,\n    index::Int64,\n    args_trapeze\n) -> Int64\n\n\nSet the constraints corresponding to the state equation\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_variable!-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.set_variable!","text":"set_variable!(xu, v_init, docp) -> Any\n\n\nSet optimization variables in the NLP variables (for initial guess)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.variables_bounds!-Tuple{DOCP}","page":"CTDirect.jl","title":"CTDirect.variables_bounds!","text":"variables_bounds!(\n    docp::DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP variable box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"","category":"page"},{"location":"api-ctbase/description.html#api-ctbase-description","page":"Description","title":"Description","text":"","category":"section"},{"location":"api-ctbase/description.html","page":"Description","title":"Description","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/description.html#Index","page":"Description","title":"Index","text":"","category":"section"},{"location":"api-ctbase/description.html","page":"Description","title":"Description","text":"Pages   = [\"description.md\"]\nModules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/description.html#Documentation","page":"Description","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/description.html","page":"Description","title":"Description","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]\nPages   = [\"description.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/description.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nConcatenate the description y to the tuple of descriptions x if x does not contain y and return the new tuple of descriptions. Throw an error if the description y is already contained in x.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> descriptions = add(descriptions, (:b,))\n(:a,)\n(:b,)\njulia> descriptions = add(descriptions, (:b,))\nERROR: IncorrectArgument: the description (:b,) is already in ((:a,), (:b,))\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/description.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> print(descriptions)\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/description.html#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"Description","title":"CTBase.getFullDescription","text":"getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn a complete description from an incomplete description desc and  a list of complete descriptions desc_list. If several complete descriptions are possible,  then the first one is returned.\n\nExample\n\njulia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n(:a, :b)\n(:b, :c)\n(:a, :c)\njulia> getFullDescription((:a,), desc_list)\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/description.html","page":"Description","title":"Description","text":"","category":"page"},{"location":"tutorial-double-integrator.html#double-int","page":"Time minimisation","title":"Double integrator: time minimisation","text":"","category":"section"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"The problem consists in minimising the final time t_f for the double integrator system","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) quad u(t) in -11","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"and the limit conditions","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"    x(0) = (12) quad x(t_f) = (00)","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"This problem can be interpretated as a simple model for a wagon with constant mass moving along a line without fricton.","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"First, we need to import the OptimalControl.jl package to define the optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"Then, we can define the problem","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"@def ocp begin\n\n    tf âˆˆ R,          variable\n    t âˆˆ [ 0, tf ],   time\n    x = (q, v) âˆˆ RÂ², state\n    u âˆˆ R,           control\n\n    tf â‰¥ 0\n    -1 â‰¤ u(t) â‰¤ 1\n\n    q(0)  == 1\n    v(0)  == 2\n    q(tf) == 0\n    v(tf) == 0\n\n     0 â‰¤ q(t) â‰¤ 5,          (1)\n    -2 â‰¤ v(t) â‰¤ 3,          (2)\n\n    xÌ‡(t) == [ v(t), u(t) ]\n\n    tf â†’ min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"note: Nota bene\nIn order to ensure convergence of the direct solver, we have added the state constraints labelled (1) and (2):0 leq q(t) leq 5quad -2 leq v(t) leq 3quad t in  0 t_f ","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"Solve it","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"sol = solve(ocp; grid_size=100)\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"and plot the solution","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"plot(sol)","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time minimisation","title":"Time minimisation","text":"","category":"page"},{"location":"tutorial-continuation.html#Discrete-continuation","page":"Discrete continuation","title":"Discrete continuation","text":"","category":"section"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Using the warm start option, it is easy to implement a basic discrete continuation method, where a sequence of problems is solved using each solution as initial guess for the next problem. This usually gives better and faster convergence than solving each problem with the same initial guess, and is a way to handle problems that require a good initial guess.","category":"page"},{"location":"tutorial-continuation.html#Continuation-on-parametric-OCP","page":"Discrete continuation","title":"Continuation on parametric OCP","text":"","category":"section"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"The most compact syntax to perform a discrete continuation is to use a function that returns the OCP for a given value of the continuation parameter, and solve a sequence of these problems. We illustrate this on a very basic double integrator with increasing fixed final time.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"First we load the required packages","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Printf\nusing Plots","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"and write a function that returns the OCP for a given final time","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"function ocp_T(T)\n    @def ocp begin\n        t âˆˆ [0, T], time\n        x âˆˆ RÂ², state\n        u âˆˆ R, control\n        q = xâ‚\n        v = xâ‚‚\n        q(0) == 0\n        v(0) == 0\n        q(T) == 1\n        v(T) == 0\n        xÌ‡(t) == [ v(t), u(t) ]\n        âˆ«(u(t)^2) â†’ min\n    end\n    return ocp\nend\nnothing # hide","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Then we perform the continuation with a simple for loop, using each solution to initialize the next problem.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"init1 = ()\nfor T=1:5\n    ocp1 = ocp_T(T) \n    sol1 = solve(ocp1; display=false, init=init1)\n    global init1 = sol1\n    @printf(\"T %.2f objective %9.6f iterations %d\\n\", T, sol1.objective, sol1.iterations)\nend","category":"page"},{"location":"tutorial-continuation.html#Continuation-on-global-variable","page":"Discrete continuation","title":"Continuation on global variable","text":"","category":"section"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"As a second example, we show how to avoid redefining a new OCP each time, and modify the original one instead. More precisely we now solve a Goddard problem for a decreasing maximal thrust. If we store the value for Tmax in a global variable, we can simply modify this variable and keep the same OCP problem during the continuation.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Let us first define the Goddard problem (note that the formulation below illustrates all the possible constraints types, and the problem could be defined in a more compact way).","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Cd = 310\nTmax = 3.5\nÎ² = 500\nb = 2\nfunction F0(x)\n    r, v, m = x\n    D = Cd * v^2 * exp(-Î²*(r - 1))\n    return [ v, -D/m - 1/r^2, 0 ]\nend\nfunction F1(x)\n    r, v, m = x\n    return [ 0, Tmax/m, -b*Tmax ]\nend\n\nocp = Model(variable=true)\n\nr0 = 1\nv0 = 0\nm0 = 1\nmf = 0.6\nx0=[r0,v0,m0]\n\nvmax = 0.1\n\nstate!(ocp, 3)\ncontrol!(ocp, 1)\nvariable!(ocp, 1)\ntime!(ocp; t0=0, indf=1)\n\nconstraint!(ocp, :initial; lb=x0, ub=x0)\nconstraint!(ocp, :final; rg=3, lb=mf, ub=Inf)\nconstraint!(ocp, :state; lb=[r0,v0,mf], ub=[r0+0.2,vmax,m0])\nconstraint!(ocp, :control; lb=0, ub=1)\nconstraint!(ocp, :variable; lb=0.01, ub=Inf)\n\nobjective!(ocp, :mayer, (x0, xf, v) -> xf[1], :max)\n\ndynamics!(ocp, (x, u, v) -> F0(x) + u*F1(x) )\n\nsol0 = solve(ocp; display=false)\n@printf(\"Objective for reference solution %.6f\\n\", sol0.objective)","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Then we perform the continuation on the maximal thrust.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"sol       = sol0\nTmax_list = []\nobj_list  = []\nfor Tmax_local=3.5:-0.5:1\n    global Tmax = Tmax_local  \n    global sol = solve(ocp; display=false, init=sol)\n    @printf(\"Tmax %.2f objective %.6f iterations %d\\n\", Tmax, sol.objective, sol.iterations)\n    push!(Tmax_list, Tmax)\n    push!(obj_list, sol.objective)\nend ","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"We plot now the objective w.r.t the maximal thrust, as well as both solutions for Tmax=3.5 and Tmax=1.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"using Plots.PlotMeasures # for leftmargin\n\nplt_obj = plot(Tmax_list, obj_list;\n    seriestype=:scatter,\n    title=\"Goddard problem\",\n    label=\"r(tf)\", \n    xlabel=\"Maximal thrust (Tmax)\",\n    ylabel=\"Maximal altitude r(tf)\")\n\nplt_sol = plot(sol0; solution_label=\"(Tmax = \"*string(Tmax_list[1])*\")\")\nplot!(plt_sol, sol;  solution_label=\"(Tmax = \"*string(Tmax_list[end])*\")\")\n\nlayout = grid(2, 1, heights=[0.2, 0.8])\nplot(plt_obj, plt_sol; layout=layout, size=(800, 1000), leftmargin=5mm)","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"","category":"page"},{"location":"api-ctbase/plot.html#api-ctbase-plot","page":"Plot","title":"Plot","text":"","category":"section"},{"location":"api-ctbase/plot.html","page":"Plot","title":"Plot","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/plot.html","page":"Plot","title":"Plot","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]\nPages   = [\"plot.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/plot.html","page":"Plot","title":"Plot","text":"","category":"page"},{"location":"api-ctbase/diffgeometry.html#api-ctbase-diffegeometry","page":"Differential geometry","title":"Differential geometry","text":"","category":"section"},{"location":"api-ctbase/diffgeometry.html","page":"Differential geometry","title":"Differential geometry","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/diffgeometry.html#Index","page":"Differential geometry","title":"Index","text":"","category":"section"},{"location":"api-ctbase/diffgeometry.html","page":"Differential geometry","title":"Differential geometry","text":"Pages   = [\"diffgeometry.md\"]\nModules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/diffgeometry.html#Documentation","page":"Differential geometry","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/diffgeometry.html","page":"Differential geometry","title":"Differential geometry","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]\nPages   = [\"differential_geometry.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/diffgeometry.html#CTBase.:â‹…-Tuple{Function, Function}","page":"Differential geometry","title":"CTBase.:â‹…","text":"â‹…(X::Function, f::Function) -> Function\n\n\nLie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable.\n\nExample\n\njulia> Ï† = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (Ï†â‹…f)([1, 2])\n0\njulia> Ï† = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (Ï†â‹…f)(1, [1, 2], [2, 1])\nMethodError\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.:â‹…-Tuple{VectorField{Autonomous, <:VariableDependence}, Function}","page":"Differential geometry","title":"CTBase.:â‹…","text":"â‹…(\n    X::VectorField{Autonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#97#99\"{VectorField{Autonomous, var\"#s98\"}, <:Function} where var\"#s98\"<:VariableDependence\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = Xâ‹…f, in autonomous case\n\nExample\n\njulia> Ï† = x -> [x[2], -x[1]]\njulia> X = VectorField(Ï†)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (Xâ‹…f)([1, 2])\n0\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.:â‹…-Tuple{VectorField{NonAutonomous, <:VariableDependence}, Function}","page":"Differential geometry","title":"CTBase.:â‹…","text":"â‹…(\n    X::VectorField{NonAutonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#101#103\"{VectorField{NonAutonomous, var\"#s98\"}, <:Function} where var\"#s98\"<:VariableDependence\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = Xâ‹…f, in nonautonomous case\n\nExample\n\njulia> Ï† = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(Ï†, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (Xâ‹…f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lie-Tuple{Function, Function, Vararg{DataType}}","page":"Differential geometry","title":"CTBase.Lie","text":"Lie(\n    X::Function,\n    f::Function,\n    dependences::DataType...\n) -> Function\n\n\nLie derivative of a scalar function along a vector field or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> Ï† = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(Ï†,f)([1, 2])\n0\njulia> Ï† = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(Ï†, f, NonAutonomous, NonFixed)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lie-Tuple{Function, Function}","page":"Differential geometry","title":"CTBase.Lie","text":"Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Function\n\n\nLie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> Ï† = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(Ï†,f)([1, 2])\n0\njulia> Ï† = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(Ï†, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lie-Tuple{VectorField, Function}","page":"Differential geometry","title":"CTBase.Lie","text":"Lie(X::VectorField, f::Function) -> Function\n\n\nLie derivative of a scalar function along a vector field.\n\nExample\n\njulia> Ï† = x -> [x[2], -x[1]]\njulia> X = VectorField(Ï†)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> Ï† = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(Ï†, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V<:VariableDependence","page":"Differential geometry","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{Autonomous, V<:VariableDependence},\n    Y::VectorField{Autonomous, V<:VariableDependence}\n) -> VectorField\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case\n\nExample\n\njulia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V<:VariableDependence","page":"Differential geometry","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{NonAutonomous, V<:VariableDependence},\n    Y::VectorField{NonAutonomous, V<:VariableDependence}\n) -> VectorField{NonAutonomous}\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case\n\nExample\n\njulia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lift-Tuple{Function, Vararg{DataType}}","page":"Differential geometry","title":"CTBase.Lift","text":"Lift(\n    X::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a VectorField or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lift-Tuple{Function}","page":"Differential geometry","title":"CTBase.Lift","text":"Lift(X::Function; autonomous, variable) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lift-Tuple{VectorField}","page":"Differential geometry","title":"CTBase.Lift","text":"Lift(X::VectorField) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a VectorField.\n\nExample\n\njulia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Tuple{Function, Function, Vararg{DataType}}","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::Function,\n    dependences::DataType...\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Tuple{Function, Function}","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{Autonomous, V}, AbstractHamiltonian{Autonomous, V}}} where V<:VariableDependence","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{Autonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{Autonomous, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{NonAutonomous, V}, AbstractHamiltonian{NonAutonomous, V}}} where V<:VariableDependence","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{NonAutonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{NonAutonomous, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case\n\nExample\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{AbstractHamiltonian{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence},\n    g::Function\n) -> Hamiltonian\n\n\nPoisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{Function, AbstractHamiltonian{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence}\n) -> Hamiltonian\n\n\nPoisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::HamiltonianLift{T<:TimeDependence, V<:VariableDependence},\n    g::HamiltonianLift{T<:TimeDependence, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.âˆ‚â‚œ-Tuple{Any}","page":"Differential geometry","title":"CTBase.âˆ‚â‚œ","text":"âˆ‚â‚œ(f) -> CTBase.var\"#106#108\"\n\n\nPartial derivative wrt time of a function.\n\nExample\n\njulia> âˆ‚â‚œ((t,x) -> t*x)(0,8)\n8\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.@Lie-Tuple{Expr, Any, Any}","page":"Differential geometry","title":"CTBase.@Lie","text":"Macros for Poisson brackets\n\nExample\n\njulia> H0 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7]) autonomous=true variable=false\n#\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false variable=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) autonomous=true variable=true\n#\njulia> H0 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2) autonomous=false variable=true\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase/diffgeometry.html#CTBase.@Lie-Tuple{Expr, Any}","page":"Differential geometry","title":"CTBase.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) variable=true\n#\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase/diffgeometry.html#CTBase.@Lie-Tuple{Expr}","page":"Differential geometry","title":"CTBase.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\n#\njulia> F0 = VectorField((t, x) -> [t+x[1], x[2], (1-x[3])], autonomous=false)\njulia> F1 = VectorField((t, x) -> [t, -x[3], x[2]], autonomous=false)\njulia> @Lie [F0, F1](1, [1, 2, 3])\n#\njulia> F0 = VectorField((x, v) -> [x[1]+v, x[2], (1-x[3])], variable=true)\njulia> F1 = VectorField((x, v) -> [0, -x[3]-v, x[2]], variable=true)\njulia> @Lie [F0, F1]([1, 2, 3], 2)\n#\njulia> F0 = VectorField((t, x, v) -> [t+x[1]+v, x[2], (1-x[3])], autonomous=false, variable=true)\njulia> F1 = VectorField((t, x, v) -> [t, -x[3]-v, x[2]], autonomous=false, variable=true)\njulia> @Lie [F0, F1](1, [1, 2, 3], 2)\n#\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7])\n3.0\n#\njulia> H0 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2), autonomous=false)\njulia> H1 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2), autonomous=false)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7])\n#\njulia> H0 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), variable=true)\njulia> H1 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), variable=true)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2)\n#\njulia> H0 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), autonomous=false, variable=true)\njulia> H1 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), autonomous=false, variable=true)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2)\n#\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase/diffgeometry.html","page":"Differential geometry","title":"Differential geometry","text":"","category":"page"},{"location":"api-ctbase/exceptions.html#api-ctbase-exceptions","page":"Exceptions","title":"Exceptions","text":"","category":"section"},{"location":"api-ctbase/exceptions.html","page":"Exceptions","title":"Exceptions","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/exceptions.html#Index","page":"Exceptions","title":"Index","text":"","category":"section"},{"location":"api-ctbase/exceptions.html","page":"Exceptions","title":"Exceptions","text":"Pages   = [\"exceptions.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/exceptions.html#Documentation","page":"Exceptions","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/exceptions.html","page":"Exceptions","title":"Exceptions","text":"Modules = [CTBase]\nOrder = [:module, :constant, :function, :macro]\nPages = [\"exception.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/exceptions.html","page":"Exceptions","title":"Exceptions","text":"","category":"page"},{"location":"api-ctbase/print.html#api-ctbase-print","page":"Print","title":"Print","text":"","category":"section"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]\nPages   = [\"print.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/print.html#Examples","page":"Print","title":"Examples","text":"","category":"section"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"An optimal control problem can be described as minimising the cost functional","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"g(t_0 x(t_0) t_f x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"and other constraints such as","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"Let us define the following optimal control problem.","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"using OptimalControl\n\nocp = Model()\n\nstate!(ocp, 2, \"x\", [\"r\", \"v\"]) # dimension of the state with the names of the components\ncontrol!(ocp, 1)           # dimension of the control\ntime!(ocp, t0=0, tf=1, name=\"s\")    # initial and final time, with the name of the variable time\n\nconstraint!(ocp, :initial, lb=[-1, 0], ub=[-1, 0])\nconstraint!(ocp, :final  , lb=[ 0, 0], ub=[ 0, 0])\nA = [ 0 1\n      0 0 ]\nB = [ 0\n      1 ]\ndynamics!(ocp, (x, u) -> A*x + B*u)\n\nobjective!(ocp, :lagrange, (x, u) -> 0.5u^2)","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"Then, we can print the form of this optimal control problem:","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"ocp","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"You can also define the optimal control problem in an abstract form:","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"using OptimalControl\n\n@def ocp begin\n    t âˆˆ [ 0, 1 ], time\n    x âˆˆ R^2, state\n    u âˆˆ R, control\n    x(0) == [ -1, 0 ], (1)\n    x(1) == [  0, 0 ]\n    xÌ‡(t) == A * x(t) + B * u(t)\n    âˆ«( 0.5u(t)^2 ) â†’ min\nend\nA = [ 0 1\n      0 0 ]\nB = [ 0\n      1 ]\nnothing #hide","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"Then, you can print this optimal control problem:","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"ocp","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"","category":"page"},{"location":"dev-ctbase.html#dev-ctbase","page":"CTBase.jl","title":"CTBase.jl private functions","text":"","category":"section"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-ctbase.html#Index","page":"CTBase.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Pages   = [\"dev-ctbase.md\"]\nModules = [CTBase]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctbase.html#Documentation","page":"CTBase.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-ctbase.html#CTBase.DescVarArg","page":"CTBase.jl","title":"CTBase.DescVarArg","text":"DescVarArg is a Vararg of symbols. DescVarArg is a type alias for a Vararg of symbols.\n\njulia> const DescVarArg = Vararg{Symbol}\n\nSee also: Description.\n\n\n\n\n\n","category":"constant"},{"location":"dev-ctbase.html#CTBase.RangeConstraint","page":"CTBase.jl","title":"CTBase.RangeConstraint","text":"Type alias for an index or range.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.AbstractCTFunction","page":"CTBase.jl","title":"CTBase.AbstractCTFunction","text":"abstract type AbstractCTFunction <: Function\n\nAbstract type for functions.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.AbstractOptimalControlModel","page":"CTBase.jl","title":"CTBase.AbstractOptimalControlModel","text":"abstract type AbstractOptimalControlModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.AbstractOptimalControlSolution","page":"CTBase.jl","title":"CTBase.AbstractOptimalControlSolution","text":"abstract type AbstractOptimalControlSolution\n\nAbstract type for optimal control solutions.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.AbstractVectorField","page":"CTBase.jl","title":"CTBase.AbstractVectorField","text":"abstract type AbstractVectorField{time_dependence, variable_dependence}\n\nAbstract type for vectorfields.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.ParsingInfo","page":"CTBase.jl","title":"CTBase.ParsingInfo","text":"mutable struct ParsingInfo\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.PrintCallbacks","page":"CTBase.jl","title":"CTBase.PrintCallbacks","text":"Tuple of print callbacks.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.StopCallbacks","page":"CTBase.jl","title":"CTBase.StopCallbacks","text":"Tuple of stop callbacks.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#Base.:\\-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Symbol}}}","page":"CTBase.jl","title":"Base.:\\","text":"\\(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn the difference between the description x and the description y.\n\nExample\n\njulia> (:a, :b) \\ (:a,)\n(:b,)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, OptimalControlModel}","page":"CTBase.jl","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::OptimalControlModel\n)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, OptimalControlSolution}","page":"CTBase.jl","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    sol::OptimalControlSolution\n)\n\n\nPrints the solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"CTBase.jl","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    descriptions::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n)\n\n\nPrint a tuple of descriptions.\n\nExample\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, AmbiguousDescription}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::AmbiguousDescription)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, IncorrectArgument}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectArgument)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, IncorrectMethod}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectMethod)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, IncorrectOutput}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectOutput)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, NotImplemented}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::NotImplemented)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, ParsingError}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::ParsingError)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, UnauthorizedCall}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::UnauthorizedCall)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.:â…‹-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V<:VariableDependence","page":"CTBase.jl","title":"CTBase.:â…‹","text":"â…‹(\n    X::VectorField{Autonomous, V<:VariableDependence},\n    Y::VectorField{Autonomous, V<:VariableDependence}\n) -> VectorField\n\n\n\"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, autonomous case\n\nExample\n\njulia> X = VectorField(x -> [x[2], -x[1]])\njulia> Y = VectorField(x -> [x[1], x[2]])\njulia> CTBase.:(â…‹)(X, Y)([1, 2])\n[2, -1]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.:â…‹-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V<:VariableDependence","page":"CTBase.jl","title":"CTBase.:â…‹","text":"â…‹(\n    X::VectorField{NonAutonomous, V<:VariableDependence},\n    Y::VectorField{NonAutonomous, V<:VariableDependence}\n) -> VectorField{NonAutonomous}\n\n\n\"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, nonautonomous case\n\nExample\n\njulia> X = VectorField((t, x, v) -> [t + v[1] + v[2] + x[2], -x[1]], NonFixed, NonAutonomous)\njulia> Y = VectorField((t, x, v) ->  [v[1] + v[2] + x[1], x[2]], NonFixed, NonAutonomous)\njulia> CTBase.:(â…‹)(X, Y)(1, [1, 2], [2, 3])\n[8, -1]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__callbacks-Tuple{}","page":"CTBase.jl","title":"CTBase.__callbacks","text":"__callbacks() -> Tuple{}\n\n\nUsed to set the default value of the callbacks argument. The default value is (), which means that no additional callback is given.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_all_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__check_all_set","text":"__check_all_set(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Bool}\n\n\nCheck if the parameters of an ocp are set.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_control_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__check_control_set","text":"__check_control_set(ocp::OptimalControlModel) -> Bool\n\n\nThrow UnauthorizedCall exception if the control of an ocp is not set.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_dependencies-Tuple{Tuple{Vararg{DataType}}}","page":"CTBase.jl","title":"CTBase.__check_dependencies","text":"__check_dependencies(\n    dependencies::Tuple{Vararg{DataType}}\n) -> Bool\n\n\nThrow IncorrectArgument exception if dependencies arguments are incorrect.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_is_time_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__check_is_time_set","text":"__check_is_time_set(ocp::OptimalControlModel) -> Bool\n\n\nThrow UnauthorizedCall exception if the time of an ocp is not set.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_state_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__check_state_set","text":"__check_state_set(ocp::OptimalControlModel) -> Bool\n\n\nThrow UnauthorizedCall exception if the state of an ocp is not set.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_variable_set-Tuple{OptimalControlModel{<:TimeDependence, Fixed}}","page":"CTBase.jl","title":"CTBase.__check_variable_set","text":"__check_variable_set(\n    ocp::OptimalControlModel{<:TimeDependence, Fixed}\n)\n\n\nDo nothing, no variable for fixed ocp.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_variable_set-Tuple{OptimalControlModel{<:TimeDependence, NonFixed}}","page":"CTBase.jl","title":"CTBase.__check_variable_set","text":"__check_variable_set(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed}\n) -> Bool\n\n\nThrow UnauthorizedCall exception if the variable of an ocp is not set.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__constraint_label-Tuple{}","page":"CTBase.jl","title":"CTBase.__constraint_label","text":"__constraint_label() -> Symbol\n\n\nUsed to set the default value of the label of a constraint. A unique value is given to each constraint using the gensym function and prefixing by :unamed.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__control_components_names-Tuple{Integer, String}","page":"CTBase.jl","title":"CTBase.__control_components_names","text":"__control_components_names(m::Integer, name::String) -> Any\n\n\nUsed to set the default value of the names of the controls. The default value is [\"u\"] for a one dimensional control, and [\"uâ‚\", \"uâ‚‚\", ...] for a multi dimensional control.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__control_name-Tuple{}","page":"CTBase.jl","title":"CTBase.__control_name","text":"__control_name() -> String\n\n\nUsed to set the default value of the names of the control. The default value is \"u\".\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__criterion_type-Tuple{}","page":"CTBase.jl","title":"CTBase.__criterion_type","text":"__criterion_type() -> Symbol\n\n\nUsed to set the default value of the type of criterion. Either :min or :max. The default value is :min. The other possible criterion type is :max.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__display-Tuple{}","page":"CTBase.jl","title":"CTBase.__display","text":"__display() -> Bool\n\n\nUsed to set the default value of the display argument. The default value is true, which means that the output is printed during resolution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__fun_time_dependence-Tuple{}","page":"CTBase.jl","title":"CTBase.__fun_time_dependence","text":"__fun_time_dependence() -> Type{Autonomous}\n\n\nUsed to set the default value of the time dependence of the functions.\n\nThe default value is Autonomous, which means that the functions are considered time independent. The other possible time dependence is NonAutonomous, which means that the functions are considered time dependent.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__fun_variable_dependence-Tuple{}","page":"CTBase.jl","title":"CTBase.__fun_variable_dependence","text":"__fun_variable_dependence() -> Type{Fixed}\n\n\nUsed to set the default value of the variable dependence of the functions.\n\nThe default value is Fixed, which means that the functions are considered variable independent. The other possible variable dependence is NonFixed, which means that the functions are considered variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__get_AD_backend-Tuple{}","page":"CTBase.jl","title":"CTBase.__get_AD_backend","text":"__get_AD_backend(\n\n) -> ADTypes.AutoForwardDiff{nothing, Nothing}\n\n\nUsed to set the default value of Automatic Differentiation backend.\n\nThe default value is AutoForwardDiff(), that is the ForwardDiff package is used by default.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__init_interpolation-Tuple{}","page":"CTBase.jl","title":"CTBase.__init_interpolation","text":"__init_interpolation() -> CTBase.var\"#13#14\"\n\n\nUsed to set the default interpolation function used for initialisation. The default value is Interpolations.linear_interpolation, which means that the initial guess is linearly interpolated.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__matrix_dimension_stock-Tuple{}","page":"CTBase.jl","title":"CTBase.__matrix_dimension_stock","text":"__matrix_dimension_stock() -> Int64\n\n\nUsed to set the default value of the stockage of elements in a matrix. The default value is 1.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__mu_strategy_ipopt-Tuple{}","page":"CTBase.jl","title":"CTBase.__mu_strategy_ipopt","text":"__mu_strategy_ipopt() -> String\n\n\nUsed to set the default value of the Î¼ strategy of ipopt for the direct method. The default value is adaptive.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__ocp_time_dependence-Tuple{}","page":"CTBase.jl","title":"CTBase.__ocp_time_dependence","text":"__ocp_time_dependence() -> Type{Autonomous}\n\n\nUsed to set the default value of the time dependence of the Optimal Control Problem. The default value is Autonomous, which means that the Optimal Control Problem is considered time independent. The other possible time dependence is NonAutonomous, which means that all the functions used to define the  Optimal Control Problem are considered time dependent.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__ocp_variable_dependence-Tuple{}","page":"CTBase.jl","title":"CTBase.__ocp_variable_dependence","text":"__ocp_variable_dependence() -> Type{Fixed}\n\n\nUsed to set the default value of the variable dependence of the Optimal Control Problem. The default value is Fixed, which means that the Optimal Control Problem is considered variable independent. The other possible variable dependence is NonFixed, which means that all the functions used to define the Optimal Control Problem are considered variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__print_level_ipopt-Tuple{}","page":"CTBase.jl","title":"CTBase.__print_level_ipopt","text":"__print_level_ipopt() -> Int64\n\n\nUsed to set the default value of the print level of ipopt for the direct method. The default value is 5.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__state_components_names-Tuple{Integer, String}","page":"CTBase.jl","title":"CTBase.__state_components_names","text":"__state_components_names(n::Integer, name::String) -> Any\n\n\nUsed to set the default value of the names of the states. The default value is [\"x\"] for a one dimensional state, and [\"xâ‚\", \"xâ‚‚\", ...] for a multi dimensional state.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__state_name-Tuple{}","page":"CTBase.jl","title":"CTBase.__state_name","text":"__state_name() -> String\n\n\nUsed to set the default value of the name of the state. The default value is \"x\".\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__time_name-Tuple{}","page":"CTBase.jl","title":"CTBase.__time_name","text":"__time_name() -> String\n\n\nUsed to set the default value of the name of the time. The default value is t.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__variable_components_names-Tuple{Integer, String}","page":"CTBase.jl","title":"CTBase.__variable_components_names","text":"__variable_components_names(q::Integer, name::String) -> Any\n\n\nUsed to set the default value of the names of the variables. The default value is [\"v\"] for a one dimensional variable, and [\"vâ‚\", \"vâ‚‚\", ...] for a multi dimensional variable.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__variable_name-Tuple{}","page":"CTBase.jl","title":"CTBase.__variable_name","text":"__variable_name() -> String\n\n\nUsed to set the default value of the names of the variables. The default value is \"v\".\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.buildFunctionalInit-Tuple{Any, Any, Any}","page":"CTBase.jl","title":"CTBase.buildFunctionalInit","text":"buildFunctionalInit(data, time, dim) -> CTBase.var\"#217#218\"\n\n\nBuild functional initialization: general interpolation case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.buildFunctionalInit-Tuple{Function, Any, Any}","page":"CTBase.jl","title":"CTBase.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Function,\n    time,\n    dim\n) -> CTBase.var\"#219#220\"{<:Function}\n\n\nBuild functional initialization: function case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.buildFunctionalInit-Tuple{Nothing, Any, Any}","page":"CTBase.jl","title":"CTBase.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Nothing,\n    time,\n    dim\n) -> CTBase.var\"#217#218\"\n\n\nBuild functional initialization: default case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.buildFunctionalInit-Tuple{Union{Real, AbstractVector{<:Real}}, Any, Any}","page":"CTBase.jl","title":"CTBase.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Union{Real, AbstractVector{<:Real}},\n    time,\n    dim\n) -> Any\n\n\nBuild functional initialization: constant / 1D interpolation\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.buildVectorInit-Tuple{Any, Any}","page":"CTBase.jl","title":"CTBase.buildVectorInit","text":"buildVectorInit(data, dim) -> Any\n\n\nBuild vector initialization: default / vector case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.checkDim-Tuple{Any, Any}","page":"CTBase.jl","title":"CTBase.checkDim","text":"checkDim(actual_dim, target_dim)\n\n\nCheck if actual dimension is equal to target dimension, error otherwise\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.ctindice-Tuple{Integer}","page":"CTBase.jl","title":"CTBase.ctindice","text":"ctindice(i::Integer) -> Char\n\n\nReturn i âˆˆ [0, 9] as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.ctupperscript-Tuple{Integer}","page":"CTBase.jl","title":"CTBase.ctupperscript","text":"ctupperscript(i::Integer) -> Char\n\n\nReturn i âˆˆ [0, 9] as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.expand-Tuple{Matrix{<:Real}}","page":"CTBase.jl","title":"CTBase.expand","text":"expand(x::Matrix{<:Real}) -> Vector{<:Real}\n\n\nReturn expand(matrix2vec(x, 1))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.expand-Tuple{Vector{<:Real}}","page":"CTBase.jl","title":"CTBase.expand","text":"expand(x::Vector{<:Real}) -> Vector{<:Real}\n\n\nReturn x.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.expand-Tuple{Vector{<:Vector{<:Real}}}","page":"CTBase.jl","title":"CTBase.expand","text":"expand(x::Vector{<:Vector{<:Real}}) -> Vector{<:Real}\n\n\nEquivalent to vec2vec(x)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.expr_it-Tuple{Any, Any, Any}","page":"CTBase.jl","title":"CTBase.expr_it","text":"expr_it(e, _Expr, f) -> Any\n\n\nExpr iterator: apply _Expr to nodes and f to leaves of the AST.\n\nExample\n\njulia> id(e) = expr_it(e, Expr, x -> x)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.formatData-Tuple{Any}","page":"CTBase.jl","title":"CTBase.formatData","text":"formatData(data) -> Any\n\n\nConvert matrix to vector of vectors (could be expanded)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.formatTimeGrid-Tuple{Any}","page":"CTBase.jl","title":"CTBase.formatTimeGrid","text":"formatTimeGrid(time) -> Any\n\n\nConvert matrix time-grid to vector\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.has-Tuple{Any, Any, Any}","page":"CTBase.jl","title":"CTBase.has","text":"has(e, x, t) -> Union{Missing, Bool}\n\n\nReturn true if e contains a (...x...)(t) call.\n\nExample\n\njulia> e = :( âˆ«( x[1](t)^2 + 2*u(t) ) â†’ min )\n:(âˆ«((x[1])(t) ^ 2 + 2 * u(t)) â†’ min)\n\njulia> has(e, :x, :t)\ntrue\n\njulia> has(e, :u, :t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.has-Tuple{Any, Any}","page":"CTBase.jl","title":"CTBase.has","text":"has(e, e1) -> Union{Missing, Bool}\n\n\nReturn true if e contains e1.\n\nExample\n\njulia> e = :( âˆ«( x[1](t)^2 + 2*u(t) ) â†’ min )\n:(âˆ«((x[1])(t) ^ 2 + 2 * u(t)) â†’ min)\n\njulia> has(e, 2)\ntrue\n\njulia> has(e, :x)\ntrue\n\njulia> has(e, :min)\ntrue\n\njulia> has(e, :( x[1](t)^2 ))\ntrue\n\njulia> !has(e, :( x[1](t)^3 ))\ntrue\n\njulia> !has(e, 3)\ntrue\n\njulia> !has(e, :max)\ntrue\n\njulia> has(:x, :x)\ntrue\n\njulia> !has(:x, 2)\ntrue\n\njulia> !has(:x, :y)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.isaVectVect-Tuple{Any}","page":"CTBase.jl","title":"CTBase.isaVectVect","text":"isaVectVect(data) -> Bool\n\n\nReturn true if argument is a vector of vectors\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.matrix2vec","page":"CTBase.jl","title":"CTBase.matrix2vec","text":"matrix2vec(x::Matrix{<:Real}) -> Vector{<:Vector{<:Real}}\nmatrix2vec(\n    x::Matrix{<:Real},\n    dim::Integer\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms x to a Vector{<:Vector{<:ctNumber}}.\n\nNote. dim âˆˆ {1, 2} is the dimension along which the matrix is transformed.\n\n\n\n\n\n","category":"function"},{"location":"dev-ctbase.html#CTBase.parse!-Tuple{Any, Any, Any}","page":"CTBase.jl","title":"CTBase.parse!","text":"parse!(p, ocp, e; log) -> Union{Expr, LineNumberNode}\n\n\nFoo\n\nExample\n\nFoo\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.subs-Tuple{Any, Union{Real, Symbol}, Any}","page":"CTBase.jl","title":"CTBase.subs","text":"subs(e, e1::Union{Real, Symbol}, e2) -> Any\n\n\nSubstitute expression e1 by expression e2 in expression e.\n\nExamples\n\njulia> e = :( âˆ«( r(t)^2 + 2uâ‚(t)) â†’ min )\n:(âˆ«(r(t) ^ 2 + 2 * uâ‚(t)) â†’ min)\n\njulia> subs(e, :r, :( x[1] ))\n:(âˆ«((x[1])(t) ^ 2 + 2 * uâ‚(t)) â†’ min)\n\njulia> e = :( âˆ«( uâ‚(t)^2 + 2uâ‚‚(t)) â†’ min )\n:(âˆ«(uâ‚(t) ^ 2 + 2 * uâ‚‚(t)) â†’ min)\n\njulia> for i âˆˆ 1:2\n       e = subs(e, Symbol(:u, Char(8320+i)), :( u[$i] ))\n       end; e\n:(âˆ«((u[1])(t) ^ 2 + 2 * (u[2])(t)) â†’ min)\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); subs(e, :( $x[1]($(t0)) ), :( $x0[1] ))\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.vec2vec-Tuple{Vector{<:Real}, Integer}","page":"CTBase.jl","title":"CTBase.vec2vec","text":"vec2vec(\n    x::Vector{<:Real},\n    n::Integer\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms x to a Vector{<:Vector{<:ctNumber}}.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.vec2vec-Tuple{Vector{<:Vector{<:Real}}}","page":"CTBase.jl","title":"CTBase.vec2vec","text":"vec2vec(x::Vector{<:Vector{<:Real}}) -> Vector{<:Real}\n\n\nTransforms x to a Vector{<:ctNumber}.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"page"},{"location":"api-ctflows.html#CTFlows.jl","page":"CTFlows.jl","title":"CTFlows.jl","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"The CTFlows.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"flowchart TD\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctbase.html'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctdirect.html'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctflows.html'>CTFlows</a>)\nF --> B\nD --> B\nstyle F fill:#FBF275","category":"page"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-ctflows.html#Index","page":"CTFlows.jl","title":"Index","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Pages   = [\"api-ctflows.md\"]\nModules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-ctflows.html#Documentation","page":"CTFlows.jl","title":"Documentation","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Modules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"","category":"page"},{"location":"tutorial-goddard.html#goddard","page":"Goddard: direct, indirect","title":"Direct and indirect methods for the Goddard problem","text":"","category":"section"},{"location":"tutorial-goddard.html#Introduction","page":"Goddard: direct, indirect","title":"Introduction","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"<img src=\"./assets/Goddard_and_Rocket.jpg\" style=\"float: left; margin: auto 10px;\" width=\"200px\">","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"For this advanced example, we consider the well-known Goddard problem[1] [2] which models the ascent of a rocket through the atmosphere, and we restrict here ourselves to vertical (one dimensional) trajectories. The state variables are the altitude r, speed v and mass m of the rocket during the flight, for a total dimension of 3. The rocket is subject to gravity g, thrust u and drag force D (function of speed and altitude). The final time t_f is free, and the objective is to reach a maximal altitude with a bounded fuel consumption.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We thus want to solve the optimal control problem in Mayer form","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"    r(t_f) to max","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"subject to the controlled dynamics","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"    dotr = v quad\n    dotv = fracT_maxu - D(rv)m - g quad\n    dotm = -u","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"and subject to the control constraint u(t) in 01 and the state constraint v(t) leq v_max. The initial state is fixed while only the final mass is prescribed.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"note: Nota bene\nThe Hamiltonian is affine with respect to the control, so singular arcs may occur, as well as constrained arcs due to the path constraint on the velocity (see below).","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"using Suppressor # to suppress warnings","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We import the OptimalControl.jl package to define the optimal control problem and NLPModelsIpopt.jl to solve it.  We import the Plots.jl package to plot the solution.  The OrdinaryDiffEq.jl package is used to  define the shooting function for the indirect method and the  NonlinearSolve.jl and  MINPACK.jl packages permit to solve the shooting  equation.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"using OptimalControl  # to define the optimal control problem and more\nusing NLPModelsIpopt  # to solve the problem via a direct method\nusing OrdinaryDiffEq  # to get the Flow function from OptimalControl\nusing NonlinearSolve  # interface to NLE solvers\nusing MINPACK         # NLE solver: use to solve the shooting equation\nusing Plots           # to plot the solution","category":"page"},{"location":"tutorial-goddard.html#Optimal-control-problem","page":"Goddard: direct, indirect","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We define the problem","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"t0 = 0      # initial time\nr0 = 1      # initial altitude\nv0 = 0      # initial speed\nm0 = 1      # initial mass\nvmax = 0.1  # maximal authorized speed\nmf = 0.6    # final mass to target\n\n@def ocp begin # definition of the optimal control problem\n\n    tf âˆˆ R, variable\n    t âˆˆ [t0, tf], time\n    x = (r, v, m) âˆˆ RÂ³, state\n    u âˆˆ R, control\n\n    x(t0) == [ r0, v0, m0 ]\n    m(tf) == mf,         (1)\n    0 â‰¤ u(t) â‰¤ 1\n    r(t) â‰¥ r0\n    0 â‰¤ v(t) â‰¤ vmax\n\n    áº‹(t) == F0(x(t)) + u(t) * F1(x(t))\n\n    r(tf) â†’ max\n\nend;\n\n# Dynamics\nconst Cd = 310\nconst Tmax = 3.5\nconst Î² = 500\nconst b = 2\n\nF0(x) = begin\n    r, v, m = x\n    D = Cd * v^2 * exp(-Î²*(r - 1)) # Drag force\n    return [ v, -D/m - 1/r^2, 0 ]\nend\n\nF1(x) = begin\n    r, v, m = x\n    return [ 0, Tmax/m, -b*Tmax ]\nend\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html#Direct-method","page":"Goddard: direct, indirect","title":"Direct method","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We then solve it","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"direct_sol = solve(ocp; grid_size=100, linear_solver=\"mumps\")\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"and plot the solution","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"plt = plot(direct_sol, solution_label=\"(direct)\", size=(800, 800))","category":"page"},{"location":"tutorial-goddard.html#Structure-of-the-solution","page":"Goddard: direct, indirect","title":"Structure of the solution","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We first determine visually the structure of the optimal solution which is composed of a bang arc with maximal control, followed by a singular arc, then by a boundary arc and the final arc is with zero control. Note that the switching function vanishes along the singular and boundary arcs.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"t = direct_sol.times\nx = direct_sol.state\nu = direct_sol.control\np = direct_sol.costate\n\nH1 = Lift(F1)           # H1(x, p) = p' * F1(x)\nÏ†(t) = H1(x(t), p(t))   # switching function\ng(x) = vmax - x[2]      # state constraint v â‰¤ vmax\n\nu_plot  = plot(t, u,     label = \"u(t)\")\nH1_plot = plot(t, Ï†,     label = \"Hâ‚(x(t), p(t))\")\ng_plot  = plot(t, g âˆ˜ x, label = \"g(x(t))\")\n\nplot(u_plot, H1_plot, g_plot, layout=(3,1), size=(500, 500))","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We are now in position to solve the problem by an indirect shooting method. We first define the four control laws in feedback form and their associated flows. For this we need to compute some Lie derivatives, namely Poisson brackets of Hamiltonians (themselves obtained as lifts to the cotangent bundle of vector fields), or derivatives of functions along a vector field. For instance, the control along the minimal order singular arcs is obtained as the quotient","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"u_s = -fracH_001H_101","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"of length three Poisson brackets:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"H_001 = H_0H_0H_1 quad H_101 = H_1H_0H_1","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"where, for two Hamiltonians H and G,","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"HG = (nabla_p Hnabla_x G) - (nabla_x Hnabla_p G)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"While the Lie derivative of a function f wrt. a vector field X is simply obtained as","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"(X cdot f)(x) = f(x) cdot X(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"and is used to the compute the control along the boundary arc,","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"u_b(x) = -(F_0 cdot g)(x)  (F_1 cdot g)(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"as well as the associated multiplier for the order one state constraint on the velocity:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"mu(x p) = H_01(x p)  (F_1 cdot g)(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"note: Poisson bracket and Lie derivative\nThe Poisson bracket HG is also given by the Lie derivative of G along the Hamiltonian vector field X_H = (nabla_p H -nabla_x H) of H, that is    HG = X_H cdot Gwhich is the reason why we use the @Lie macro to compute Poisson brackets below.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"With the help of the differential geometry primitives from CTBase.jl, these expressions are straightforwardly translated into Julia code:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# Controls\nu0 = 0                                  # off control\nu1 = 1                                  # bang control\n\nH0 = Lift(F0)                           # H0(x, p) = p' * F0(x)\nH01  = @Lie { H0, H1 }\nH001 = @Lie { H0, H01 }\nH101 = @Lie { H1, H01 }\nus(x, p) = -H001(x, p) / H101(x, p)     # singular control\n\nub(x) = -(F0â‹…g)(x) / (F1â‹…g)(x)          # boundary control\nÎ¼(x, p) = H01(x, p) / (F1â‹…g)(x)         # multiplier associated to the state constraint g\n\n# Flows\nf0 = Flow(ocp, (x, p, tf) -> u0)\nf1 = Flow(ocp, (x, p, tf) -> u1)\nfs = Flow(ocp, (x, p, tf) -> us(x, p))\nfb = Flow(ocp, (x, p, tf) -> ub(x), (x, u, tf) -> g(x), (x, p, tf) -> Î¼(x, p))\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html#Shooting-function","page":"Goddard: direct, indirect","title":"Shooting function","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Then, we define the shooting function according to the optimal structure we have determined, that is a concatenation of four arcs.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"x0 = [ r0, v0, m0 ] # initial state\n\nfunction shoot!(s, p0, t1, t2, t3, tf)\n\n    x1, p1 = f1(t0, x0, p0, t1)\n    x2, p2 = fs(t1, x1, p1, t2)\n    x3, p3 = fb(t2, x2, p2, t3)\n    xf, pf = f0(t3, x3, p3, tf)\n\n    s[1] = constraint(ocp, :eq1)(x0, xf, tf) - mf # final mass constraint (1)\n    s[2:3] = pf[1:2] - [ 1, 0 ]                   # transversality conditions\n    s[4] = H1(x1, p1)                             # H1 = H01 = 0\n    s[5] = H01(x1, p1)                            # at the entrance of the singular arc\n    s[6] = g(x2)                                  # g = 0 when entering the boundary arc\n    s[7] = H0(xf, pf)                             # since tf is free\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html#Initial-guess","page":"Goddard: direct, indirect","title":"Initial guess","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"To solve the problem by an indirect shooting method, we then need a good initial guess, that is a good approximation of the initial costate, the three switching times and the final time.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Î· = 1e-3\nt13 = t[ abs.(Ï†.(t)) .â‰¤ Î· ]\nt23 = t[ 0 .â‰¤ (g âˆ˜ x).(t) .â‰¤ Î· ]\np0 = p(t0)\nt1 = min(t13...)\nt2 = min(t23...)\nt3 = max(t23...)\ntf = t[end]\n\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\nusing LinearAlgebra: norm\ns = similar(p0, 7)\n@suppress_err begin # hide\nshoot!(s, p0, t1, t2, t3, tf)\nend # hide\nprintln(\"\\nNorm of the shooting function: â€–sâ€– = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html#Indirect-shooting","page":"Goddard: direct, indirect","title":"Indirect shooting","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We aggregate the data to define the initial guess vector.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Î¾ = [ p0 ; t1 ; t2 ; t3 ; tf ] # initial guess","category":"page"},{"location":"tutorial-goddard.html#NonlinearSolve.jl","page":"Goddard: direct, indirect","title":"NonlinearSolve.jl","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We first use the NonlinearSolve.jl package to solve the shooting equation. Let us define the problem.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# auxiliary function with aggregated inputs\nnle! = (s, Î¾, Î») -> shoot!(s, Î¾[1:3], Î¾[4], Î¾[5], Î¾[6], Î¾[7])\n\n# NLE problem with initial guess\nprob = NonlinearProblem(nle!, Î¾)\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Let us do some benchmarking.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"using BenchmarkTools\n@benchmark solve(prob; abstol=1e-8, reltol=1e-8, show_trace=Val(false))","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"For small nonlinear systems, it could be faster to use the  SimpleNewtonRaphson() descent algorithm.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"@benchmark solve(prob, SimpleNewtonRaphson(); abstol=1e-8, reltol=1e-8, show_trace=Val(false))","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Now, let us solve the problem and retrieve the initial costate solution.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"global indirect_sol =               # hide\n@suppress_err begin                 # hide\nsolve(prob; show_trace=Val(false))  # hide\n# resolution of S(Î¾) = 0\nindirect_sol = solve(prob; abstol=1e-8, reltol=1e-8, show_trace=Val(true))\nend                                 # hide\n\n# we retrieve the costate solution together with the times\np0 = indirect_sol.u[1:3]\nt1 = indirect_sol.u[4]\nt2 = indirect_sol.u[5]\nt3 = indirect_sol.u[6]\ntf = indirect_sol.u[7]\n\nprintln(\"\")\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\ns = similar(p0, 7)\n@suppress_err begin # hide\nshoot!(s, p0, t1, t2, t3, tf)\nend # hide\nprintln(\"\\nNorm of the shooting function: â€–sâ€– = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html#MINPACK.jl","page":"Goddard: direct, indirect","title":"MINPACK.jl","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"using MINPACK\nfunction fsolve(f, j, x; kwargs...)\n    try\n        MINPACK.fsolve(f, j, x; kwargs...)\n    catch e\n        println(\"Erreur using MINPACK\")\n        println(e)\n        println(\"hybrj not supported. Replaced by hybrd even if it is not visible on the doc.\")\n        MINPACK.fsolve(f, x; kwargs...)\n    end\nend","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Instead of the NonlinearSolve.jl package we can use the  MINPACK.jl package to solve  the shooting equation. To compute the Jacobian of the shooting function we use the  DifferentiationInterface.jl package with  ForwardDiff backend.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"using DifferentiationInterface\nimport ForwardDiff\nbackend = AutoForwardDiff()\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Let us define the problem to solve.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# auxiliary function with aggregated inputs\nnle!  = ( s, Î¾) -> shoot!(s, Î¾[1:3], Î¾[4], Î¾[5], Î¾[6], Î¾[7])\n\n # Jacobian of the (auxiliary) shooting function\njnle! = (js, Î¾) -> jacobian!(nle!, similar(Î¾), js, backend, Î¾)\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We are now in position to solve the problem with the hybrj solver from MINPACK through the fsolve  function, providing the Jacobian. Let us do some benchmarking.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"@benchmark fsolve(nle!, jnle!, Î¾; show_trace=false) # initial guess given to the solver","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We can also use the preparation step of DifferentiationInterface.jl.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"extras = prepare_jacobian(nle!, similar(Î¾), backend, Î¾)\njnle_prepared!(js, Î¾) = jacobian!(nle!, similar(Î¾), js, backend, Î¾, extras)\n@benchmark fsolve(nle!, jnle_prepared!, Î¾; show_trace=false)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Now, let us solve the problem and retrieve the initial costate solution.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"\nglobal indirect_sol =                                   # hide\n@suppress_err begin                                     # hide\nfsolve(nle!, jnle!, Î¾; show_trace=false)                # hide\n# resolution of S(Î¾) = 0\nindirect_sol = fsolve(nle!, jnle!, Î¾, show_trace=true)\nend                                                     # hide\n\n# we retrieve the costate solution together with the times\np0 = indirect_sol.x[1:3]\nt1 = indirect_sol.x[4]\nt2 = indirect_sol.x[5]\nt3 = indirect_sol.x[6]\ntf = indirect_sol.x[7]\n\nprintln(\"\")\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\ns = similar(p0, 7)\n@suppress_err begin                                     # hide\nshoot!(s, p0, t1, t2, t3, tf)\nend                                                     # hide\nprintln(\"\\nNorm of the shooting function: â€–sâ€– = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html#Plot-of-the-solution","page":"Goddard: direct, indirect","title":"Plot of the solution","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We plot the solution of the indirect solution (in red) over the solution of the direct method  (in blue).","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"f = f1 * (t1, fs) * (t2, fb) * (t3, f0) # concatenation of the flows\nflow_sol = f((t0, tf), x0, p0)          # compute the solution: state, costate, control...\n\nplot!(plt, flow_sol, solution_label=\"(indirect)\")","category":"page"},{"location":"tutorial-goddard.html#References","page":"Goddard: direct, indirect","title":"References","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"[1]: R.H. Goddard. A Method of Reaching Extreme Altitudes, volume 71(2) of Smithsonian Miscellaneous Collections. Smithsonian institution, City of Washington, 1919.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"[2]: H. Seywald and E.M. Cliff. Goddard problem in presence of a dynamic pressure limit. Journal of Guidance, Control, and Dynamics, 16(4):776â€“781, 1993.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"","category":"page"},{"location":"dev-ctflows.html#dev-ctflows","page":"CTFlows.jl","title":"CTFlows.jl private functions","text":"","category":"section"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-ctflows.html#Index","page":"CTFlows.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Pages   = [\"dev-ctflows.md\"]\nModules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctflows.html#Documentation","page":"CTFlows.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Modules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-ctflows.html#CTBase.OptimalControlSolution-Tuple{CTFlows.OptimalControlFlowSolution}","page":"CTFlows.jl","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(\n    ocfs::CTFlows.OptimalControlFlowSolution\n) -> OptimalControlSolution\n\n\nConstruct an OptimalControlSolution from an OptimalControlFlowSolution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.ExtensionError","page":"CTFlows.jl","title":"CTFlows.ExtensionError","text":"struct ExtensionError <: CTException\n\nException thrown when an extension is not loaded but the user tries to call a function of it.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctflows.html#CTFlows.OptimalControlFlowSolution","page":"CTFlows.jl","title":"CTFlows.OptimalControlFlowSolution","text":"struct OptimalControlFlowSolution\n\nType of an optimal control flow solution.\n\nFields\n\node_sol::Any\nfeedback_control::ControlLaw\nocp::OptimalControlModel\nvariable::Union{Real, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctflows.html#Base.showerror-Tuple{IO, CTFlows.ExtensionError}","page":"CTFlows.jl","title":"Base.showerror","text":"showerror(io::IO, e::CTFlows.ExtensionError)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.__abstol-Tuple{}","page":"CTFlows.jl","title":"CTFlows.__abstol","text":"__abstol() -> Float64\n\n\nDefault absolute tolerance for ODE solvers.\n\nSee abstol from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.__alg-Tuple{}","page":"CTFlows.jl","title":"CTFlows.__alg","text":"__alg() -> Any\n\n\nDefault algorithm for ODE solvers.\n\nSee alg from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.__callback-Tuple{}","page":"CTFlows.jl","title":"CTFlows.__callback","text":"__callback()\n\n\nSee callback from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.__reltol-Tuple{}","page":"CTFlows.jl","title":"CTFlows.__reltol","text":"__reltol() -> Float64\n\n\nDefault relative tolerance for ODE solvers.\n\nSee reltol from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.__saveat-Tuple{}","page":"CTFlows.jl","title":"CTFlows.__saveat","text":"__saveat() -> Vector{Any}\n\n\nSee saveat from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.__tstops-Tuple{}","page":"CTFlows.jl","title":"CTFlows.__tstops","text":"__tstops() -> Vector{Real}\n\n\nSee tstops from DifferentialEquations.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{Dynamics, ControlLaw, Lagrange, Real, Real, MixedConstraint, Multiplier}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::Dynamics,\n    u::ControlLaw,\n    fâ°::Lagrange,\n    pâ°::Real,\n    s::Real,\n    g::MixedConstraint,\n    Î¼::Multiplier\n) -> CTFlows.var\"#H#43\"{Dynamics{time_dependence, variable_dependence}, ControlLaw{time_dependence1, variable_dependence1}, Lagrange{time_dependence2, variable_dependence2}, var\"#s178\", var\"#s1781\", MixedConstraint{time_dependence3, variable_dependence3}, Multiplier{time_dependence4, variable_dependence4}} where {time_dependence, variable_dependence, time_dependence1, variable_dependence1, time_dependence2, variable_dependence2, var\"#s178\"<:Real, var\"#s1781\"<:Real, time_dependence3, variable_dependence3, time_dependence4, variable_dependence4}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p â‹… f(t, x, u(t, x, p)) + s pâ° fâ°(t, x, u(t, x, p)) + Î¼(t, x, p) â‹… g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{Dynamics, ControlLaw, Lagrange, Real, Real}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::Dynamics,\n    u::ControlLaw,\n    fâ°::Lagrange,\n    pâ°::Real,\n    s::Real\n) -> CTFlows.var\"#H#41\"{Dynamics{time_dependence, variable_dependence}, ControlLaw{time_dependence1, variable_dependence1}, Lagrange{time_dependence2, variable_dependence2}, <:Real, <:Real} where {time_dependence, variable_dependence, time_dependence1, variable_dependence1, time_dependence2, variable_dependence2}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p â‹… f(t, x, u(t, x, p)) + s pâ° fâ°(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{Dynamics, ControlLaw, MixedConstraint, Multiplier}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::Dynamics,\n    u::ControlLaw,\n    g::MixedConstraint,\n    Î¼::Multiplier\n) -> CTFlows.var\"#H#42\"{Dynamics{time_dependence, variable_dependence}, ControlLaw{time_dependence1, variable_dependence1}, MixedConstraint{time_dependence2, variable_dependence2}, Multiplier{time_dependence3, variable_dependence3}} where {time_dependence, variable_dependence, time_dependence1, variable_dependence1, time_dependence2, variable_dependence2, time_dependence3, variable_dependence3}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p â‹… f(t, x, u(t, x, p)) + Î¼(t, x, p) â‹… g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{Dynamics, ControlLaw}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::Dynamics,\n    u::ControlLaw\n) -> CTFlows.var\"#39#40\"{Dynamics{time_dependence, variable_dependence}, ControlLaw{time_dependence1, variable_dependence1}} where {time_dependence, variable_dependence, time_dependence1, variable_dependence1}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p f(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"","category":"page"},{"location":"api-ctbase/repl.html#api-ctbase-repl","page":"Repl","title":"Repl","text":"","category":"section"},{"location":"api-ctbase/repl.html","page":"Repl","title":"Repl","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/repl.html#Index","page":"Repl","title":"Index","text":"","category":"section"},{"location":"api-ctbase/repl.html","page":"Repl","title":"Repl","text":"Pages   = [\"repl.md\"]\nModules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/repl.html#Documentation","page":"Repl","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/repl.html","page":"Repl","title":"Repl","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]\nPages   = [\"repl.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/repl.html#CTBase.ct_repl-Tuple{}","page":"Repl","title":"CTBase.ct_repl","text":"ct_repl(; debug, verbose)\n\n\nCreate a ct REPL.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/repl.html#CTBase.ct_repl_update_model-Tuple{Expr}","page":"Repl","title":"CTBase.ct_repl_update_model","text":"ct_repl_update_model(e::Expr)\n\n\nUpdate the model adding the expression e. It must be public since in the ct repl, this function  is quoted each time an expression is parsed and is valid. \n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/repl.html","page":"Repl","title":"Repl","text":"","category":"page"},{"location":"tutorial-initial-guess.html#Initial-guess-(or-iterate)-for-the-resolution","page":"Initial guess","title":"Initial guess (or iterate) for the resolution","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"We present in this tutorial the different possibilities to provide an initial guess to solve an  optimal control problem with the OptimalControl.jl package. ","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"First, we need to import the OptimalControl.jl package to define the optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"For the illustrations, we define the following optimal control problem.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"t0 = 0\ntf = 10\nÎ±  = 5\n\n@def ocp begin\n    t âˆˆ [t0, tf], time\n    v âˆˆ R, variable\n    x âˆˆ RÂ², state\n    u âˆˆ R, control\n    x(t0) == [ -1, 0 ]\n    x(tf) - [ 0, v ] == [0, 0]\n    xÌ‡(t) == [ xâ‚‚(t), xâ‚(t) + Î±*xâ‚(t)^2 + u(t) ]\n    v^2 + âˆ«( 0.5u(t)^2 ) â†’ min\nend\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Default-initial-guess","page":"Initial guess","title":"Default initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"We first solve the problem without giving an initial guess. This will default to initialize all variables to 0.1.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# solve the optimal control problem without initial guess\nsol = solve(ocp; display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Let us plot the solution of the optimal control problem.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"plot(sol; size=(600, 450))","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Note that the following formulations are equivalent to not giving an initial guess.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"sol = solve(ocp; init=nothing, display=false)\nprintln(\"Number of iterations: \", sol.iterations)\n\nsol = solve(ocp; init=(), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"To reduce the number of iterations and improve the convergence, we can give an initial guess to the solver.  This initial guess can be built from constant values, interpolated vectors, functions, or existing solutions. Except when initializing from a solution, the arguments are to be passed as a named tuple init=(state=..., control=..., variable=...) whose fields are optional. Missing fields will revert to default initialization (ie constant 0.1).","category":"page"},{"location":"tutorial-initial-guess.html#Constant-initial-guess","page":"Initial guess","title":"Constant initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"We first illustrate the constant initial guess, using vectors or scalars according to the dimension.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# solve the optimal control problem with initial guess with constant values\nsol = solve(ocp; init=(state=[-0.2, 0.1], control=-0.2, variable=0.05), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Partial initializations are also valid, as shown below. Note the ending comma when a single argument is passed (tuple).","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# initialisation only on the state\nsol = solve(ocp; init=(state=[-0.2, 0.1],), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\n\n# initialisation only on the control\nsol = solve(ocp; init=(control=-0.2,), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\n\n# initialisation only on the state and the variable\nsol = solve(ocp; init=(state=[-0.2, 0.1], variable=0.05), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Functional-initial-guess","page":"Initial guess","title":"Functional initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"For the state and control, we can also provide functions of time as initial guess.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# initial guess as functions of time\nx(t) = [ -0.2t, 0.1t ]\nu(t) = -0.2t\n\nsol = solve(ocp; init=(state=x, control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Vector-initial-guess-(interpolated)","page":"Initial guess","title":"Vector initial guess (interpolated)","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Initialization can also be provided with vectors / matrices to be interpolated along a given time grid.  In this case the time steps must be given through an additional argument time, which can be a vector or line/column matrix. For the values to be interpolated both matrices and vectors of vectors are allowed, but the shape should be number of time steps x variable dimension. Simple vectors are also allowed for variables of dimension 1.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# initial guess as vector of points\nt_vec = LinRange(t0,tf,4)\nx_vec = [[0, 0], [-0.1, 0.3], [-0.15,0.4], [-0.3, 0.5]]\nu_vec = [0, -0.8,  -0.3, 0]\n\nsol = solve(ocp; init=(time=t_vec, state=x_vec, control=u_vec, variable=0.05), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Note: in the free final time case, the given time grid should be consistent with the initial guess provided for the final time (in the optimization variables).","category":"page"},{"location":"tutorial-initial-guess.html#Mixed-initial-guess","page":"Initial guess","title":"Mixed initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"The constant, functional and vector initializations can be mixed, for instance as","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# we can mix constant values with functions of time\nsol = solve(ocp; init=(state=[-0.2, 0.1], control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\n\n# wa can mix every possibility\nsol = solve(ocp; init=(time=t_vec, state=x_vec, control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Solution-as-initial-guess-(warm-start)","page":"Initial guess","title":"Solution as initial guess (warm start)","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Finally, we can use an existing solution to provide the initial guess.  The dimensions of the state, control and optimization variable must coincide. This particular feature allows an easy implementation of discrete continuations.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# generate the initial solution\nsol_init = solve(ocp; display=false)\n\n# solve the problem using solution as initial guess\nsol = solve(ocp; init=sol_init, display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Note that you can also manually pick and choose which data to reuse from a solution, by recovering the  functions sol.state, sol.control and the values sol.variable. For instance the following formulation is equivalent to the init=sol one.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# use a previous solution to initialise picking data\nsol = solve(ocp; \n    init = (\n        state    = sol.state, \n        control  = sol.control, \n        variable = sol.variable\n    ), \n    display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Costate-/-multipliers","page":"Initial guess","title":"Costate / multipliers","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"For the moment we can not provide an initial guess for the costate / multipliers.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"","category":"page"},{"location":"api-ctbase/types.html#api-ctbase-types","page":"Types","title":"Types","text":"","category":"section"},{"location":"api-ctbase/types.html","page":"Types","title":"Types","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/types.html#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"api-ctbase/types.html","page":"Types","title":"Types","text":"Pages   = [\"types.md\"]\nModules = [CTBase]\nOrder   = [:type]","category":"page"},{"location":"api-ctbase/types.html#Documentation","page":"Types","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/types.html","page":"Types","title":"Types","text":"Modules = [CTBase]\nOrder   = [:type]\nPrivate = false","category":"page"},{"location":"api-ctbase/types.html#CTBase.AbstractHamiltonian","page":"Types","title":"CTBase.AbstractHamiltonian","text":"abstract type AbstractHamiltonian{time_dependence, variable_dependence}\n\nAbstract type for hamiltonians.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.AmbiguousDescription","page":"Types","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTException\n\nException thrown when the description is ambiguous / incorrect.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Autonomous","page":"Types","title":"CTBase.Autonomous","text":"abstract type Autonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.BoundaryConstraint","page":"Types","title":"CTBase.BoundaryConstraint","text":"struct BoundaryConstraint{variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor BoundaryConstraint returns a BoundaryConstraint of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar. When the constraint is dimension 1, return a scalar.\n\nCall\n\nThe call returns the evaluation of the BoundaryConstraint for given values. If a variable is given for a non variable dependent boundary constraint, it will be ignored.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.BoundaryConstraint-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.BoundaryConstraint","text":"BoundaryConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> BoundaryConstraint{Fixed}\n\n\nReturn a BoundaryConstraint of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.BoundaryConstraint-Tuple{Function}","page":"Types","title":"CTBase.BoundaryConstraint","text":"BoundaryConstraint(\n    f::Function;\n    variable\n) -> BoundaryConstraint{Fixed}\n\n\nReturn a BoundaryConstraint of a function. Dependencies are specified with a boolean, variable, false by default.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.BoundaryConstraint","text":"Return the evaluation of the BoundaryConstraint.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.CTCallback","page":"Types","title":"CTBase.CTCallback","text":"abstract type CTCallback\n\nAbstract type for callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.CTCallbacks","page":"Types","title":"CTBase.CTCallbacks","text":"Tuple of callbacks\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.CTException","page":"Types","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract type for exceptions.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.ControlConstraint","page":"Types","title":"CTBase.ControlConstraint","text":"struct ControlConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlConstraint returns a ControlConstraint of a function. The function must take 1 to 3 arguments, u to (t, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the control is of dimension 1, consider u as a scalar.\n\nCall\n\nThe call returns the evaluation of the ControlConstraint for given values.\n\nExamples\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.ControlConstraint-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> ControlConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlConstraint-Tuple{Function}","page":"Types","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlConstraint{Autonomous, Fixed}\n\n\nReturn the ControlConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.ControlConstraint","text":"Return the value of the ControlConstraint function.\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlLaw","page":"Types","title":"CTBase.ControlLaw","text":"struct ControlLaw{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to Hamiltonian in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlLaw returns a ControlLaw of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the ControlLaw for given values.\n\nExamples\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.ControlLaw-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.ControlLaw","text":"ControlLaw(\n    f::Function,\n    dependencies::DataType...\n) -> ControlLaw{Autonomous, Fixed}\n\n\nReturn the ControlLaw of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlLaw-Tuple{Function}","page":"Types","title":"CTBase.ControlLaw","text":"ControlLaw(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlLaw{Autonomous, Fixed}\n\n\nReturn the ControlLaw of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlLaw-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.ControlLaw","text":"Return the value of the ControlLaw function.\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Controls","page":"Types","title":"CTBase.Controls","text":"Type alias for a vector of controls.\n\njulia> const Controls = AbstractVector{<:Control}\n\nSee also: Control, States, Costates.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Costates","page":"Types","title":"CTBase.Costates","text":"Type alias for a vector of costates.\n\njulia> const Costates = AbstractVector{<:Costate}\n\nSee also: Costate, States, Controls.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Description","page":"Types","title":"CTBase.Description","text":"A description is a tuple of symbols. Description is a type alias for a tuple of symbols.\n\njulia> const Description = Tuple{DescVarArg}\n\nSee also: DescVarArg.\n\nExample\n\nBase.show is overloaded for descriptions, that is tuple of descriptions are printed as follows:\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Dimension","page":"Types","title":"CTBase.Dimension","text":"Type alias for a dimension. This is used to define the dimension of the state space,  the costate space, the control space, etc.\n\njulia> const Dimension = Integer\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Dynamics","page":"Types","title":"CTBase.Dynamics","text":"struct Dynamics{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Dynamics returns a Dynamics of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Dynamics for given values.\n\nExamples\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Dynamics-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.Dynamics","text":"Dynamics(\n    f::Function,\n    dependencies::DataType...\n) -> Dynamics{Autonomous, Fixed}\n\n\nReturn the Dynamics of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Dynamics-Tuple{Function}","page":"Types","title":"CTBase.Dynamics","text":"Dynamics(\n    f::Function;\n    autonomous,\n    variable\n) -> Dynamics{Autonomous, Fixed}\n\n\nReturn the Dynamics of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Dynamics-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.Dynamics","text":"Return the value of the Dynamics function.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.FeedbackControl","page":"Types","title":"CTBase.FeedbackControl","text":"struct FeedbackControl{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor FeedbackControl returns a FeedbackControl of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the FeedbackControl for given values.\n\nExamples\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.FeedbackControl-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function,\n    dependencies::DataType...\n) -> FeedbackControl{Autonomous, Fixed}\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.FeedbackControl-Tuple{Function}","page":"Types","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function;\n    autonomous,\n    variable\n) -> FeedbackControl{Autonomous, Fixed}\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.FeedbackControl-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.FeedbackControl","text":"Return the value of the FeedbackControl function.\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Fixed","page":"Types","title":"CTBase.Fixed","text":"abstract type Fixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Hamiltonian","page":"Types","title":"CTBase.Hamiltonian","text":"struct Hamiltonian{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Hamiltonian returns a Hamiltonian of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Hamiltonian for given values.\n\nExamples\n\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Hamiltonian-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function,\n    dependencies::DataType...\n) -> Hamiltonian{Autonomous, Fixed}\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Hamiltonian-Tuple{Function}","page":"Types","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function;\n    autonomous,\n    variable\n) -> Hamiltonian{Autonomous, Fixed}\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Hamiltonian-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.Hamiltonian","text":"Return the value of the Hamiltonian.\n\njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianLift","page":"Types","title":"CTBase.HamiltonianLift","text":"struct HamiltonianLift{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence}\n\nLifts\n\nX::VectorField\n\nThe values for time_dependence and variable_dependence are deternimed by the values of those for the VectorField.\n\nConstructor\n\nThe constructor HamiltonianLift returns a HamiltonianLift of a VectorField.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed))\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianLift for given values.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\nAlternatively, it is possible to construct the HamiltonianLift from a Function being the VectorField.\n\njulia> HL1 = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL2 = HamiltonianLift(VectorField((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true))\njulia> HL1([1, 0], [0, 1], 1) == HL2([1, 0], [0, 1], 1)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.HamiltonianLift-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], Autonomous, Fixed)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], Autonomous, NonFixed)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], NonAutonomous, Fixed)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianLift-Tuple{Function}","page":"Types","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianLift\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], autonomous=false, variable=false)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianLift-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.HamiltonianLift","text":"Return the value of the HamiltonianLift.\n\nExamples\n\njulia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianVectorField","page":"Types","title":"CTBase.HamiltonianVectorField","text":"struct HamiltonianVectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor HamiltonianVectorField returns a HamiltonianVectorField of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianVectorField for given values.\n\nExamples\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.HamiltonianVectorField-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function,\n    dependencies::DataType...\n) -> HamiltonianVectorField{Autonomous, Fixed}\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianVectorField-Tuple{Function}","page":"Types","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianVectorField{Autonomous, Fixed}\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianVectorField-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.HamiltonianVectorField","text":"Return the value of the HamiltonianVectorField.\n\nExamples\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.IncorrectArgument","page":"Types","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTException\n\nException thrown when an argument is inconsistent.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.IncorrectMethod","page":"Types","title":"CTBase.IncorrectMethod","text":"struct IncorrectMethod <: CTException\n\nException thrown when a method is incorrect.\n\nFields\n\nvar::Symbol\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.IncorrectOutput","page":"Types","title":"CTBase.IncorrectOutput","text":"struct IncorrectOutput <: CTException\n\nException thrown when the output is incorrect.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Index","page":"Types","title":"CTBase.Index","text":"mutable struct Index\n\nFields\n\nval::Integer\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Lagrange","page":"Types","title":"CTBase.Lagrange","text":"struct Lagrange{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Lagrange returns a Lagrange cost of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], Autonomous, Fixed)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, Autonomous, Fixed)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], Autonomous, NonFixed)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, Fixed)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Lagrange cost for given values.\n\nExamples\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Lagrange-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.Lagrange","text":"Lagrange(\n    f::Function,\n    dependencies::DataType...\n) -> Lagrange{Autonomous, Fixed}\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Lagrange-Tuple{Function}","page":"Types","title":"CTBase.Lagrange","text":"Lagrange(\n    f::Function;\n    autonomous,\n    variable\n) -> Lagrange{Autonomous, Fixed}\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Lagrange-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.Lagrange","text":"Return the value of the Lagrange function.\n\nExamples\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Mayer","page":"Types","title":"CTBase.Mayer","text":"struct Mayer{variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor Mayer returns a Mayer cost of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar.\n\nCall\n\nThe call returns the evaluation of the Mayer cost for given values. If a variable is given for a non variable dependent Mayer cost, it will be ignored.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1],Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Mayer-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.Mayer","text":"Mayer(\n    f::Function,\n    dependencies::DataType...\n) -> Mayer{Fixed}\n\n\nReturn a Mayer cost of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Mayer-Tuple{Function}","page":"Types","title":"CTBase.Mayer","text":"Mayer(f::Function; variable) -> Mayer{Fixed}\n\n\nReturn a Mayer cost of a function. Dependencies are specified with a boolean, variable, false by default.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Mayer-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.Mayer","text":"Return the evaluation of the Mayer cost.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1], Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.MixedConstraint","page":"Types","title":"CTBase.MixedConstraint","text":"struct MixedConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to Lagrange in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor MixedConstraint returns a MixedConstraint of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the MixedConstraint for given values.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.MixedConstraint-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> MixedConstraint{Autonomous, Fixed}\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.MixedConstraint-Tuple{Function}","page":"Types","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> MixedConstraint{Autonomous, Fixed}\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.MixedConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.MixedConstraint","text":"Return the value of the MixedConstraint function.\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Multiplier","page":"Types","title":"CTBase.Multiplier","text":"struct Multiplier{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to ControlLaw in the usage.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Multiplier returns a Multiplier of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Î¼ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> Î¼ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> Î¼ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> Î¼ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> Î¼ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> Î¼ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> Î¼ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> Î¼ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Multiplier for given values.\n\nExamples\n\njulia> Î¼ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> Î¼([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> Î¼(t, [1, 0], [0, 1])\nMethodError\njulia> Î¼([1, 0], [0, 1], v)\nMethodError\njulia> Î¼(t, [1, 0], [0, 1], v)\n3\njulia> Î¼ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> Î¼([1, 0], [0, 1], [1, 2, 3])\n6\njulia> Î¼(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> Î¼ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> Î¼(1, [1, 0], [0, 1])\n4\njulia> Î¼(1, [1, 0], [0, 1], v)\n4\njulia> Î¼ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> Î¼(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Multiplier-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.Multiplier","text":"Multiplier(\n    f::Function,\n    dependencies::DataType...\n) -> Multiplier{Autonomous, Fixed}\n\n\nReturn the Multiplier of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Î¼ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> Î¼ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> Î¼ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> Î¼ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Multiplier-Tuple{Function}","page":"Types","title":"CTBase.Multiplier","text":"Multiplier(\n    f::Function;\n    autonomous,\n    variable\n) -> Multiplier{Autonomous, Fixed}\n\n\nReturn the Multiplier of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> Î¼ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> Î¼ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> Î¼ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> Î¼ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Multiplier-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.Multiplier","text":"Return the value of the Multiplier function.\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Î¼ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> Î¼([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> Î¼(t, [1, 0], [0, 1])\nMethodError\njulia> Î¼([1, 0], [0, 1], v)\nMethodError\njulia> Î¼(t, [1, 0], [0, 1], v)\n3\njulia> Î¼ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> Î¼([1, 0], [0, 1], [1, 2, 3])\n6\njulia> Î¼(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> Î¼ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> Î¼(1, [1, 0], [0, 1])\n4\njulia> Î¼(1, [1, 0], [0, 1], v)\n4\njulia> Î¼ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> Î¼(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.NonAutonomous","page":"Types","title":"CTBase.NonAutonomous","text":"abstract type NonAutonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.NonFixed","page":"Types","title":"CTBase.NonFixed","text":"abstract type NonFixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.NotImplemented","page":"Types","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTException\n\nException thrown when a method is not implemented.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.OptimalControlInit","page":"Types","title":"CTBase.OptimalControlInit","text":"Initial guess for OCP, contains\n\nfunctions of time for the state and control variables\nvector for optimization variables\n\nInitialization data for each field can be left to default or: \n\nvector for optimization variables\nconstant / vector / function for state and control  \nexisting solution ('warm start') for all fields\n\nConstructors:\n\nOptimalControlInit(): default initialization\nOptimalControlInit(state, control, variable, time): constant vector, function handles and / or matrices / vectors interpolated along given time grid\nOptimalControlInit(sol): from existing solution\n\nExamples\n\njulia> init = OptimalControlInit()\njulia> init = OptimalControlInit(state=[0.1, 0.2], control=0.3)\njulia> init = OptimalControlInit(state=[0.1, 0.2], control=0.3, variable=0.5)\njulia> init = OptimalControlInit(state=[0.1, 0.2], controlt=t->sin(t), variable=0.5)\njulia> init = OptimalControlInit(state=[[0, 0], [1, 2], [5, -1]], time=[0, .3, 1.], controlt=t->sin(t))\njulia> init = OptimalControlInit(sol)\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.OptimalControlModel","page":"Types","title":"CTBase.OptimalControlModel","text":"mutable struct OptimalControlModel{time_dependence<:TimeDependence, variable_dependence<:VariableDependence} <: CTBase.AbstractOptimalControlModel\n\nFields\n\nmodel_expression::Union{Nothing, Expr}: Default: nothing\ninitial_time::Union{Nothing, Index, Real}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time::Union{Nothing, Index, Real}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nvariable_dimension::Union{Nothing, Integer}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nlagrange::Union{Nothing, Lagrange}: Default: nothing\nmayer::Union{Nothing, Mayer}: Default: nothing\ncriterion::Union{Nothing, Symbol}: Default: nothing\ndynamics::Union{Nothing, Dynamics}: Default: nothing\nconstraints::Dict{Symbol, Tuple}: Default: Dict{Symbol, Tuple{Vararg{Any}}}()\ndim_control_constraints::Union{Nothing, Integer}: Default: nothing\ndim_state_constraints::Union{Nothing, Integer}: Default: nothing\ndim_mixed_constraints::Union{Nothing, Integer}: Default: nothing\ndim_boundary_constraints::Union{Nothing, Integer}: Default: nothing\ndim_variable_constraints::Union{Nothing, Integer}: Default: nothing\ndim_control_range::Union{Nothing, Integer}: Default: nothing\ndim_state_range::Union{Nothing, Integer}: Default: nothing\ndim_variable_range::Union{Nothing, Integer}: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.OptimalControlSolution","page":"Types","title":"CTBase.OptimalControlSolution","text":"mutable struct OptimalControlSolution <: CTBase.AbstractOptimalControlSolution\n\nType of an optimal control solution.\n\nFields\n\ntimes::Union{Nothing, StepRangeLen, AbstractVector{<:Real}}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\ncontrol::Union{Nothing, Function}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nstate::Union{Nothing, Function}: Default: nothing\nvariable_dimension::Union{Nothing, Integer}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nvariable::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\ncostate::Union{Nothing, Function}: Default: nothing\nobjective::Union{Nothing, Real}: Default: nothing\niterations::Union{Nothing, Integer}: Default: nothing\nstopping::Union{Nothing, Symbol}: Default: nothing\nmessage::Union{Nothing, String}: Default: nothing\nsuccess::Union{Nothing, Bool}: Default: nothing\ninfos::Dict{Symbol, Any}: Default: Dict{Symbol, Any}()\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.ParsingError","page":"Types","title":"CTBase.ParsingError","text":"struct ParsingError <: CTException\n\nException thrown for syntax error during abstract parsing.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.PrintCallback","page":"Types","title":"CTBase.PrintCallback","text":"mutable struct PrintCallback <: CTCallback\n\nCallback for printing.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.PrintCallback-Tuple","page":"Types","title":"CTBase.PrintCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.StateConstraint","page":"Types","title":"CTBase.StateConstraint","text":"struct StateConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor StateConstraint returns a StateConstraint of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the StateConstraint for given values.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.StateConstraint-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> StateConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.StateConstraint-Tuple{Function}","page":"Types","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> StateConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.StateConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.StateConstraint","text":"Return the value of the StateConstraint function.\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.States","page":"Types","title":"CTBase.States","text":"Type alias for a vector of states.\n\njulia> const States = AbstractVector{<:State}\n\nSee also: State, Costates, Controls.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.StopCallback","page":"Types","title":"CTBase.StopCallback","text":"Stopping callback.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.StopCallback-Tuple","page":"Types","title":"CTBase.StopCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Time","page":"Types","title":"CTBase.Time","text":"Type alias for a time.\n\njulia> const Time = ctNumber\n\nSee also: ctNumber, Times, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.TimeDependence","page":"Types","title":"CTBase.TimeDependence","text":"abstract type TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Times","page":"Types","title":"CTBase.Times","text":"Type alias for a vector of times.\n\njulia> const Times = AbstractVector{<:Time}\n\nSee also: Time, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.UnauthorizedCall","page":"Types","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTException\n\nException thrown when a call to a function is not authorized.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.VariableConstraint","page":"Types","title":"CTBase.VariableConstraint","text":"struct VariableConstraint\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VariableConstraint returns a VariableConstraint of a function. The function must take 1 argument, v.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\n\nwarning: Warning\nWhen the variable is of dimension 1, consider v as a scalar.\n\nCall\n\nThe call returns the evaluation of the VariableConstraint for given values.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.VariableConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.VariableConstraint","text":"Return the value of the VariableConstraint function.\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.VariableDependence","page":"Types","title":"CTBase.VariableDependence","text":"abstract type VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.VectorField","page":"Types","title":"CTBase.VectorField","text":"struct VectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VectorField returns a VectorField of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the VectorField for given values.\n\nExamples\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.VectorField-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.VectorField","text":"VectorField(\n    f::Function,\n    dependencies::DataType...\n) -> VectorField{Autonomous, Fixed}\n\n\nReturn a VectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.VectorField-Tuple{Function}","page":"Types","title":"CTBase.VectorField","text":"VectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> VectorField{Autonomous, Fixed}\n\n\nReturn a VectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.VectorField-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.VectorField","text":"Return the value of the VectorField.\n\nExamples\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ctNumber","page":"Types","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\njulia> const ctNumber = Real\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html","page":"Types","title":"Types","text":"","category":"page"},{"location":"tutorial-basic-example-f.html#basic-f","page":"Energy min (functional syntax)","title":"Double integrator: energy min (functional syntax)","text":"","category":"section"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force u. We denote by x = (x_1 x_2) the state of the wagon, that is its position x_1 and its velocity x_2.","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"We assume that the mass is constant and unitary and that there is no friction. The dynamics we consider is given by","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) quad u(t) in R","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"which is simply the double integrator system. Les us consider a transfer starting at time t_0 = 0 and ending at time t_f = 1, for which we want to minimise the transfer energy","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"    frac12int_0^1 u^2(t)  mathrmdt","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"starting from the condition x(0) = (-1 0) and with the goal to reach the target x(1) = (0 0).","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"First, we need to import the OptimalControl.jl package to define the optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"Then, we can define the problem","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"ocp = Model()                                   # empty optimal control problem\n\ntime!(ocp, t0=0, tf=1)                          # initial and final times\nstate!(ocp, 2)                                  # dimension of the state\ncontrol!(ocp, 1)                                # dimension of the control\n\nconstraint!(ocp, :initial; lb=[ -1, 0 ], ub=[ -1, 0 ]) # initial condition\nconstraint!(ocp, :final;   lb=[  0, 0 ], ub=[  0, 0 ]) # final condition\n\ndynamics!(ocp, (x, u) -> [ x[2], u ])           # dynamics of the double integrator\n\nobjective!(ocp, :lagrange, (x, u) -> 0.5u^2)    # cost in Lagrange form\nnothing # hide","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"note: Nota bene\nThere are two ways to define an optimal control problem:using functions like in this example, see also the Model documentation for more details.\nusing an abstract formulation, see for instance basic example to compare.","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"Solve it","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"and plot the solution","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"plot(sol)","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Energy min (functional syntax)","title":"Energy min (functional syntax)","text":"","category":"page"},{"location":"api-ctbase/utils.html#api-ctbase-utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"api-ctbase/utils.html","page":"Utils","title":"Utils","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/utils.html#Index","page":"Utils","title":"Index","text":"","category":"section"},{"location":"api-ctbase/utils.html","page":"Utils","title":"Utils","text":"Pages   = [\"utils.md\"]\nModules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/utils.html#Documentation","page":"Utils","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/utils.html","page":"Utils","title":"Utils","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]\nPages   = [\"utils.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/utils.html#CTBase.ctgradient-Tuple{Function, Any}","page":"Utils","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x; backend) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctgradient-Tuple{Function, Real}","page":"Utils","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x::Real; backend) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctgradient-Tuple{VectorField, Any}","page":"Utils","title":"CTBase.ctgradient","text":"ctgradient(X::VectorField, x) -> Any\n\n\nReturn the gradient of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctindices-Tuple{Integer}","page":"Utils","title":"CTBase.ctindices","text":"ctindices(i::Integer) -> String\n\n\nReturn i > 0 as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctinterpolate-Tuple{Any, Any}","page":"Utils","title":"CTBase.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn the interpolation of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctjacobian-Tuple{Function, Any}","page":"Utils","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x; backend) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctjacobian-Tuple{Function, Real}","page":"Utils","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x::Real; backend) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctjacobian-Tuple{VectorField, Any}","page":"Utils","title":"CTBase.ctjacobian","text":"ctjacobian(X::VectorField, x) -> Any\n\n\nReturn the Jacobian of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctupperscripts-Tuple{Integer}","page":"Utils","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Integer) -> String\n\n\nReturn i > 0 as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html","page":"Utils","title":"Utils","text":"","category":"page"},{"location":"index.html#OptimalControl.jl","page":"Introduction","title":"OptimalControl.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The OptimalControl.jl package aims to provide tools to solve optimal control problems by direct and indirect methods. It is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Install and documentation\nTo install a package from the control-toolbox ecosystem,  please visit the installation page. The documentation is accessible from the main menu.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"An optimal control problem with fixed initial and final times can be described as minimising the cost functional","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"g(x(t_0) x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and other constraints such as","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"See our tutorials to get started solving optimal control problems.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
