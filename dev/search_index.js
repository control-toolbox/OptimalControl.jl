var documenterSearchIndex = {"docs":
[{"location":"tutorial-basic-example.html#basic","page":"Basic example","title":"Basic example","text":"","category":"section"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force u. We denote by x = (x_1 x_2) the state of the wagon, that is its position x_1 and its velocity x_2.","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"We assume that the mass is constant and unitary and that there is no friction. The dynamics is thus given by","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) in mathbbR","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"which is simply the double integrator system. Les us consider a transfer starting at time t_0 = 0 and ending at time t_f = 1, for which we want to minimise the transfer energy","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"    frac12int_0^1 u^2(t)  mathrmdt","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"starting from the condition x(0) = (-1 0) and with the goal to reach the target x(1) = (0 0).","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"note: Solution and details\nSee the page  Double integrator: energy minimisation  for the analytical solution and details about this problem.","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"using Plots\nusing Plots.PlotMeasures\nplot(args...; kwargs...) = Plots.plot(args...; kwargs..., leftmargin=25px)","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"First, we need to import the OptimalControl.jl package:","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"using OptimalControl","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"Then, we can define the problem","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"@def ocp begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n    ẋ(t) == [ x₂(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"Solve it","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"and plot the solution","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"plot(sol, size=(600, 450))","category":"page"},{"location":"tutorial-lqr-basic.html#LQR-example","page":"LQR example","title":"LQR example","text":"","category":"section"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"The energy and distance minimisation Linear Quadratic Problem (LQR) problem consists in minimising","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"    frac12 int_0^t_f left( x_1^2(t) + x_2^2(t) + u^2(t) right)  mathrmdt ","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"subject to the constraints","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = -x_1(t) + u(t) quad u(t) in R","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"and the initial condition","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"    x(0) = (01)","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"We define A and B as","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"    A = beginpmatrix 0  1  -1  0  endpmatrix quad\n    B = beginpmatrix 0  1  endpmatrix","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"and we aim to solve this optimal control problem for different values of t_f. First, we need to import the OptimalControl.jl package.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"using OptimalControl","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"Then, we can define the problem parameterized by the final time tf.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"x0 = [ 0\n       1 ]\nA  = [ 0 1\n      -1 0 ]\nB  = [ 0\n       1 ]\n\nfunction LQRProblem(tf)\n\n    @def ocp begin\n        t ∈ [ 0, tf ], time\n        x ∈ R², state\n        u ∈ R, control\n        x(0) == x0, initial_con\n        ẋ(t) == A * x(t) + B * u(t)\n        ∫( 0.5(x₁(t)^2 + x₂(t)^2 + u(t)^2) ) → min\n    end\n\n    return ocp\nend;\nnothing # hide","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"We solve the problem for t_f in 3 5 30.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"solutions = []\ntfspan    = [3, 5, 30]\n\nfor tf ∈ tfspan\n    sol = solve(LQRProblem(tf), display=false)\n    push!(solutions, sol)\nend\nnothing # hide","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"We choose to plot the solutions considering a normalized time s=(t-t_0)(t_f-t_0). We thus introduce the function rescale that rescales the time and redefine the state, costate and control variables.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"tip: Tip\nInstead of defining the function rescale, you can consider t_f as a parameter and define the following optimal control problem:@def ocp begin\n    s ∈ [ 0, 1 ], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == x0, initial_con\n    ẋ(s) == tf * ( A * x(s) + B * u(s) )\n    ∫( 0.5(x₁(s)^2 + x₂(s)^2 + u(s)^2) ) → min\nend","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"function rescale(sol)\n\n    # integration times\n    times = sol.times\n\n    # s is the rescaled time between 0 and 1\n    t(s)  = times[1] + s * (times[end] - times[1])\n\n    # rescaled times\n    sol.times = (times .- times[1]) ./ (times[end] .- times[1])\n\n    # redefinition of the state, control and costate\n    x = sol.state\n    u = sol.control\n    p = sol.costate\n\n    sol.state   = x∘t   # s → x(t(s))\n    sol.control = u∘t   # s → u(t(s))\n    sol.costate = p∘t   # s → p(t(s))\n\n    return sol\nend\nnothing # hide","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"note: Note\nThe ∘ operator is the composition operator. Hence, x∘t is the function s -> x(t(s)).","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"Finally we choose to plot only the state and control variables.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"using Plots.PlotMeasures # for leftmargin, bottommargin\n\n# we construct the plots from the solutions with default options\nplt = plot(rescale(solutions[1]))\nfor sol in solutions[2:end]\n    plot!(plt, rescale(sol))\nend\n\n# we plot only the state and control variables and we add the legend\npx1 = plot(plt[1], legend=false, xlabel=\"s\", ylabel=\"x₁\")\npx2 = plot(plt[2], label=reshape([\"tf = $tf\" for tf ∈ tfspan], \n    (1, length(tfspan))), xlabel=\"s\", ylabel=\"x₂\")\npu  = plot(plt[5], legend=false, xlabel=\"s\", ylabel=\"u\")\nplot(px1, px2, pu, layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"note: Note\nWe can observe that x(t_f) converges to the origin as t_f increases.","category":"page"},{"location":"tutorial-iss.html#Indirect-simple-shooting","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"In construction.","category":"page"},{"location":"tutorial-ct_repl.html#Repl","page":"Repl","title":"Repl","text":"","category":"section"},{"location":"tutorial-ct_repl.html","page":"Repl","title":"Repl","text":"See ct_repl method.","category":"page"},{"location":"api-ctbase.html#CTBase-API","page":"CTBase API","title":"CTBase API","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"This is just a dump of CTBase API documentation. For more details about CTBase.jl package, see the documentation.","category":"page"},{"location":"api-ctbase.html#Index","page":"CTBase API","title":"Index","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"Pages   = [\"api-ctbase.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctbase.html#Documentation","page":"CTBase API","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctbase.html#CTBase.CTBase","page":"CTBase API","title":"CTBase.CTBase","text":"CTBase module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDataStructures\nDocStringExtensions\nLinearAlgebra\nMLStyle\nParameters\nPlots\nPrettyTables\nPrintf\nReplMaker\nUnicode\n\nList of all the exported names:\n\nAbstractHamiltonian\nAmbiguousDescription\nAutonomous\nBoundaryConstraint\nCTCallback\nCTCallbacks\nCTException\nControl\nControlConstraint\nControlLaw\nControls\nCostate\nCostates\nDCostate\nDState\nDescription\nDimension\nDynamics\nFeedbackControl\nFixed\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\nIncorrectArgument\nIncorrectMethod\nIncorrectOutput\nIndex\nLagrange\n@Lie\nLie\nLift\nMayer\nMixedConstraint\nModel\nMultiplier\nNonAutonomous\nNonFixed\nNotImplemented\nOptimalControlModel\nOptimalControlSolution\nParsingError\nPoisson\nPrintCallback\nState\nStateConstraint\nStates\nStopCallback\nTime\nTimeDependence\nTimes\nTimesDisc\nUnauthorizedCall\nVariable\nVariableConstraint\nVariableDependence\nVectorField\nadd\nconstraint\nconstraint!\nconstraint_type\nconstraints_labels\ncontrol!\nctNumber\nctVector\nct_repl\nctgradient\nctindices\nctinterpolate\nctjacobian\nctupperscripts\n@def\ndynamics!\ngetFullDescription\nget_priority_print_callbacks\nget_priority_stop_callbacks\nis_max\nis_min\nis_time_dependent\nis_time_independent\nis_variable_dependent\nis_variable_independent\nnlp_constraints\nobjective!\nplot\nplot!\nremove_constraint!\nreplace_call\nstate!\ntime!\nvariable!\n∂ₜ\n⋅\n\n\n\n\n\n","category":"module"},{"location":"api-ctbase.html#CTBase.Control","page":"CTBase API","title":"CTBase.Control","text":"Type alias for a control.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Costate","page":"CTBase API","title":"CTBase.Costate","text":"Type alias for an costate.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.DCostate","page":"CTBase API","title":"CTBase.DCostate","text":"Type alias for a tangent vector to the costate space.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.DState","page":"CTBase API","title":"CTBase.DState","text":"Type alias for a tangent vector to the state space.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.State","page":"CTBase API","title":"CTBase.State","text":"Type alias for a state.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.TimesDisc","page":"CTBase API","title":"CTBase.TimesDisc","text":"Type alias for a grid of times.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Variable","page":"CTBase API","title":"CTBase.Variable","text":"Type alias for a variable.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ctVector","page":"CTBase API","title":"CTBase.ctVector","text":"Type alias for a vector of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.AbstractHamiltonian","page":"CTBase API","title":"CTBase.AbstractHamiltonian","text":"abstract type AbstractHamiltonian{time_dependence, variable_dependence}\n\nAbstract type for hamiltonians.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.AmbiguousDescription","page":"CTBase API","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTException\n\nException thrown when the description is ambiguous / incorrect.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Autonomous","page":"CTBase API","title":"CTBase.Autonomous","text":"abstract type Autonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"struct BoundaryConstraint{variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor BoundaryConstraint returns a BoundaryConstraint of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar. When the constraint is dimension 1, return a scalar.\n\nCall\n\nThe call returns the evaluation of the BoundaryConstraint for given values. If a variable is given for a non variable dependent boundary constraint, it will be ignored.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"BoundaryConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> BoundaryConstraint{Fixed}\n\n\nReturn a BoundaryConstraint of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"BoundaryConstraint(\n    f::Function;\n    variable\n) -> BoundaryConstraint{Fixed}\n\n\nReturn a BoundaryConstraint of a function. Dependencies are specified with a boolean, variable, false by default.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"Return the evaluation of the BoundaryConstraint.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.CTCallback","page":"CTBase API","title":"CTBase.CTCallback","text":"abstract type CTCallback\n\nAbstract type for callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.CTCallbacks","page":"CTBase API","title":"CTBase.CTCallbacks","text":"Tuple of callbacks\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.CTException","page":"CTBase API","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract type for exceptions.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ControlConstraint","page":"CTBase API","title":"CTBase.ControlConstraint","text":"struct ControlConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlConstraint returns a ControlConstraint of a function. The function must take 1 to 3 arguments, u to (t, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the control is of dimension 1, consider u as a scalar.\n\nCall\n\nThe call returns the evaluation of the ControlConstraint for given values.\n\nExamples\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ControlConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> ControlConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlConstraint{Autonomous, Fixed}\n\n\nReturn the ControlConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.ControlConstraint","text":"Return the value of the ControlConstraint function.\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlLaw","page":"CTBase API","title":"CTBase.ControlLaw","text":"struct ControlLaw{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to Hamiltonian in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlLaw returns a ControlLaw of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the ControlLaw for given values.\n\nExamples\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ControlLaw-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.ControlLaw","text":"ControlLaw(\n    f::Function,\n    dependencies::DataType...\n) -> ControlLaw{Autonomous, Fixed}\n\n\nReturn the ControlLaw of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlLaw-Tuple{Function}","page":"CTBase API","title":"CTBase.ControlLaw","text":"ControlLaw(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlLaw{Autonomous, Fixed}\n\n\nReturn the ControlLaw of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlLaw-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.ControlLaw","text":"Return the value of the ControlLaw function.\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Controls","page":"CTBase API","title":"CTBase.Controls","text":"Type alias for a vector of controls.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Costates","page":"CTBase API","title":"CTBase.Costates","text":"Type alias for a vector of costates.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Description","page":"CTBase API","title":"CTBase.Description","text":"A description is a tuple of symbols, that is a Tuple{Vararg{Symbol}}.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dimension","page":"CTBase API","title":"CTBase.Dimension","text":"Type alias for a dimension.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dynamics","page":"CTBase API","title":"CTBase.Dynamics","text":"struct Dynamics{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Dynamics returns a Dynamics of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Dynamics for given values.\n\nExamples\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dynamics-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Dynamics","text":"Dynamics(\n    f::Function,\n    dependencies::DataType...\n) -> Dynamics{Autonomous, Fixed}\n\n\nReturn the Dynamics of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Dynamics-Tuple{Function}","page":"CTBase API","title":"CTBase.Dynamics","text":"Dynamics(\n    f::Function;\n    autonomous,\n    variable\n) -> Dynamics{Autonomous, Fixed}\n\n\nReturn the Dynamics of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Dynamics-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Dynamics","text":"Return the value of the Dynamics function.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.FeedbackControl","page":"CTBase API","title":"CTBase.FeedbackControl","text":"struct FeedbackControl{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor FeedbackControl returns a FeedbackControl of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the FeedbackControl for given values.\n\nExamples\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.FeedbackControl-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function,\n    dependencies::DataType...\n) -> FeedbackControl{Autonomous, Fixed}\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.FeedbackControl-Tuple{Function}","page":"CTBase API","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function;\n    autonomous,\n    variable\n) -> FeedbackControl{Autonomous, Fixed}\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.FeedbackControl-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.FeedbackControl","text":"Return the value of the FeedbackControl function.\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Fixed","page":"CTBase API","title":"CTBase.Fixed","text":"abstract type Fixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Hamiltonian","page":"CTBase API","title":"CTBase.Hamiltonian","text":"struct Hamiltonian{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Hamiltonian returns a Hamiltonian of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Hamiltonian for given values.\n\nExamples\n\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Hamiltonian-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function,\n    dependencies::DataType...\n) -> Hamiltonian{Autonomous, Fixed}\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Hamiltonian-Tuple{Function}","page":"CTBase API","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function;\n    autonomous,\n    variable\n) -> Hamiltonian{Autonomous, Fixed}\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Hamiltonian-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Hamiltonian","text":"Return the value of the Hamiltonian.\n\njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianLift","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"struct HamiltonianLift{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence}\n\nLifts\n\nX::VectorField\n\nThe values for time_dependence and variable_dependence are deternimed by the values of those for the VectorField.\n\nConstructor\n\nThe constructor HamiltonianLift returns a HamiltonianLift of a VectorField.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed))\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianLift for given values.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\nAlternatively, it is possible to construct the HamiltonianLift from a Function being the VectorField.\n\njulia> HL1 = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL2 = HamiltonianLift(VectorField((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true))\njulia> HL1([1, 0], [0, 1], 1) == HL2([1, 0], [0, 1], 1)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.HamiltonianLift-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], Autonomous, Fixed)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], Autonomous, NonFixed)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], NonAutonomous, Fixed)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianLift-Tuple{Function}","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianLift\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], autonomous=false, variable=false)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianLift-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"Return the value of the HamiltonianLift.\n\nExamples\n\njulia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"struct HamiltonianVectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor HamiltonianVectorField returns a HamiltonianVectorField of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianVectorField for given values.\n\nExamples\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function,\n    dependencies::DataType...\n) -> HamiltonianVectorField{Autonomous, Fixed}\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Function}","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianVectorField{Autonomous, Fixed}\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"Return the value of the HamiltonianVectorField.\n\nExamples\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.IncorrectArgument","page":"CTBase API","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTException\n\nException thrown when an argument is inconsistent.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.IncorrectMethod","page":"CTBase API","title":"CTBase.IncorrectMethod","text":"struct IncorrectMethod <: CTException\n\nException thrown when a method is incorrect.\n\nFields\n\nvar::Symbol\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.IncorrectOutput","page":"CTBase API","title":"CTBase.IncorrectOutput","text":"struct IncorrectOutput <: CTException\n\nException thrown when the output is incorrect.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Index","page":"CTBase API","title":"CTBase.Index","text":"mutable struct Index\n\nFields\n\nval::Integer\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Lagrange","page":"CTBase API","title":"CTBase.Lagrange","text":"struct Lagrange{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Lagrange returns a Lagrange cost of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], Autonomous, Fixed)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, Autonomous, Fixed)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], Autonomous, NonFixed)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, Fixed)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Lagrange cost for given values.\n\nExamples\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Lagrange-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Lagrange","text":"Lagrange(\n    f::Function,\n    dependencies::DataType...\n) -> Lagrange{Autonomous, Fixed}\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lagrange-Tuple{Function}","page":"CTBase API","title":"CTBase.Lagrange","text":"Lagrange(\n    f::Function;\n    autonomous,\n    variable\n) -> Lagrange{Autonomous, Fixed}\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lagrange-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Lagrange","text":"Return the value of the Lagrange function.\n\nExamples\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Mayer","page":"CTBase API","title":"CTBase.Mayer","text":"struct Mayer{variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor Mayer returns a Mayer cost of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar.\n\nCall\n\nThe call returns the evaluation of the Mayer cost for given values. If a variable is given for a non variable dependent Mayer cost, it will be ignored.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1],Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Mayer-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Mayer","text":"Mayer(\n    f::Function,\n    dependencies::DataType...\n) -> Mayer{Fixed}\n\n\nReturn a Mayer cost of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Mayer-Tuple{Function}","page":"CTBase API","title":"CTBase.Mayer","text":"Mayer(f::Function; variable) -> Mayer{Fixed}\n\n\nReturn a Mayer cost of a function. Dependencies are specified with a boolean, variable, false by default.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Mayer-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Mayer","text":"Return the evaluation of the Mayer cost.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1], Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.MixedConstraint","page":"CTBase API","title":"CTBase.MixedConstraint","text":"struct MixedConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to Lagrange in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor MixedConstraint returns a MixedConstraint of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the MixedConstraint for given values.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.MixedConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> MixedConstraint{Autonomous, Fixed}\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.MixedConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> MixedConstraint{Autonomous, Fixed}\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.MixedConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.MixedConstraint","text":"Return the value of the MixedConstraint function.\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Multiplier","page":"CTBase API","title":"CTBase.Multiplier","text":"struct Multiplier{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to ControlLaw in the usage.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Multiplier returns a Multiplier of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Multiplier for given values.\n\nExamples\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Multiplier-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Multiplier","text":"Multiplier(\n    f::Function,\n    dependencies::DataType...\n) -> Multiplier{Autonomous, Fixed}\n\n\nReturn the Multiplier of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Multiplier-Tuple{Function}","page":"CTBase API","title":"CTBase.Multiplier","text":"Multiplier(\n    f::Function;\n    autonomous,\n    variable\n) -> Multiplier{Autonomous, Fixed}\n\n\nReturn the Multiplier of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Multiplier-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Multiplier","text":"Return the value of the Multiplier function.\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.NonAutonomous","page":"CTBase API","title":"CTBase.NonAutonomous","text":"abstract type NonAutonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.NonFixed","page":"CTBase API","title":"CTBase.NonFixed","text":"abstract type NonFixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.NotImplemented","page":"CTBase API","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTException\n\nException thrown when a method is not implemented.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.OptimalControlModel","page":"CTBase API","title":"CTBase.OptimalControlModel","text":"mutable struct OptimalControlModel{time_dependence<:TimeDependence, variable_dependence<:VariableDependence} <: CTBase.AbstractOptimalControlModel\n\nFields\n\nmodel_expression::Union{Nothing, Expr}: Default: nothing\ninitial_time::Union{Nothing, Index, Real}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time::Union{Nothing, Index, Real}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nvariable_dimension::Union{Nothing, Integer}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nlagrange::Union{Nothing, Lagrange}: Default: nothing\nmayer::Union{Nothing, Mayer}: Default: nothing\ncriterion::Union{Nothing, Symbol}: Default: nothing\ndynamics::Union{Nothing, Dynamics}: Default: nothing\nconstraints::Dict{Symbol, Tuple}: Default: Dict{Symbol, Tuple{Vararg{Any}}}()\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.OptimalControlSolution","page":"CTBase API","title":"CTBase.OptimalControlSolution","text":"mutable struct OptimalControlSolution <: CTBase.AbstractOptimalControlSolution\n\nType of an optimal control solution.\n\nFields\n\ntimes::Union{Nothing, StepRangeLen, AbstractVector{<:Real}}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\ncontrol::Union{Nothing, Function}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nstate::Union{Nothing, Function}: Default: nothing\nvariable_dimension::Union{Nothing, Integer}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nvariable::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\ncostate::Union{Nothing, Function}: Default: nothing\nobjective::Union{Nothing, Real}: Default: nothing\niterations::Union{Nothing, Integer}: Default: nothing\nstopping::Union{Nothing, Symbol}: Default: nothing\nmessage::Union{Nothing, String}: Default: nothing\nsuccess::Union{Nothing, Bool}: Default: nothing\ninfos::Dict{Symbol, Any}: Default: Dict{Symbol, Any}()\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ParsingError","page":"CTBase API","title":"CTBase.ParsingError","text":"struct ParsingError <: CTException\n\nException thrown for syntax error during abstract parsing.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.PrintCallback","page":"CTBase API","title":"CTBase.PrintCallback","text":"mutable struct PrintCallback <: CTCallback\n\nCallback for printing.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.PrintCallback-Tuple","page":"CTBase API","title":"CTBase.PrintCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.StateConstraint","page":"CTBase API","title":"CTBase.StateConstraint","text":"struct StateConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor StateConstraint returns a StateConstraint of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the StateConstraint for given values.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.StateConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> StateConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.StateConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> StateConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.StateConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.StateConstraint","text":"Return the value of the StateConstraint function.\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.States","page":"CTBase API","title":"CTBase.States","text":"Type alias for a vector of states.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.StopCallback","page":"CTBase API","title":"CTBase.StopCallback","text":"Stopping callback.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.StopCallback-Tuple","page":"CTBase API","title":"CTBase.StopCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Time","page":"CTBase API","title":"CTBase.Time","text":"Type alias for a time.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.TimeDependence","page":"CTBase API","title":"CTBase.TimeDependence","text":"abstract type TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Times","page":"CTBase API","title":"CTBase.Times","text":"Type alias for a vector of times.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.UnauthorizedCall","page":"CTBase API","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTException\n\nException thrown when a call to a function is not authorized.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VariableConstraint","page":"CTBase API","title":"CTBase.VariableConstraint","text":"struct VariableConstraint\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VariableConstraint returns a VariableConstraint of a function. The function must take 1 argument, v.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\n\nwarning: Warning\nWhen the variable is of dimension 1, consider v as a scalar.\n\nCall\n\nThe call returns the evaluation of the VariableConstraint for given values.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VariableConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.VariableConstraint","text":"Return the value of the VariableConstraint function.\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.VariableDependence","page":"CTBase API","title":"CTBase.VariableDependence","text":"abstract type VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VectorField","page":"CTBase API","title":"CTBase.VectorField","text":"struct VectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VectorField returns a VectorField of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the VectorField for given values.\n\nExamples\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VectorField-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.VectorField","text":"VectorField(\n    f::Function,\n    dependencies::DataType...\n) -> VectorField{Autonomous, Fixed}\n\n\nReturn a VectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.VectorField-Tuple{Function}","page":"CTBase API","title":"CTBase.VectorField","text":"VectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> VectorField{Autonomous, Fixed}\n\n\nReturn a VectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.VectorField-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.VectorField","text":"Return the value of the VectorField.\n\nExamples\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctNumber","page":"CTBase API","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.:⋅-Tuple{Function, Function}","page":"CTBase API","title":"CTBase.:⋅","text":"⋅(X::Function, f::Function) -> Function\n\n\nLie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.:⋅-Tuple{VectorField{Autonomous, <:VariableDependence}, Function}","page":"CTBase API","title":"CTBase.:⋅","text":"⋅(\n    X::VectorField{Autonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#105#107\"\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in autonomous case\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.:⋅-Tuple{VectorField{NonAutonomous, <:VariableDependence}, Function}","page":"CTBase API","title":"CTBase.:⋅","text":"⋅(\n    X::VectorField{NonAutonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#109#111\"\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in nonautonomous case\n\nExample\n\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Tuple{Function, Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::Function,\n    f::Function,\n    dependences::DataType...\n) -> Function\n\n\nLie derivative of a scalar function along a vector field or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, NonAutonomous, NonFixed)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Tuple{Function, Function}","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Function\n\n\nLie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Tuple{VectorField, Function}","page":"CTBase API","title":"CTBase.Lie","text":"Lie(X::VectorField, f::Function) -> Function\n\n\nLie derivative of a scalar function along a vector field.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{Autonomous, V<:VariableDependence},\n    Y::VectorField{Autonomous, V<:VariableDependence}\n) -> VectorField{Autonomous}\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case\n\nExample\n\njulia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{NonAutonomous, V<:VariableDependence},\n    Y::VectorField{NonAutonomous, V<:VariableDependence}\n) -> VectorField{NonAutonomous}\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case\n\nExample\n\njulia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lift-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Lift","text":"Lift(\n    X::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a VectorField or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lift-Tuple{Function}","page":"CTBase API","title":"CTBase.Lift","text":"Lift(X::Function; autonomous, variable) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lift-Tuple{VectorField}","page":"CTBase API","title":"CTBase.Lift","text":"Lift(X::VectorField) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a VectorField.\n\nExample\n\njulia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Model-Tuple{Vararg{DataType}}","page":"CTBase API","title":"CTBase.Model","text":"Model(\n    dependencies::DataType...\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following argument:\n\ndependencies: either Autonomous or NonAutonomous. Default is Autonomous. And either NonFixed or Fixed. Default is Fixed.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(NonAutonomous)\njulia> ocp = Model(Autonomous, NonFixed)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Model-Tuple{}","page":"CTBase API","title":"CTBase.Model","text":"Model(\n;\n    autonomous,\n    variable\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following optional keyword argument:\n\nautonomous: either true or false. Default is true.\nvariable: either true or false. Default is false.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(autonomous=false)\njulia> ocp = Model(autonomous=false, variable=true)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Tuple{Function, Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::Function,\n    dependences::DataType...\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Tuple{Function, Function}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{Autonomous, V}, AbstractHamiltonian{Autonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{Autonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{Autonomous, V<:VariableDependence}\n) -> HamiltonianLift{Autonomous}\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{NonAutonomous, V}, AbstractHamiltonian{NonAutonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{NonAutonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{NonAutonomous, V<:VariableDependence}\n) -> HamiltonianLift{NonAutonomous}\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case\n\nExample\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{AbstractHamiltonian{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence},\n    g::Function\n) -> Hamiltonian\n\n\nPoisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{Function, AbstractHamiltonian{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence}\n) -> Hamiltonian\n\n\nPoisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::HamiltonianLift{T<:TimeDependence, V<:VariableDependence},\n    g::HamiltonianLift{T<:TimeDependence, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","page":"CTBase API","title":"CTBase.add","text":"add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nConcatenate the description y at the tuple of descriptions x if it is not already in the tuple x.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions = add(descriptions, (:b,))\n((:a,), (:b,))\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","page":"CTBase API","title":"CTBase.add","text":"add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint!","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd an :initial or :final value constraint on a range of the state, or a value constraint on a range of the :variable.\n\nnote: Note\nThe range of the constraint must be contained in 1:n if the constraint is on the state, or 1:q if the constraint is on the variable.\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\n\nExamples\n\njulia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0 ])\njulia> constraint!(ocp, :initial, 2:3, [ 0, 0 ])\njulia> constraint!(ocp, :final, Index(2), 0)\njulia> constraint!(ocp, :variable, 2:3, [ 0, 3 ])\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.constraint!-2","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd a :boundary, :control, :state, :mixed or :variable value functional constraint.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\n# variable independent ocp\njulia> constraint!(ocp, :boundary, (x0, xf) -> x0[3]+xf[2], 0)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary, (x0, xf, v) -> x0[3]+xf[2]*v[1], 0)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control, u -> 2u, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control, (u, v) -> 2u*v[1], 1)\njulia> constraint!(ocp, :state, (x, v) -> x-v[2], [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u+v[1], 0)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control, (t, u, v) -> 2u-t*v[2], 1)\njulia> constraint!(ocp, :state, (t, x, v) -> x-t+v[1], [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (t, x, u, v) -> x[1]-u*v[1], 0)\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.constraint!-3","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd an :initial, :final, :control, :state or :variable box constraint (whole range).\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\njulia> constraint!(ocp, :initial, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :final, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :control, [ 0, 0 ], [ 2, 3 ])\njulia> constraint!(ocp, :state, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, 0, 1) # the variable here is of dimension 1\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.constraint!-4","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd an :initial or :final value constraint on the state, or a :variable value. Can also be used with :state and :control.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\njulia> constraint!(ocp, :initial, [ 0, 0 ])\njulia> constraint!(ocp, :final, 2) # if the state is of dimension 1\njulia> constraint!(ocp, :variable, [ 3, 0, 1 ])\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.constraint!-Tuple{OptimalControlModel, Symbol}","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol;\n    rg,\n    f,\n    val,\n    lb,\n    ub,\n    label\n)\n\n\nAdd an :initial, :final, :control, :state or :variable box constraint on a range.\n\nnote: Note\nThe range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable.\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\n\nExamples\n\njulia> constraint!(ocp, :initial, rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :final, val=Index(1), lb=0, ub=2)\njulia> constraint!(ocp, :control, val=Index(1), lb=0, ub=2)\njulia> constraint!(ocp, :state, rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :initial, rg=1:2:5, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, rg=1:2, lb=[ 0, 0 ], ub=[ 1, 2 ])\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint!-Union{Tuple{V}, Tuple{OptimalControlModel{<:TimeDependence, V}, Symbol, Union{Index, OrdinalRange{<:Integer}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}, Tuple{OptimalControlModel{<:TimeDependence, V}, Symbol, Union{Index, OrdinalRange{<:Integer}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Symbol}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel{<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel{<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd an :initial, :final, :control, :state or :variable box constraint on a range.\n\nnote: Note\nThe range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable.\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\n\nExamples\n\njulia> constraint!(ocp, :initial, 2:3, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :final, Index(1), 0, 2)\njulia> constraint!(ocp, :control, Index(1), 0, 2)\njulia> constraint!(ocp, :state, 2:3, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, 1:2, [ 0, 0 ], [ 1, 2 ])\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Symbol}} where {T, V}","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel{T, V},\n    type::Symbol,\n    f::Function,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel{T, V},\n    type::Symbol,\n    f::Function,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd a :boundary, :control, :state, :mixed or :variable box functional constraint.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\n# variable independent ocp\njulia> constraint!(ocp, :boundary, (x0, xf) -> x0[3]+xf[2], 0, 1)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary, (x0, xf, v) -> x0[3]+xf[2]*v[1], 0, 1)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control, u -> 2u, 0, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0, 1)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 0, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0, 1)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control, (u, v) -> 2u*v[1], 0, 1)\njulia> constraint!(ocp, :state, (x, v) -> x-v[1], [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (x, u, v) -> x[1]-v[2]*u, 0, 1)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control, (t, u, v) -> 2u+v[2], 0, 1)\njulia> constraint!(ocp, :state, (t, x, v) -> x-t*v[1], [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (t, x, u, v) -> x[1]*v[2]-u, 0, 1)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.constraint","text":"constraint(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    label::Symbol\n) -> Any\n\n\nRetrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds).\n\nExample\n\njulia> constraint!(ocp, :initial, 0, :c0)\njulia> c = constraint(ocp, :c0)\njulia> c(1)\n1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint_type-NTuple{7, Any}","page":"CTBase API","title":"CTBase.constraint_type","text":"constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n\n\nReturn the type constraint among :initial, :final, :boundary, :control_range, :control_fun, :state_range, :state_fun, :mixed, :variable_range, :variable_fun (:other otherwise), together with the appropriate value (range, updated expression...)\n\nExample\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, Index(1))\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, Index(1))\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, Index(1))\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, Index(1))\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, Index(2))\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n(:variable_fun, :(v ^ 2 + 1))\n\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n(:variable_fun, :(v[2] ^ 2 + 1))\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraints_labels-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.constraints_labels","text":"constraints_labels(\n    ocp::OptimalControlModel\n) -> Base.KeySet{Symbol, Dict{Symbol, Tuple}}\n\n\nReturn the labels of the constraints as a Base.keys.\n\nExample\n\njulia> constraints_labels(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.control!","page":"CTBase API","title":"CTBase.control!","text":"control!(ocp::OptimalControlModel, m::Integer)\ncontrol!(ocp::OptimalControlModel, m::Integer, name::String)\ncontrol!(\n    ocp::OptimalControlModel,\n    m::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the control dimension and possibly the names of each coordinate.\n\nnote: Note\nYou must use control! only once to set the control dimension.\n\nExamples\n\njulia> control!(ocp, 1)\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.ct_repl-Tuple{}","page":"CTBase API","title":"CTBase.ct_repl","text":"ct_repl(; debug, demo) -> Any\n\n\nCreate a ct REPL.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctgradient-Tuple{Function, Any}","page":"CTBase API","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctgradient-Tuple{Function, Real}","page":"CTBase API","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x::Real) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctgradient-Tuple{VectorField, Any}","page":"CTBase API","title":"CTBase.ctgradient","text":"ctgradient(X::VectorField, x) -> Any\n\n\nReturn the gradient of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctindices-Tuple{Integer}","page":"CTBase API","title":"CTBase.ctindices","text":"ctindices(i::Integer) -> String\n\n\nReturn i > 0 as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctinterpolate-Tuple{Any, Any}","page":"CTBase API","title":"CTBase.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn the interpolation of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctjacobian-Tuple{Function, Any}","page":"CTBase API","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctjacobian-Tuple{Function, Real}","page":"CTBase API","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x::Real) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctjacobian-Tuple{VectorField, Any}","page":"CTBase API","title":"CTBase.ctjacobian","text":"ctjacobian(X::VectorField, x) -> Any\n\n\nReturn the Jacobian of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctupperscripts-Tuple{Integer}","page":"CTBase API","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Integer) -> String\n\n\nReturn i > 0 as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.dynamics!","text":"dynamics!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    f::Function\n)\n\n\nSet the dynamics.\n\nnote: Note\nYou can use dynamics! only once to define the dynamics.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> dynamics!(ocp, f)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"CTBase API","title":"CTBase.getFullDescription","text":"getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn a complete description from an incomplete description desc and  a list of complete descriptions desc_list. If several complete descriptions are possible,  then the first one is returned.\n\nExample\n\njulia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n((:a, :b), (:b, :c), (:a, :c))\njulia> getFullDescription((:a,), desc_list)\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.get_priority_print_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","page":"CTBase API","title":"CTBase.get_priority_print_callbacks","text":"get_priority_print_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n\n\nGet the highest priority print callbacks.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.get_priority_stop_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","page":"CTBase API","title":"CTBase.get_priority_stop_callbacks","text":"get_priority_stop_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n\n\nGet the highest priority stop callbacks.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_max-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_max","text":"is_max(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :max.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_min-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_min","text":"is_min(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :min.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_time_dependent-Tuple{OptimalControlModel{NonAutonomous}}","page":"CTBase API","title":"CTBase.is_time_dependent","text":"is_time_dependent(\n    ocp::OptimalControlModel{NonAutonomous}\n) -> Bool\n\n\nReturn true if the model has been defined as time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_time_independent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_time_independent","text":"is_time_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as time independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_variable_dependent-Tuple{OptimalControlModel{<:TimeDependence, NonFixed}}","page":"CTBase API","title":"CTBase.is_variable_dependent","text":"is_variable_dependent(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed}\n) -> Bool\n\n\nReturn true if the model has been defined as variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_variable_independent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_variable_independent","text":"is_variable_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as variable independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.nlp_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.nlp_constraints","text":"nlp_constraints(\n    ocp::OptimalControlModel\n) -> Tuple{Tuple{Vector{Real}, CTBase.var\"#ξ#99\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#η#100\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ψ#101\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ϕ#102\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#θ#103\", Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}\n\n\nReturn a 6-tuple of tuples:\n\n(ξl, ξ, ξu) are control constraints\n(ηl, η, ηu) are state constraints\n(ψl, ψ, ψu) are mixed constraints\n(ϕl, ϕ, ϕu) are boundary constraints\n(θl, θ, θu) are variable constraints\n(ul, uind, uu) are control linear constraints of a subset of indices\n(xl, xind, xu) are state linear constraints of a subset of indices\n(vl, vind, vu) are variable linear constraints of a subset of indices\n\nnote: Note\nThe dimensions of the state and control must be set before calling nlp_constraints.\n\nExample\n\njulia> (ξl, ξ, ξu), (ηl, η, ηu), (ψl, ψ, ψu), (ϕl, ϕ, ϕu), (θl, θ, θu),\n    (ul, uind, uu), (xl, xind, xu), (vl, vind, vu) = nlp_constraints(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function g and f⁰. Type can be :bolza. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> objective!(ocp, :bolza, (x0, xf) -> x0[1] + xf[2], (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function f. Type can be :mayer or :lagrange. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\njulia> objective!(ocp, :mayer, (x0, xf) -> x0[1] + xf[2])\njulia> objective!(ocp, :lagrange, (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\nwarning: Warning\nIf you set twice the objective, only the last one will be taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}","page":"CTBase API","title":"CTBase.remove_constraint!","text":"remove_constraint!(ocp::OptimalControlModel, label::Symbol)\n\n\nRemove a labeled constraint.\n\nExample\n\njulia> remove_constraint!(ocp, :con)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}","page":"CTBase API","title":"CTBase.replace_call","text":"replace_call(e, x::Symbol, t, y) -> Any\n\n\nReplace calls in e of the form (...x...)(t) by (...y...).\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","page":"CTBase API","title":"CTBase.replace_call","text":"replace_call(e, x::Vector{Symbol}, t, y) -> Any\n\n\nReplace calls in e of the form (...x1...x2...)(t) by (...y1...y2...) for all symbols x1, x2... in the vector x.\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.state!","page":"CTBase API","title":"CTBase.state!","text":"state!(ocp::OptimalControlModel, n::Integer)\nstate!(ocp::OptimalControlModel, n::Integer, name::String)\nstate!(\n    ocp::OptimalControlModel,\n    n::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the state dimension and possibly the names of each component.\n\nnote: Note\nYou must use state! only once to set the state dimension.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.time!","page":"CTBase API","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    tf::Real\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    tf::Real,\n    name::String\n)\n\n\nFix final time, initial time is free and given by the variable at the provided index.\n\nExamples\n\njulia> time!(ocp, Index(2), 1, \"t\")\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.time!-2","page":"CTBase API","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    indf::Index\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    indf::Index,\n    name::String\n)\n\n\nInitial and final times are free and given by the variable at the provided indices.\n\nExamples\n\njulia> time!(ocp, Index(2), Index(3), \"t\")\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.time!-3","page":"CTBase API","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    t0::Real,\n    indf::Index\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    t0::Real,\n    indf::Index,\n    name::String\n)\n\n\nFix initial time, final time is free and given by the variable at the provided index.\n\nnote: Note\nYou must use time! only once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, 0, Index(2), \"t\")\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.time!-4","page":"CTBase API","title":"CTBase.time!","text":"time!(ocp::OptimalControlModel, t0::Real, tf::Real)\ntime!(\n    ocp::OptimalControlModel,\n    t0::Real,\n    tf::Real,\n    name::String\n)\n\n\nFix initial and final times to times[1] and times[2], respectively.\n\nExamples\n\njulia> time!(ocp, 0, 1)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, 0, 1, \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, 0, 1, :s)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.time!-5","page":"CTBase API","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real}\n) -> Any\ntime!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real},\n    name::String\n) -> Any\n\n\nFix initial and final times to times[1] and times[2], respectively.\n\nExamples\n\njulia> time!(ocp, [ 0, 1 ])\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, [ 0, 1 ], \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, [ 0, 1 ], :s)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.variable!","page":"CTBase API","title":"CTBase.variable!","text":"variable!(ocp::OptimalControlModel, q::Integer)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String\n)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the variable dimension and possibly the names of each component.\n\nnote: Note\nYou can use variable! once to set the variable dimension when the model is NonFixed.\n\nExamples\n\njulia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"v₁\", \"v₂\" ])\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.∂ₜ-Tuple{Any}","page":"CTBase API","title":"CTBase.∂ₜ","text":"∂ₜ(f) -> CTBase.var\"#114#116\"\n\n\nPartial derivative wrt time of a function.\n\nExample\n\njulia> ∂ₜ((t,x) -> t*x)(0,8)\n8\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#RecipesBase.plot!-Tuple{Plots.Plot, OptimalControlSolution}","page":"CTBase API","title":"RecipesBase.plot!","text":"plot!(\n    p::Plots.Plot,\n    sol::OptimalControlSolution;\n    layout,\n    control,\n    state_style,\n    control_style,\n    costate_style,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot the optimal control solution sol using the layout layout.\n\nNotes.\n\nThe argument layout can be :group or :split (default).\nThe keyword arguments state_style, control_style and costate_style are passed to the plot function of the Plots package. The state_style is passed to the plot of the state, the control_style is passed to the plot of the control and the costate_style is passed to the plot of the costate.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#RecipesBase.plot-Tuple{OptimalControlSolution}","page":"CTBase API","title":"RecipesBase.plot","text":"plot(\n    sol::OptimalControlSolution;\n    layout,\n    state_style,\n    control_style,\n    costate_style,\n    kwargs...\n) -> Any\n\n\nPlot the optimal control solution sol using the layout layout.\n\nNotes.\n\nThe argument layout can be :group or :split (default).\nThe keyword arguments state_style, control_style and costate_style are passed to the plot function of the Plots package. The state_style is passed to the plot of the state, the control_style is passed to the plot of the control and the costate_style is passed to the plot of the costate.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.@Lie-Tuple{Expr}","page":"CTBase API","title":"CTBase.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1,0,7])\n3.0\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase.html#CTBase.@def","page":"CTBase API","title":"CTBase.@def","text":"Define an optimal control problem. One pass parsing of the definition.\n\nExample\n\n@def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend\n\n\n\n\n\n","category":"macro"},{"location":"api-ctdirect.html#CTDirect-API","page":"CTDirect API","title":"CTDirect API","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect API","title":"CTDirect API","text":"This is just a dump of CTDirect API documentation. For more details about CTDirect.jl package, see the documentation.","category":"page"},{"location":"api-ctdirect.html#Index","page":"CTDirect API","title":"Index","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect API","title":"CTDirect API","text":"Pages   = [\"api-ctdirect.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctdirect.html#Documentation","page":"CTDirect API","title":"Documentation","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect API","title":"CTDirect API","text":"Modules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctdirect.html#CTDirect.OptimalControlInit","page":"CTDirect API","title":"CTDirect.OptimalControlInit","text":"Initialization of the optimal control problem solution for the NLP problem.\n\nConstructors:\n\nOptimalControlInit(): default initialization\nOptimalControlInit(x_init, u_init, v_init): constant vector or function handles\nOptimalControlInit(sol): from existing solution\n\nExamples\n\njulia> init = OptimalControlInit()\njulia> init = OptimalControlInit(x_init=[0.1, 0.2], u_init=0.3)\njulia> init = OptimalControlInit(x_init=[0.1, 0.2], u_init=0.3, v_init=0.5)\njulia> init = OptimalControlInit(x_init=[0.1, 0.2], u_init=t->sin(t), v_init=0.5)\njulia> init = OptimalControlInit(sol)\n\n\n\n\n\n","category":"type"},{"location":"api-ctdirect.html#CTDirect.available_methods-Tuple{}","page":"CTDirect API","title":"CTDirect.available_methods","text":"available_methods() -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.is_solvable-Tuple{Any}","page":"CTDirect API","title":"CTDirect.is_solvable","text":"is_solvable(ocp) -> Bool\n\n\nReturn if the optimal control problem ocp is solvable or not by the method solve.\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.solve-Tuple{OptimalControlModel, Vararg{Any}}","page":"CTDirect API","title":"CTDirect.solve","text":"solve(\n    ocp::OptimalControlModel,\n    description...;\n    display,\n    init,\n    grid_size,\n    print_level,\n    mu_strategy,\n    kwargs...\n) -> OptimalControlSolution\n\n\nSolve the the optimal control problem ocp by the method given by the (optional) description. Return an  OptimalControlSolution from CTBase package, that is an approximation of  the optimal solution if the method has converged correctly.\n\nThe (optional) description\n\nYou can pass a partial description. If you give a partial description, then, if several complete descriptions contains the partial one,  then, the method with the highest priority is chosen. The higher in the list, the higher is the priority.\n\nKeyword arguments:\n\ndisplay: print or not information during the resolution\ninit: an initial condition for the solver\ngrid_size: number of time steps for the discretization\nprint_level: print level for the Ipopt solver\nmu_strategy: mu strategy for the Ipopt solver\n\nwarning: Warning\nThere is only one available method for the moment: the direct method transforms the optimal control problem into a nonlinear programming problem (NLP) solved by Ipopt, thanks to the package  ADNLPModels.\n\ntip: Tip\nTo see the list of available methods, simply call available_methods().\nYou can pass any other option by a pair keyword=value according to the chosen method. See for instance, Ipopt options.\nThe default values for the keyword arguments are given here.\n\njulia> solve(ocp)\njulia> solve(ocp, :adnlp)\njulia> solve(ocp, :adnlp, :ipopt)\njulia> solve(ocp, display=false, init=OptimalControlInit(), grid_size=100, print_level=0, mu_strategy=\"adaptive\")\n\n\n\n\n\n","category":"method"},{"location":"tutorial-init.html#Initial-guess","page":"Initial guess","title":"Initial guess","text":"","category":"section"},{"location":"tutorial-init.html","page":"Initial guess","title":"Initial guess","text":"We define the following optimal control problem.","category":"page"},{"location":"tutorial-init.html","page":"Initial guess","title":"Initial guess","text":"using OptimalControl\n\nt0 = 0\ntf = 10\nα  = 5\n\n@def ocp begin\n    t ∈ [ t0, tf ], time\n    v ∈ R, variable\n    x ∈ R², state\n    u ∈ R, control\n    x(t0) == [ -1, 0 ]\n    x(tf) - [ 0, v ] == [0, 0]\n    ẋ(t) == [ x₂(t), x₁(t) + α*x₁(t)^2 + u(t) ]\n    v^2 + ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-init.html","page":"Initial guess","title":"Initial guess","text":"We first solve the problem without giving an initial guess.","category":"page"},{"location":"tutorial-init.html","page":"Initial guess","title":"Initial guess","text":"# solve the optimal control problem without initial guess\nsol = solve(ocp, display=false)\n\n# print the number of iterations \nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-init.html","page":"Initial guess","title":"Initial guess","text":"Let us plot the solution of the optimal control problem.","category":"page"},{"location":"tutorial-init.html","page":"Initial guess","title":"Initial guess","text":"plot(sol, size=(600, 450))","category":"page"},{"location":"tutorial-init.html","page":"Initial guess","title":"Initial guess","text":"To reduce the number of iterations and improve the convergence, we can give an initial guess to the solver. We define the following initial guess.","category":"page"},{"location":"tutorial-init.html","page":"Initial guess","title":"Initial guess","text":"# constant initial guess\ninitial_guess = (state=[-0.2, 0.1], control=-0.2, variable=0.05)\n\n# solve the optimal control problem with initial guess\nsol = solve(ocp, display=false, init=initial_guess)\n\n# print the number of iterations\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-init.html","page":"Initial guess","title":"Initial guess","text":"We can also provide functions of time as initial guess for the state and the control.","category":"page"},{"location":"tutorial-init.html","page":"Initial guess","title":"Initial guess","text":"# initial guess as functions of time\nx(t) = [ -0.2 * t, 0.1 * t ]\nu(t) = -0.2 * t\ninitial_guess = (state=x, control=u, variable=0.05)\n\n# solve the optimal control problem with initial guess\nsol = solve(ocp, display=false, init=initial_guess)\n\n# print the number of iterations\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-init.html","page":"Initial guess","title":"Initial guess","text":"warning: Warning\nFor the moment we can not provide an initial guess for the costate. Besides, there is neither cold nor warm start implemented yet. That is, we can not use the solution of a previous optimal control problem as initial guess.","category":"page"},{"location":"juliacon2023.html","page":"JuliaCon2023","title":"JuliaCon2023","text":"<img width=\"800\" alt=\"juliacon\" src=\"./assets/juliacon.jpg\">","category":"page"},{"location":"juliacon2023.html#Solving-optimal-control-problems-with-Julia","page":"JuliaCon2023","title":"Solving optimal control problems with Julia","text":"","category":"section"},{"location":"juliacon2023.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://scholar.google.com/citations?userpkH4An4AAAAJ-and-hlfr),-[Pierre-Martinon](https://www.linkedin.com/in/pierre-martinon-b4603a17),-[Sophia-Sed](https://iww.inria.fr/sed-sophia)","page":"JuliaCon2023","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"","category":"section"},{"location":"juliacon2023.html","page":"JuliaCon2023","title":"JuliaCon2023","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"page"},{"location":"juliacon2023.html#What-it's-about","page":"JuliaCon2023","title":"What it's about","text":"","category":"section"},{"location":"juliacon2023.html","page":"JuliaCon2023","title":"JuliaCon2023","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"juliacon2023.html","page":"JuliaCon2023","title":"JuliaCon2023","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) to min","category":"page"},{"location":"juliacon2023.html","page":"JuliaCon2023","title":"JuliaCon2023","text":"subject to","category":"page"},{"location":"juliacon2023.html","page":"JuliaCon2023","title":"JuliaCon2023","text":"dotx(t) = f(x(t) u(t))quad t in 0 t_f","category":"page"},{"location":"juliacon2023.html","page":"JuliaCon2023","title":"JuliaCon2023","text":"plus boundary, control and state constraints","category":"page"},{"location":"juliacon2023.html","page":"JuliaCon2023","title":"JuliaCon2023","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"juliacon2023.html#Where-it-comes-from","page":"JuliaCon2023","title":"Where it comes from","text":"","category":"section"},{"location":"juliacon2023.html","page":"JuliaCon2023","title":"JuliaCon2023","text":"BOCOP: the optimal control solver\nHamPath: indirect and Hamiltonian pathfollowing\nCoupling direct and indirect solvers, examples","category":"page"},{"location":"juliacon2023.html#OptimalControl.jl","page":"JuliaCon2023","title":"OptimalControl.jl","text":"","category":"section"},{"location":"juliacon2023.html","page":"JuliaCon2023","title":"JuliaCon2023","text":"Basic example: double integrator\nBasic example: double integrator (cont'ed)\nAdvanced example: Goddard problem","category":"page"},{"location":"juliacon2023.html#Wrap-up","page":"JuliaCon2023","title":"Wrap up","text":"","category":"section"},{"location":"juliacon2023.html","page":"JuliaCon2023","title":"JuliaCon2023","text":"[X] High level modelling of optimal control problems\n[X] Efficient numerical resolution coupling direct and indirect methods\n[X] Collection of examples ","category":"page"},{"location":"juliacon2023.html#Future","page":"JuliaCon2023","title":"Future","text":"","category":"section"},{"location":"juliacon2023.html","page":"JuliaCon2023","title":"JuliaCon2023","text":"ct_repl\nAdditional solvers: direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions!\nCTProblems.jl","category":"page"},{"location":"juliacon2023.html#control-toolbox.org","page":"JuliaCon2023","title":"control-toolbox.org","text":"","category":"section"},{"location":"juliacon2023.html","page":"JuliaCon2023","title":"JuliaCon2023","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"juliacon2023.html","page":"JuliaCon2023","title":"JuliaCon2023","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"juliacon2023.html#Credits-(not-exhaustive!)","page":"JuliaCon2023","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"juliacon2023.html","page":"JuliaCon2023","title":"JuliaCon2023","text":"DifferentialEquations.jl\nJuMP, InfiniteOpt.jl, ADNLPModels.jl\nIpopt\nJuliaDiff (FowardDiff.jl, Zygote.jl)\nMLStyle.jl\nREPLMaker.jl","category":"page"},{"location":"tutorial-flows.html#Flows","page":"Flows","title":"Flows","text":"","category":"section"},{"location":"tutorial-flows.html","page":"Flows","title":"Flows","text":"See the page CTFlows.","category":"page"},{"location":"tutorial-solvers.html#Solvers-and-options","page":"Solvers and options","title":"Solvers and options","text":"","category":"section"},{"location":"tutorial-solvers.html","page":"Solvers and options","title":"Solvers and options","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-solvers.html","page":"Solvers and options","title":"Solvers and options","text":"See solve method.","category":"page"},{"location":"tutorial-plot.html#Plot-a-solution","page":"Plot a solution","title":"Plot a solution","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In this tutorial we explain the different ways to plot a solution from an optimal control problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Let us start by importing the necessary package.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using OptimalControl","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Then, we define a simple optimal control problem and solve it.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"@def ocp begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n    ẋ(t) == [ x₂(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend\n\nsol = solve(ocp, display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html#First-ways-to-plot","page":"Plot a solution","title":"First ways to plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The simplest way to plot the solution is to use the plot function with only the solution as argument.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"As you can see, it produces a grid of subplots. The left column contains the state trajectories, the right column the costate trajectories, and at the bottom we have the control trajectory.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Attributes from Plots.jl can be passed to the plot function:","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In addition to sol you can pass attributes to the full Plot, see the attribute plot documentation from Plots.jl for more details. For instance, you can specify the size of the figure.\nYou can also pass attributes to the subplots, see the attribute subplot documentation from Plots.jl for more details. However, it will affect all the subplots. For instance, you can specify the location of the legend.\nIn the same way, you can pass axis attributes to the subplots, see the attribute axis documentation from Plots.jl for more details. It will also affect all the subplots. For instance, you can remove the grid.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, size=(700, 450), legend=:bottomright, grid=false)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To specify series attributes to a specific subplot, you can use the optional keyword arguments state_style, costate_style and control_style which correspond respectively to the state, costate and control trajectories. See the attribute series documentation from Plots.jl for more details. For instance, you can specify the color of the state trajectories and more.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, \n    state_style=(color=:blue,), \n    costate_style=(color=:black, linestyle=:dash),\n    control_style=(color=:red, linewidth=2))","category":"page"},{"location":"tutorial-plot.html#Split-versus-group-layout","page":"Plot a solution","title":"Split versus group layout","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"If you prefer to get a more compact figure, you can use the layout optional keyword argument with :group value. It will group the state, costate and control trajectories in one subplot each.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, layout=:group, size=(700, 300))","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Default layout value\nThe default layout value is :split which corresponds to the grid of subplots presented above.","category":"page"},{"location":"tutorial-plot.html#Additional-plots","page":"Plot a solution","title":"Additional plots","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can plot the solution of a second optimal control problem on the same figure if it has the same number of states, costates and controls. For instance, consider the same optimal control problem but with a different initial condition.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"@def ocp begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [ -0.5, -0.5 ]\n    x(1) == [ 0, 0 ]\n    ẋ(t) == [ x₂(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend\nsol2 = solve(ocp, display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We first plot the solution of the first optimal control problem. Then, we plot the solution of the second optimal control problem on the same figure, but with dashed lines.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"# first plot\nplt = plot(sol, size=(700, 450))\n# second plot\nstyle = (linestyle=:dash, )\nplot!(plt, sol2, state_style=style, costate_style=style, control_style=style)","category":"page"},{"location":"tutorial-plot.html#Plot-the-norm-of-the-control","page":"Plot a solution","title":"Plot the norm of the control","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"For some problem, it is interesting to plot the norm of the control. You can do it by using the control optional keyword argument with :norm value. The default value is :components. Let us illustrate this on the consumption minimisation orbital transfer problem from CTProlbems.jl.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using CTProblems\nprob = Problem(:orbital_transfert, :consumption)\nsol  = prob.solution\nplot(sol, control=:norm, size=(800, 300), layout=:group)","category":"page"},{"location":"tutorial-plot.html#Custom-plot","page":"Plot a solution","title":"Custom plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can of course create your own plots by getting the state, costate and control from the optimal control solution. For instance, let us plot the norm of the control for the orbital transfer problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using LinearAlgebra\nt = sol.times\nx = sol.state\np = sol.costate\nu = sol.control\nplot(t, norm∘u, label=\"‖u‖\") ","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Note\nThe norm function is from LinearAlgebra.jl. The ∘ operator is the composition operator. Hence, norm∘u is equivalent to t -> norm(u(t)). The sol.state, sol.costate and sol.control are functions that return the state, costate and control trajectories at a given time.","category":"page"},{"location":"tutorial-double-integrator.html#double-int","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"","category":"section"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"The problem consists in minimising the final time t_f for the double integrator system","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) quad u(t) in -11","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"and the limit conditions","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"    x(0) = (12) quad x(t_f) = (00)","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"This problem can be interpretated as a simple model for a wagon with constant mass moving along a line without fricton.","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"First, we need to import the OptimalControl.jl package:","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"using OptimalControl","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"Then, we can define the problem","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"@def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"note: Nota bene\nIn order to ensure convergence of the direct solver, we have added the state constraints labelled (1) and (2):","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"0 leq q(t) leq 5quad -2 leq v(t) leq 3quad t in  0 tf ","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"Solve it","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"and plot the solution","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"plot(sol, size=(600, 450))","category":"page"},{"location":"api-ctproblems.html#CTProblems-API","page":"CTProblems API","title":"CTProblems API","text":"","category":"section"},{"location":"api-ctproblems.html","page":"CTProblems API","title":"CTProblems API","text":"This is just a dump of CTProblems API documentation. For more details about CTProblems.jl package, see the documentation.","category":"page"},{"location":"api-ctproblems.html#Index","page":"CTProblems API","title":"Index","text":"","category":"section"},{"location":"api-ctproblems.html","page":"CTProblems API","title":"CTProblems API","text":"Pages   = [\"api-ctproblems.md\"]\nModules = [CTProblems]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctproblems.html#Documentation","page":"CTProblems API","title":"Documentation","text":"","category":"section"},{"location":"api-ctproblems.html","page":"CTProblems API","title":"CTProblems API","text":"Modules = [CTProblems]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctproblems.html#CTProblems.CTProblems","page":"CTProblems API","title":"CTProblems.CTProblems","text":"CTProblems module.\n\nLists all the imported modules and packages:\n\nBase\nCTBase\nCTFlows\nCore\nDocStringExtensions\nForwardDiff\nLinearAlgebra\nMINPACK\nOrdinaryDiffEq\n\nList of all the exported names:\n\nProblem\n@Problems\nProblems\n@ProblemsDescriptions\nProblemsDescriptions\nplot\n\n\n\n\n\n","category":"module"},{"location":"api-ctproblems.html#CTProblems.Problem-Tuple{Vararg{Symbol}}","page":"CTProblems API","title":"CTProblems.Problem","text":"Problem(\n    description::Symbol...\n) -> CTProblems.OptimalControlProblem\n\n\nReturn the optimal control problem described by description.\n\nIf you give a partial description, then, if several complete descriptions contains the partial one, then,  only the problem with the highest priority is returned. The higher in the list, the higher is the priority.\n\nExample\n\njulia> Problem(:integrator, :energy)\n\n\n\n\n\n","category":"method"},{"location":"api-ctproblems.html#CTProblems.Problems-Tuple{Vararg{Symbol}}","page":"CTProblems API","title":"CTProblems.Problems","text":"Problems(\n    description::Symbol...\n) -> Tuple{Vararg{CTProblems.OptimalControlProblem}}\n\n\nReturn the list of optimal control problems consistent with the description.\n\nIf you give a partial description, then, if several complete descriptions contains the partial one, then,  only the problem with the highest priority is returned. The higher in the list, the higher is the priority.\n\nExample\n\njulia> Problems(:integrator, :energy)\n\n\n\n\n\n","category":"method"},{"location":"api-ctproblems.html#CTProblems.ProblemsDescriptions-Tuple{Vararg{Symbol}}","page":"CTProblems API","title":"CTProblems.ProblemsDescriptions","text":"ProblemsDescriptions(\n    description::Symbol...\n) -> Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n\n\nReturn the list of problems descriptions consistent with the description, as a Tuple of Description. \n\nExample\n\njulia> ProblemsDescriptions(:integrator, :energy)\n\n\n\n\n\n","category":"method"},{"location":"api-ctproblems.html#CTProblems.@Problems","page":"CTProblems API","title":"CTProblems.@Problems","text":"Return the list of problems consistent with the description.\n\nExample\n\njulia> @Problems :integrator & :energy\n\nnote: Note\nYou have to define a logical condition with the combination of symbols and the three  operators: !, | and &, respectively for the negation, the disjunction and the conjunction.\n\n\n\n\n\n","category":"macro"},{"location":"api-ctproblems.html#CTProblems.@ProblemsDescriptions","page":"CTProblems API","title":"CTProblems.@ProblemsDescriptions","text":"Return the list of problems descriptions consistent with the expression.\n\nExample\n\njulia> @ProblemsDescriptions :integrator & :energy\n\nnote: Note\nYou have to define a logical condition with the combination of symbols and the three  operators: !, | and &, respectively for the negation, the disjunction and the conjunction.\n\n\n\n\n\n","category":"macro"},{"location":"api.html#OptimalControl-API","page":"API","title":"OptimalControl API","text":"","category":"section"},{"location":"api.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Pages   = [\"api.md\"]\nModules = [OptimalControl]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api.html#Available-methods","page":"API","title":"Available methods","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"using OptimalControl\navailable_methods()","category":"page"},{"location":"api.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [OptimalControl]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api.html#OptimalControl.OptimalControl","page":"API","title":"OptimalControl.OptimalControl","text":"OptimalControl module.\n\nLists all the imported modules and packages:\n\nBase\nCTBase\nCTDirect\nCTFlows\nCTProblems\nCore\nDocStringExtensions\n\nList of all the exported names:\n\n*\nAutonomous\nControlConstraint\nControlLaw\nFeedbackControl\nFixed\nFlow\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\nIndex\n@Lie\nLie\nLift\nMixedConstraint\nModel\nMultiplier\nNonAutonomous\nNonFixed\nParsingError\nPoisson\nProblem\n@Problems\nProblems\n@ProblemsDescriptions\nProblemsDescriptions\nStateConstraint\nVectorField\navailable_methods\nconstraint\nconstraint!\ncontrol!\nct_repl\n@def\ndynamics!\nis_max\nis_min\nis_time_dependent\nis_time_independent\nis_variable_dependent\nis_variable_independent\nobjective!\nplot\nplot!\nremove_constraint!\nsolve\nstate!\ntime!\nvariable!\n∂ₜ\n⋅\n\n\n\n\n\n","category":"module"},{"location":"api.html#OptimalControl.available_methods-Tuple{}","page":"API","title":"OptimalControl.available_methods","text":"available_methods() -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api.html#OptimalControl.solve-Tuple{OptimalControlModel, Vararg{Symbol}}","page":"API","title":"OptimalControl.solve","text":"solve(\n    ocp::OptimalControlModel,\n    description::Symbol...;\n    display,\n    init,\n    kwargs...\n) -> Union{Nothing, OptimalControlSolution}\n\n\nSolve the the optimal control problem ocp by the method given by the (optional) description.\n\nThe (optional) description\n\nYou can pass a partial description. If you give a partial description, then, if several complete descriptions contains the partial one,  then, the method with the highest priority is chosen. The higher in the list,  the higher is the priority.\n\nKeyword arguments:\n\ndisplay: print or not information during the resolution\ninit: an initial condition for the solver\n\nwarning: Warning\nThere is only one available method for the moment: a direct method which transforms the optimal control problem into a nonlinear programming problem (NLP) solved by Ipopt, thanks to the package  ADNLPModels. The direct method comes from the  CTDirect package.\n\ntip: Tip\nTo see the list of available methods, simply call available_methods().\nYou can pass any other option by a pair keyword=value according to the chosen method.\n\nExamples\n\njulia> sol = solve(ocp)\njulia> sol = solve(ocp, :direct)\njulia> sol = solve(ocp, :direct, :ipopt)\njulia> sol = solve(ocp, :direct, :ipopt, display=false)\njulia> sol = solve(ocp, :direct, :ipopt, display=false, init=sol)\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2],))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5, variable=[1, 2]))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=t->6-12*t))\njulia> sol = solve(ocp, init=(state=t->[-1+t, t*(t-1)], control=0.5))\njulia> sol = solve(ocp, init=(state=t->[-1+t, t*(t-1)], control=t->6-12*t))\n\n\n\n\n\n","category":"method"},{"location":"api-ctflows.html#CTFlows-API","page":"CTFlows API","title":"CTFlows API","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows API","title":"CTFlows API","text":"This is just a dump of CTFlows API documentation. For more details about CTFlows.jl package, see the documentation.","category":"page"},{"location":"api-ctflows.html#Index","page":"CTFlows API","title":"Index","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows API","title":"CTFlows API","text":"Pages   = [\"api-ctflows.md\"]\nModules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctflows.html#Documentation","page":"CTFlows API","title":"Documentation","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows API","title":"CTFlows API","text":"Modules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctflows.html#CTFlows.Flow-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Union{ControlLaw{T, V}, FeedbackControl{T, V}, Function}, Union{MixedConstraint{T, V}, StateConstraint{T, V}, Function}, Union{Multiplier{T, V}, Function}}} where {T, V}","page":"CTFlows API","title":"CTFlows.Flow","text":"Flow(\n    ocp::OptimalControlModel{T, V},\n    u_::Union{ControlLaw{T, V}, FeedbackControl{T, V}, Function},\n    g_::Union{MixedConstraint{T, V}, StateConstraint{T, V}, Function},\n    μ_::Union{Multiplier{T, V}, Function};\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    kwargs_Flow...\n) -> CTFlows.OptimalControlFlow\n\n\nFlow from an optimal control problem, a control function in feedback form, a state constraint and its  associated multiplier in feedback form.\n\nExample\n\njulia> ocp = Model(autonomous=false)\njulia> f = Flow(ocp, (t, x, p) -> p[1], (t, x, u) -> x[1] - 1, (t, x, p) -> x[1]+p[1])\n\nwarning: Warning\nThe time dependence of the control function must be consistent with the time dependence of the optimal control problem. The dimension of the output of the control function must be consistent with the dimension usage of the control of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api-ctflows.html#CTFlows.Flow-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Union{ControlLaw{T, V}, Function}}} where {T, V}","page":"CTFlows API","title":"CTFlows.Flow","text":"Flow(\n    ocp::OptimalControlModel{T, V},\n    u_::Union{ControlLaw{T, V}, Function};\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    kwargs_Flow...\n) -> CTFlows.OptimalControlFlow\n\n\nFlow from an optimal control problem and a control function in feedback form.\n\nExample\n\njulia> f = Flow(ocp, (x, p) -> p)\n\nwarning: Warning\nThe time dependence of the control function must be consistent with the time dependence of the optimal control problem. The dimension of the output of the control function must be consistent with the dimension usage of the control of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"tutorial-goddard.html#goddard","page":"Advanced example","title":"Advanced example","text":"","category":"section"},{"location":"tutorial-goddard.html#Introduction","page":"Advanced example","title":"Introduction","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"<img src=\"./assets/Goddard_and_Rocket.jpg\" style=\"float: left; margin: auto 10px;\" width=\"200px\">","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"For this advanced example, we consider the well-known Goddard problem[1] [2] which models the ascent of a rocket through the atmosphere, and we restrict here ourselves to vertical (one dimensional) trajectories. The state variables are the altitude r, speed v and mass m of the rocket during the flight, for a total dimension of 3. The rocket is subject to gravity g, thrust u and drag force D (function of speed and altitude). The final time t_f is free, and the objective is to reach a maximal altitude with a bounded fuel consumption.","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"We thus want to solve the optimal control problem in Mayer form","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"    r(t_f) to max","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"subject to the controlled dynamics","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"    dotr = v quad\n    dotv = fracT_maxu - D(rv)m - g quad\n    dotm = -u","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"and subject to the control constraint u(t) in 01 and the state constraint v(t) leq v_max. The initial state is fixed while only the final mass is prescribed.","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"note: Note\nThe Hamiltonian is affine with respect to the control, so singular arcs may occur, as well as constrained arcs due to the path constraint on the velocity (see below).","category":"page"},{"location":"tutorial-goddard.html#Direct-method","page":"Advanced example","title":"Direct method","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"using Plots\nusing Plots.PlotMeasures\nplot(args...; kwargs...) = Plots.plot(args...; kwargs..., leftmargin=25px)\nusing Suppressor # to suppress warnings","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"We import the OptimalControl.jl package:","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"using OptimalControl","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"We define the problem","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"t0 = 0      # initial time\nr0 = 1      # initial altitude\nv0 = 0      # initial speed\nm0 = 1      # initial mass\nvmax = 0.1  # maximal authorized speed\nmf = 0.6    # final mass to target\n\n@def ocp begin # definition of the optimal control problem\n\n    tf, variable\n    t ∈ [ t0, tf ], time\n    x ∈ R³, state\n    u ∈ R, control\n\n    r = x₁\n    v = x₂\n    m = x₃\n\n    x(t0) == [ r0, v0, m0 ]\n    m(tf) == mf,         (1)\n    0 ≤ u(t) ≤ 1\n    r(t) ≥ r0\n    0 ≤ v(t) ≤ vmax\n\n    ẋ(t) == F0(x(t)) + u(t) * F1(x(t))\n\n    r(tf) → max\n\nend;\n\n# Dynamics\nconst Cd = 310\nconst Tmax = 3.5\nconst β = 500\nconst b = 2\n\nF0(x) = begin\n    r, v, m = x\n    D = Cd * v^2 * exp(-β*(r - 1)) # Drag force\n    return [ v, -D/m - 1/r^2, 0 ]\nend\n\nF1(x) = begin\n    r, v, m = x\n    return [ 0, Tmax/m, -b*Tmax ]\nend\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"We then solve it","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"direct_sol = solve(ocp, grid_size=100)\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"and plot the solution","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"plt = plot(direct_sol, size=(600, 600))","category":"page"},{"location":"tutorial-goddard.html#Indirect-method","page":"Advanced example","title":"Indirect method","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"We first determine visually the structure of the optimal solution which is composed of a bang arc with maximal control, followed by a singular arc, then by a boundary arc and the final arc is with zero control. Note that the switching function vanishes along the singular and boundary arcs.","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"t = direct_sol.times\nx = direct_sol.state\nu = direct_sol.control\np = direct_sol.costate\n\nH1 = Lift(F1)           # H1(x, p) = p' * F1(x)\nφ(t) = H1(x(t), p(t))   # switching function\ng(x) = vmax - x[2]      # state constraint v ≤ vmax\n\nu_plot  = plot(t, u,     label = \"u(t)\")\nH1_plot = plot(t, φ,     label = \"H₁(x(t), p(t))\")\ng_plot  = plot(t, g ∘ x, label = \"g(x(t))\")\n\nplot(u_plot, H1_plot, g_plot, layout=(3,1), size=(600,450))","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"We are now in position to solve the problem by an indirect shooting method. We first define the four control laws in feedback form and their associated flows. For this we need to compute some Lie derivatives, namely Poisson brackets of Hamiltonians (themselves obtained as lifts to the cotangent bundle of vector fields), or derivatives of functions along a vector field. For instance, the control along the minimal order singular arcs is obtained as the quotient","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"u_s = -fracH_001H_101","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"of length three Poisson brackets:","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"H_001 = H_0H_0H_1 quad H_101 = H_1H_0H_1","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"where, for two Hamiltonians H and G,","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"HG = (nabla_p Hnabla_x G) - (nabla_x Hnabla_p G)","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"While the Lie derivative of a function f wrt. a vector field X is simply obtained as","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"(X cdot f)(x) = f(x) cdot X(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"and is used to the compute the control along the boundary arc,","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"u_b(x) = -(F_0 cdot g)(x)  (F_1 cdot g)(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"as well as the associated multiplier for the order one state constraint on the velocity:","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"mu(x p) = H_01(x p)  (F_1 cdot g)(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"note: Note\nThe Poisson bracket HG is also given by the Lie derivative of G along the Hamiltonian vector field X_H = (nabla_p H -nabla_x H) of H, that is    HG = X_H cdot Gwhich is the reason why we use the @Lie macro to compute Poisson brackets below.","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"With the help of the differential geometry primitives from CTBase.jl, these expressions are straightforwardly translated into Julia code:","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"# Controls\nu0 = 0                                  # off control\nu1 = 1                                  # bang control\n\nH0 = Lift(F0)                           # H0(x, p) = p' * F0(x)\nH01  = @Lie { H0, H1 }\nH001 = @Lie { H0, H01 }\nH101 = @Lie { H1, H01 }\nus(x, p) = -H001(x, p) / H101(x, p)     # singular control\n\nub(x) = -(F0⋅g)(x) / (F1⋅g)(x)          # boundary control\nμ(x, p) = H01(x, p) / (F1⋅g)(x)         # multiplier associated to the state constraint g\n\n# Flows\nf0 = Flow(ocp, (x, p, tf) -> u0)\nf1 = Flow(ocp, (x, p, tf) -> u1)\nfs = Flow(ocp, (x, p, tf) -> us(x, p))\nfb = Flow(ocp, (x, p, tf) -> ub(x), (x, u, tf) -> g(x), (x, p, tf) -> μ(x, p))\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"Then, we define the shooting function according to the optimal structure we have determined, that is a concatenation of four arcs.","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"x0 = [ r0, v0, m0 ] # initial state\n\nfunction shoot!(s, p0, t1, t2, t3, tf)\n\n    x1, p1 = f1(t0, x0, p0, t1)\n    x2, p2 = fs(t1, x1, p1, t2)\n    x3, p3 = fb(t2, x2, p2, t3)\n    xf, pf = f0(t3, x3, p3, tf)\n\n    s[1] = constraint(ocp, :eq1)(x0, xf, tf) - mf # final mass constraint (1)\n    s[2:3] = pf[1:2] - [ 1, 0 ]                   # transversality conditions\n    s[4] = H1(x1, p1)                             # H1 = H01 = 0\n    s[5] = H01(x1, p1)                            # at the entrance of the singular arc\n    s[6] = g(x2)                                  # g = 0 when entering the boundary arc\n    s[7] = H0(xf, pf)                             # since tf is free\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"To solve the problem by an indirect shooting method, we then need a good initial guess, that is a good approximation of the initial costate, the three switching times and the final time.","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"η = 1e-3\nt13 = t[ abs.(φ.(t)) .≤ η ]\nt23 = t[ 0 .≤ (g ∘ x).(t) .≤ η ]\np0 = p(t0)\nt1 = min(t13...)\nt2 = min(t23...)\nt3 = max(t23...)\ntf = t[end]\n\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\nusing LinearAlgebra: norm\ns = similar(p0, 7)\n@suppress_err begin # hide\nshoot!(s, p0, t1, t2, t3, tf)\nend # hide\nprintln(\"Norm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"Finally, we can solve the shooting equations thanks to the MINPACK solver.","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"using MINPACK                                               # NLE solver\n\nnle = (s, ξ) -> shoot!(s, ξ[1:3], ξ[4], ξ[5], ξ[6], ξ[7])   # auxiliary function\n                                                            # with aggregated inputs\nξ = [ p0 ; t1 ; t2 ; t3 ; tf ]                              # initial guess\nindirect_sol = @suppress_err begin # hide\nfsolve(nle, ξ)\nend # hide\n\n# we retrieve the costate solution together with the times\np0 = indirect_sol.x[1:3]\nt1 = indirect_sol.x[4]\nt2 = indirect_sol.x[5]\nt3 = indirect_sol.x[6]\ntf = indirect_sol.x[7]\n\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\ns = similar(p0, 7)\n@suppress_err begin # hide\nshoot!(s, p0, t1, t2, t3, tf)\nend # hide\nprintln(\"Norm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"We plot the solution of the indirect solution (in red) over the solution of the direct method (in blue).","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"f = f1 * (t1, fs) * (t2, fb) * (t3, f0) # concatenation of the flows\nflow_sol = f((t0, tf), x0, p0)          # compute the solution: state, costate, control...\n\nplot!(plt, flow_sol)","category":"page"},{"location":"tutorial-goddard.html#References","page":"Advanced example","title":"References","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"[1]: R.H. Goddard. A Method of Reaching Extreme Altitudes, volume 71(2) of Smithsonian Miscellaneous Collections. Smithsonian institution, City of Washington, 1919.","category":"page"},{"location":"tutorial-goddard.html","page":"Advanced example","title":"Advanced example","text":"[2]: H. Seywald and E.M. Cliff. Goddard problem in presence of a dynamic pressure limit. Journal of Guidance, Control, and Dynamics, 16(4):776–781, 1993.","category":"page"},{"location":"tutorial-model.html#Modelling","page":"Modelling","title":"Modelling","text":"","category":"section"},{"location":"tutorial-model.html","page":"Modelling","title":"Modelling","text":"See OptimalControlModel type.","category":"page"},{"location":"tutorial-basic-example-f.html#basic-f","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"","category":"section"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force u. We denote by x = (x_1 x_2) the state of the wagon, that is its position x_1 and its velocity x_2.","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"We assume that the mass is constant and unitary and that there is no friction. The dynamics is thus given by","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) in mathbbR","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"which is simply the double integrator system. Les us consider a transfer starting at time t_0 = 0 and ending at time t_f = 1, for which we want to minimise the transfer energy","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"    frac12int_0^1 u^2(t)  mathrmdt","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"starting from the condition x(0) = (-1 0) and with the goal to reach the target x(1) = (0 0).","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"note: Solution and details\nSee the page  Double integrator: energy minimisation  for the analytical solution and details about this problem.","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"using Plots\nusing Plots.PlotMeasures\nplot(args...; kwargs...) = Plots.plot(args...; kwargs..., leftmargin=25px)","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"First, we need to import the OptimalControl.jl package:","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"using OptimalControl","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"Then, we can define the problem","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"ocp = Model()\n\ntime!(ocp, [ 0, 1 ])\nstate!(ocp, 2)\ncontrol!(ocp, 1)\n\nconstraint!(ocp, :initial, [ -1, 0 ])\nconstraint!(ocp, :final,   [  0, 0 ])\n\ndynamics!(ocp, (x, u) -> [ x[2], u ])\n\nobjective!(ocp, :lagrange, (x, u) -> 0.5u^2)\nnothing # hide","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"Solve it","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"and plot the solution","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"plot(sol, size=(600, 450))","category":"page"},{"location":"index.html#OptimalControl.jl","page":"Introduction","title":"OptimalControl.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The OptimalControl.jl package aims to provide tools to solve optimal control problems by direct and indirect methods. It is part of the control-toolbox ecosystem:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"<img src=\"./assets/diagram.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"320px\">","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Install and documentation\nTo install a package from the control-toolbox ecosystem,  please visit the installation page. The documentation is accessible from the main menu.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"An optimal control problem with fixed initial and final times can be described as minimising the cost functional","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"g(x(t_0) x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and other constraints such as","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"See our tutorials to get started solving optimal control problems:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Basic example: a simple smooth optimal control problem solved by the direct method.\nDouble integrator: the classical double integrator, minimum time. \nAdvanced example: the Goddard problem solved by direct and indirect methods.","category":"page"}]
}
