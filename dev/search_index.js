var documenterSearchIndex = {"docs":
[{"location":"api-ctbase/init.html#api-ctbase-init","page":"Initial guess","title":"Initial guess","text":"","category":"section"},{"location":"api-ctbase/init.html","page":"Initial guess","title":"Initial guess","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/init.html#Index","page":"Initial guess","title":"Index","text":"","category":"section"},{"location":"api-ctbase/init.html","page":"Initial guess","title":"Initial guess","text":"Pages   = [\"init.md\"]\nModules = [CTBase]\nOrder   = [:type, :module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/init.html#Documentation","page":"Initial guess","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/init.html","page":"Initial guess","title":"Initial guess","text":"Modules = [CTBase]\nOrder   = [:type, :module, :constant, :function, :macro]\nPages   = [\"init.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/init.html#CTBase.OptimalControlInit","page":"Initial guess","title":"CTBase.OptimalControlInit","text":"Initial guess for OCP, contains\n\nfunctions of time for the state and control variables\nvector for optimization variables\n\nInitialization data for each field can be left to default or: \n\nvector for optimization variables\nconstant / vector / function for state and control  \nexisting solution ('warm start') for all fields\n\nConstructors:\n\nOptimalControlInit(): default initialization\nOptimalControlInit(state, control, variable, time): constant vector, function handles and / or matrices / vectors interpolated along given time grid\nOptimalControlInit(sol): from existing solution\n\nExamples\n\njulia> init = OptimalControlInit()\njulia> init = OptimalControlInit(state=[0.1, 0.2], control=0.3)\njulia> init = OptimalControlInit(state=[0.1, 0.2], control=0.3, variable=0.5)\njulia> init = OptimalControlInit(state=[0.1, 0.2], controlt=t->sin(t), variable=0.5)\njulia> init = OptimalControlInit(state=[[0, 0], [1, 2], [5, -1]], time=[0, .3, 1.], controlt=t->sin(t))\njulia> init = OptimalControlInit(sol)\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/init.html","page":"Initial guess","title":"Initial guess","text":"","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<img width=\"800\" alt=\"juliaopt2024\" src=\"./assets/juliacon2024.jpg\">","category":"page"},{"location":"juliacon2024.html#Trajectory-optimisation-in-space-mechanics-with-Julia","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"","category":"section"},{"location":"juliacon2024.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Alesia-Herasimenka](https://www.uni.lu/snt-en/people/alesia-herasimenka)","page":"Trajectory optimisation in space mechanics with Julia","title":"Jean-Baptiste Caillau, Olivier Cots, Alesia Herasimenka","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil-lux.jpg\">","category":"page"},{"location":"juliacon2024.html#What-it's-about","page":"Trajectory optimisation in space mechanics with Julia","title":"What it's about","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"subject to","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"plus boundary, control and state constraints","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"juliacon2024.html#OptimalControl.jl-for-trajectory-optimisation","page":"Trajectory optimisation in space mechanics with Julia","title":"OptimalControl.jl for trajectory optimisation","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Basic example\nGoddard problem\nOrbit transfer","category":"page"},{"location":"juliacon2024.html#Wrap-up","page":"Trajectory optimisation in space mechanics with Julia","title":"Wrap up","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"High level modelling of optimal control problems\nEfficient numerical resolution coupling direct and indirect methods\nCollection of examples","category":"page"},{"location":"juliacon2024.html#Future","page":"Trajectory optimisation in space mechanics with Julia","title":"Future","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"New applications (biology, space mechanics, quantum mechanics and more)\nAdditional solvers: direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions!","category":"page"},{"location":"juliacon2024.html#control-toolbox.org","page":"Trajectory optimisation in space mechanics with Julia","title":"control-toolbox.org","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"juliacon2024.html#Credits-(not-exhaustive!)","page":"Trajectory optimisation in space mechanics with Julia","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nMLStyle.jl","category":"page"},{"location":"juliacon2024.html#Acknowledgements","page":"Trajectory optimisation in space mechanics with Julia","title":"Acknowledgements","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Jean-Baptiste Caillau is partially funded by a France 2030 support managed by the Agence Nationale de la Recherche, under the reference ANR-23-PEIA-0004 (PDE-AI project).","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<img width=\"200\" alt=\"affiliations\" src=\"./assets/france-2030.png\">","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"","category":"page"},{"location":"tutorial-lqr-basic.html#A-simple-Linear–quadratic-regulator-example","page":"Linear–quadratic regulator","title":"A simple Linear–quadratic regulator example","text":"","category":"section"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"We consider the following Linear Quadratic Regulator (LQR) problem which consists in minimising","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"    frac12 int_0^t_f left( x_1^2(t) + x_2^2(t) + u^2(t) right)  mathrmdt ","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"subject to the constraints","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = -x_1(t) + u(t) quad u(t) in R","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"and the initial condition","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"    x(0) = (01)","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"We aim to solve this optimal control problem for different values of t_f. First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"Then, we can define the problem parameterized by the final time tf.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"x0 = [ 0\n       1 ]\n\nfunction lqr(tf)\n\n    ocp = @def begin\n        t ∈ [0, tf], time\n        x ∈ R², state\n        u ∈ R, control\n        x(0) == x0\n        ẋ(t) == [x₂(t), - x₁(t) + u(t)]\n        ∫( 0.5(x₁(t)^2 + x₂(t)^2 + u(t)^2) ) → min\n    end\n\n    return ocp\nend;\nnothing # hide","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"We solve the problem for t_f in 3 5 30.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"solutions = []   # empty list of solutions\ntfs = [3, 5, 30]\n\nfor tf ∈ tfs\n    solution = solve(lqr(tf), display=false)\n    push!(solutions, solution)\nend\nnothing # hide","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"We plot the state and control variables considering a normalized time s=(t-t_0)(t_f-t_0), thanks to the keyword argument time=:normalized of the plot function.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"plt = plot(solutions[1], time=:normalized)\nfor sol ∈ solutions[2:end]\n    plot!(plt, sol, time=:normalized)\nend\n\n# we plot only the state and control variables and we add the legend\nN = length(tfs)\npx1 = plot(plt[1], legend=false, xlabel=\"s\", ylabel=\"x₁\")\npx2 = plot(plt[2], label=reshape([\"tf = $tf\" for tf ∈ tfs], (1, N)), xlabel=\"s\", ylabel=\"x₂\")\npu  = plot(plt[5], legend=false, xlabel=\"s\", ylabel=\"u\")\n\nusing Plots.PlotMeasures # for leftmargin, bottommargin\nplot(px1, px2, pu, layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"note: Nota bene\nWe can observe that x(t_f) converges to the origin as t_f increases.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"","category":"page"},{"location":"tutorial-iss.html#iss","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"In this tutorial we present the indirect simple shooting method on a simple example.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us start by importing the necessary packages.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using OptimalControl    # to define the optimal control problem and its flow\nusing OrdinaryDiffEq    # to get the Flow function from OptimalControl\nusing NonlinearSolve    # interface to NLE solvers\nusing MINPACK           # NLE solver: use to solve the shooting equation\nusing Plots             # to plot the solution","category":"page"},{"location":"tutorial-iss.html#Optimal-control-problem","page":"Indirect simple shooting","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us consider the following optimal control problem:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"left \n    beginarrayl\n        min displaystyle frac12 int_t_0^t_f u^2(t)  mathrmd t10em\n        dotx(t)  =  displaystyle -x(t)+alpha x^2(t)+u(t) quad  u(t) in R \n        quad t in t_0 t_f text ae 05em\n        x(t_0) = x_0 quad x(t_f) = x_f\n    endarray\nright","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"with t_0 = 0, t_f = 1, x_0 = -1, x_f = 0, alpha=15 and forall t in t_0 t_f, x(t) in R.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"t0 = 0\ntf = 1\nx0 = -1\nxf = 0\nα  = 1.5\nocp = @def begin\n\n    t ∈ [t0, tf], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == xf\n\n    ẋ(t) == -x(t) + α * x(t)^2 + u(t)\n\n    ∫( 0.5u(t)^2 ) → min\n    \nend;\nnothing # hide","category":"page"},{"location":"tutorial-iss.html#Boundary-value-problem","page":"Indirect simple shooting","title":"Boundary value problem","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"The pseudo-Hamiltonian of this problem is","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    H(xpu) = p  (-x+alpha x^2+u) + p^0 u^2 2","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"where p^0 = -1 since we are in the normal case. From the Pontryagin Maximum Principle, the maximising control is given by","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"u(x p) = p","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"since partial^2_uu H = p^0 = - 1  0. Plugging this control in feedback form into the pseudo-Hamiltonian, and considering the limit conditions, we obtain the following two-points boundary value problem (BVP).","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    left \n        beginarrayl\n            dotx(t)  = phantom- nabla_p Ht = -x(t) + alpha x^2(t) + u(x(t) p(t)) \n            = -x(t) + alpha x^2(t) + p(t) 05em\n            dotp(t)  = -           nabla_x Ht = (1 - 2 alpha x(t)) p(t)    05em\n            x(t_0)        = x_0 quad x(t_f) = x_f\n        endarray\n    right","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"where t=  (x(t)p(t)u(x(t) p(t))).","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"note: Our goal\nOur goal is to solve this (BVP). Solving (BVP) consists in solving the Pontryagin Maximum Principle which provides necessary conditions of optimality.","category":"page"},{"location":"tutorial-iss.html#Shooting-function","page":"Indirect simple shooting","title":"Shooting function","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"To achive our goal, let us first introduce the pseudo-Hamiltonian vector field","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    vecH(zu) = left( nabla_p H(zu) -nabla_x H(zu) right) quad z = (xp)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"and then denote by varphi_t_0 x_0 p_0(cdot) the solution of the following Cauchy problem","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"dotz(t) = vecH(z(t) u(z(t))) quad z(t_0) = (x_0 p_0)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Our goal becomes to solve","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"pi( varphi_t_0 x_0 p_0(t_f) ) = x_f","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"where pi(x p) = x. To compute varphi with OptimalControl.jl package, we define the flow of the associated Hamiltonian vector field by:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"u(x, p) = p\nφ = Flow(ocp, u)\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We define also the projection function on the state space.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"π((x, p)) = x\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"note: Nota bene\nActually, varphi_t_0 x_0 p_0(cdot) is also solution of    dotz(t) = vecmathbfH(z(t)) quad z(t_0) = (x_0 p_0)where mathbfH(z) = H(z u(z)) and vecmathbfH = (nabla_p mathbfH -nabla_x mathbfH). This is what is actually computed by Flow.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Now, to solve the (BVP) we introduce the shooting function:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    beginarrayrlll\n        S colon     R     longrightarrow    R \n                     p_0     longmapsto      S(p_0) = pi( varphi_t_0 x_0 p_0(t_f) ) - x_f\n    endarray","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"S(p0) = π( φ(t0, x0, p0, tf) ) - xf    # shooting function\nnothing # hide","category":"page"},{"location":"tutorial-iss.html#Resolution-of-the-shooting-equation","page":"Indirect simple shooting","title":"Resolution of the shooting equation","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"At the end, solving (BVP) is equivalent to solve S(p_0) = 0. This is what we call the  indirect simple shooting method. We define an initial guess.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"ξ = [ 0.1 ]    # initial guess\nnothing # hide","category":"page"},{"location":"tutorial-iss.html#NonlinearSolve.jl","page":"Indirect simple shooting","title":"NonlinearSolve.jl","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We first use the NonlinearSolve.jl package to solve the shooting equation. Let us define the problem.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"nle! = (s, ξ, λ) -> s[1] = S(ξ[1])    # auxiliary function\nprob = NonlinearProblem(nle!, ξ)      # NLE problem with initial guess\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us do some benchmarking.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using BenchmarkTools\n@benchmark solve(prob; show_trace=Val(false))","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"For small nonlinear systems, it could be faster to use the  SimpleNewtonRaphson() descent algorithm.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"@benchmark solve(prob, SimpleNewtonRaphson(); show_trace=Val(false))","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Now, let us solve the problem and retrieve the initial costate solution.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"indirect_sol = solve(prob; show_trace=Val(true))      # resolution of S(p0) = 0  \np0_sol = indirect_sol.u[1]                            # costate solution\nprintln(\"\\ncostate:    p0 = \", p0_sol)\nprintln(\"shoot: |S(p0)| = \", abs(S(p0_sol)), \"\\n\")","category":"page"},{"location":"tutorial-iss.html#MINPACK.jl","page":"Indirect simple shooting","title":"MINPACK.jl","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using MINPACK\nfunction fsolve(f, j, x; kwargs...)\n    try\n        MINPACK.fsolve(f, j, x; kwargs...)\n    catch e\n        println(\"Erreur using MINPACK\")\n        println(e)\n        println(\"hybrj not supported. Replaced by hybrd even if it is not visible on the doc.\")\n        MINPACK.fsolve(f, x; kwargs...)\n    end\nend","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Instead of the NonlinearSolve.jl package we can use the  MINPACK.jl package to solve  the shooting equation. To compute the Jacobian of the shooting function we use the  DifferentiationInterface.jl package with  ForwardDiff.jl backend.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using DifferentiationInterface\nimport ForwardDiff\nbackend = AutoForwardDiff()\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us define the problem to solve.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"nle!  = ( s, ξ) -> s[1] = S(ξ[1])                                 # auxiliary function\njnle! = (js, ξ) -> jacobian!(nle!, similar(ξ), js, backend, ξ)    # Jacobian of nle\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We are now in position to solve the problem with the hybrj solver from MINPACK.jl through the fsolve  function, providing the Jacobian. Let us do some benchmarking.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"@benchmark fsolve(nle!, jnle!, ξ; show_trace=false)    # initial guess given to the solver","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We can also use the preparation step of DifferentiationInterface.jl.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"extras = prepare_jacobian(nle!, similar(ξ), backend, ξ)\njnle_prepared!(js, ξ) = jacobian!(nle!, similar(ξ), js, backend, ξ, extras)\n@benchmark fsolve(nle!, jnle_prepared!, ξ; show_trace=false)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Now, let us solve the problem and retrieve the initial costate solution.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"indirect_sol = fsolve(nle!, jnle!, ξ; show_trace=true)    # resolution of S(p0) = 0\np0_sol = indirect_sol.x[1]                                # costate solution\nprintln(\"\\ncostate:    p0 = \", p0_sol)\nprintln(\"shoot: |S(p0)| = \", abs(S(p0_sol)), \"\\n\")","category":"page"},{"location":"tutorial-iss.html#Plot-of-the-solution","page":"Indirect simple shooting","title":"Plot of the solution","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"The solution can be plot calling first the flow.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"sol = φ((t0, tf), x0, p0_sol)\nplot(sol)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"In the indirect shooting method, the research of the optimal control is replaced by the computation of its associated extremal. This computation is equivalent to finding the initial covector solution to the shooting function. Let us plot the extremal in the phase space and the shooting function with  the solution.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"<article class=\"docstring\">\n<header>\n    <a class=\"docstring-article-toggle-button fa-solid fa-chevron-right\" href=\"javascript:;\" title=\"Expand docstring\"> </a>\n    <code>pretty_plot</code> — <span class=\"docstring-category\">Function</span>\n</header>\n<section style=\"display: none;\"><div><pre><code class=\"language-julia hljs\">using Plots.PlotMeasures\n\nexp(p0; saveat=[]) = φ((t0, tf), x0, p0, saveat=saveat)\n\nfunction pretty_plot(S, p0; Np0=20, kwargs...)\n\n    times = range(t0, tf, length=2)\n    p0_min = -0.5\n    p0_max = 2\n    p0_sol = p0\n\n    # plot of the flow in phase space\n    plt_flow = plot()\n    p0s = range(p0_min, p0_max, length=Np0)\n    for i ∈ eachindex(p0s)\n        sol = exp(p0s[i])\n        x = [state(sol)(t)   for t ∈ time_grid(sol)]\n        p = [costate(sol)(t) for t ∈ time_grid(sol)]\n        label = i==1 ? \"extremals\" : false\n        plot!(plt_flow, x, p, color=:blue, label=label)\n    end\n\n    # plot of wavefronts in phase space\n    p0s = range(p0_min, p0_max, length=200)\n    xs  = zeros(length(p0s), length(times))\n    ps  = zeros(length(p0s), length(times))\n    for i ∈ eachindex(p0s)\n        sol = exp(p0s[i], saveat=times)\n        xs[i, :] .= state(sol).(times)\n        ps[i, :] .= costate(sol).(times)\n    end\n    for j ∈ eachindex(times)\n        label = j==1 ? \"flow at times\" : false\n        plot!(plt_flow, xs[:, j], ps[:, j], color=:green, linewidth=2, label=label)\n    end\n\n    # \n    plot!(plt_flow, xlims=(-1.1, 1), ylims=(p0_min, p0_max))\n    plot!(plt_flow, [0, 0], [p0_min, p0_max], color=:black, xlabel=\"x\", ylabel=\"p\", label=\"x=xf\")\n    \n    # solution\n    sol = exp(p0_sol)\n    x = [state(sol)(t)   for t ∈ time_grid(sol)]\n    p = [costate(sol)(t) for t ∈ time_grid(sol)]\n    plot!(plt_flow, x, p, color=:red, linewidth=2, label=\"extremal solution\")\n    plot!(plt_flow, [x[end]], [p[end]], seriestype=:scatter, color=:green, label=false)\n\n    # plot of the shooting function \n    p0s = range(p0_min, p0_max, length=200)\n    plt_shoot = plot(xlims=(p0_min, p0_max), ylims=(-2, 4), xlabel=\"p₀\", ylabel=\"y\")\n    plot!(plt_shoot, p0s, S, linewidth=2, label=\"S(p₀)\", color=:green)\n    plot!(plt_shoot, [p0_min, p0_max], [0, 0], color=:black, label=\"y=0\")\n    plot!(plt_shoot, [p0_sol, p0_sol], [-2, 0], color=:black, label=\"p₀ solution\", linestyle=:dash)\n    plot!(plt_shoot, [p0_sol], [0], seriestype=:scatter, color=:green, label=false)\n\n    # final plot\n    plot(plt_flow, plt_shoot; layout=(1,2), leftmargin=15px, bottommargin=15px, kwargs...)\n\nend</code><button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code ;opblock\" title=\"Copy\"></button></pre></div>\n</section>\n</article>","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using Plots.PlotMeasures # hide\nexp(p0; saveat=[]) = φ((t0, tf), x0, p0, saveat=saveat) # hide\n # hide\nfunction pretty_plot(S, p0; Np0=20, kwargs...) # hide\n # hide\n    times = range(t0, tf, length=2) # hide\n    p0_min = -0.5 # hide\n    p0_max = 2 # hide\n    p0_sol = p0 # hide\n # hide\n    # plot of the flow in phase space # hide\n    plt_flow = plot() # hide\n    p0s = range(p0_min, p0_max, length=Np0) # hide\n    for i ∈ eachindex(p0s) # hide\n        sol = exp(p0s[i]) # hide\n        x = [state(sol)(t)   for t ∈ time_grid(sol)] # hide\n        p = [costate(sol)(t) for t ∈ time_grid(sol)] # hide\n        label = i==1 ? \"extremals\" : false # hide\n        plot!(plt_flow, x, p, color=:blue, label=label) # hide\n    end # hide\n # hide\n    # plot of wavefronts in phase space # hide\n    p0s = range(p0_min, p0_max, length=200) # hide\n    xs  = zeros(length(p0s), length(times)) # hide\n    ps  = zeros(length(p0s), length(times)) # hide\n    for i ∈ eachindex(p0s) # hide\n        sol = exp(p0s[i], saveat=times) # hide\n        xs[i, :] .= state(sol).(times) # hide\n        ps[i, :] .= costate(sol).(times) # hide\n    end # hide\n    for j ∈ eachindex(times) # hide\n        label = j==1 ? \"flow at times\" : false # hide\n        plot!(plt_flow, xs[:, j], ps[:, j], color=:green, linewidth=2, label=label) # hide\n    end # hide\n # hide\n    #  # hide\n    plot!(plt_flow, xlims=(-1.1, 1), ylims=(p0_min, p0_max)) # hide\n    plot!(plt_flow, [0, 0], [p0_min, p0_max], color=:black, xlabel=\"x\", ylabel=\"p\", label=\"x=xf\") # hide\n     # hide\n    # solution # hide\n    sol = exp(p0_sol) # hide\n    x = [state(sol)(t)   for t ∈ time_grid(sol)] # hide\n    p = [costate(sol)(t) for t ∈ time_grid(sol)] # hide\n    plot!(plt_flow, x, p, color=:red, linewidth=2, label=\"extremal solution\") # hide\n    plot!(plt_flow, [x[end]], [p[end]], seriestype=:scatter, color=:green, label=false) # hide\n # hide\n    # plot of the shooting function  # hide\n    p0s = range(p0_min, p0_max, length=200) # hide\n    plt_shoot = plot(xlims=(p0_min, p0_max), ylims=(-2, 4), xlabel=\"p₀\", ylabel=\"y\") # hide\n    plot!(plt_shoot, p0s, S, linewidth=2, label=\"S(p₀)\", color=:green) # hide\n    plot!(plt_shoot, [p0_min, p0_max], [0, 0], color=:black, label=\"y=0\") # hide\n    plot!(plt_shoot, [p0_sol, p0_sol], [-2, 0], color=:black, label=\"p₀ solution\", linestyle=:dash) # hide\n    plot!(plt_shoot, [p0_sol], [0], seriestype=:scatter, color=:green, label=false) # hide\n # hide\n    # final plot # hide\n    plot(plt_flow, plt_shoot; layout=(1,2), leftmargin=15px, bottommargin=15px, kwargs...) # hide\n # hide\nend # hide\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"pretty_plot(S, p0_sol; size=(800, 450))","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"","category":"page"},{"location":"api-ctbase/solution.html#api-ctbase-solution","page":"Solution","title":"Solution","text":"","category":"section"},{"location":"api-ctbase/solution.html","page":"Solution","title":"Solution","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/solution.html","page":"Solution","title":"Solution","text":"Pages   = [\"solution.md\"]","category":"page"},{"location":"api-ctbase/solution.html#Optimal-control-solution-type","page":"Solution","title":"Optimal control solution type","text":"","category":"section"},{"location":"api-ctbase/solution.html","page":"Solution","title":"Solution","text":"Modules = [CTBase]\nOrder   = [:type, :module, :constant, :function, :macro]\nPages   = [\"optimal_control_solution-type.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/solution.html#CTBase.OptimalControlSolution","page":"Solution","title":"CTBase.OptimalControlSolution","text":"mutable struct OptimalControlSolution <: CTBase.AbstractOptimalControlSolution\n\nType of an optimal control solution.\n\nFields\n\ntime_grid::Union{Nothing, StepRangeLen, AbstractVector{<:Real}}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Int64}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\ncontrol::Union{Nothing, Function}: Default: nothing\nstate_dimension::Union{Nothing, Int64}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nstate::Union{Nothing, Function}: Default: nothing\nvariable_dimension::Union{Nothing, Int64}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nvariable::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\ncostate::Union{Nothing, Function}: Default: nothing\nobjective::Union{Nothing, Real}: Default: nothing\niterations::Union{Nothing, Int64}: Default: nothing\nstopping::Union{Nothing, Symbol}: Default: nothing\nmessage::Union{Nothing, String}: Default: nothing\nsuccess::Union{Nothing, Bool}: Default: nothing\ninfos::Dict{Symbol, Any}: Default: Dict{Symbol, Any}()\nboundary_constraints::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\nmult_boundary_constraints::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\nvariable_constraints::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\nmult_variable_constraints::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\nmult_variable_box_lower::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\nmult_variable_box_upper::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\ncontrol_constraints::Union{Nothing, Function}: Default: nothing\nmult_control_constraints::Union{Nothing, Function}: Default: nothing\nstate_constraints::Union{Nothing, Function}: Default: nothing\nmult_state_constraints::Union{Nothing, Function}: Default: nothing\nmixed_constraints::Union{Nothing, Function}: Default: nothing\nmult_mixed_constraints::Union{Nothing, Function}: Default: nothing\nmult_state_box_lower::Union{Nothing, Function}: Default: nothing\nmult_state_box_upper::Union{Nothing, Function}: Default: nothing\nmult_control_box_lower::Union{Nothing, Function}: Default: nothing\nmult_control_box_upper::Union{Nothing, Function}: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/solution.html#Getters","page":"Solution","title":"Getters","text":"","category":"section"},{"location":"api-ctbase/solution.html","page":"Solution","title":"Solution","text":"Modules = [CTBase]\nOrder   = [:type, :module, :constant, :function, :macro]\nPages   = [\"optimal_control_solution-getters.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/solution.html#CTBase.boundary_constraints-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.boundary_constraints","text":"boundary_constraints(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Real, AbstractVector{<:Real}}\n\n\nReturn the boundary constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.control-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.control","text":"control(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Function}\n\n\nReturn the control (function of time) of the optimal control solution or nothing.\n\njulia> t0 = time_grid(sol)[1]\njulia> u  = control(sol)\njulia> u0 = u(t0) # control at initial time\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.control_components_names-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.control_components_names","text":"control_components_names(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Vector{String}}\n\n\nReturn the names of the components of the control of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.control_constraints-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.control_constraints","text":"control_constraints(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Function}\n\n\nReturn the control constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.control_dimension-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.control_dimension","text":"control_dimension(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Int64}\n\n\nReturn the dimension of the control of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.control_discretized-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.control_discretized","text":"control_discretized(sol::OptimalControlSolution) -> Any\n\n\nReturn the control values at times time_grid(sol) of the optimal control solution or nothing.\n\njulia> u  = control_discretized(sol)\njulia> u0 = u[1] # control at initial time\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.control_name-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.control_name","text":"control_name(\n    sol::OptimalControlSolution\n) -> Union{Nothing, String}\n\n\nReturn the name of the control of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.costate-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.costate","text":"costate(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Function}\n\n\nReturn the costate of the optimal control solution or nothing.\n\njulia> t0 = time_grid(sol)[1]\njulia> p  = costate(sol)\njulia> p0 = p(t0)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.costate_discretized-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.costate_discretized","text":"costate_discretized(sol::OptimalControlSolution) -> Any\n\n\nReturn the costate values at times time_grid(sol) of the optimal control solution or nothing.\n\njulia> p  = costate_discretized(sol)\njulia> p0 = p[1] # costate at initial time\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.final_time_name-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.final_time_name","text":"final_time_name(\n    sol::OptimalControlSolution\n) -> Union{Nothing, String}\n\n\nReturn the name of final time of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.infos-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.infos","text":"infos(sol::OptimalControlSolution) -> Dict{Symbol, Any}\n\n\nReturn a dictionary of additional infos depending on the solver or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.initial_time_name-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.initial_time_name","text":"initial_time_name(\n    sol::OptimalControlSolution\n) -> Union{Nothing, String}\n\n\nReturn the name of the initial time of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.iterations-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.iterations","text":"iterations(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Int64}\n\n\nReturn the number of iterations (if solved by an iterative method) of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.message-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.message","text":"message(\n    sol::OptimalControlSolution\n) -> Union{Nothing, String}\n\n\nReturn the message associated to the stopping criterion of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mixed_constraints-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.mixed_constraints","text":"mixed_constraints(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Function}\n\n\nReturn the mixed state-control constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_boundary_constraints-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.mult_boundary_constraints","text":"mult_boundary_constraints(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Real, AbstractVector{<:Real}}\n\n\nReturn the multipliers to the boundary constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_control_box_lower-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.mult_control_box_lower","text":"mult_control_box_lower(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Function}\n\n\nReturn the multipliers to the control lower bounds of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_control_box_upper-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.mult_control_box_upper","text":"mult_control_box_upper(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Function}\n\n\nReturn the multipliers to the control upper bounds of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_control_constraints-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.mult_control_constraints","text":"mult_control_constraints(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Function}\n\n\nReturn the multipliers to the control constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_mixed_constraints-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.mult_mixed_constraints","text":"mult_mixed_constraints(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Function}\n\n\nReturn the multipliers to the mixed state-control constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_state_box_lower-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.mult_state_box_lower","text":"mult_state_box_lower(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Function}\n\n\nReturn the multipliers to the state lower bounds of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_state_box_upper-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.mult_state_box_upper","text":"mult_state_box_upper(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Function}\n\n\nReturn the multipliers to the state upper bounds of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_state_constraints-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.mult_state_constraints","text":"mult_state_constraints(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Function}\n\n\nReturn the multipliers to the state constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_variable_box_lower-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.mult_variable_box_lower","text":"mult_variable_box_lower(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Real, AbstractVector{<:Real}}\n\n\nReturn the multipliers to the variable lower bounds of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_variable_box_upper-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.mult_variable_box_upper","text":"mult_variable_box_upper(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Real, AbstractVector{<:Real}}\n\n\nReturn the multipliers to the variable upper bounds of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_variable_constraints-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.mult_variable_constraints","text":"mult_variable_constraints(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Real, AbstractVector{<:Real}}\n\n\nReturn the multipliers to the variable constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.objective-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.objective","text":"objective(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Real}\n\n\nReturn the objective value of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.state-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.state","text":"state(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Function}\n\n\nReturn the state (function of time) of the optimal control solution or nothing.\n\njulia> t0 = time_grid(sol)[1]\njulia> x  = state(sol)\njulia> x0 = x(t0)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.state_components_names-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.state_components_names","text":"state_components_names(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Vector{String}}\n\n\nReturn the names of the components of the state of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.state_constraints-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.state_constraints","text":"state_constraints(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Function}\n\n\nReturn the state constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.state_dimension-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.state_dimension","text":"state_dimension(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Int64}\n\n\nReturn the dimension of the state of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.state_discretized-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.state_discretized","text":"state_discretized(sol::OptimalControlSolution) -> Any\n\n\nReturn the state values at times time_grid(sol) of the optimal control solution or nothing.\n\njulia> x  = state_discretized(sol)\njulia> x0 = x[1] # state at initial time\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.state_name-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.state_name","text":"state_name(\n    sol::OptimalControlSolution\n) -> Union{Nothing, String}\n\n\nReturn the name of the state of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.stopping-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.stopping","text":"stopping(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Symbol}\n\n\nReturn the stopping criterion (a Symbol) of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.success-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.success","text":"success(sol::OptimalControlSolution) -> Union{Nothing, Bool}\n\n\nReturn the true if the solver has finished successfully of false if not, or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.time_grid-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.time_grid","text":"time_grid(\n    sol::OptimalControlSolution\n) -> Union{Nothing, StepRangeLen, AbstractVector{<:Real}}\n\n\nReturn the time grid of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.time_name-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.time_name","text":"time_name(\n    sol::OptimalControlSolution\n) -> Union{Nothing, String}\n\n\nReturn the name of the time component of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.variable-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.variable","text":"variable(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Real, AbstractVector{<:Real}}\n\n\nReturn the variable of the optimal control solution or nothing.\n\njulia> v  = variable(sol)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.variable_components_names-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.variable_components_names","text":"variable_components_names(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Vector{String}}\n\n\nReturn the names of the components of the variable of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.variable_constraints-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.variable_constraints","text":"variable_constraints(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Real, AbstractVector{<:Real}}\n\n\nReturn the variable constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.variable_dimension-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.variable_dimension","text":"variable_dimension(\n    sol::OptimalControlSolution\n) -> Union{Nothing, Int64}\n\n\nReturn the dimension of the variable of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.variable_name-Tuple{OptimalControlSolution}","page":"Solution","title":"CTBase.variable_name","text":"variable_name(\n    sol::OptimalControlSolution\n) -> Union{Nothing, String}\n\n\nReturn the name of the variable of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#Constructors-and-setters","page":"Solution","title":"Constructors and setters","text":"","category":"section"},{"location":"api-ctbase/solution.html","page":"Solution","title":"Solution","text":"Modules = [CTBase]\nOrder   = [:type, :module, :constant, :function, :macro]\nPages   = [\"optimal_control_solution-setters.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/solution.html#CTBase.OptimalControlSolution-Tuple{OptimalControlModel, Vararg{Any, 5}}","page":"Solution","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(\n    ocp::OptimalControlModel,\n    T,\n    X,\n    U,\n    v,\n    P;\n    objective,\n    iterations,\n    constraints_violation,\n    message,\n    stopping,\n    success,\n    constraints_types,\n    constraints_mult,\n    box_multipliers\n) -> OptimalControlSolution\n\n\nBuild OCP functional solution from discrete solution (given as raw variables and multipliers plus some optional infos)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.OptimalControlSolution-Tuple{OptimalControlModel{<:TimeDependence, Fixed}}","page":"Solution","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(\n    ocp::OptimalControlModel{<:TimeDependence, Fixed};\n    state,\n    control,\n    objective,\n    variable,\n    costate,\n    time_grid,\n    iterations,\n    stopping,\n    message,\n    success,\n    infos,\n    boundary_constraints,\n    mult_boundary_constraints,\n    variable_constraints,\n    mult_variable_constraints,\n    mult_variable_box_lower,\n    mult_variable_box_upper,\n    control_constraints,\n    mult_control_constraints,\n    state_constraints,\n    mult_state_constraints,\n    mixed_constraints,\n    mult_mixed_constraints,\n    mult_state_box_lower,\n    mult_state_box_upper,\n    mult_control_box_lower,\n    mult_control_box_upper\n)\n\n\nConstructor from an optimal control problem for a Fixed ocp.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.OptimalControlSolution-Tuple{OptimalControlModel{<:TimeDependence, NonFixed}}","page":"Solution","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed};\n    state,\n    control,\n    objective,\n    variable,\n    costate,\n    time_grid,\n    iterations,\n    stopping,\n    message,\n    success,\n    infos,\n    boundary_constraints,\n    mult_boundary_constraints,\n    variable_constraints,\n    mult_variable_constraints,\n    mult_variable_box_lower,\n    mult_variable_box_upper,\n    control_constraints,\n    mult_control_constraints,\n    state_constraints,\n    mult_state_constraints,\n    mixed_constraints,\n    mult_mixed_constraints,\n    mult_state_box_lower,\n    mult_state_box_upper,\n    mult_control_box_lower,\n    mult_control_box_upper\n)\n\n\nConstructor from an optimal control problem for a NonFixed ocp.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.boundary_constraints!-Tuple{OptimalControlSolution, Union{Real, AbstractVector{<:Real}}}","page":"Solution","title":"CTBase.boundary_constraints!","text":"boundary_constraints!(\n    sol::OptimalControlSolution,\n    boundary_constraints::Union{Real, AbstractVector{<:Real}}\n)\n\n\nSet the boundary constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.control_constraints!-Tuple{OptimalControlSolution, Function}","page":"Solution","title":"CTBase.control_constraints!","text":"control_constraints!(\n    sol::OptimalControlSolution,\n    control_constraints::Function\n)\n\n\nSet the control constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.costate!-Tuple{OptimalControlSolution, Function}","page":"Solution","title":"CTBase.costate!","text":"costate!(sol::OptimalControlSolution, costate::Function)\n\n\nSet the costate.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.infos!-Tuple{OptimalControlSolution, Dict{Symbol, Any}}","page":"Solution","title":"CTBase.infos!","text":"infos!(\n    sol::OptimalControlSolution,\n    infos::Dict{Symbol, Any}\n)\n\n\nSet the additional infos.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.iterations!-Tuple{OptimalControlSolution, Int64}","page":"Solution","title":"CTBase.iterations!","text":"iterations!(sol::OptimalControlSolution, iterations::Int64)\n\n\nSet the number of iterations.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.message!-Tuple{OptimalControlSolution, String}","page":"Solution","title":"CTBase.message!","text":"message!(sol::OptimalControlSolution, message::String)\n\n\nSet the message of stopping.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mixed_constraints!-Tuple{OptimalControlSolution, Function}","page":"Solution","title":"CTBase.mixed_constraints!","text":"mixed_constraints!(\n    sol::OptimalControlSolution,\n    mixed_constraints::Function\n)\n\n\nSet the mixed state/control constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_boundary_constraints!-Tuple{OptimalControlSolution, Union{Real, AbstractVector{<:Real}}}","page":"Solution","title":"CTBase.mult_boundary_constraints!","text":"mult_boundary_constraints!(\n    sol::OptimalControlSolution,\n    mult_boundary_constraints::Union{Real, AbstractVector{<:Real}}\n)\n\n\nSet the multipliers to the boundary constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_control_box_lower!-Tuple{OptimalControlSolution, Function}","page":"Solution","title":"CTBase.mult_control_box_lower!","text":"mult_control_box_lower!(\n    sol::OptimalControlSolution,\n    mult_control_box_lower::Function\n)\n\n\nSet the multipliers to the control lower bounds.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_control_box_upper!-Tuple{OptimalControlSolution, Function}","page":"Solution","title":"CTBase.mult_control_box_upper!","text":"mult_control_box_upper!(\n    sol::OptimalControlSolution,\n    mult_control_box_upper::Function\n)\n\n\nSet the multipliers to the control upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_control_constraints!-Tuple{OptimalControlSolution, Function}","page":"Solution","title":"CTBase.mult_control_constraints!","text":"mult_control_constraints!(\n    sol::OptimalControlSolution,\n    mult_control_constraints::Function\n)\n\n\nSet the multipliers to the control constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_mixed_constraints!-Tuple{OptimalControlSolution, Function}","page":"Solution","title":"CTBase.mult_mixed_constraints!","text":"mult_mixed_constraints!(\n    sol::OptimalControlSolution,\n    mult_mixed_constraints::Function\n)\n\n\nSet the multipliers to the mixed state/control constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_state_box_lower!-Tuple{OptimalControlSolution, Function}","page":"Solution","title":"CTBase.mult_state_box_lower!","text":"mult_state_box_lower!(\n    sol::OptimalControlSolution,\n    mult_state_box_lower::Function\n)\n\n\nSet the multipliers to the state lower bounds.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_state_box_upper!-Tuple{OptimalControlSolution, Function}","page":"Solution","title":"CTBase.mult_state_box_upper!","text":"mult_state_box_upper!(\n    sol::OptimalControlSolution,\n    mult_state_box_upper::Function\n)\n\n\nSet the multipliers to the state upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_state_constraints!-Tuple{OptimalControlSolution, Function}","page":"Solution","title":"CTBase.mult_state_constraints!","text":"mult_state_constraints!(\n    sol::OptimalControlSolution,\n    mult_state_constraints::Function\n)\n\n\nSet the multipliers to the state constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_variable_box_lower!-Tuple{OptimalControlSolution, Union{Real, AbstractVector{<:Real}}}","page":"Solution","title":"CTBase.mult_variable_box_lower!","text":"mult_variable_box_lower!(\n    sol::OptimalControlSolution,\n    mult_variable_box_lower::Union{Real, AbstractVector{<:Real}}\n)\n\n\nSet the multipliers to the variable lower bounds.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_variable_box_upper!-Tuple{OptimalControlSolution, Union{Real, AbstractVector{<:Real}}}","page":"Solution","title":"CTBase.mult_variable_box_upper!","text":"mult_variable_box_upper!(\n    sol::OptimalControlSolution,\n    mult_variable_box_upper::Union{Real, AbstractVector{<:Real}}\n)\n\n\nSet the multipliers to the variable upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.mult_variable_constraints!-Tuple{OptimalControlSolution, Union{Real, AbstractVector{<:Real}}}","page":"Solution","title":"CTBase.mult_variable_constraints!","text":"mult_variable_constraints!(\n    sol::OptimalControlSolution,\n    mult_variable_constraints::Union{Real, AbstractVector{<:Real}}\n)\n\n\nSet the multipliers to the variable constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.state_constraints!-Tuple{OptimalControlSolution, Function}","page":"Solution","title":"CTBase.state_constraints!","text":"state_constraints!(\n    sol::OptimalControlSolution,\n    state_constraints::Function\n)\n\n\nSet the state constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.stopping!-Tuple{OptimalControlSolution, Symbol}","page":"Solution","title":"CTBase.stopping!","text":"stopping!(sol::OptimalControlSolution, stopping::Symbol)\n\n\nSet the stopping criterion.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.success!-Tuple{OptimalControlSolution, Bool}","page":"Solution","title":"CTBase.success!","text":"success!(sol::OptimalControlSolution, success::Bool)\n\n\nSet the success.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.time_grid!-Tuple{OptimalControlSolution, Union{StepRangeLen, AbstractVector{<:Real}}}","page":"Solution","title":"CTBase.time_grid!","text":"time_grid!(\n    sol::OptimalControlSolution,\n    time_grid::Union{StepRangeLen, AbstractVector{<:Real}}\n)\n\n\nSet the time grid.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html#CTBase.variable_constraints!-Tuple{OptimalControlSolution, Union{Real, AbstractVector{<:Real}}}","page":"Solution","title":"CTBase.variable_constraints!","text":"variable_constraints!(\n    sol::OptimalControlSolution,\n    variable_constraints::Union{Real, AbstractVector{<:Real}}\n)\n\n\nSet the variable constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/solution.html","page":"Solution","title":"Solution","text":"","category":"page"},{"location":"dev-optimalcontrol.html#dev-optimalcontrol","page":"OptimalControl.jl","title":"OptimalControl.jl private functions","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-optimalcontrol.html#Index","page":"OptimalControl.jl","title":"Index","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Pages   = [\"dev-optimalcontrol.md\"]\nModules = [OptimalControl]\nOrder   = [:type, :module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-optimalcontrol.html#Documentation","page":"OptimalControl.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Modules = [OptimalControl]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-optimalcontrol.html#OptimalControl.clean-Tuple{Tuple{Vararg{Symbol}}}","page":"OptimalControl.jl","title":"OptimalControl.clean","text":"clean(d::Tuple{Vararg{Symbol}}) -> Tuple{Vararg{Symbol}}\n\n\nWhen calling the function solve, the user can provide a description of the method to use to solve the optimal control problem. The description can be a partial description or a full description. The function solve will find the best match from the available methods, thanks to the function getFullDescription. Then, the description is cleaned by the function clean to remove the Symbols that are specific to  OptimalControl.jl and so must not be passed to the solver. For instance, the Symbol :direct is specific to OptimalControl.jl and must be removed. It must not be passed to the CTDirect.jl solver.\n\n\n\n\n\n","category":"method"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"","category":"page"},{"location":"tutorial-abstract.html#tutorial-abstract","page":"Abstract syntax","title":"The abstract syntax to define an optimal control problem","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The full grammar of OptimalControl.jl small Domain Specific Language is given below. The idea is to use a syntax that is","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"pure Julia (and, as such, effortlessly analysed by the standard Julia parser),\nas close as possible to the mathematical description of an optimal control problem. ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"While the syntax will be transparent to those users familiar with Julia expressions (Expr's), we provide examples for every case that should be widely understandable. We rely heavily on MLStyle.jl and its pattern matching abilities 👍🏽 for the semantic pass. Abstract definitions use the macro @def.","category":"page"},{"location":"tutorial-abstract.html#variable","page":"Abstract syntax","title":"Variable","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $v ∈ R^$q, variable ) \n:( $v ∈ R   , variable ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"A variable (only one is allowed) is a finite dimensional vector or reals that will be optimised along with state and control values. To define an (almost empty!) optimal control problem, named ocp, having a dimension two variable named v, do the following:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"using OptimalControl #hide\n@def begin\n    v ∈ R², variable\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Aliases v₁, v₂ (and v1, v2) are automatically defined and can be used in subsequent expressions instead of v[1] and v[2]. The user can also define her own aliases for the components (one alias per dimension):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    v = (a, b) ∈ R², variable\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"A one dimensional variable can be declared according to","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    v ∈ R, variable\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"note: Note\nIt is also possible to use the following syntax@def ocp begin\n    v ∈ R, variable\nend\nnothing # hidethat is equivalent toocp = @def begin\n    v ∈ R, variable\nend\nnothing # hide","category":"page"},{"location":"tutorial-abstract.html#Time","page":"Abstract syntax","title":"Time","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $t ∈ [$t0, $tf], time ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The independent variable or time is a scalar bound to a given interval. Its name is arbitrary.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"t0 = 1\ntf = 5\n@def begin\n    t ∈ [t0, tf], time\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"One (or even the two bounds) can be variable, typically for minimum time problems (see Mayer cost section):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    v = (T, λ) ∈ R², variable\n    t ∈ [0, T], time\nend","category":"page"},{"location":"tutorial-abstract.html#state","page":"Abstract syntax","title":"State","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $x ∈ R^$n, state ) \n:( $x ∈ R   , state ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The state declaration defines the name and the dimension of the state:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    x ∈ R⁴, state\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"As for the variable, there are automatic aliases (x₁ and x1 for x[1], etc.) and the user can define her own aliases (one per scalar component of the state):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    x = (q₁, q₂, v₁, v₂) ∈ R⁴, state\nend","category":"page"},{"location":"tutorial-abstract.html#control","page":"Abstract syntax","title":"Control","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $u ∈ R^$m, control ) \n:( $u ∈ R   , control ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The control declaration defines the name and the dimension of the control:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    u ∈ R², control\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"As before, there are automatic aliases (u₁ and u1 for u[1], etc.) and the user can define her own aliases (one per scalar component of the state):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    u = (α, β) ∈ R², control\nend","category":"page"},{"location":"tutorial-abstract.html#dynamics","page":"Abstract syntax","title":"Dynamics","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( ∂($x)($t) == $e1 ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The dynamics is given in the standard vectorial ODE form:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"    dotx(t) = f(t x(t) u(t) v)","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"depending on whether it is autonomous / with a variable or not (the parser will detect time and variable dependences, which entails that time, state and variable must be declared prior to dynamics - an error will be issued otherwise). The symbol ∂, or the dotted state name (ẋ), or the keyword derivative can be used:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    ∂(x)(t) == [x₂(t), u(t)]\nend\nnothing # hide","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"or","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    ẋ(t) == [x₂(t), u(t)]\nend\nnothing # hide","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"or","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    derivative(x)(t) == [x₂(t), u(t)]\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Any Julia code can be used, so the following is also OK: ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"ocp = @def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    ẋ(t) == F₀(x(t)) + u(t) * F₁(x(t))\nend\n\nF₀(x) = [x[2], 0]\nF₁(x) = [0, 1]\nnothing # hide","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"note: Note\nThe vector fields F₀ and F₁ can be defined afterwards, as they only need to be available when the dynamics will be evaluated.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Currently, it is not possible to declare the dynamics component after component, but a simple workaround is to use aliases (check the relevant aliases section below):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    q̇ = v(t)\n    v̇ = u(t) - c(t)\n    ẋ(t) == [q̇, v̇]\nend","category":"page"},{"location":"tutorial-abstract.html#Constraints","page":"Abstract syntax","title":"Constraints","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $e1 == $e2        ) \n:( $e1 ≤  $e2 ≤  $e3 ) \n:(        $e2 ≤  $e3 ) \n:( $e3 ≥  $e2 ≥  $e1 ) \n:( $e2 ≥  $e1        ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Admissible constraints can be","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"five types: boundary, control, state, mixed, variable,\nlinear (ranges) or nonlinear (not ranges),\nequalities or (one or two-sided) inequalities.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Boundary conditions are detected when the expression contains evaluations of the state at initial and / or final time bounds (e.g., x(0)), and may not involve the control. Conversely control, state or mixed constraints will involve control, state or both evaluated at the declared time (e.g., x(t) + u(t)).  Other combinations should be detected as incorrect by the parser 🤞🏾. The variable may be involved in any of the four previous constraints. Constraints involving the variable only are variable constraints, either linear or nonlinear. In the example below, there are","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"two linear boundary constraints,\none linear variable constraint,\none linear state constraint,\none (two-sided) nonlinear control constraint.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(tf) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    tf ≥ 0 \n    x₂(t) ≤ 1\n    u(t)^2 ≤ 1\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"note: Note\nSymbols like <= or >= are also authorised:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(tf) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    tf >= 0 \n    x₂(t) <= 1\n    u(t)^2 <= 1\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"caveat: Caveat\nWrite either u(t)^2 or (u^2)(t), not u^2(t) since in Julia the latter is means u^(2t). Moreover, in the case of equalities or of one-sided inequalities, the control and / or the state must belong to the left-hand side. The following will error:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"using OptimalControl","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    t ∈ [0, 2], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(2) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    1 ≤ x₂(t)\n    -1 ≤ u(t) ≤ 1\nend","category":"page"},{"location":"tutorial-abstract.html#mayer","page":"Abstract syntax","title":"Mayer cost","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $e1 → min ) \n:( $e1 → max ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Mayer costs are defined in a similar way to boundary conditions and follow the same rules. The symbol → is used to denote minimisation or maximisation, the latter being treated by minimising the opposite cost. (The symbol => can also be used.)","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5\n   -2 ≤ v(t) ≤ 3\n    ẋ(t) == [v(t), u(t)]\n    tf → min\nend","category":"page"},{"location":"tutorial-abstract.html#Lagrange-cost","page":"Abstract syntax","title":"Lagrange cost","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":(       ∫($e1) → min ) \n:(     - ∫($e1) → min ) \n:( $e1 * ∫($e2) → min ) \n:(       ∫($e1) → max ) \n:(     - ∫($e1) → max ) \n:( $e1 * ∫($e2) → max ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Lagrange (integral) costs are defined used the symbol ∫, with parentheses. The keyword integral can also be used:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    t ∈ [0, 1], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    0.5∫(q(t) + u(t)^2) → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"or","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    t ∈ [0, 1], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    0.5integrate(q(t) + u(t)^2) → min\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The integration range is implicitly equal to the time range, so the cost above is to be understood as","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"int_0^1 left( q(t) + u^2(t) right) mathrmdt to min","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"As for the dynamics, the parser will detect whether the integrand depends or not on time (autonomous / non-autonomous case).","category":"page"},{"location":"tutorial-abstract.html#Bolza-cost","page":"Abstract syntax","title":"Bolza cost","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $e1 +       ∫($e2)       → min ) \n:( $e1 + $e2 * ∫($e3)       → min ) \n:( $e1 -       ∫($e2)       → min ) \n:( $e1 - $e2 * ∫($e3)       → min ) \n:( $e1 +       ∫($e2)       → max ) \n:( $e1 + $e2 * ∫($e3)       → max ) \n:( $e1 -       ∫($e2)       → max ) \n:( $e1 - $e2 * ∫($e3)       → max ) \n:(             ∫($e2) + $e1 → min ) \n:(       $e2 * ∫($e3) + $e1 → min ) \n:(             ∫($e2) - $e1 → min ) \n:(       $e2 * ∫($e3) - $e1 → min ) \n:(             ∫($e2) + $e1 → max ) \n:(       $e2 * ∫($e3) + $e1 → max ) \n:(             ∫($e2) - $e1 → max ) \n:(       $e2 * ∫($e3) - $e1 → max ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Quite readily, Mayer and Lagrange costs can be combined into general Bolza costs. For instance as follows:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    p = (t0, tf) ∈ R², variable\n    t ∈ [t0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R², control\n    (tf - t0) + 0.5∫(c(t) * u(t)^2) → min\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"caveat: Caveat\nThe expression must be the sum of two terms (plus, possibly, a scalar factor before the integral), not more, so mind the parentheses. For instance, the following errors:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    p = (t0, tf) ∈ R², variable\n    t ∈ [t0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R², control\n    (tf - t0) + q(tf) + 0.5∫( c(t) * u(t)^2 ) → min\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The correct syntax is","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    p = (t0, tf) ∈ R², variable\n    t ∈ [t0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R², control\n    ((tf - t0) + q(tf)) + 0.5∫( c(t) * u(t)^2 ) → min\nend","category":"page"},{"location":"tutorial-abstract.html#aliases","page":"Abstract syntax","title":"Aliases","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $a = $e1 )","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The single = symbol is used to define not a constraint but an alias, that is a purely syntactic replacement. There are some automatic aliases, e.g. x₁ for x[1] if x is the state, and we have also seen that the user can define her own aliases when declaring the variable, state and control. Arbitrary aliases can be further defined, as below (compare with previous examples in the dynamics section):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    F₀ = [x₂(t), 0]\n    F₁ = [0, 1]\n    ẋ(t) == F₀ + u(t) * F₁\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"caveat: Caveat\nSuch aliases do not define any additional function and are just replaced textually by the parser. In particular, they cannot be used outside the @def begin ... end block.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"hint: Hint\nYou can rely on a trace mode for the macro @def to look at your code after expansions of the aliases using the @def ocp ... syntax and adding true after your begin ... end block:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    q̇ = v(t)\n    v̇ = u(t) - c(t)\n    ẋ(t) == [q̇, v̇]\nend true;","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"caveat: Caveat\nThe dynamics of an OCP is indeed a particular constraint, be careful to use == and not a single = that would try to define an alias:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"double_integrator = @def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    q̇ = v\n    v̇ = u\n    ẋ(t) = [q̇, v̇]\nend","category":"page"},{"location":"tutorial-abstract.html#Misc","page":"Abstract syntax","title":"Misc","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Declarations (of variable - if any -, time, state and control) must be done first. Then, dynamics, constraints and cost can be introduced in an arbitrary order.\nIt is possible to provide numbers / labels (as in math equations) for the constraints to improve readability (this is mostly for future use, typically to retrieve the Lagrange multiplier associated with the discretisation of a given constraint):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    tf ≥ 0, (1)\n    q(0) == 2, (♡)\n    q̇ = v(t)\n    v̇ = u(t) - c(t)\n    ẋ(t) == [q̇, v̇]\n    x(t).^2  ≤ [1, 2], (state_con) \nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Parsing errors should be explicit enough (with line number in the @def begin ... end block indicated) 🤞🏾\nCheck tutorials and applications in the documentation for further use.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"","category":"page"},{"location":"tutorial-double-integrator-energy.html#tutorial-basic","page":"Energy minimisation","title":"Double integrator: energy min (abstract syntax)","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force u. We denote by x = (x_1 x_2) the state of the wagon, that is its position x_1 and its velocity x_2.","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We assume that the mass is constant and unitary and that there is no friction. The dynamics we consider is given by","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t)quad u(t) in R","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"which is simply the double integrator system. Les us consider a transfer starting at time t_0 = 0 and ending at time t_f = 1, for which we want to minimise the transfer energy","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"    frac12int_0^1 u^2(t)  mathrmdt","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"starting from the condition x(0) = (-1 0) and with the goal to reach the target x(1) = (0 0).","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-double-integrator-energy.html#Optimal-control-problem","page":"Energy minimisation","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"Let us define the problem","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"ocp = @def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n    ẋ(t) == [ x₂(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"note: Nota bene\nFor a comprehensive introduction to the syntax used above to describe the optimal control problem, check this abstract syntax tutorial. In particular, there are non-unicode alternatives for derivatives, integrals, etc.","category":"page"},{"location":"tutorial-double-integrator-energy.html#basic-solve-plot","page":"Energy minimisation","title":"Solve and plot","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We can solve it simply with:","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"And plot the solution with:","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"plot(sol)","category":"page"},{"location":"tutorial-double-integrator-energy.html#State-constraint","page":"Energy minimisation","title":"State constraint","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We add the path constraint","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"x_2(t) le 12","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"ocp = @def begin\n\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x₂(t) ≤ 1.2\n\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n\n    ẋ(t) == [ x₂(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\n\nsol = solve(ocp)\nplot(sol)","category":"page"},{"location":"tutorial-double-integrator-energy.html#Save-and-load","page":"Energy minimisation","title":"Save and load","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We can save the solution in a Julia .jld2 data file and reload it later, and also export a discretised version of the solution in a more portable JSON format. Note that the OCP is needed when loading a solution.","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"# load additional modules\nusing JLD2, JSON3\n\n# JLD save / load\nusing Suppressor # hide\n@suppress_err begin # hide\nexport_ocp_solution(sol; filename_prefix=\"my_solution\")\nend # hide\nsol_reloaded = import_ocp_solution(ocp; filename_prefix=\"my_solution\")\nprintln(\"Objective from loaded solution: \", sol_reloaded.objective)\n\n# JSON export / read\nexport_ocp_solution(sol; filename_prefix=\"my_solution\", format=:JSON)\nsol_json = import_ocp_solution(ocp; filename_prefix=\"my_solution\", format=:JSON)\nprintln(\"Objective from JSON discrete solution: \", sol_json.objective)","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"","category":"page"},{"location":"tutorial-solve.html#tutorial-solve","page":"Solve","title":"The solve function","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"In this tutorial, we explain the solve function from OptimalControl.jl package.","category":"page"},{"location":"tutorial-solve.html#Basic-usage","page":"Solve","title":"Basic usage","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Let us define a basic optimal control problem.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"using OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == [ 0, 0 ]\n\n    ẋ(t)  == [ v(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"We can now solve the problem:","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"using NLPModelsIpopt\n\nsolve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Notice that we need to load the NLPModelsIpopt package before calling solve. This is because the method currently implements a direct approach, where the optimal control problem is transcribed to a nonlinear optimization problem (NLP) of the form","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"textminimizequad F(y) quadtextsubject to the constraintsquad g(y)=0 quad h(y)le 0 ","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Note: calling solve without loading a NLP solver package first will notify the user:","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"julia> solve(ocp)\nERROR: ExtensionError. Please make: julia> using NLPModelsIpopt","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"See below for the NLP solver options.","category":"page"},{"location":"tutorial-solve.html#Options","page":"Solve","title":"Options","text":"","category":"section"},{"location":"tutorial-solve.html#Methods","page":"Solve","title":"Methods","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"OptimalControl.jl offers a list of methods to solve your optimal control problem. To get the list of methods, simply call available_methods.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"available_methods()","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Each line is a method, with priority going from top to bottom. This means that ","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"solve(ocp)","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"is equivalent to ","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"solve(ocp, :direct, :adnlp, :ipopt)","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"The first symbol :direct refers to the general class of method, with only the so-called direct approach currently implemented. Direct methods discretize the original optimal control problem and solve the resulting NLP problem. The second symbol :adnlp is for the choice of NLP modeler.  We currently use ADNLPModels.jl which provides an automatic differentiation (AD)-based model implementations that conform to the NLPModels.jl API. The third symbol corresponds to the NLP solver, with the possible values:","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":":ipopt (default value) for Ipopt (via the NLPModelsIpopt.jl package).\n:madnlp is MadNLP.jl, an open-source nonlinear programming solver purely implemented in Julia, which implements a filter line-search interior-point algorithm, as the one in Ipopt.\n:knitro for the Knitro solver (requires a license).","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"For instance, let us try MadNLP.jl.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"using MadNLP\n\nsolve(ocp, :madnlp)\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Note that you can provide a partial description.  If several full descriptions contain it, the priority is given to first one in the list.  Hence, these calls are all equivalent:","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"solve(ocp)\nsolve(ocp, :direct                )\nsolve(ocp,          :adnlp        )\nsolve(ocp,                  :ipopt)\nsolve(ocp, :direct, :adnlp        )\nsolve(ocp, :direct,         :ipopt)\nsolve(ocp, :direct, :adnlp, :ipopt)","category":"page"},{"location":"tutorial-solve.html#Direct-method","page":"Solve","title":"Direct method","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"The options for the direct method are listed in the direct_solve keywords. The main options, with their [default values], are:","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"display ([true], false): setting display to false will disable output\ngrid_size ([250]): size of the (uniform) time discretization grid. More precisely, it is the number of time steps, that is if N = grid_size and if the initial and final times are denoted respectively t0 and tf, then we have Δt = (tf - t0) / N\ndisc_method ([:trapeze], :midpoint, :gauss_legendre_2): see discretisation methods\ninit: info for the starting guess, which can be provided as numerical values, functions, or an existing solution. See initial guess tutorial. ","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"For examples of more advanced use, see ","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"discrete continuation\nNLP direct handling","category":"page"},{"location":"tutorial-solve.html#NLP-solver-specific-options","page":"Solve","title":"NLP solver specific options","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"In addition to these options, all remaining keyword arguments passed to solve will be transmitted to the NLP solver used.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Please check the list of Ipopt options and the NLPModelsIpopt.jl documentation.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"solve(ocp; max_iter=0)\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Similarly, please check the MadNLP.jl documentation and the list of MadNLP.jl options.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"solve(ocp, :madnlp; max_iter=0)\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"","category":"page"},{"location":"api-ctbase/parser.html#api-ctbase-parser","page":"Parser","title":"Parser","text":"","category":"section"},{"location":"api-ctbase/parser.html","page":"Parser","title":"Parser","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/parser.html#Index","page":"Parser","title":"Index","text":"","category":"section"},{"location":"api-ctbase/parser.html","page":"Parser","title":"Parser","text":"Pages   = [\"parser.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/parser.html#Documentation","page":"Parser","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/parser.html","page":"Parser","title":"Parser","text":"Modules = [CTBase]\nOrder = [:module, :constant, :macro, :function]\nPages = [\"ctparser_utils.jl\", \"onepass.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/parser.html#CTBase.constraint_type-NTuple{7, Any}","page":"Parser","title":"CTBase.constraint_type","text":"constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n\n\nReturn the type constraint among :initial, :final, :boundary, :control_range, :control_fun, :state_range, :state_fun, :mixed, :variable_range, :variable_fun (:other otherwise), together with the appropriate value (range, updated expression...) Expressions like u(t0) where u is the control and t0 the initial time return :other.\n\nExample\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, 1)\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, 1)\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, 1)\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, 1)\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, 2)\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n:variable_fun\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n:variable_fun\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/parser.html#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}","page":"Parser","title":"CTBase.replace_call","text":"replace_call(e, x::Symbol, t, y) -> Any\n\n\nReplace calls in e of the form (...x...)(t) by (...y...).\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/parser.html#CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","page":"Parser","title":"CTBase.replace_call","text":"replace_call(e, x::Vector{Symbol}, t, y) -> Any\n\n\nReplace calls in e of the form (...x1...x2...)(t) by (...y1...y2...) for all symbols x1, x2... in the vector x.\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/parser.html#CTBase.@def-Tuple{Any}","page":"Parser","title":"CTBase.@def","text":"Define an optimal control problem. One pass parsing of the definition. Can be used writing either ocp = @def begin ... end or @def ocp begin ... end. In the second case, setting log to true will display the parsing steps.\n\nExample\n\nocp = @def begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend\n\n@def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend true # final boolean to show parsing log\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase/parser.html#CTBase.__OCPModel-Tuple","page":"Parser","title":"CTBase.__OCPModel","text":"__OCPModel(args...; kwargs...) -> OptimalControlModel\n\n\nRedirection to Model to avoid confusion with other functions Model from other packages if imported. This function is used by @def.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/parser.html","page":"Parser","title":"Parser","text":"","category":"page"},{"location":"api-optimalcontrol.html#OptimalControl.jl","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"","category":"section"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"The OptimalControl.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"flowchart TD\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-optimalcontrol.html'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctbase.html'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctdirect.html'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctflows.html'>CTFlows</a>)\nF --> B\nD --> B\nstyle O fill:#FBF275","category":"page"},{"location":"api-optimalcontrol.html#Index","page":"OptimalControl.jl","title":"Index","text":"","category":"section"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Pages   = [\"api-optimalcontrol.md\"]\nModules = [OptimalControl]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-optimalcontrol.html#Available-methods","page":"OptimalControl.jl","title":"Available methods","text":"","category":"section"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"using OptimalControl\navailable_methods()","category":"page"},{"location":"api-optimalcontrol.html#Documentation","page":"OptimalControl.jl","title":"Documentation","text":"","category":"section"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Modules = [OptimalControl]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-optimalcontrol.html#OptimalControl.OptimalControl","page":"OptimalControl.jl","title":"OptimalControl.OptimalControl","text":"OptimalControl module.\n\nLists all the imported modules and packages:\n\nBase\nCTBase\nCTDirect\nCTFlows\nCore\nDocStringExtensions\n\nList of all the exported names:\n\n*\nAutonomous\nFixed\nFlow\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\n@Lie\nLie\nLift\nModel\nNonAutonomous\nNonFixed\nOptimalControlModel\nOptimalControlSolution\nParsingError\nPoisson\nVectorField\n__OCPModel\navailable_methods\nconstraint\nconstraint!\ncontrol\ncontrol!\ncostate\nct_repl\nct_repl_update_model\n@def\ndirect_transcription\ndynamics!\nexport_ocp_solution\nimport_ocp_solution\ninfos\niterations\nload\nmessage\nobjective\nobjective!\nremove_constraint!\nsave\nset_initial_guess\nsolve\nstate\nstate!\nstopping\ntime!\ntime_grid\nvariable\nvariable!\n∂ₜ\n⋅\n\n\n\n\n\n","category":"module"},{"location":"api-optimalcontrol.html#CommonSolve.solve-Tuple{OptimalControlModel, Vararg{Symbol}}","page":"OptimalControl.jl","title":"CommonSolve.solve","text":"solve(\n    ocp::OptimalControlModel,\n    description::Symbol...;\n    kwargs...\n)\n\n\nSolve the the optimal control problem ocp by the method given by the (optional) description. The available methods are given by available_methods(). The higher in the list, the higher is the priority. The keyword arguments are specific to the chosen method and represent the options of the solver.\n\nnote: Note\nSee the tutorial on solving optimal control problems for more information.\n\nArguments\n\nocp::OptimalControlModel: the optimal control problem to solve.\ndescription::Symbol...: the description of the method to use to solve the problem.\nkwargs...: the options of the solver.\n\nExamples\n\nThe simplest way to solve the optimal control problem is to call the function without any argument.\n\njulia> sol = solve(ocp)\n\nThe method can be specified by passing the description as a Symbol. You can provide a partial description, the function will  find the best match.\n\njulia> sol = solve(ocp, :direct)\n\nThe method can be specified by passing the full description as a list of Symbols.\n\njulia> sol = solve(ocp, :direct, :adnlp, :ipopt)\n\nThe keyword arguments are specific to the chosen method and represent the options of the solver. For example, the keyword display is used to display the information of the solver. The default value is true.\n\njulia> sol = solve(ocp, :direct, :ipopt, display=false)\n\nThe initial guess can be provided by the keyword init. You can provide the initial guess for the state, control, and variable.\n\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5))\n\ntip: Tip\nFor more information on how to provide the initial guess, see the tutorial on the initial guess.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol.html#OptimalControl.available_methods-Tuple{}","page":"OptimalControl.jl","title":"OptimalControl.available_methods","text":"available_methods(\n\n) -> Tuple{Vararg{Tuple{Symbol, Symbol, Symbol}}}\n\n\nReturn the list of available methods that can be used to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"","category":"page"},{"location":"api-ctbase.html#CTBase.jl","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"The CTBase.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"flowchart TD\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-optimalcontrol.html'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctbase.html'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctdirect.html'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctflows.html'>CTFlows</a>)\nF --> B\nD --> B\nstyle B fill:#FBF275","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"You may find in this package:","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Description: tools to manipulate tuples.\nDifferential geometry: tools to compute Lie brackets, Poisson brackets...\nExceptions.\nInitial guess: tools to define an initial guess.\nModel: tools to model an optimal control problem in a functional manner.\nParser: tools to model an optimal control problem in an abstract manner.\nPrint: check how an optimal control problem is displayed.\nRepl: control-toolbox repl.\nSolution: optimal control solution.\nTypes: the common types and associated methods if any.\nUtils: auxiliary methods.","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Here is the list of imported packages and exported functions.","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Modules = [CTBase, Base]\nOrder = [:module]\nPages = [\"CTBase.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase.html#CTBase.CTBase","page":"CTBase.jl","title":"CTBase.CTBase","text":"CTBase module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDataStructures\nDocStringExtensions\nLinearAlgebra\nMLStyle\nParameters\nPrettyTables\nPrintf\nReplMaker\nSparseArrays\nStaticArrays\nUnicode\n\nList of all the exported names:\n\nAbstractHamiltonian\nAmbiguousDescription\nAutonomous\nBoundaryConstraint\nBoundaryConstraint!\nCTException\nControl\nControlConstraint\nControlConstraint!\nControlLaw\nControls\nCostate\nCostates\nDCostate\nDState\nDescription\nDimension\nDynamics\nDynamics!\nExtensionError\nFeedbackControl\nFixed\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\nIncorrectArgument\nIncorrectMethod\nIncorrectOutput\nIndex\nLagrange\nLagrange!\n@Lie\nLie\nLift\nMayer\nMayer!\nMixedConstraint\nMixedConstraint!\nModel\nMultiplier\nNonAutonomous\nNonFixed\nNotImplemented\nOptimalControlInit\nOptimalControlModel\nOptimalControlSolution\nParsingError\nPoisson\nState\nStateConstraint\nStateConstraint!\nStates\nTime\nTimeDependence\nTimes\nTimesDisc\nUnauthorizedCall\nVariable\nVariableConstraint\nVariableConstraint!\nVariableDependence\nVectorField\n__OCPModel\n__constraint\n__dynamics\n__lagrange\n__mayer\nadd\nboundary_constraints\nboundary_constraints!\nconstraint\nconstraint!\nconstraint_type\nconstraints\nconstraints_labels\ncontrol\ncontrol!\ncontrol_components_names\ncontrol_constraints\ncontrol_constraints!\ncontrol_dimension\ncontrol_discretized\ncontrol_name\ncostate\ncostate!\ncostate_discretized\ncriterion\nctNumber\nctVector\nct_repl\nct_repl_update_model\nctgradient\nctindices\nctinterpolate\nctjacobian\nctupperscripts\n@def\ndim_boundary_constraints\ndim_control_constraints\ndim_control_range\ndim_mixed_constraints\ndim_path_constraints\ndim_state_constraints\ndim_state_range\ndim_variable_constraints\ndim_variable_range\ndynamics\ndynamics!\nexport_ocp_solution\nfinal_time\nfinal_time_name\ngetFullDescription\nhas_free_final_time\nhas_free_initial_time\nhas_lagrange_cost\nhas_mayer_cost\nimport_ocp_solution\ninfos\ninfos!\ninitial_time\ninitial_time_name\nis_autonomous\nis_fixed\nis_in_place\nis_max\nis_min\nis_time_dependent\nis_time_independent\nis_variable_dependent\nis_variable_independent\niterations\niterations!\nlagrange\nmayer\nmessage\nmessage!\nmixed_constraints\nmixed_constraints!\nmodel_expression\nmodel_expression!\nmult_boundary_constraints\nmult_boundary_constraints!\nmult_control_box_lower\nmult_control_box_lower!\nmult_control_box_upper\nmult_control_box_upper!\nmult_control_constraints\nmult_control_constraints!\nmult_mixed_constraints\nmult_mixed_constraints!\nmult_state_box_lower\nmult_state_box_lower!\nmult_state_box_upper\nmult_state_box_upper!\nmult_state_constraints\nmult_state_constraints!\nmult_variable_box_lower\nmult_variable_box_lower!\nmult_variable_box_upper\nmult_variable_box_upper!\nmult_variable_constraints\nmult_variable_constraints!\nnlp_constraints!\nobjective\nobjective!\nremove\nremove_constraint!\nreplace_call\nset_AD_backend\nstate\nstate!\nstate_components_names\nstate_constraints\nstate_constraints!\nstate_dimension\nstate_discretized\nstate_name\nstopping\nstopping!\nsuccess\nsuccess!\ntime!\ntime_grid\ntime_grid!\ntime_name\nvariable\nvariable!\nvariable_components_names\nvariable_constraints\nvariable_constraints!\nvariable_dimension\nvariable_name\n∂ₜ\n⋅\n\n\n\n\n\n","category":"module"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"page"},{"location":"api-ctdirect.html#CTDirect.jl","page":"CTDirect.jl","title":"CTDirect.jl","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"The CTDirect.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"flowchart TD\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-optimalcontrol.html'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctbase.html'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctdirect.html'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctflows.html'>CTFlows</a>)\nF --> B\nD --> B\nstyle D fill:#FBF275","category":"page"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-ctdirect.html#Index","page":"CTDirect.jl","title":"Index","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Pages   = [\"api-ctdirect.md\"]\nModules = [CTDirect]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-ctdirect.html#Documentation","page":"CTDirect.jl","title":"Documentation","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Modules = [CTDirect]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctdirect.html#CTDirect.available_methods-Tuple{}","page":"CTDirect.jl","title":"CTDirect.available_methods","text":"available_methods(\n\n) -> Tuple{Tuple{Symbol, Symbol}, Tuple{Symbol, Symbol}, Tuple{Symbol, Symbol}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.direct_solve-Tuple{OptimalControlModel, Vararg{Symbol}}","page":"CTDirect.jl","title":"CTDirect.direct_solve","text":"direct_solve(\n    ocp::OptimalControlModel,\n    description::Symbol...;\n    display,\n    grid_size,\n    disc_method,\n    time_grid,\n    init,\n    adnlp_backend,\n    control_type,\n    kwargs...\n)\n\n\nSolve an OCP with a direct method\n\nArguments\n\nocp: optimal control problem as defined in CTBase\n[description]: can specifiy for instance the NLP model and / or solver (:ipopt, :madnlp or :knitro)\n\nKeyword arguments (optional)\n\ndisplay: ([true], false) will disable output if set to false\ngrid_size: number of time steps for the discretized problem ([250])\ndisc_method: discretization method ([:trapeze], :midpoint, gauss_legendre_2)\ntime_grid: explicit time grid (can be non uniform)\ninit: info for the starting guess (values or existing solution)\nadnlp_backend: backend for automatic differentiation in ADNLPModels ([:optimized], :manual, :default)\ncontrol_type: ([:constant], :linear) control piecewise parametrization for IRK methods \n\nAll further keywords are passed to the inner call of solve_docp\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.direct_transcription-Tuple{OptimalControlModel, Vararg{Any}}","page":"CTDirect.jl","title":"CTDirect.direct_transcription","text":"direct_transcription(\n    ocp::OptimalControlModel,\n    description...;\n    grid_size,\n    disc_method,\n    time_grid,\n    init,\n    adnlp_backend,\n    solver_backend,\n    control_type,\n    show_time\n) -> Tuple{CTDirect.DOCP, ADNLPModels.ADNLPModel{Float64, Vector{Float64}, Vector{Int64}}}\n\n\nDiscretize an optimal control problem into a nonlinear optimization problem (ie direct transcription)\n\nArguments\n\nocp: optimal control problem as defined in CTBase\n[description]: can specifiy for instance the NLP model and / or solver (:ipopt, :madnlp or :knitro)\n\nKeyword arguments (optional)\n\ngrid_size: number of time steps for the discretized problem ([250])\ndisc_method: discretization method ([:trapeze], :midpoint, gauss_legendre_2)\ntime_grid: explicit time grid (can be non uniform)\ninit: info for the starting guess (values or existing solution)\nadnlp_backend: backend for automatic differentiation in ADNLPModels ([:optimized], :manual, :default)\ncontrol_type: ([:constant], :linear) control piecewise parametrization for IRK methods\nshow_time: (:true, [:false]) show timing details from ADNLPModels\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.is_solvable-Tuple{Any}","page":"CTDirect.jl","title":"CTDirect.is_solvable","text":"is_solvable(ocp) -> Bool\n\n\nCheck if an OCP is solvable by the method solve.\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.set_initial_guess-Tuple{CTDirect.DOCP, Any, Any}","page":"CTDirect.jl","title":"CTDirect.set_initial_guess","text":"set_initial_guess(docp::CTDirect.DOCP, nlp, init) -> Any\n\n\nSet initial guess in the DOCP\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"","category":"page"},{"location":"api-ctbase/model.html#api-ctbase-model","page":"Model","title":"Model","text":"","category":"section"},{"location":"api-ctbase/model.html","page":"Model","title":"Model","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/model.html","page":"Model","title":"Model","text":"Pages   = [\"model.md\"]","category":"page"},{"location":"api-ctbase/model.html#Optimal-control-model-type","page":"Model","title":"Optimal control model type","text":"","category":"section"},{"location":"api-ctbase/model.html","page":"Model","title":"Model","text":"Modules = [CTBase]\nOrder   = [:type, :module, :constant, :function, :macro]\nPages   = [\"optimal_control_model-type.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/model.html#CTBase.OptimalControlModel","page":"Model","title":"CTBase.OptimalControlModel","text":"mutable struct OptimalControlModel{time_dependence<:TimeDependence, variable_dependence<:VariableDependence} <: CTBase.AbstractOptimalControlModel\n\nFields\n\nmodel_expression::Union{Nothing, Expr}: Default: nothing\ninitial_time::Union{Nothing, Index, Real}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time::Union{Nothing, Index, Real}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Int64}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\nstate_dimension::Union{Nothing, Int64}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nvariable_dimension::Union{Nothing, Int64}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nlagrange::Union{Nothing, Lagrange, Lagrange!}: Default: nothing\nmayer::Union{Nothing, Mayer, Mayer!}: Default: nothing\ncriterion::Union{Nothing, Symbol}: Default: nothing\ndynamics::Union{Nothing, Dynamics, Dynamics!}: Default: nothing\nconstraints::Dict{Symbol, Tuple}: Default: Dict{Symbol, Tuple{Vararg{Any}}}()\ndim_control_constraints::Union{Nothing, Int64}: Default: nothing\ndim_state_constraints::Union{Nothing, Int64}: Default: nothing\ndim_mixed_constraints::Union{Nothing, Int64}: Default: nothing\ndim_boundary_constraints::Union{Nothing, Int64}: Default: nothing\ndim_variable_constraints::Union{Nothing, Int64}: Default: nothing\ndim_control_range::Union{Nothing, Int64}: Default: nothing\ndim_state_range::Union{Nothing, Int64}: Default: nothing\ndim_variable_range::Union{Nothing, Int64}: Default: nothing\nin_place::Union{Nothing, Bool}: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/model.html#Getters","page":"Model","title":"Getters","text":"","category":"section"},{"location":"api-ctbase/model.html","page":"Model","title":"Model","text":"Modules = [CTBase]\nOrder   = [:type, :module, :constant, :function, :macro]\nPages   = [\"optimal_control_model-getters.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/model.html#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.constraint","text":"constraint(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    label::Symbol\n) -> Any\n\n\nRetrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds).\n\nExample\n\njulia> constraint!(ocp, :initial, 0, :c0)\njulia> c = constraint(ocp, :c0)\njulia> c(1)\n1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.constraints","text":"constraints(ocp::OptimalControlModel) -> Dict{Symbol, Tuple}\n\n\nReturn the constraints of the ocp or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.constraints_labels-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.constraints_labels","text":"constraints_labels(\n    ocp::OptimalControlModel\n) -> Base.KeySet{Symbol, Dict{Symbol, Tuple}}\n\n\nReturn the labels of the constraints as a Base.keys.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.control_components_names-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.control_components_names","text":"control_components_names(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Vector{String}}\n\n\nReturn the names of the components of the control of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.control_dimension-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.control_dimension","text":"control_dimension(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Int64}\n\n\nReturn the dimention of the control of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.control_name-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.control_name","text":"control_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the control of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.criterion-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.criterion","text":"criterion(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Symbol}\n\n\nReturn the criterion (:min or :max) of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_boundary_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_boundary_constraints","text":"dim_boundary_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Int64}\n\n\nReturn the dimension of the boundary constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_control_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_control_constraints","text":"dim_control_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Int64}\n\n\nReturn the dimension of nonlinear control constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_control_range-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_control_range","text":"dim_control_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Int64}\n\n\nReturn the dimension of range constraints on control (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_mixed_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_mixed_constraints","text":"dim_mixed_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Int64}\n\n\nReturn the dimension of nonlinear mixed constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_path_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_path_constraints","text":"dim_path_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Int64}\n\n\nReturn the dimension of nonlinear path (state + control + mixed) constraints (nothing if one of them is not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_state_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_state_constraints","text":"dim_state_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Int64}\n\n\nReturn the dimension of nonlinear state constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_state_range-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_state_range","text":"dim_state_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Int64}\n\n\nReturn the dimension of range constraints on state (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_variable_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_variable_constraints","text":"dim_variable_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Int64}\n\n\nReturn the dimension of nonlinear variable constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_variable_range-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_variable_range","text":"dim_variable_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Int64}\n\n\nReturn the dimension of range constraints on variable (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dynamics-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dynamics","text":"dynamics(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Dynamics, Dynamics!}\n\n\nReturn the dynamics of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.final_time-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.final_time","text":"final_time(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Index, Real}\n\n\nReturn the final time of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.final_time_name-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.final_time_name","text":"final_time_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the final time of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.has_free_final_time-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.has_free_final_time","text":"has_free_final_time(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with free final time.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.has_free_initial_time-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.has_free_initial_time","text":"has_free_initial_time(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with free initial time.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.has_lagrange_cost-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.has_lagrange_cost","text":"has_lagrange_cost(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with lagrange cost.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.has_mayer_cost-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.has_mayer_cost","text":"has_mayer_cost(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with mayer cost.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.initial_time-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.initial_time","text":"initial_time(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Index, Real}\n\n\nReturn the initial time of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.initial_time_name-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.initial_time_name","text":"initial_time_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the initial time of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_autonomous-Tuple{OptimalControlModel{Autonomous}}","page":"Model","title":"CTBase.is_autonomous","text":"is_autonomous(ocp::OptimalControlModel{Autonomous}) -> Bool\n\n\nReturn true if the model is autonomous.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_fixed-Tuple{OptimalControlModel{<:TimeDependence, Fixed}}","page":"Model","title":"CTBase.is_fixed","text":"is_fixed(\n    ocp::OptimalControlModel{<:TimeDependence, Fixed}\n) -> Bool\n\n\nReturn true if the model is fixed (= has no variable).\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_in_place-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_in_place","text":"is_in_place(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Bool}\n\n\nReturn true if functions defining the ocp are in-place. Return nothing if this information has not yet been set.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_max-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_max","text":"is_max(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :max.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_min-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_min","text":"is_min(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :min.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_time_dependent-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_time_dependent","text":"is_time_dependent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_time_independent-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_time_independent","text":"is_time_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as time independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_variable_dependent-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_variable_dependent","text":"is_variable_dependent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_variable_independent-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_variable_independent","text":"is_variable_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as variable independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.lagrange-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.lagrange","text":"lagrange(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Lagrange, Lagrange!}\n\n\nReturn the Lagrange part of the cost of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.mayer-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.mayer","text":"mayer(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Mayer, Mayer!}\n\n\nReturn the Mayer part of the cost of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.model_expression-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.model_expression","text":"model_expression(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Expr}\n\n\nReturn the model expression of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.nlp_constraints!-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.nlp_constraints!","text":"nlp_constraints!(\n    ocp::OptimalControlModel\n) -> Tuple{Tuple{Any, Union{CTBase.var\"#ξ!#53\", CTBase.var\"#ξ#52\"}, Vector{Real}}, Tuple{Any, Union{CTBase.var\"#η!#55\", CTBase.var\"#η#54\"}, Vector{Real}}, Tuple{Any, Union{CTBase.var\"#ψ!#57\", CTBase.var\"#ψ#56\"}, Vector{Real}}, Tuple{Any, Union{CTBase.var\"#ϕ!#59\", CTBase.var\"#ϕ#58\"}, Vector{Real}}, Tuple{Any, Union{CTBase.var\"#θ!#61\", CTBase.var\"#θ#60\"}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}\n\n\nReturn a 6-tuple of tuples:\n\n(ξl, ξ, ξu) are control constraints\n(ηl, η, ηu) are state constraints\n(ψl, ψ, ψu) are mixed constraints\n(ϕl, ϕ, ϕu) are boundary constraints\n(θl, θ, θu) are variable constraints\n(ul, uind, uu) are control linear constraints of a subset of indices\n(xl, xind, xu) are state linear constraints of a subset of indices\n(vl, vind, vu) are variable linear constraints of a subset of indices\n\nand update information about constraints dimensions of  ocp. Functions ξ, η, ψ, ϕ, θ are used to evaluate the constraints at given time and state, control, or variable values. These functions are in place when the problem is defined as in place, that is when is_in_place(ocp).\n\nnote: Note\nThe dimensions of the state and control must be set before calling nlp_constraints!.\nFor a Fixed problem, dimensions associated with constraints on the variable are set to zero.\n\nExample\n\njulia> (ξl, ξ, ξu), (ηl, η, ηu), (ψl, ψ, ψu), (ϕl, ϕ, ϕu), (θl, θ, θu),\n    (ul, uind, uu), (xl, xind, xu), (vl, vind, vu) = nlp_constraints!(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.state_components_names-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.state_components_names","text":"state_components_names(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Vector{String}}\n\n\nReturn the names of the components of the state of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.state_dimension-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.state_dimension","text":"state_dimension(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Int64}\n\n\nReturn the dimension of the state of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.state_name-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.state_name","text":"state_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the state of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.time_name-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.time_name","text":"time_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the time component of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.variable_components_names-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.variable_components_names","text":"variable_components_names(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Vector{String}}\n\n\nReturn the names of the components of the variable of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.variable_dimension-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.variable_dimension","text":"variable_dimension(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Int64}\n\n\nReturn the dimension of the variable of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.variable_name-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.variable_name","text":"variable_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the variable of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#Constructors-and-setters","page":"Model","title":"Constructors and setters","text":"","category":"section"},{"location":"api-ctbase/model.html","page":"Model","title":"Model","text":"Modules = [CTBase]\nOrder   = [:type, :module, :constant, :function, :macro]\nPages   = [\"optimal_control_model-setters.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/model.html#CTBase.Model-Tuple{Vararg{DataType}}","page":"Model","title":"CTBase.Model","text":"Model(\n    dependencies::DataType...;\n    in_place\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following argument:\n\ndependencies: either Autonomous or NonAutonomous. Default is Autonomous. And either NonFixed or Fixed. Default is Fixed.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(NonAutonomous)\njulia> ocp = Model(Autonomous, NonFixed)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.Model-Tuple{}","page":"Model","title":"CTBase.Model","text":"Model(\n;\n    autonomous,\n    variable,\n    in_place\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following optional keyword argument:\n\nautonomous: either true or false. Default is true.\nvariable: either true or false. Default is false.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(autonomous=false)\njulia> ocp = Model(autonomous=false, variable=true)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol;\n    rg,\n    f,\n    lb,\n    ub,\n    val,\n    label\n)\n\n\nAdd a constraint to an optimal control problem, denoted ocp.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe initial and final times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nYou can add an :initial, :final, :control, :state or :variable box constraint (whole range). \n\nRange constraint on the state, control or variable\n\nYou can add an :initial, :final, :control, :state or :variable box constraint on a range of it, that is only on some components. If not range is specified, then the constraint is on the whole range. We denote by x, u and v respectively the state, control and variable. We denote by n, m and q respectively the dimension of the state, control and variable. The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable.\n\nExamples\n\njulia> constraint!(ocp, :initial; rg=1:2:5, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :initial; rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :final; rg=1, lb=0, ub=2)\njulia> constraint!(ocp, :control; rg=1, lb=0, ub=2)\njulia> constraint!(ocp, :state; rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :variable; rg=1:2, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :initial; lb=[ 0, 0, 0 ])                 # [ 0, 0, 0 ] ≤ x(t0),                          dim(x) = 3\njulia> constraint!(ocp, :initial; lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ]) # [ 0, 0, 0 ] ≤ x(t0) ≤ [ 1, 2, 1 ],            dim(x) = 3\njulia> constraint!(ocp, :final; lb=-1, ub=1)                      #          -1 ≤ x(tf) ≤ 1,                      dim(x) = 1\njulia> constraint!(ocp, :control; lb=0, ub=2)                     #           0 ≤ u(t)  ≤ 2,        t ∈ [t0, tf], dim(u) = 1\njulia> constraint!(ocp, :state; lb=[ 0, 0 ], ub=[ 1, 2 ])         #    [ 0, 0 ] ≤ x(t)  ≤ [ 1, 2 ], t ∈ [t0, tf], dim(x) = 2\njulia> constraint!(ocp, :variable; lb=[ 0, 0 ], ub=[ 1, 2 ])      #    [ 0, 0 ] ≤    v  ≤ [ 1, 2 ],               dim(v) = 2\n\nFunctional constraint\n\nYou can add a :boundary, :control, :state, :mixed or :variable box functional constraint.\n\nExamples\n\n# variable independent ocp\njulia> constraint!(ocp, :boundary; f = (x0, xf) -> x0[3]+xf[2], lb=0, ub=1)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary; f = (x0, xf, v) -> x0[3]+xf[2]*v[1], lb=0, ub=1)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control; f = u -> 2u, lb=0, ub=1)\njulia> constraint!(ocp, :state; f = x -> x-1, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (x, u) -> x[1]-u, lb=0, ub=1)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control; f = (t, u) -> 2u, lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (t, x) -> t * x, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (t, x, u) -> x[1]-u, lb=0, ub=1)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control; f = (u, v) -> 2u * v[1], lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (x, v) -> x * v[1], lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (x, u, v) -> x[1]-v[2]*u, lb=0, ub=1)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control; f = (t, u, v) -> 2u+v[2], lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (t, x, v) -> x-t*v[1], lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (t, x, u, v) -> x[1]*v[2]-u, lb=0, ub=1)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.control!","page":"Model","title":"CTBase.control!","text":"control!(ocp::OptimalControlModel, m::Int64)\ncontrol!(ocp::OptimalControlModel, m::Int64, name::String)\ncontrol!(\n    ocp::OptimalControlModel,\n    m::Int64,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the control dimension and possibly the names of each coordinate.\n\nnote: Note\nYou must use control! only once to set the control dimension.\n\nExamples\n\njulia> control!(ocp, 1)\njulia> control_dimension(ocp)\n1\njulia> control_components_names(ocp)\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> control_dimension(ocp)\n1\njulia> control_components_names(ocp)\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> control_dimension(ocp)\n2\njulia> control_components_names(ocp)\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> control_dimension(ocp)\n2\njulia> control_components_names(ocp)\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> control_dimension(ocp)\n2\njulia> control_components_names(ocp)\n[\"v₁\", \"v₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase/model.html#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.dynamics!","text":"dynamics!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    f::Function\n)\n\n\nSet the dynamics.\n\nnote: Note\nYou can use dynamics! only once to define the dynamics.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> dynamics!(ocp, f)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.model_expression!-Tuple{OptimalControlModel, Expr}","page":"Model","title":"CTBase.model_expression!","text":"model_expression!(\n    ocp::OptimalControlModel,\n    model_expression::Expr\n)\n\n\nSet the model expression of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function g and f⁰. Type can be :bolza. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> objective!(ocp, :bolza, (x0, xf) -> x0[1] + xf[2], (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function f. Type can be :mayer or :lagrange. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\njulia> objective!(ocp, :mayer, (x0, xf) -> x0[1] + xf[2])\njulia> objective!(ocp, :lagrange, (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\nwarning: Warning\nIf you set twice the objective, only the last one will be taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}","page":"Model","title":"CTBase.remove_constraint!","text":"remove_constraint!(ocp::OptimalControlModel, label::Symbol)\n\n\nRemove a labeled constraint.\n\nExample\n\njulia> remove_constraint!(ocp, :con)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.state!","page":"Model","title":"CTBase.state!","text":"state!(ocp::OptimalControlModel, n::Int64)\nstate!(ocp::OptimalControlModel, n::Int64, name::String)\nstate!(\n    ocp::OptimalControlModel,\n    n::Int64,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the state dimension and possibly the names of each component.\n\nnote: Note\nYou must use state! only once to set the state dimension.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> state_dimension(ocp)\n1\njulia> state_components_names(ocp)\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> state_dimension(ocp)\n1\njulia> state_components_names(ocp)\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> state_dimension(ocp)\n2\njulia> state_components_names(ocp)\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> state_dimension(ocp)\n2\njulia> state_components_names(ocp)\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> state_dimension(ocp)\n2\njulia> state_components_names(ocp)\n[\"y₁\", \"y₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase/model.html#CTBase.time!-Union{Tuple{OptimalControlModel{<:TimeDependence, VT}}, Tuple{VT}} where VT","page":"Model","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel{<:TimeDependence, VT};\n    t0,\n    tf,\n    ind0,\n    indf,\n    name\n)\n\n\nSet the initial and final times. We denote by t0 the initial time and tf the final time. The optimal control problem is denoted ocp. When a time is free, then one must provide the corresponding index of the ocp variable.\n\nnote: Note\nYou must use time! only once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, t0=0,   tf=1  ) # Fixed t0 and fixed tf\njulia> time!(ocp, t0=0,   indf=2) # Fixed t0 and free  tf\njulia> time!(ocp, ind0=2, tf=1  ) # Free  t0 and fixed tf\njulia> time!(ocp, ind0=2, indf=3) # Free  t0 and free  tf\n\nWhen you plot a solution of an optimal control problem, the name of the time variable appears. By default, the name is \"t\". Consider you want to set the name of the time variable to \"s\".\n\njulia> time!(ocp, t0=0, tf=1, name=\"s\") # name is a String\n# or\njulia> time!(ocp, t0=0, tf=1, name=:s ) # name is a Symbol  \n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.variable!","page":"Model","title":"CTBase.variable!","text":"variable!(ocp::OptimalControlModel, q::Int64)\nvariable!(ocp::OptimalControlModel, q::Int64, name::String)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Int64,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the variable dimension and possibly the names of each component.\n\nnote: Note\nYou can use variable! once to set the variable dimension when the model is NonFixed.\n\nExamples\n\njulia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"v₁\", \"v₂\" ])\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase/model.html","page":"Model","title":"Model","text":"","category":"page"},{"location":"tutorial-nlp.html#NLP-and-DOCP-manipulations","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"We describe here some more advanced operations related to the discretized optimal control problem. When calling solve(ocp) three steps are performed internally:","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"first, the OCP is discretized into a DOCP (a nonlinear optimization problem) with direct_transcription,\nthen, this DOCP is solved (with the internal function solve_docp),\nfinally, a functional solution of the OCP is rebuilt from the solution of the discretized problem, with OptimalControlSolution.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"These steps can also be done separately, for instance if you want to use your own NLP solver. ","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"Let us load the packages.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"using OptimalControl\nusing Plots","category":"page"},{"location":"tutorial-nlp.html#Definition-of-the-optimal-control-problem","page":"NLP and DOCP manipulations","title":"Definition of the optimal control problem","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"We define a test problem","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"ocp = @def begin\n\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n\n    ẋ(t) == [ x₂(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html#Discretization-and-NLP-problem","page":"NLP and DOCP manipulations","title":"Discretization and NLP problem","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"We discretize the problem.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"docp, nlp = direct_transcription(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"The DOCP contains information related to the transcription, including a copy of the original OCP, and the NLP is the resulting discretized problem, in our case an ADNLPModel.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"We can now use the solver of our choice to solve it.","category":"page"},{"location":"tutorial-nlp.html#Resolution-of-the-NLP-problem","page":"NLP and DOCP manipulations","title":"Resolution of the NLP problem","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"For a first example we use the ipopt solver from NLPModelsIpopt.jl package to solve the NLP problem.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"using NLPModelsIpopt\n\nnlp_sol = ipopt(nlp; print_level=5, mu_strategy=\"adaptive\", tol=1e-8, sb=\"yes\")\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"Then we can rebuild and plot an optimal control problem solution (note that the multipliers are optional, but the OCP costate will not be retrieved if the multipliers are not provided).","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"sol = OptimalControlSolution(docp; primal=nlp_sol.solution, dual=nlp_sol.multipliers)\nplot(sol)","category":"page"},{"location":"tutorial-nlp.html#Change-the-NLP-solver","page":"NLP and DOCP manipulations","title":"Change the NLP solver","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"Alternatively, we can use MadNLP.jl to solve anew the NLP problem:","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"using MadNLP\n\nnlp_sol = madnlp(nlp)","category":"page"},{"location":"tutorial-nlp.html#Initial-guess","page":"NLP and DOCP manipulations","title":"Initial guess","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"An initial guess, including warm start, can be passed to direct_transcription the same way as for solve.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"docp, nlp = direct_transcription(ocp; init=sol)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"It can also be changed after the transcription is done, with  set_initial_guess.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"set_initial_guess(docp, nlp, sol)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"","category":"page"},{"location":"tutorial-plot.html#tutorial-plot","page":"Plot a solution","title":"How to plot a solution","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In this tutorial we explain the different ways to plot a solution of an optimal control problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Let us start by importing the package to define the problem and solve it.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using OptimalControl\nusing NLPModelsIpopt","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Then, we define a simple optimal control problem and solve it.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"ocp = @def begin\n\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x(0) == [-1, 0]\n    x(1) == [0, 0]\n\n    ẋ(t) == [x₂(t), u(t)]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\n\nsol = solve(ocp, display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html#First-ways-to-plot","page":"Plot a solution","title":"First ways to plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The simplest way to plot the solution is to use the plot function with only the solution as argument.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: The plot function\nThe plot function on a solution of an optimal control problem is an extension of the plot function from the package Plots.jl. Hence, we need to import this package to plot a solution.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using Plots\nplot(sol)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"As you can see, it produces a grid of subplots. The left column contains the state trajectories, the right column the costate trajectories, and at the bottom we have the control trajectory.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Attributes from Plots.jl can be passed to the plot function:","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In addition to sol you can pass attributes to the full plot, see the attributes plot documentation from Plots.jl for more details. For instance, you can specify the size of the figure.\nYou can also pass attributes to the subplots, see the attributes subplot documentation from Plots.jl for more details. However, it will affect all the subplots. For instance, you can specify the location of the legend.\nIn the same way, you can pass axis attributes to the subplots, see the attributes axis documentation from Plots.jl for more details. It will also affect all the subplots. For instance, you can remove the grid.\nIn the same way, you can pass series attributes to the all the subplots, see the attributes series documentation from Plots.jl for more details. It will also affect all the subplots. For instance, you can set the width of the curves with linewidth.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, size=(700, 450), legend=:bottomright, grid=false, linewidth=2)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To specify series attributes to a specific subplot, you can use the optional keyword arguments state_style, costate_style and control_style which correspond respectively to the state, costate and control trajectories. See the attribute series documentation from Plots.jl for more details. For instance, you can specify the color of the state trajectories and more.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; \n     state_style   = (color=:blue,), \n     costate_style = (color=:black, linestyle=:dash),\n     control_style = (color=:red, linewidth=2))","category":"page"},{"location":"tutorial-plot.html#From-Flow","page":"Plot a solution","title":"From Flow","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The previous resolution of the optimal control problem was done with the solve function. If you use an indirect shooting method and solve shooting equations, you may want to plot the  associated solution. To do so, you need to use the Flow function to  reconstruct the solution. See the Indirect Simple Shooting tutorial for an example. In our example, you must provide the maximising control (x p) mapsto p_2 together with the  optimal control problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"tip: Interactions with an optimal control solution\nPlease check state, costate, control and variable to get data from the solution. The functions state, costate and control return functions of time and variable returns a vector.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using OrdinaryDiffEq\nt0 = 0\ntf = 1\nx0 = [ -1, 0 ]\np0 = costate(sol)(t0)\nf  = Flow(ocp, (x, p) -> p[2])\nsol_flow = f( (t0, tf), x0, p0 )\nplot(sol_flow)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can notice that the time grid has very few points. To have a better visualisation (the accuracy  won't change), you can give a finer grid.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"sol_flow = f( (t0, tf), x0, p0; saveat=range(t0, tf, 100) )\nplot(sol_flow)","category":"page"},{"location":"tutorial-plot.html#Split-versus-group-layout","page":"Plot a solution","title":"Split versus group layout","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"If you prefer to get a more compact figure, you can use the layout optional keyword argument with :group value. It will group the state, costate and control trajectories in one subplot for each.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; layout=:group, size=(800, 300))","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Default layout value\nThe default layout value is :split which corresponds to the grid of subplots presented above.","category":"page"},{"location":"tutorial-plot.html#Additional-plots","page":"Plot a solution","title":"Additional plots","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can plot the solution of a second optimal control problem on the same figure if it has the same number of states, costates and controls. For instance, consider the same optimal control problem but with a different initial condition.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"ocp = @def begin\n\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x(0) == [-0.5, -0.5]\n    x(1) == [0, 0]\n\n    ẋ(t) == [x₂(t), u(t)]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nsol2 = solve(ocp; display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We first plot the solution of the first optimal control problem, then, we plot the solution of the second optimal control problem on the same figure, but with dashed lines.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"# first plot\nplt = plot(sol; solution_label=\"(sol1)\", size=(700, 500))\n\n# second plot\nplot!(plt, sol2; solution_label=\"(sol2)\", linestyle=:dash)","category":"page"},{"location":"tutorial-plot.html#Plot-the-norm-of-the-control","page":"Plot a solution","title":"Plot the norm of the control","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"For some problem, it is interesting to plot the norm of the control. You can do it by using the control optional keyword argument with :norm value. The default value is :components.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; control=:norm, size=(800, 300), layout=:group)","category":"page"},{"location":"tutorial-plot.html#Custom-plot","page":"Plot a solution","title":"Custom plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can of course create your own plots by getting the state, costate and control from the optimal control solution. For instance, let us plot the norm of the control for the orbital transfer problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"tip: Interactions with an optimal control solution\nAdditionally to state, costate, control and variable, the function time_grid returns the discretized time grid returned by the solver.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using LinearAlgebra\nt = time_grid(sol)\nx = state(sol)\np = costate(sol)\nu = control(sol)\nplot(t, norm∘u; label=\"‖u‖\") ","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Nota bene\nThe norm function is from LinearAlgebra.jl. \nThe ∘ operator is the composition operator. Hence, norm∘u is the function t -> norm(u(t)). ","category":"page"},{"location":"tutorial-plot.html#Normalized-time","page":"Plot a solution","title":"Normalized time","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We consider a LQR example and solve the problem for different values of the final time tf. Then, we plot the solutions on the same figure considering a normalized time s=(t-t_0)(t_f-t_0), thanks to the keyword argument time=:normalized of the plot function.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"\n# parameters\nx0 = [ 0\n       1 ]\n\n# definition\nfunction lqr(tf)\n\n    ocp = @def begin\n        t ∈ [0, tf], time\n        x ∈ R², state\n        u ∈ R, control\n        x(0) == x0\n        ẋ(t) == [x₂(t), - x₁(t) + u(t)]\n        ∫( 0.5(x₁(t)^2 + x₂(t)^2 + u(t)^2) ) → min\n    end\n\n    return ocp\nend;\n\n# solve\nsolutions = []\ntfs = [3, 5, 30]\nfor tf ∈ tfs\n    solution = solve(lqr(tf); display=false)\n    push!(solutions, solution)\nend\n\n# create plots\nplt = plot(solutions[1]; time=:normalized)\nfor sol ∈ solutions[2:end]\n    plot!(plt, sol; time=:normalized)\nend\n\n# make a custom plot from created plots: only state and control are plotted\nN = length(tfs)\npx1 = plot(plt[1]; legend=false, xlabel=\"s\", ylabel=\"x₁\")\npx2 = plot(plt[2]; label=reshape([\"tf = $tf\" for tf ∈ tfs], (1, N)), xlabel=\"s\", ylabel=\"x₂\")\npu  = plot(plt[5]; legend=false, xlabel=\"s\", ylabel=\"u\")\n\nusing Plots.PlotMeasures # for leftmargin, bottommargin\nplot(px1, px2, pu; layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"","category":"page"},{"location":"dev-ctdirect.html#dev-ctdirect","page":"CTDirect.jl","title":"CTDirect.jl private functions","text":"","category":"section"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-ctdirect.html#Index","page":"CTDirect.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Pages   = [\"dev-ctdirect.md\"]\nModules = [CTDirect]\nOrder   = [:type, :module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctdirect.html#Documentation","page":"CTDirect.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Modules = [CTDirect]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-ctdirect.html#CTBase.OptimalControlSolution-Tuple{CTDirect.DOCP, Any}","page":"CTDirect.jl","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(\n    docp::CTDirect.DOCP,\n    docp_solution\n) -> OptimalControlSolution\n\n\nBuild OCP functional solution from DOCP discrete solution (given as a SolverCore.GenericExecutionStats)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTBase.OptimalControlSolution-Tuple{CTDirect.DOCP}","page":"CTDirect.jl","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(\n    docp::CTDirect.DOCP;\n    primal,\n    dual,\n    objective,\n    iterations,\n    constraints_violation,\n    message,\n    mult_LB,\n    mult_UB\n) -> OptimalControlSolution\n\n\nBuild OCP functional solution from the DOCP discrete solution, given as a vector. Costate will be retrieved from dual variables (multipliers) if available.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP","page":"CTDirect.jl","title":"CTDirect.DOCP","text":"Struct for discretized optimal control problem DOCP\n\nContains:\n\na copy of the original OCP\ndata required to link the OCP with the discretized DOCP\n\n\n\n\n\n","category":"type"},{"location":"dev-ctdirect.html#CTDirect.Gauss_Legendre_1","page":"CTDirect.jl","title":"CTDirect.Gauss_Legendre_1","text":"Implicit Midpoint discretization, formulated as a generic IRK (ie Gauss Legendre 1) NB. does not use the simplification xs = 0.5 * (xi + xip1) as in midpoint.jl\n\n\n\n\n\n","category":"type"},{"location":"dev-ctdirect.html#CTDirect.Gauss_Legendre_2","page":"CTDirect.jl","title":"CTDirect.Gauss_Legendre_2","text":"Gauss Legendre 2 discretization, formulated as a generic IRK\n\n\n\n\n\n","category":"type"},{"location":"dev-ctdirect.html#CTDirect.Gauss_Legendre_3","page":"CTDirect.jl","title":"CTDirect.Gauss_Legendre_3","text":"Gauss Legendre 3 discretization, formulated as a generic IRK\n\n\n\n\n\n","category":"type"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Midpoint}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Midpoint}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Trapeze}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Trapeze}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Midpoint}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Midpoint}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Trapeze}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Trapeze}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_constraints!-Tuple{Any, Any, CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.DOCP_constraints!","text":"DOCP_constraints!(c, xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the constraints C for the DOCP problem (modeled as LB <= C(X) <= UB).\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_initial_guess","page":"CTDirect.jl","title":"CTDirect.DOCP_initial_guess","text":"DOCP_initial_guess(docp::CTDirect.DOCP) -> Vector{Float64}\nDOCP_initial_guess(\n    docp::CTDirect.DOCP,\n    init::OptimalControlInit\n) -> Vector{Float64}\n\n\nBuild initial guess for discretized problem\n\n\n\n\n\n","category":"function"},{"location":"dev-ctdirect.html#CTDirect.DOCP_objective-Tuple{Any, CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.DOCP_objective","text":"DOCP_objective(xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the objective for the DOCP problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.IRK_dims-NTuple{10, Any}","page":"CTDirect.jl","title":"CTDirect.IRK_dims","text":"IRK_dims(\n    dim_NLP_steps,\n    dim_NLP_x,\n    dim_NLP_u,\n    dim_NLP_v,\n    dim_u_cons,\n    dim_x_cons,\n    dim_xu_cons,\n    dim_boundary_cons,\n    dim_v_cons,\n    stage\n) -> NTuple{5, Any}\n\n\nReturn the dimension of the NLP variables and constraints for a generic IRK discretizion, with the control taken constant per step (ie not distinct controls at time stages)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__adnlp_backend-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__adnlp_backend","text":"__adnlp_backend() -> Symbol\n\n\nUsed to set the default backend for AD in ADNLPModels. The default value is :optimized.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__control_type-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__control_type","text":"__control_type() -> Symbol\n\n\nUsed to set the default control type for IRK schemes  The default value is :constant.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__disc_method-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__disc_method","text":"__disc_method() -> Symbol\n\n\nUsed to set the default discretization method. The default value is trapeze.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__grid_size-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__grid_size","text":"__grid_size() -> Int64\n\n\nUsed to set the default grid size. The default value is 250.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__ipopt_linear_solver-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__ipopt_linear_solver","text":"__ipopt_linear_solver() -> String\n\n\nUsed to set the default value of the linear solver of Ipopt for the direct method. The default value is mumps.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__ipopt_mu_strategy-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__ipopt_mu_strategy","text":"__ipopt_mu_strategy() -> String\n\n\nUsed to set the default value of the μ strategy of Ipopt for the direct method. The default value is adaptive.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__ipopt_print_level-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__ipopt_print_level","text":"__ipopt_print_level() -> Int64\n\n\nUsed to set the default value of the print level of Ipopt for the direct method. The default value is 5.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__knitro_print_level-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__knitro_print_level","text":"__knitro_print_level() -> Int64\n\n\nUsed to set the default value of the print level of Knitro for the direct method. The default value is 3.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__madnlp_linear_solver-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__madnlp_linear_solver","text":"__madnlp_linear_solver() -> String\n\n\nUsed to set the default value of the linear solver of MadNLP for the direct method. The default value is umfpack.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__max_iterations-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__max_iterations","text":"__max_iterations() -> Int64\n\n\nUsed to set the default maximum of iterations. The default value is 1000.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__time_grid-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__time_grid","text":"__time_grid()\n\n\nUsed to set the default time grid. The default value is nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__tolerance-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__tolerance","text":"__tolerance() -> Float64\n\n\nUsed to set the default tolerance. The default value is 1e-6.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.add_nonzero_block!-NTuple{5, Any}","page":"CTDirect.jl","title":"CTDirect.add_nonzero_block!","text":"add_nonzero_block!(M, i_start, i_end, j_start, j_end; sym)\n\n\nAdd block of nonzeros elements to a sparsity pattern  Format: boolean matrix (M) or index vectors (Is, Js)  Includes a more compact method for single element case Option to add the symmetric block also (eg for Hessian) Note: independent from discretization scheme\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.build_bounds-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.build_bounds","text":"build_bounds(\n    dim_var,\n    dim_box,\n    box_triplet\n) -> Tuple{Any, Any}\n\n\nBuild full, ordered sets of bounds for state, control or optimization variables\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.constraints_bounds!-Tuple{CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.constraints_bounds!","text":"constraints_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP nonlinear constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_OCP_control_at_time_step-Tuple{Any, CTDirect.DOCP{<:CTDirect.GenericIRK, <:CTDirect.ScalVect, CTDirect.ScalVariable}, Any}","page":"CTDirect.jl","title":"CTDirect.get_OCP_control_at_time_step","text":"get_OCP_control_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK, <:CTDirect.ScalVect, CTDirect.ScalVariable},\n    i\n) -> Any\n\n\nRetrieve control variables at given time step (/stage) from the NLP variables. Convention: 1 <= i <= dimNLPsteps Scalar / Vector output Step / Stage versions\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_OCP_control_at_time_step-Tuple{Any, CTDirect.DOCP{CTDirect.Midpoint, <:CTDirect.ScalVect, CTDirect.ScalVariable}, Any}","page":"CTDirect.jl","title":"CTDirect.get_OCP_control_at_time_step","text":"get_OCP_control_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{CTDirect.Midpoint, <:CTDirect.ScalVect, CTDirect.ScalVariable},\n    i\n) -> Any\n\n\nRetrieve control variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps(+1), with convention u(tf) = U_N Scalar / Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_OCP_control_at_time_step-Tuple{Any, CTDirect.DOCP{CTDirect.Trapeze, <:CTDirect.ScalVect, CTDirect.ScalVariable}, Any}","page":"CTDirect.jl","title":"CTDirect.get_OCP_control_at_time_step","text":"get_OCP_control_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{CTDirect.Trapeze, <:CTDirect.ScalVect, CTDirect.ScalVariable},\n    i\n) -> Any\n\n\nRetrieve control variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1 Scalar / Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_OCP_state_at_time_step-Tuple{Any, CTDirect.DOCP{<:CTDirect.GenericIRK, CTDirect.ScalVariable}, Any}","page":"CTDirect.jl","title":"CTDirect.get_OCP_state_at_time_step","text":"get_OCP_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK, CTDirect.ScalVariable},\n    i\n) -> Any\n\n\nRetrieve state variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1 Scalar / Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_OCP_state_at_time_step-Tuple{Any, CTDirect.DOCP{CTDirect.Midpoint, CTDirect.ScalVariable}, Any}","page":"CTDirect.jl","title":"CTDirect.get_OCP_state_at_time_step","text":"get_OCP_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{CTDirect.Midpoint, CTDirect.ScalVariable},\n    i\n) -> Any\n\n\nRetrieve state variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1 Scalar / Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_OCP_state_at_time_step-Tuple{Any, CTDirect.DOCP{CTDirect.Trapeze, CTDirect.ScalVariable}, Any}","page":"CTDirect.jl","title":"CTDirect.get_OCP_state_at_time_step","text":"get_OCP_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{CTDirect.Trapeze, CTDirect.ScalVariable},\n    i\n) -> Any\n\n\nRetrieve state variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1 Scalar / Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_lagrange_state_at_time_step-Tuple{Any, CTDirect.DOCP{<:CTDirect.GenericIRK}, Any}","page":"CTDirect.jl","title":"CTDirect.get_lagrange_state_at_time_step","text":"get_lagrange_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    i\n) -> Any\n\n\nRetrieve state variable for lagrange cost at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1   (no check for actual lagrange cost presence !)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_lagrange_state_at_time_step-Tuple{Any, CTDirect.DOCP{CTDirect.Midpoint}, Any}","page":"CTDirect.jl","title":"CTDirect.get_lagrange_state_at_time_step","text":"get_lagrange_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    i\n) -> Any\n\n\nRetrieve state variable for lagrange cost at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_lagrange_state_at_time_step-Tuple{Any, CTDirect.DOCP{CTDirect.Trapeze}, Any}","page":"CTDirect.jl","title":"CTDirect.get_lagrange_state_at_time_step","text":"get_lagrange_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    i\n) -> Any\n\n\nRetrieve state variable for lagrange cost at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_stagevars_at_time_step-Tuple{Any, CTDirect.DOCP{<:CTDirect.GenericIRK}, Any, Any}","page":"CTDirect.jl","title":"CTDirect.get_stagevars_at_time_step","text":"get_stagevars_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    i,\n    j\n) -> Any\n\n\nRetrieve stage variables at given time step/stage from the NLP variables. Convention: 1 <= i <= dimNLPsteps,\t1 <= j <= s Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_stagevars_at_time_step-Tuple{Any, CTDirect.DOCP{CTDirect.Midpoint}, Any, Any}","page":"CTDirect.jl","title":"CTDirect.get_stagevars_at_time_step","text":"get_stagevars_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    i,\n    j\n) -> Any\n\n\nRetrieve stage variables at given time step/stage from the NLP variables. Convention: 1 <= i <= dimNLPsteps,\t1 <= j <= s Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.parse_DOCP_solution_dual-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.parse_DOCP_solution_dual","text":"parse_DOCP_solution_dual(\n    docp,\n    multipliers,\n    constraints\n) -> Tuple{Any, Tuple{Any, Any, Any, Vector{Float64}, Vector{Float64}}, Tuple{Any, Any, Any, Vector{Float64}, Vector{Float64}}}\n\n\nRecover OCP costate and constraints multipliers from DOCP multipliers\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.parse_DOCP_solution_primal-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTDirect.parse_DOCP_solution_primal","text":"parse_DOCP_solution_primal(\n    docp,\n    solution;\n    mult_LB,\n    mult_UB\n) -> Tuple{Any, Any, Any, NTuple{6, Any}}\n\n\nRecover OCP primal variables from DOCP solution\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setPathBounds!-Tuple{CTDirect.DOCP, Int64, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setPathBounds!","text":"setPathBounds!(\n    docp::CTDirect.DOCP,\n    index::Int64,\n    lb,\n    ub\n) -> Int64\n\n\nSet bounds for the path constraints at given time step\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setPathConstraints!-NTuple{7, Any}","page":"CTDirect.jl","title":"CTDirect.setPathConstraints!","text":"setPathConstraints!(docp, c, ti, xi, ui, v, offset) -> Any\n\n\nSet path constraints at given time step\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setPointBounds!-Tuple{CTDirect.DOCP, Int64, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setPointBounds!","text":"setPointBounds!(\n    docp::CTDirect.DOCP,\n    index::Int64,\n    lb,\n    ub\n) -> Int64\n\n\nSet bounds for the boundary and variable constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setPointConstraints!-Tuple{CTDirect.DOCP, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setPointConstraints!","text":"setPointConstraints!(docp::CTDirect.DOCP, c, xu, v) -> Any\n\n\nSet the boundary and variable constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Vararg{Any, 6}}","page":"CTDirect.jl","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps (+1)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Vararg{Any, 6}}","page":"CTDirect.jl","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Vararg{Any, 6}}","page":"CTDirect.jl","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_control_at_time_step!-Tuple{Any, Any, CTDirect.DOCP{<:CTDirect.GenericIRK}, Any}","page":"CTDirect.jl","title":"CTDirect.set_control_at_time_step!","text":"set_control_at_time_step!(\n    xu,\n    u_init,\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    i\n) -> Any\n\n\nSet initial guess for control variables at given time step (/stage) Convention: 1 <= i <= dimNLPsteps+1 Step / stage versions\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_control_at_time_step!-Tuple{Any, Any, CTDirect.DOCP{CTDirect.Midpoint}, Any}","page":"CTDirect.jl","title":"CTDirect.set_control_at_time_step!","text":"set_control_at_time_step!(\n    xu,\n    u_init,\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    i\n) -> Any\n\n\nSet initial guess for control variables at given time step Convention: 1 <= i <= dimNLPsteps\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_control_at_time_step!-Tuple{Any, Any, CTDirect.DOCP{CTDirect.Trapeze}, Any}","page":"CTDirect.jl","title":"CTDirect.set_control_at_time_step!","text":"set_control_at_time_step!(\n    xu,\n    u_init,\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    i\n) -> Any\n\n\nSet initial guess for control variables at given time step Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_optim_variable!-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.set_optim_variable!","text":"set_optim_variable!(xu, v_init, docp) -> Any\n\n\nSet optimization variables in the NLP variables (for initial guess)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_state_at_time_step!-Tuple{Any, Any, CTDirect.DOCP{<:CTDirect.GenericIRK}, Any}","page":"CTDirect.jl","title":"CTDirect.set_state_at_time_step!","text":"set_state_at_time_step!(\n    xu,\n    x_init,\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    i\n) -> Any\n\n\nSet initial guess for state variables at given time step Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_state_at_time_step!-Tuple{Any, Any, CTDirect.DOCP{CTDirect.Midpoint}, Any}","page":"CTDirect.jl","title":"CTDirect.set_state_at_time_step!","text":"set_state_at_time_step!(\n    xu,\n    x_init,\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    i\n) -> Any\n\n\nSet initial guess for state variables at given time step Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_state_at_time_step!-Tuple{Any, Any, CTDirect.DOCP{CTDirect.Trapeze}, Any}","page":"CTDirect.jl","title":"CTDirect.set_state_at_time_step!","text":"set_state_at_time_step!(\n    xu,\n    x_init,\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    i\n) -> Any\n\n\nSet initial guess for state variables at given time step Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.variables_bounds!-Tuple{CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.variables_bounds!","text":"variables_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP variable box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"","category":"page"},{"location":"api-ctbase/description.html#api-ctbase-description","page":"Description","title":"Description","text":"","category":"section"},{"location":"api-ctbase/description.html","page":"Description","title":"Description","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/description.html#Index","page":"Description","title":"Index","text":"","category":"section"},{"location":"api-ctbase/description.html","page":"Description","title":"Description","text":"Pages   = [\"description.md\"]\nModules = [CTBase]\nOrder = [:type, :module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/description.html#Documentation","page":"Description","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/description.html","page":"Description","title":"Description","text":"Modules = [CTBase]\nOrder = [:type, :module, :constant, :function, :macro]\nPages   = [\"description.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/description.html#CTBase.Description","page":"Description","title":"CTBase.Description","text":"A description is a tuple of symbols. Description is a type alias for a tuple of symbols.\n\njulia> const Description = Tuple{DescVarArg}\n\nSee also: DescVarArg.\n\nExample\n\nBase.show is overloaded for descriptions, that is tuple of descriptions are printed as follows:\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/description.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nConcatenate the description y to the tuple of descriptions x if x does not contain y and return the new tuple of descriptions. Throw an error if the description y is already contained in x.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> descriptions = add(descriptions, (:b,))\n(:a,)\n(:b,)\njulia> descriptions = add(descriptions, (:b,))\nERROR: IncorrectArgument: the description (:b,) is already in ((:a,), (:b,))\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/description.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> print(descriptions)\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/description.html#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"Description","title":"CTBase.getFullDescription","text":"getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn a complete description from an incomplete description desc and  a list of complete descriptions desc_list. If several complete descriptions are possible,  then the first one is returned.\n\nExample\n\njulia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n(:a, :b)\n(:b, :c)\n(:a, :c)\njulia> getFullDescription((:a,), desc_list)\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/description.html#CTBase.remove-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.remove","text":"remove(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn the difference between the description x and the description y.\n\nExample\n\njulia> remove((:a, :b), (:a,))\n(:b,)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/description.html","page":"Description","title":"Description","text":"","category":"page"},{"location":"tutorial-continuation.html#Discrete-continuation","page":"Discrete continuation","title":"Discrete continuation","text":"","category":"section"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Using the warm start option, it is easy to implement a basic discrete continuation method, where a sequence of problems is solved using each solution as initial guess for the next problem. This usually gives better and faster convergence than solving each problem with the same initial guess, and is a way to handle problems that require a good initial guess.","category":"page"},{"location":"tutorial-continuation.html#Continuation-on-parametric-OCP","page":"Discrete continuation","title":"Continuation on parametric OCP","text":"","category":"section"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"The most compact syntax to perform a discrete continuation is to use a function that returns the OCP for a given value of the continuation parameter, and solve a sequence of these problems. We illustrate this on a very basic double integrator with increasing fixed final time.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"First we load the required packages","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Printf\nusing Plots","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"and write a function that returns the OCP for a given final time","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"function ocp_T(T)\n    ocp = @def begin\n        t ∈ [0, T], time\n        x ∈ R², state\n        u ∈ R, control\n        q = x₁\n        v = x₂\n        q(0) == 0\n        v(0) == 0\n        q(T) == 1\n        v(T) == 0\n        ẋ(t) == [ v(t), u(t) ]\n        ∫(u(t)^2) → min\n    end\n    return ocp\nend\nnothing # hide","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Then we perform the continuation with a simple for loop, using each solution to initialize the next problem.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"init1 = ()\nfor T=1:5\n    ocp1 = ocp_T(T) \n    sol1 = solve(ocp1; display=false, init=init1)\n    global init1 = sol1\n    @printf(\"T %.2f objective %9.6f iterations %d\\n\", T, sol1.objective, sol1.iterations)\nend","category":"page"},{"location":"tutorial-continuation.html#Continuation-on-global-variable","page":"Discrete continuation","title":"Continuation on global variable","text":"","category":"section"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"As a second example, we show how to avoid redefining a new OCP each time, and modify the original one instead. More precisely we now solve a Goddard problem for a decreasing maximal thrust. If we store the value for Tmax in a global variable, we can simply modify this variable and keep the same OCP problem during the continuation.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Let us first define the Goddard problem (note that the formulation below illustrates all the possible constraints types, and the problem could be defined in a more compact way).","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Cd = 310\nTmax = 3.5\nβ = 500\nb = 2\nfunction F0(x)\n    r, v, m = x\n    D = Cd * v^2 * exp(-β*(r - 1))\n    return [ v, -D/m - 1/r^2, 0 ]\nend\nfunction F1(x)\n    r, v, m = x\n    return [ 0, Tmax/m, -b*Tmax ]\nend\nr0 = 1\nv0 = 0\nm0 = 1\nmf = 0.6\nx0 = [r0, v0, m0]\nvmax = 0.1\n\n@def ocp begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x ∈ R^3, state\n    u ∈ R, control\n    0.01 ≤ tf ≤ Inf\n    r = x[1]\n    v = x[2]\n    m = x[3]\n    x(0) == x0\n    m(tf) == mf\n    r0 ≤ r(t) ≤ r0 + 0.1\n    v0 ≤ v(t) ≤ vmax\n    mf ≤ m(t) ≤ m0\n    0 ≤ u(t) ≤ 1\n    ẋ(t) == F0(x(t)) + u(t) * F1(x(t))\n    r(tf) → max\nend\n\nsol0 = solve(ocp; display=false)\n@printf(\"Objective for reference solution %.6f\\n\", objective(sol0))","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Then we perform the continuation on the maximal thrust.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"sol       = sol0\nTmax_list = []\nobj_list  = []\nfor Tmax_local=3.5:-0.5:1\n    global Tmax = Tmax_local  \n    global sol = solve(ocp; display=false, init=sol)\n    @printf(\"Tmax %.2f objective %.6f iterations %d\\n\", Tmax, objective(sol), iterations(sol))\n    push!(Tmax_list, Tmax)\n    push!(obj_list, objective(sol))\nend ","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"We plot now the objective w.r.t the maximal thrust, as well as both solutions for Tmax=3.5 and Tmax=1.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"using Plots.PlotMeasures # for leftmargin\n\nplt_obj = plot(Tmax_list, obj_list;\n    seriestype=:scatter,\n    title=\"Goddard problem\",\n    label=\"r(tf)\", \n    xlabel=\"Maximal thrust (Tmax)\",\n    ylabel=\"Maximal altitude r(tf)\")\n\nplt_sol = plot(sol0; solution_label=\"(Tmax = \"*string(Tmax_list[1])*\")\")\nplot!(plt_sol, sol;  solution_label=\"(Tmax = \"*string(Tmax_list[end])*\")\")\n\nlayout = grid(2, 1, heights=[0.2, 0.8])\nplot(plt_obj, plt_sol; layout=layout, size=(800, 1000), leftmargin=5mm)","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"","category":"page"},{"location":"api-ctbase/plot.html#api-ctbase-plot","page":"Plot","title":"Plot","text":"","category":"section"},{"location":"api-ctbase/plot.html","page":"Plot","title":"Plot","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/plot.html","page":"Plot","title":"Plot","text":"Modules = [CTBase]\nOrder = [:type, :module, :constant, :function, :macro]\nPages   = [\"plot.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/plot.html","page":"Plot","title":"Plot","text":"","category":"page"},{"location":"api-ctbase/diffgeometry.html#api-ctbase-differential-geometry","page":"Differential geometry","title":"Differential geometry","text":"","category":"section"},{"location":"api-ctbase/diffgeometry.html","page":"Differential geometry","title":"Differential geometry","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/diffgeometry.html#Index","page":"Differential geometry","title":"Index","text":"","category":"section"},{"location":"api-ctbase/diffgeometry.html","page":"Differential geometry","title":"Differential geometry","text":"Pages   = [\"diffgeometry.md\"]\nModules = [CTBase]\nOrder = [:type, :module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/diffgeometry.html#Documentation","page":"Differential geometry","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/diffgeometry.html","page":"Differential geometry","title":"Differential geometry","text":"Modules = [CTBase]\nOrder = [:type, :module, :constant, :function, :macro]\nPages   = [\"differential_geometry.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/diffgeometry.html#CTBase.:⋅-Tuple{Function, Function}","page":"Differential geometry","title":"CTBase.:⋅","text":"⋅(\n    X::Function,\n    f::Function\n) -> CTBase.var\"#168#170\"{VectorField{var\"#s182\", Autonomous, Fixed}, <:Function} where var\"#s182\"<:Function\n\n\nLie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.:⋅-Tuple{VectorField{<:Function, Autonomous}, Function}","page":"Differential geometry","title":"CTBase.:⋅","text":"⋅(\n    X::VectorField{<:Function, Autonomous},\n    f::Function\n) -> CTBase.var\"#168#170\"{VectorField{var\"#s285\", Autonomous, var\"#s284\"}, <:Function} where {var\"#s285\"<:Function, var\"#s284\"<:VariableDependence}\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in autonomous case\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.:⋅-Tuple{VectorField{<:Function, NonAutonomous}, Function}","page":"Differential geometry","title":"CTBase.:⋅","text":"⋅(\n    X::VectorField{<:Function, NonAutonomous},\n    f::Function\n) -> CTBase.var\"#172#174\"{VectorField{var\"#s285\", NonAutonomous, var\"#s284\"}, <:Function} where {var\"#s285\"<:Function, var\"#s284\"<:VariableDependence}\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in nonautonomous case\n\nExample\n\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lie-Tuple{Function, Function}","page":"Differential geometry","title":"CTBase.Lie","text":"Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Union{CTBase.var\"#168#170\"{VectorField{var\"#s285\", Autonomous, var\"#s284\"}, <:Function} where {var\"#s285\"<:Function, var\"#s284\"<:VariableDependence}, CTBase.var\"#172#174\"{VectorField{var\"#s285\", NonAutonomous, var\"#s284\"}, <:Function} where {var\"#s285\"<:Function, var\"#s284\"<:VariableDependence}}\n\n\nLie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lie-Tuple{VectorField, Function}","page":"Differential geometry","title":"CTBase.Lie","text":"Lie(\n    X::VectorField,\n    f::Function\n) -> Union{CTBase.var\"#168#170\"{VectorField{var\"#s285\", Autonomous, var\"#s284\"}, <:Function} where {var\"#s285\"<:Function, var\"#s284\"<:VariableDependence}, CTBase.var\"#172#174\"{VectorField{var\"#s285\", NonAutonomous, var\"#s284\"}, <:Function} where {var\"#s285\"<:Function, var\"#s284\"<:VariableDependence}}\n\n\nLie derivative of a scalar function along a vector field.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{<:Function, Autonomous, V}, VectorField{<:Function, Autonomous, V}}} where V<:VariableDependence","page":"Differential geometry","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{<:Function, Autonomous, V<:VariableDependence},\n    Y::VectorField{<:Function, Autonomous, V<:VariableDependence}\n) -> Any\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case\n\nExample\n\njulia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{<:Function, NonAutonomous, V}, VectorField{<:Function, NonAutonomous, V}}} where V<:VariableDependence","page":"Differential geometry","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{<:Function, NonAutonomous, V<:VariableDependence},\n    Y::VectorField{<:Function, NonAutonomous, V<:VariableDependence}\n) -> Any\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case\n\nExample\n\njulia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lift-Tuple{Function}","page":"Differential geometry","title":"CTBase.Lift","text":"Lift(\n    X::Function;\n    autonomous,\n    variable\n) -> CTBase.var\"#160#164\"{<:Function}\n\n\nReturn the Lift of a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lift-Tuple{VectorField}","page":"Differential geometry","title":"CTBase.Lift","text":"Lift(\n    X::VectorField\n) -> HamiltonianLift{VectorField{TF, TD, VD}} where {TF<:Function, TD<:TimeDependence, VD<:VariableDependence}\n\n\nReturn the HamiltonianLift of a VectorField.\n\nExample\n\njulia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Tuple{Function, Function}","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Union{Tuple{VD}, Tuple{TD}, Tuple{AbstractHamiltonian{TD, VD}, Function}} where {TD<:TimeDependence, VD<:VariableDependence}","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{TD<:TimeDependence, VD<:VariableDependence},\n    g::Function\n) -> Hamiltonian\n\n\nPoisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Union{Tuple{VD}, Tuple{TD}, Tuple{Function, AbstractHamiltonian{TD, VD}}} where {TD<:TimeDependence, VD<:VariableDependence}","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::AbstractHamiltonian{TD<:TimeDependence, VD<:VariableDependence}\n) -> Hamiltonian\n\n\nPoisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{Autonomous, V}, AbstractHamiltonian{Autonomous, V}}} where V<:VariableDependence","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{Autonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{Autonomous, V<:VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{NonAutonomous, V}, AbstractHamiltonian{NonAutonomous, V}}} where V<:VariableDependence","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{NonAutonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{NonAutonomous, V<:VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case\n\nExample\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::HamiltonianLift{T<:TimeDependence, V<:VariableDependence},\n    g::HamiltonianLift{T<:TimeDependence, V<:VariableDependence}\n)\n\n\nPoisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.∂ₜ-Tuple{Any}","page":"Differential geometry","title":"CTBase.∂ₜ","text":"∂ₜ(f) -> CTBase.var\"#177#179\"\n\n\nPartial derivative wrt time of a function.\n\nExample\n\njulia> ∂ₜ((t,x) -> t*x)(0,8)\n8\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.@Lie-Tuple{Expr, Any, Any}","page":"Differential geometry","title":"CTBase.@Lie","text":"Macros for Poisson brackets\n\nExample\n\njulia> H0 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7]) autonomous=true variable=false\n#\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false variable=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) autonomous=true variable=true\n#\njulia> H0 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2) autonomous=false variable=true\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase/diffgeometry.html#CTBase.@Lie-Tuple{Expr, Any}","page":"Differential geometry","title":"CTBase.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) variable=true\n#\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase/diffgeometry.html#CTBase.@Lie-Tuple{Expr}","page":"Differential geometry","title":"CTBase.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\n#\njulia> F0 = VectorField((t, x) -> [t+x[1], x[2], (1-x[3])], autonomous=false)\njulia> F1 = VectorField((t, x) -> [t, -x[3], x[2]], autonomous=false)\njulia> @Lie [F0, F1](1, [1, 2, 3])\n#\njulia> F0 = VectorField((x, v) -> [x[1]+v, x[2], (1-x[3])], variable=true)\njulia> F1 = VectorField((x, v) -> [0, -x[3]-v, x[2]], variable=true)\njulia> @Lie [F0, F1]([1, 2, 3], 2)\n#\njulia> F0 = VectorField((t, x, v) -> [t+x[1]+v, x[2], (1-x[3])], autonomous=false, variable=true)\njulia> F1 = VectorField((t, x, v) -> [t, -x[3]-v, x[2]], autonomous=false, variable=true)\njulia> @Lie [F0, F1](1, [1, 2, 3], 2)\n#\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7])\n3.0\n#\njulia> H0 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2), autonomous=false)\njulia> H1 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2), autonomous=false)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7])\n#\njulia> H0 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), variable=true)\njulia> H1 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), variable=true)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2)\n#\njulia> H0 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), autonomous=false, variable=true)\njulia> H1 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), autonomous=false, variable=true)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2)\n#\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase/diffgeometry.html","page":"Differential geometry","title":"Differential geometry","text":"","category":"page"},{"location":"api-ctbase/exceptions.html#api-ctbase-exceptions","page":"Exceptions","title":"Exceptions","text":"","category":"section"},{"location":"api-ctbase/exceptions.html","page":"Exceptions","title":"Exceptions","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/exceptions.html#Index","page":"Exceptions","title":"Index","text":"","category":"section"},{"location":"api-ctbase/exceptions.html","page":"Exceptions","title":"Exceptions","text":"Pages   = [\"exceptions.md\"]\nModules = [CTBase]\nOrder = [:type, :module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/exceptions.html#Documentation","page":"Exceptions","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/exceptions.html","page":"Exceptions","title":"Exceptions","text":"Modules = [CTBase]\nOrder = [:type, :module, :constant, :function, :macro]\nPages = [\"exception.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/exceptions.html#CTBase.AmbiguousDescription","page":"Exceptions","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTException\n\nException thrown when the description is ambiguous / incorrect.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/exceptions.html#CTBase.CTException","page":"Exceptions","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract type for exceptions.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/exceptions.html#CTBase.ExtensionError","page":"Exceptions","title":"CTBase.ExtensionError","text":"mutable struct ExtensionError <: CTException\n\nException thrown when an extension is not loaded but the user tries to call a function of it.\n\nFields\n\nweakdeps::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/exceptions.html#CTBase.IncorrectArgument","page":"Exceptions","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTException\n\nException thrown when an argument is inconsistent.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/exceptions.html#CTBase.IncorrectMethod","page":"Exceptions","title":"CTBase.IncorrectMethod","text":"struct IncorrectMethod <: CTException\n\nException thrown when a method is incorrect.\n\nFields\n\nvar::Symbol\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/exceptions.html#CTBase.IncorrectOutput","page":"Exceptions","title":"CTBase.IncorrectOutput","text":"struct IncorrectOutput <: CTException\n\nException thrown when the output is incorrect.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/exceptions.html#CTBase.NotImplemented","page":"Exceptions","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTException\n\nException thrown when a method is not implemented.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/exceptions.html#CTBase.ParsingError","page":"Exceptions","title":"CTBase.ParsingError","text":"struct ParsingError <: CTException\n\nException thrown for syntax error during abstract parsing.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/exceptions.html#CTBase.UnauthorizedCall","page":"Exceptions","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTException\n\nException thrown when a call to a function is not authorized.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/exceptions.html","page":"Exceptions","title":"Exceptions","text":"","category":"page"},{"location":"api-ctbase/print.html#api-ctbase-print","page":"Print","title":"Print","text":"","category":"section"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"Modules = [CTBase]\nOrder = [:type, :module, :constant, :function, :macro]\nPages   = [\"print.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/print.html#Examples","page":"Print","title":"Examples","text":"","category":"section"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"An optimal control problem can be described as minimising the cost functional","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"g(t_0 x(t_0) t_f x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"and other constraints such as","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"Let us define the following optimal control problem.","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"using OptimalControl\n\nocp = Model()\n\nstate!(ocp, 2, \"x\", [\"r\", \"v\"]) # dimension of the state with the names of the components\ncontrol!(ocp, 1)           # dimension of the control\ntime!(ocp, t0=0, tf=1, name=\"s\")    # initial and final time, with the name of the variable time\n\nconstraint!(ocp, :initial, lb=[-1, 0], ub=[-1, 0])\nconstraint!(ocp, :final  , lb=[ 0, 0], ub=[ 0, 0])\nA = [ 0 1\n      0 0 ]\nB = [ 0\n      1 ]\ndynamics!(ocp, (x, u) -> A*x + B*u)\n\nobjective!(ocp, :lagrange, (x, u) -> 0.5u^2)","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"Then, we can print the form of this optimal control problem:","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"ocp","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"You can also define the optimal control problem in an abstract form:","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"using OptimalControl\n\nocp = @def begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R^2, state\n    u ∈ R, control\n    x(0) == [ -1, 0 ], (1)\n    x(1) == [  0, 0 ]\n    ẋ(t) == A * x(t) + B * u(t)\n    ∫( 0.5u(t)^2 ) → min\nend\nA = [ 0 1\n      0 0 ]\nB = [ 0\n      1 ]\nnothing #hide","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"Then, you can print this optimal control problem:","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"ocp","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"","category":"page"},{"location":"dev-ctbase.html#dev-ctbase","page":"CTBase.jl","title":"CTBase.jl private functions","text":"","category":"section"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-ctbase.html#Index","page":"CTBase.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Pages   = [\"dev-ctbase.md\"]\nModules = [CTBase]\nOrder   = [:type, :module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctbase.html#Documentation","page":"CTBase.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Modules = [CTBase]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-ctbase.html#CTBase.DescVarArg","page":"CTBase.jl","title":"CTBase.DescVarArg","text":"DescVarArg is a Vararg of symbols. DescVarArg is a type alias for a Vararg of symbols.\n\njulia> const DescVarArg = Vararg{Symbol}\n\nSee also: Description.\n\n\n\n\n\n","category":"constant"},{"location":"dev-ctbase.html#CTBase.RangeConstraint","page":"CTBase.jl","title":"CTBase.RangeConstraint","text":"Type alias for an index or range.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.AbstractOptimalControlModel","page":"CTBase.jl","title":"CTBase.AbstractOptimalControlModel","text":"abstract type AbstractOptimalControlModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.AbstractOptimalControlSolution","page":"CTBase.jl","title":"CTBase.AbstractOptimalControlSolution","text":"abstract type AbstractOptimalControlSolution\n\nAbstract type for optimal control solutions.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.AbstractVectorField","page":"CTBase.jl","title":"CTBase.AbstractVectorField","text":"abstract type AbstractVectorField{TD<:TimeDependence, VD<:VariableDependence}\n\nAbstract type for vector fields.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.ParsingInfo","page":"CTBase.jl","title":"CTBase.ParsingInfo","text":"mutable struct ParsingInfo\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, OptimalControlModel}","page":"CTBase.jl","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::OptimalControlModel\n)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, OptimalControlSolution}","page":"CTBase.jl","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    sol::OptimalControlSolution\n)\n\n\nPrints the solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"CTBase.jl","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    descriptions::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n)\n\n\nPrint a tuple of descriptions.\n\nExample\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, AmbiguousDescription}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::AmbiguousDescription)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, ExtensionError}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::ExtensionError)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, IncorrectArgument}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectArgument)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, IncorrectMethod}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectMethod)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, IncorrectOutput}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectOutput)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, NotImplemented}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::NotImplemented)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, ParsingError}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::ParsingError)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, UnauthorizedCall}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::UnauthorizedCall)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.:⅋-Union{Tuple{V}, Tuple{VectorField{<:Function, Autonomous, V}, VectorField{<:Function, Autonomous, V}}} where V<:VariableDependence","page":"CTBase.jl","title":"CTBase.:⅋","text":"⅋(\n    X::VectorField{<:Function, Autonomous, V<:VariableDependence},\n    Y::VectorField{<:Function, Autonomous, V<:VariableDependence}\n) -> Any\n\n\n\"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, autonomous case\n\nExample\n\njulia> X = VectorField(x -> [x[2], -x[1]])\njulia> Y = VectorField(x -> [x[1], x[2]])\njulia> CTBase.:(⅋)(X, Y)([1, 2])\n[2, -1]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.:⅋-Union{Tuple{V}, Tuple{VectorField{<:Function, NonAutonomous, V}, VectorField{<:Function, NonAutonomous, V}}} where V<:VariableDependence","page":"CTBase.jl","title":"CTBase.:⅋","text":"⅋(\n    X::VectorField{<:Function, NonAutonomous, V<:VariableDependence},\n    Y::VectorField{<:Function, NonAutonomous, V<:VariableDependence}\n) -> Any\n\n\n\"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, nonautonomous case\n\nExample\n\njulia> X = VectorField((t, x, v) -> [t + v[1] + v[2] + x[2], -x[1]], NonFixed, NonAutonomous)\njulia> Y = VectorField((t, x, v) ->  [v[1] + v[2] + x[1], x[2]], NonFixed, NonAutonomous)\njulia> CTBase.:(⅋)(X, Y)(1, [1, 2], [2, 3])\n[8, -1]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__OptimalControlSolution-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__OptimalControlSolution","text":"__OptimalControlSolution(\n    ocp::OptimalControlModel;\n    state,\n    control,\n    objective,\n    costate,\n    time_grid,\n    variable,\n    iterations,\n    stopping,\n    message,\n    success,\n    infos,\n    boundary_constraints,\n    mult_boundary_constraints,\n    variable_constraints,\n    mult_variable_constraints,\n    mult_variable_box_lower,\n    mult_variable_box_upper,\n    control_constraints,\n    mult_control_constraints,\n    state_constraints,\n    mult_state_constraints,\n    mixed_constraints,\n    mult_mixed_constraints,\n    mult_state_box_lower,\n    mult_state_box_upper,\n    mult_control_box_lower,\n    mult_control_box_upper\n) -> OptimalControlSolution\n\n\nConstructor from an optimal control problem. Internal.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__callbacks-Tuple{}","page":"CTBase.jl","title":"CTBase.__callbacks","text":"__callbacks() -> Tuple{}\n\n\nUsed to set the default value of the callbacks argument. The default value is (), which means that no additional callback is given.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_all_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__check_all_set","text":"__check_all_set(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Bool}\n\n\nCheck if the parameters of an ocp are set.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_control_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__check_control_set","text":"__check_control_set(ocp::OptimalControlModel) -> Bool\n\n\nThrow UnauthorizedCall exception if the control of an ocp is not set.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_dependencies-Tuple{Tuple{Vararg{DataType}}}","page":"CTBase.jl","title":"CTBase.__check_dependencies","text":"__check_dependencies(\n    dependencies::Tuple{Vararg{DataType}}\n) -> Bool\n\n\nThrow IncorrectArgument exception if dependencies arguments are incorrect.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_is_time_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__check_is_time_set","text":"__check_is_time_set(ocp::OptimalControlModel) -> Bool\n\n\nThrow UnauthorizedCall exception if the time of an ocp is not set.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_state_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__check_state_set","text":"__check_state_set(ocp::OptimalControlModel) -> Bool\n\n\nThrow UnauthorizedCall exception if the state of an ocp is not set.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_variable_set-Tuple{OptimalControlModel{<:TimeDependence, Fixed}}","page":"CTBase.jl","title":"CTBase.__check_variable_set","text":"__check_variable_set(\n    ocp::OptimalControlModel{<:TimeDependence, Fixed}\n)\n\n\nDo nothing, no variable for fixed ocp.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_variable_set-Tuple{OptimalControlModel{<:TimeDependence, NonFixed}}","page":"CTBase.jl","title":"CTBase.__check_variable_set","text":"__check_variable_set(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed}\n) -> Bool\n\n\nThrow UnauthorizedCall exception if the variable of an ocp is not set.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__constraint_label-Tuple{}","page":"CTBase.jl","title":"CTBase.__constraint_label","text":"__constraint_label() -> Symbol\n\n\nUsed to set the default value of the label of a constraint. A unique value is given to each constraint using the gensym function and prefixing by :unamed.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__control_components_names-Tuple{Int64, String}","page":"CTBase.jl","title":"CTBase.__control_components_names","text":"__control_components_names(\n    m::Int64,\n    name::String\n) -> Vector{String}\n\n\nUsed to set the default value of the names of the controls. The default value is [\"u\"] for a one dimensional control, and [\"u₁\", \"u₂\", ...] for a multi dimensional control.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__control_name-Tuple{}","page":"CTBase.jl","title":"CTBase.__control_name","text":"__control_name() -> String\n\n\nUsed to set the default value of the names of the control. The default value is \"u\".\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__criterion_type-Tuple{}","page":"CTBase.jl","title":"CTBase.__criterion_type","text":"__criterion_type() -> Symbol\n\n\nUsed to set the default value of the type of criterion. Either :min or :max. The default value is :min. The other possible criterion type is :max.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__display-Tuple{}","page":"CTBase.jl","title":"CTBase.__display","text":"__display() -> Bool\n\n\nUsed to set the default value of the display argument. The default value is true, which means that the output is printed during resolution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__fun_time_dependence-Tuple{}","page":"CTBase.jl","title":"CTBase.__fun_time_dependence","text":"__fun_time_dependence() -> Type{Autonomous}\n\n\nUsed to set the default value of the time dependence of the functions.\n\nThe default value is Autonomous, which means that the functions are considered time independent. The other possible time dependence is NonAutonomous, which means that the functions are considered time dependent.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__fun_variable_dependence-Tuple{}","page":"CTBase.jl","title":"CTBase.__fun_variable_dependence","text":"__fun_variable_dependence() -> Type{Fixed}\n\n\nUsed to set the default value of the variable dependence of the functions.\n\nThe default value is Fixed, which means that the functions are considered variable independent. The other possible variable dependence is NonFixed, which means that the functions are considered variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__get_AD_backend-Tuple{}","page":"CTBase.jl","title":"CTBase.__get_AD_backend","text":"__get_AD_backend(\n\n) -> ADTypes.AutoForwardDiff{nothing, Nothing}\n\n\nUsed to set the default value of Automatic Differentiation backend.\n\nThe default value is AutoForwardDiff(), that is the ForwardDiff package is used by default.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__init_interpolation-Tuple{}","page":"CTBase.jl","title":"CTBase.__init_interpolation","text":"__init_interpolation() -> CTBase.var\"#7#8\"\n\n\nUsed to set the default interpolation function used for initialisation. The default value is Interpolations.linear_interpolation, which means that the initial guess is linearly interpolated.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_complete-Tuple{Any}","page":"CTBase.jl","title":"CTBase.__is_complete","text":"__is_complete(ocp) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_control_not_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__is_control_not_set","text":"__is_control_not_set(ocp::OptimalControlModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_control_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__is_control_set","text":"__is_control_set(ocp::OptimalControlModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_criterion_valid-Tuple{Symbol}","page":"CTBase.jl","title":"CTBase.__is_criterion_valid","text":"__is_criterion_valid(criterion::Symbol) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_dynamics_not_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__is_dynamics_not_set","text":"__is_dynamics_not_set(ocp::OptimalControlModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_dynamics_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__is_dynamics_set","text":"__is_dynamics_set(ocp::OptimalControlModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_empty-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__is_empty","text":"__is_empty(ocp::OptimalControlModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_final_time_free-Tuple{Any}","page":"CTBase.jl","title":"CTBase.__is_final_time_free","text":"__is_final_time_free(ocp) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_incomplete-Tuple{Any}","page":"CTBase.jl","title":"CTBase.__is_incomplete","text":"__is_incomplete(ocp) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_initial_time_free-Tuple{Any}","page":"CTBase.jl","title":"CTBase.__is_initial_time_free","text":"__is_initial_time_free(ocp) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_objective_not_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__is_objective_not_set","text":"__is_objective_not_set(ocp::OptimalControlModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_objective_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__is_objective_set","text":"__is_objective_set(ocp::OptimalControlModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_state_not_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__is_state_not_set","text":"__is_state_not_set(ocp::OptimalControlModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_state_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__is_state_set","text":"__is_state_set(ocp::OptimalControlModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_time_not_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__is_time_not_set","text":"__is_time_not_set(ocp::OptimalControlModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_time_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__is_time_set","text":"__is_time_set(ocp::OptimalControlModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_variable_not_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__is_variable_not_set","text":"__is_variable_not_set(ocp::OptimalControlModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__is_variable_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__is_variable_set","text":"__is_variable_set(ocp::OptimalControlModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__matrix_dimension_stock-Tuple{}","page":"CTBase.jl","title":"CTBase.__matrix_dimension_stock","text":"__matrix_dimension_stock() -> Int64\n\n\nUsed to set the default value of the stockage of elements in a matrix. The default value is 1.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__ocp_init-Tuple{}","page":"CTBase.jl","title":"CTBase.__ocp_init","text":"__ocp_init()\n\n\nUsed to set the default initial guess. The default value is nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__ocp_time_dependence-Tuple{}","page":"CTBase.jl","title":"CTBase.__ocp_time_dependence","text":"__ocp_time_dependence() -> Type{Autonomous}\n\n\nUsed to set the default value of the time dependence of the Optimal Control Problem. The default value is Autonomous, which means that the Optimal Control Problem is considered time independent. The other possible time dependence is NonAutonomous, which means that all the functions used to define the  Optimal Control Problem are considered time dependent.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__ocp_variable_dependence-Tuple{}","page":"CTBase.jl","title":"CTBase.__ocp_variable_dependence","text":"__ocp_variable_dependence() -> Type{Fixed}\n\n\nUsed to set the default value of the variable dependence of the Optimal Control Problem. The default value is Fixed, which means that the Optimal Control Problem is considered variable independent. The other possible variable dependence is NonFixed, which means that all the functions used to define the Optimal Control Problem are considered variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__state_components_names-Tuple{Int64, String}","page":"CTBase.jl","title":"CTBase.__state_components_names","text":"__state_components_names(\n    n::Int64,\n    name::String\n) -> Vector{String}\n\n\nUsed to set the default value of the names of the states. The default value is [\"x\"] for a one dimensional state, and [\"x₁\", \"x₂\", ...] for a multi dimensional state.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__state_name-Tuple{}","page":"CTBase.jl","title":"CTBase.__state_name","text":"__state_name() -> String\n\n\nUsed to set the default value of the name of the state. The default value is \"x\".\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__time_name-Tuple{}","page":"CTBase.jl","title":"CTBase.__time_name","text":"__time_name() -> String\n\n\nUsed to set the default value of the name of the time. The default value is t.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__variable_components_names-Tuple{Int64, String}","page":"CTBase.jl","title":"CTBase.__variable_components_names","text":"__variable_components_names(\n    q::Int64,\n    name::String\n) -> Vector{String}\n\n\nUsed to set the default value of the names of the variables. The default value is [\"v\"] for a one dimensional variable, and [\"v₁\", \"v₂\", ...] for a multi dimensional variable.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__variable_name-Tuple{}","page":"CTBase.jl","title":"CTBase.__variable_name","text":"__variable_name() -> String\n\n\nUsed to set the default value of the names of the variables. The default value is \"v\".\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.buildFunctionalInit-Tuple{Any, Any, Any}","page":"CTBase.jl","title":"CTBase.buildFunctionalInit","text":"buildFunctionalInit(data, time, dim) -> CTBase.var\"#289#290\"\n\n\nBuild functional initialization: general interpolation case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.buildFunctionalInit-Tuple{Function, Any, Any}","page":"CTBase.jl","title":"CTBase.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Function,\n    time,\n    dim\n) -> CTBase.var\"#291#292\"{<:Function}\n\n\nBuild functional initialization: function case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.buildFunctionalInit-Tuple{Nothing, Any, Any}","page":"CTBase.jl","title":"CTBase.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Nothing,\n    time,\n    dim\n) -> CTBase.var\"#289#290\"\n\n\nBuild functional initialization: default case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.buildFunctionalInit-Tuple{Union{Real, AbstractVector{<:Real}}, Any, Any}","page":"CTBase.jl","title":"CTBase.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Union{Real, AbstractVector{<:Real}},\n    time,\n    dim\n) -> Union{CTBase.var\"#293#295\", CTBase.var\"#294#296\"}\n\n\nBuild functional initialization: constant / 1D interpolation\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.buildVectorInit-Tuple{Any, Any}","page":"CTBase.jl","title":"CTBase.buildVectorInit","text":"buildVectorInit(data, dim) -> Any\n\n\nBuild vector initialization: default / vector case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.checkDim-Tuple{Any, Any}","page":"CTBase.jl","title":"CTBase.checkDim","text":"checkDim(actual_dim, target_dim)\n\n\nCheck if actual dimension is equal to target dimension, error otherwise\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.ctindice-Tuple{Int64}","page":"CTBase.jl","title":"CTBase.ctindice","text":"ctindice(i::Int64) -> Char\n\n\nReturn i ∈ [0, 9] as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.ctupperscript-Tuple{Int64}","page":"CTBase.jl","title":"CTBase.ctupperscript","text":"ctupperscript(i::Int64) -> Char\n\n\nReturn i ∈ [0, 9] as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.expand-Tuple{Matrix{<:Real}}","page":"CTBase.jl","title":"CTBase.expand","text":"expand(x::Matrix{<:Real}) -> Vector{<:Real}\n\n\nReturn expand(matrix2vec(x, 1))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.expand-Tuple{Vector{<:Real}}","page":"CTBase.jl","title":"CTBase.expand","text":"expand(x::Vector{<:Real}) -> Vector{<:Real}\n\n\nReturn x.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.expand-Tuple{Vector{<:Vector{<:Real}}}","page":"CTBase.jl","title":"CTBase.expand","text":"expand(x::Vector{<:Vector{<:Real}}) -> Vector{<:Real}\n\n\nEquivalent to vec2vec(x)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.expr_it-Tuple{Any, Any, Any}","page":"CTBase.jl","title":"CTBase.expr_it","text":"expr_it(e, _Expr, f) -> Any\n\n\nExpr iterator: apply _Expr to nodes and f to leaves of the AST.\n\nExample\n\njulia> id(e) = expr_it(e, Expr, x -> x)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.formatData-Tuple{Any}","page":"CTBase.jl","title":"CTBase.formatData","text":"formatData(data) -> Any\n\n\nConvert matrix to vector of vectors (could be expanded)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.formatTimeGrid-Tuple{Any}","page":"CTBase.jl","title":"CTBase.formatTimeGrid","text":"formatTimeGrid(time) -> Any\n\n\nConvert matrix time-grid to vector\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.has-Tuple{Any, Any, Any}","page":"CTBase.jl","title":"CTBase.has","text":"has(e, x, t) -> Union{Missing, Bool}\n\n\nReturn true if e contains a (...x...)(t) call.\n\nExample\n\njulia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, :x, :t)\ntrue\n\njulia> has(e, :u, :t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.has-Tuple{Any, Any}","page":"CTBase.jl","title":"CTBase.has","text":"has(e, e1) -> Union{Missing, Bool}\n\n\nReturn true if e contains e1.\n\nExample\n\njulia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, 2)\ntrue\n\njulia> has(e, :x)\ntrue\n\njulia> has(e, :min)\ntrue\n\njulia> has(e, :( x[1](t)^2 ))\ntrue\n\njulia> !has(e, :( x[1](t)^3 ))\ntrue\n\njulia> !has(e, 3)\ntrue\n\njulia> !has(e, :max)\ntrue\n\njulia> has(:x, :x)\ntrue\n\njulia> !has(:x, 2)\ntrue\n\njulia> !has(:x, :y)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.isaVectVect-Tuple{Any}","page":"CTBase.jl","title":"CTBase.isaVectVect","text":"isaVectVect(data) -> Bool\n\n\nReturn true if argument is a vector of vectors\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.matrix2vec","page":"CTBase.jl","title":"CTBase.matrix2vec","text":"matrix2vec(x::Matrix{<:Real}) -> Vector{<:Vector{<:Real}}\nmatrix2vec(\n    x::Matrix{<:Real},\n    dim::Int64\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms x to a Vector{<:Vector{<:ctNumber}}.\n\nNote. dim ∈ {1, 2} is the dimension along which the matrix is transformed.\n\n\n\n\n\n","category":"function"},{"location":"dev-ctbase.html#CTBase.parse!-Tuple{Any, Any, Any}","page":"CTBase.jl","title":"CTBase.parse!","text":"parse!(p, ocp, e; log) -> Union{Expr, LineNumberNode}\n\n\nParse the expression e and update the ParsingInfo structure p.\n\nExample\n\nparse!(p, :ocp, :(v ∈ R, variable))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.subs-Tuple{Any, Union{Real, Symbol}, Any}","page":"CTBase.jl","title":"CTBase.subs","text":"subs(e, e1::Union{Real, Symbol}, e2) -> Any\n\n\nSubstitute expression e1 by expression e2 in expression e.\n\nExamples\n\njulia> e = :( ∫( r(t)^2 + 2u₁(t)) → min )\n:(∫(r(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> subs(e, :r, :( x[1] ))\n:(∫((x[1])(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> e = :( ∫( u₁(t)^2 + 2u₂(t)) → min )\n:(∫(u₁(t) ^ 2 + 2 * u₂(t)) → min)\n\njulia> for i ∈ 1:2\n       e = subs(e, Symbol(:u, Char(8320+i)), :( u[$i] ))\n       end; e\n:(∫((u[1])(t) ^ 2 + 2 * (u[2])(t)) → min)\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); subs(e, :( $x[1]($(t0)) ), :( $x0[1] ))\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.to_out_of_place-Tuple{Any, Any}","page":"CTBase.jl","title":"CTBase.to_out_of_place","text":"to_out_of_place(\n    f!,\n    n;\n    T\n) -> Union{Nothing, CTBase.var\"#f#40\"{CTBase.var\"#f#39#41\"{DataType, _A, _B}} where {_A, _B}}\n\n\nTranform in place function to out of place. Pass the result size and type (default = Float64). Return a scalar when the result has size one. If f! is nothing, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.vec2vec-Tuple{Vector{<:Real}, Int64}","page":"CTBase.jl","title":"CTBase.vec2vec","text":"vec2vec(\n    x::Vector{<:Real},\n    n::Int64\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms x to a Vector{<:Vector{<:ctNumber}}.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.vec2vec-Tuple{Vector{<:Vector{<:Real}}}","page":"CTBase.jl","title":"CTBase.vec2vec","text":"vec2vec(x::Vector{<:Vector{<:Real}}) -> Vector{<:Real}\n\n\nTransforms x to a Vector{<:ctNumber}.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"page"},{"location":"tutorial-repl.html#The-control-toolbox-REPL","page":"Control-toolbox REPL","title":"The control-toolbox REPL","text":"","category":"section"},{"location":"tutorial-repl.html","page":"Control-toolbox REPL","title":"Control-toolbox REPL","text":"We present in this tutorial the control-toolbox REPL which permits first an incremental  definition of the optimal control problem, but also to solve it (with default options only)  and plot the solution (with default options only). ","category":"page"},{"location":"tutorial-repl.html","page":"Control-toolbox REPL","title":"Control-toolbox REPL","text":"To define the problem please check the abstract syntax tutorial.\nFor more details about solving an optimal control problem, we refer to the solve tutorial and to plot a solution, check the plot a solution tutorial.","category":"page"},{"location":"tutorial-repl.html","page":"Control-toolbox REPL","title":"Control-toolbox REPL","text":"To enter into the control-toolbox, press > key.","category":"page"},{"location":"tutorial-repl.html","page":"Control-toolbox REPL","title":"Control-toolbox REPL","text":"tip: Standard usage\nYou can define the problem under the control-toolbox REPL and then, solve it and plot the solution in the Julia REPL. Use the command NAME to rename the  optimal control problem: ct> NAME=ocp.","category":"page"},{"location":"tutorial-repl.html","page":"Control-toolbox REPL","title":"Control-toolbox REPL","text":"note: Nota bene\nIn the following gif, the plot is not displayed since only the terminal is recorded.","category":"page"},{"location":"tutorial-repl.html","page":"Control-toolbox REPL","title":"Control-toolbox REPL","text":"<style>\n@media (orientation: landscape) { .ct-repl-img {content:url('assets/ct-repl-95x30.gif');} }\n@media (orientation: portrait)  { .ct-repl-img {content:url('assets/ct-repl-95x60.gif');} }\n</style>\n<p><img url=\"assets/ct-repl-95x30.gif\" alt=\"Control-toolbox REPL\" class=\"ct-repl-img\"> </p>","category":"page"},{"location":"tutorial-repl.html","page":"Control-toolbox REPL","title":"Control-toolbox REPL","text":"note: Credits\nThis gif has been made with this version of Replay.jl. To make the gif we first need a script (named ct-repl.jl) containing:using Replay\n\nrepl_script = \"\"\"\nusing OptimalControl\nt0 = 0\ntf = 1\n# press \">\" to enter into control-toolbox repl\n>t ∈ [t0, tf], time\n# rename the ocp and the sol \nNAME=(ocp, sol)\nSHOW\n# more commands\nHELP\n# add \";\" at the end of the line for no output\nx ∈ R^2, state;\nu ∈ R, control;\nx(t0) == [ -1, 0 ];\nx(tf) == [ 0, 0 ];\n\\\\partial$(TAB)(x)(t) == [ x\\\\_2$(TAB)(t), u(t) ];\n\\\\int$(TAB)( 0.5u(t)^2 ) \\\\to$(TAB) min;\nSHOW\n$BACKSPACE\nusing NLPModelsIpopt\n>SOLVE\n$BACKSPACE\n# you can access the ocp and the sol in Julia repl\nocp\nsol\nusing Plots\n>PLOT\n$BACKSPACE\n\"\"\"\n\nreplay(\n    repl_script, \n    stdout, \n    julia_project=@__DIR__, \n    use_ghostwriter=true, \n    cmd=`--color=yes`\n)Then, to register the terminal we have used  asciinema  and to save the record into a gif file, we have used  agg.  The shell script to obtain the gif is:julia --project=@. -e 'using Pkg; Pkg.instantiate()'\nasciinema rec result.cast \\\n    -i 2 \\\n    --cols=95 \\\n    --rows=30 \\\n    --overwrite \\\n    --command \"julia --project=@. ./ct-repl.jl\"\nagg result.cast ct-repl.gif","category":"page"},{"location":"tutorial-repl.html","page":"Control-toolbox REPL","title":"Control-toolbox REPL","text":"","category":"page"},{"location":"tutorial-flow.html#manual-flow","page":"Flow","title":"How to compute flows","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"In this tutorial, we explain the Flow function from OptimalControl.jl package.","category":"page"},{"location":"tutorial-flow.html#Basic-usage","page":"Flow","title":"Basic usage","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Les us define a basic optimal control problem.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"using OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == [ 0, 0 ]\n\n    ẋ(t)  == [ v(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"The pseudo-Hamiltonian of this problem is","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"    H(x p u) = p_q q + p_v v + p^0 u^2 2","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"where p^0 = -1 since we are in the normal case. From the Pontryagin maximum principle, the maximising control is given in feedback form by","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"u(x p) = p_v","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"since partial^2_uu H = p^0 = - 1  0. ","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"u(x, p) = p[2]\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Actually, if (x u) is a solution of the optimal control problem,  then, the Pontryagin maximum principle tells us that there exists a costate p such that u(t) = u(x(t) p(t)) and such that the pair (x p) satisfies:","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"beginarrayl\n    dotx(t) = displaystylephantom-nabla_p H(x(t) p(t) u(x(t) p(t))) 05em\n    dotp(t) = displaystyle         - nabla_x H(x(t) p(t) u(x(t) p(t)))\nendarray","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"The Flow function aims to compute (x p) from the optimal control problem ocp and the control in  feedback form u(x, p).","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"note: Nota bene\nActually, writing z = (x p), then the pair (x p) is also solution of    dotz(t) = vecmathbfH(z(t))where mathbfH(z) = H(z u(z)) and vecmathbfH = (nabla_p mathbfH -nabla_x mathbfH). This is what is actually computed by Flow.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Let us try to get the associated flow:","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"using OptimalControl\nt0 = 0\ntf = 1\nx0 = [-1, 0]\nocp = @def begin\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    x(t0) == x0\n    x(tf) == [ 0, 0 ]\n    ẋ(t)  == [ v(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend\nu(x, p) = p[2]","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"julia> f = Flow(ocp, u)\nERROR: ExtensionError. Please make: julia> using OrdinaryDiffEq","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"As you can see, an error occured since we need the package OrdinaryDiffEq.jl. This package provides numerical integrators to compute solutions of the ordinary differential equation  dotz(t) = vecmathbfH(z(t)).","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"note: OrdinaryDiffEq.jl\nThe package OrdinaryDiffEq.jl is part of DifferentialEquations.jl. You can either use one or the other.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"using OrdinaryDiffEq\n\nf = Flow(ocp, u)\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Now we have the flow of the associated Hamiltonian vector field, we can use it. Some simple calculations shows that the initial covector p(0) solution of the Pontryagin maximum principle is 12 6. Let us check that integrating the flow from (t_0 x_0) = (0 -1 0) to the final time t_f we reach the target x_f = 0 0.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"p0 = [12, 6]\nxf, pf = f(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"If you prefer to get the state, costate and control trajectories at any time, you can call the flow:","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"sol = f((t0, tf), x0, p0)\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"In this case, you obtain a data that you can plot exactly like when solving the optimal control problem  with the function solve. See for instance the basic example or the  plot tutorial.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"using Plots\n\nplot(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"You can notice from the graph of v that the integrator has made very few steps:","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"time_grid(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"note: Time grid\nThe function time_grid returns the discretized time grid returned by the solver. In this case, the solution has been computed by numerical integration with an adaptive step-length Runge-Kutta scheme.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"To have a better visualisation (the accuracy won't change), you can provide a fine grid.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"sol = f((t0, tf), x0, p0; saveat=range(t0, tf, 100))\nplot(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"The argument saveat is an option from OrdinaryDiffEq.jl. Please check the  list of common options. For instance, one can change the integrator with the keyword argument alg or the absolute tolerance with  abstol. Note that you can set an option when declaring the flow or set an option in a particular call of the flow.  In the following example, the integrator will be BS5() and the absolute tolerance will be abstol=1e-8.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"f = Flow(ocp, u; alg=BS5(), abstol=1)   # alg=BS5(), abstol=1\nxf, pf = f(t0, x0, p0, tf; abstol=1e-8) # alg=BS5(), abstol=1e-8","category":"page"},{"location":"tutorial-flow.html#Extremals-and-trajectories","page":"Flow","title":"Extremals and trajectories","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"The pairs (x p) solution of the Hamitonian vector field are called extremals. We can compute some constructing the flow from the optimal control problem and the control in feedback form. Another way to compute extremals is  to define explicitely the Hamiltonian.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"H(x, p, u) = p[1] * x[2] + p[2] * u - 0.5 * u^2     # pseudo-Hamiltonian\nH(x, p) = H(x, p, u(x, p))                          # Hamiltonian\n\nz = Flow(Hamiltonian(H))\nxf, pf = z(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"You can also provide the Hamiltonian vector field.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Hv(x, p) = [x[2], p[2]], [0.0, -p[1]]     # Hamiltonian vector field\n\nz = Flow(HamiltonianVectorField(Hv))\nxf, pf = z(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Note that if you call the flow on tspan=(t0, tf), then you obtain the output solution  from OrdinaryDiffEq.jl.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"sol = z((t0, tf), x0, p0)\nxf, pf = sol(tf)[1:2], sol(tf)[3:4]","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"You can also compute trajectories from the control dynamics (x u) mapsto (v u) and a control law  t mapsto u(t).","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"u(t) = 6-12t\nx = Flow((t, x) -> [x[2], u(t)]; autonomous=false) # the vector field depends on t\nx(t0, x0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Again, giving a tspan you get an output solution from OrdinaryDiffEq.jl.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"sol = x((t0, tf), x0)\nplot(sol)","category":"page"},{"location":"tutorial-flow.html#Variable","page":"Flow","title":"Variable","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Let us consider an optimal control problem with a (decision / optimisation) variable.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"t0 = 0\nx0 = 0\n\nocp = @def begin\n\n    tf ∈ R, variable             # the optimisation variable is tf\n    t ∈ [t0, tf], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == 1\n    \n    ẋ(t) == tf * u(t)\n\n    tf + 0.5∫(u(t)^2) → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"As you can see, the variable is the final time tf. Note that the dynamics depends on tf. From the Pontryagin maximum principle, the solution is given by:","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"tf = (3/2)^(1/4)\np0 = 2tf/3\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"The input arguments of the maximising control are now the state x, the costate p and the variable tf.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"u(x, p, tf) = tf * p\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Let us check that the final condition x(tf) = 1 is satisfied.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"f = Flow(ocp, u)\nxf, pf = f(t0, x0, p0, tf, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"The usage of the flow f is the following: f(t0, x0, p0, tf, v) where v is the variable. If one wants to compute the state at time t1 = 0.5, then, one must write:","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"t1 = 0.5\nx1, p1 = f(t0, x0, p0, t1, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"note: Free times\nIn the particular cases: the initial time t0 is the only variable, the final time tf is the only variable, or the initial and final times t0 and tf are the only variables and are in order v=(t0, tf), the times do not need to be repeated in the call of the flow:xf, pf = f(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Since the variable is the final time, we can make the time-reparameterisation t = t_f  s to normalise the time s in 0 1.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"ocp = @def begin\n\n    tf ∈ R, variable\n    s ∈ [0, 1], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(0) == 0\n    x(1) == 1\n    \n    ẋ(s) == tf^2 * u(s)\n\n    tf + (0.5*tf)*∫(u(s)^2) → min\n\nend\n\nf = Flow(ocp, u)\nxf, pf = f(0, x0, p0, 1, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Another possibility is to add a new state variable t_f(s). The problem has no variable anymore.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"ocp = @def begin\n\n    s ∈ [0, 1], time\n    y = (x, tf) ∈ R², state\n    u ∈ R, control\n\n    x(0) == 0\n    x(1) == 1\n\n    dx = tf(s)^2 * u(s)\n    dtf = 0 * u(s) # 0\n    ẏ(s) == [dx, dtf]\n\n    tf(1) + 0.5∫(tf(s) * u(s)^2) → min\n\nend\n\nu(y, q) = y[2] * q[1]\n\nf = Flow(ocp, u)\nyf, pf = f(0, [x0, tf], [p0, 0], 1)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"danger: Bug\nNote that in the previous optimal control problem, we have dtf = 0 * u(s) instead of dtf = 0. The latter does not work.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"note: Goddard problem\nIn the Goddard problem, you may find other constructions of flows, especially for singular and boundary arcs.","category":"page"},{"location":"tutorial-flow.html#Concatenation-of-arcs","page":"Flow","title":"Concatenation of arcs","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"In this part, we present how to concatenate several flows. Let us consider the following problem.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"t0 =  0\ntf =  1\nx0 = -1\nxf =  0\n\n@def ocp begin\n\n    t ∈ [ t0, tf ], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == xf\n\n    -1 ≤ u(t) ≤ 1\n\n    ẋ(t) == -x(t) + u(t)\n\n    ∫( abs(u(t)) ) → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"From the Pontryagin maximum principle, the optimal control is a concatenation of an off arc (u=0) followed by a  positive bang arc (u=1). The initial costate is ","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"p_0 = frac1x_0 - (x_f-1) e^t_f","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"and the switching time is t_1 = -ln(p_0).","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"p0 = 1/( x0 - (xf-1) * exp(tf) )\nt1 = -log(p0)\nnothing  # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Let us define the two flows and the concatenation. Note that the concatenation of two flows is a flow.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"f0 = Flow(ocp, (x, p) -> 0)     # off arc: u = 0\nf1 = Flow(ocp, (x, p) -> 1)     # positive bang arc: u = 1\n\nf = f0 * (t1, f1)               # f0 followed by f1 whenever t ≥ t1\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Now, we can check that the state reach the target.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"sol = f((t0, tf), x0, p0)\nplot(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"note: Goddard problem\nIn the Goddard problem, you may find more complex concatenations.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"For the moment, this concatenation is not equivalent to an exact concatenation.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"f = Flow(x ->  x)\ng = Flow(x -> -x)\n\nx0 = 1\nφ(t) = (f * (t/2, g))(0, x0, t)\nψ(t) = g(t/2, f(0, x0, t/2), t)\n\nprintln(\"φ(t) = \", abs(φ(1)-x0))\nprintln(\"ψ(t) = \", abs(ψ(1)-x0))\n\nt = range(1, 5e2, 201)\n\nplt = plot(yaxis=:log, legend=:bottomright, title=\"Comparison of concatenations\", xlabel=\"t\")\nplot!(plt, t, t->abs(φ(t)-x0), label=\"OptimalControl\")\nplot!(plt, t, t->abs(ψ(t)-x0), label=\"Classical\")","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"","category":"page"},{"location":"tutorial-double-integrator-time.html#double-int","page":"Time mininimisation","title":"Double integrator: time minimisation (abstract syntax)","text":"","category":"section"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"The problem consists in minimising the final time t_f for the double integrator system","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) quad u(t) in -11","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"and the limit conditions","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"    x(0) = (12) quad x(t_f) = (00)","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"This problem can be interpretated as a simple model for a wagon with constant mass moving along a line without fricton.","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-double-integrator-time.html#Optimal-control-problem","page":"Time mininimisation","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"Let us define the problem","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"ocp = @def begin\n\n    tf ∈ R,          variable\n    t ∈ [ 0, tf ],   time\n    x = (q, v) ∈ R², state\n    u ∈ R,           control\n\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n\n    q(0)  == 1\n    v(0)  == 2\n    q(tf) == 0\n    v(tf) == 0\n\n    -5 ≤ q(t) ≤ 5,          (1)\n    -3 ≤ v(t) ≤ 3,          (2)\n\n    ẋ(t) == [ v(t), u(t) ]\n\n    tf → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"tip: Convergence\nIn order to ensure convergence of the direct solver, we have added the state constraints labelled (1) and (2):-5 leq q(t) leq 5quad -3 leq v(t) leq 3quad t in  0 t_f ","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"note: Nota bene\nFor a comprehensive introduction to the syntax used above to describe the optimal control problem, check this abstract syntax tutorial. In particular, there are non-unicode alternatives for derivatives, integrals, etc.","category":"page"},{"location":"tutorial-double-integrator-time.html#Solve-and-plot","page":"Time mininimisation","title":"Solve and plot","text":"","category":"section"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"Solve it","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"sol = solve(ocp; print_level=4)\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"and plot the solution","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"plot(sol)","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"","category":"page"},{"location":"api-ctflows.html#CTFlows.jl","page":"CTFlows.jl","title":"CTFlows.jl","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"The CTFlows.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"flowchart TD\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-optimalcontrol.html'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctbase.html'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctdirect.html'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctflows.html'>CTFlows</a>)\nF --> B\nD --> B\nstyle F fill:#FBF275","category":"page"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-ctflows.html#Index","page":"CTFlows.jl","title":"Index","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Pages   = [\"api-ctflows.md\"]\nModules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-ctflows.html#Documentation","page":"CTFlows.jl","title":"Documentation","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Modules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"","category":"page"},{"location":"tutorial-goddard.html#goddard","page":"Goddard: direct, indirect","title":"Direct and indirect methods for the Goddard problem","text":"","category":"section"},{"location":"tutorial-goddard.html#Introduction","page":"Goddard: direct, indirect","title":"Introduction","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"<img src=\"./assets/Goddard_and_Rocket.jpg\" style=\"float: left; margin: auto 10px;\" width=\"200px\">","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"For this example, we consider the well-known Goddard problem[1] [2] which models the ascent of a rocket through the atmosphere, and we restrict here ourselves to vertical (one dimensional) trajectories. The state variables are the altitude r, speed v and mass m of the rocket during the flight, for a total dimension of 3. The rocket is subject to gravity g, thrust u and drag force D (function of speed and altitude). The final time t_f is free, and the objective is to reach a maximal altitude with a bounded fuel consumption.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We thus want to solve the optimal control problem in Mayer form","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"    r(t_f) to max","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"subject to the controlled dynamics","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"    dotr = v quad\n    dotv = fracT_maxu - D(rv)m - g quad\n    dotm = -u","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"and subject to the control constraint u(t) in 01 and the state constraint v(t) leq v_max. The initial state is fixed while only the final mass is prescribed.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"note: Nota bene\nThe Hamiltonian is affine with respect to the control, so singular arcs may occur, as well as constrained arcs due to the path constraint on the velocity (see below).","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We import the OptimalControl.jl package to define the optimal control problem and NLPModelsIpopt.jl to solve it.  We import the Plots.jl package to plot the solution.  The OrdinaryDiffEq.jl package is used to  define the shooting function for the indirect method and the  NonlinearSolve.jl and  MINPACK.jl packages permit to solve the shooting  equation.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"using OptimalControl  # to define the optimal control problem and more\nusing NLPModelsIpopt  # to solve the problem via a direct method\nusing OrdinaryDiffEq  # to get the Flow function from OptimalControl\nusing NonlinearSolve  # interface to NLE solvers\nusing MINPACK         # NLE solver: use to solve the shooting equation\nusing Plots           # to plot the solution","category":"page"},{"location":"tutorial-goddard.html#Optimal-control-problem","page":"Goddard: direct, indirect","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We define the problem","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"t0 = 0      # initial time\nr0 = 1      # initial altitude\nv0 = 0      # initial speed\nm0 = 1      # initial mass\nvmax = 0.1  # maximal authorized speed\nmf = 0.6    # final mass to target\n\nocp = @def begin # definition of the optimal control problem\n\n    tf ∈ R, variable\n    t ∈ [t0, tf], time\n    x = (r, v, m) ∈ R³, state\n    u ∈ R, control\n\n    x(t0) == [ r0, v0, m0 ]\n    m(tf) == mf,         (1)\n    0 ≤ u(t) ≤ 1\n    r(t) ≥ r0\n    0 ≤ v(t) ≤ vmax\n\n    ẋ(t) == F0(x(t)) + u(t) * F1(x(t))\n\n    r(tf) → max\n\nend;\n\n# Dynamics\nconst Cd = 310\nconst Tmax = 3.5\nconst β = 500\nconst b = 2\n\nF0(x) = begin\n    r, v, m = x\n    D = Cd * v^2 * exp(-β*(r - 1)) # Drag force\n    return [ v, -D/m - 1/r^2, 0 ]\nend\n\nF1(x) = begin\n    r, v, m = x\n    return [ 0, Tmax/m, -b*Tmax ]\nend\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html#Direct-method","page":"Goddard: direct, indirect","title":"Direct method","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We then solve it","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"direct_sol = solve(ocp; grid_size=100)\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"and plot the solution","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"plt = plot(direct_sol, solution_label=\"(direct)\", size=(800, 800))","category":"page"},{"location":"tutorial-goddard.html#goddard-structure","page":"Goddard: direct, indirect","title":"Structure of the solution","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We first determine visually the structure of the optimal solution which is composed of a bang arc with maximal control, followed by a singular arc, then by a boundary arc and the final arc is with zero control. Note that the switching function vanishes along the singular and boundary arcs.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"tip: Interactions with an optimal control solution\nPlease check state, costate, control and variable to get data from the solution. The functions state, costate and control return functions of time and variable returns a vector. The function time_grid returns the discretized time grid returned by the solver.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"t = time_grid(direct_sol)\nx = state(direct_sol)\nu = control(direct_sol)\np = costate(direct_sol)\n\nH1 = Lift(F1)           # H1(x, p) = p' * F1(x)\nφ(t) = H1(x(t), p(t))   # switching function\ng(x) = vmax - x[2]      # state constraint v ≤ vmax\n\nu_plot  = plot(t, u,     label = \"u(t)\")\nH1_plot = plot(t, φ,     label = \"H₁(x(t), p(t))\")\ng_plot  = plot(t, g ∘ x, label = \"g(x(t))\")\n\nplot(u_plot, H1_plot, g_plot, layout=(3,1), size=(500, 500))","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We are now in position to solve the problem by an indirect shooting method. We first define the four control laws in feedback form and their associated flows. For this we need to compute some Lie derivatives, namely Poisson brackets of Hamiltonians (themselves obtained as lifts to the cotangent bundle of vector fields), or derivatives of functions along a vector field. For instance, the control along the minimal order singular arcs is obtained as the quotient","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"u_s = -fracH_001H_101","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"of length three Poisson brackets:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"H_001 = H_0H_0H_1 quad H_101 = H_1H_0H_1","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"where, for two Hamiltonians H and G,","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"HG = (nabla_p Hnabla_x G) - (nabla_x Hnabla_p G)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"While the Lie derivative of a function f wrt. a vector field X is simply obtained as","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"(X cdot f)(x) = f(x) cdot X(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"and is used to the compute the control along the boundary arc,","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"u_b(x) = -(F_0 cdot g)(x)  (F_1 cdot g)(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"as well as the associated multiplier for the order one state constraint on the velocity:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"mu(x p) = H_01(x p)  (F_1 cdot g)(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"note: Poisson bracket and Lie derivative\nThe Poisson bracket HG is also given by the Lie derivative of G along the Hamiltonian vector field X_H = (nabla_p H -nabla_x H) of H, that is    HG = X_H cdot Gwhich is the reason why we use the @Lie macro to compute Poisson brackets below.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"With the help of the differential geometry primitives from CTBase.jl, these expressions are straightforwardly translated into Julia code:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# Controls\nu0 = 0                                  # off control\nu1 = 1                                  # bang control\n\nH0 = Lift(F0)                           # H0(x, p) = p' * F0(x)\nH01  = @Lie { H0, H1 }\nH001 = @Lie { H0, H01 }\nH101 = @Lie { H1, H01 }\nus(x, p) = -H001(x, p) / H101(x, p)     # singular control\n\nub(x) = -(F0⋅g)(x) / (F1⋅g)(x)          # boundary control\nμ(x, p) = H01(x, p) / (F1⋅g)(x)         # multiplier associated to the state constraint g\n\n# Flows\nf0 = Flow(ocp, (x, p, tf) -> u0)\nf1 = Flow(ocp, (x, p, tf) -> u1)\nfs = Flow(ocp, (x, p, tf) -> us(x, p))\nfb = Flow(ocp, (x, p, tf) -> ub(x), (x, u, tf) -> g(x), (x, p, tf) -> μ(x, p))\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html#Shooting-function","page":"Goddard: direct, indirect","title":"Shooting function","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Then, we define the shooting function according to the optimal structure we have determined, that is a concatenation of four arcs.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"x0 = [ r0, v0, m0 ] # initial state\n\nfunction shoot!(s, p0, t1, t2, t3, tf)\n\n    x1, p1 = f1(t0, x0, p0, t1)\n    x2, p2 = fs(t1, x1, p1, t2)\n    x3, p3 = fb(t2, x2, p2, t3)\n    xf, pf = f0(t3, x3, p3, tf)\n\n    s[1] = xf[3] - mf                             # final mass constraint\n    s[2:3] = pf[1:2] - [ 1, 0 ]                   # transversality conditions\n    s[4] = H1(x1, p1)                             # H1 = H01 = 0\n    s[5] = H01(x1, p1)                            # at the entrance of the singular arc\n    s[6] = g(x2)                                  # g = 0 when entering the boundary arc\n    s[7] = H0(xf, pf)                             # since tf is free\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html#Initial-guess","page":"Goddard: direct, indirect","title":"Initial guess","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"To solve the problem by an indirect shooting method, we then need a good initial guess, that is a good approximation of the initial costate, the three switching times and the final time.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"η = 1e-3\nt13 = t[ abs.(φ.(t)) .≤ η ]\nt23 = t[ 0 .≤ (g ∘ x).(t) .≤ η ]\np0 = p(t0)\nt1 = min(t13...)\nt2 = min(t23...)\nt3 = max(t23...)\ntf = t[end]\n\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\nusing LinearAlgebra: norm\ns = similar(p0, 7)\nshoot!(s, p0, t1, t2, t3, tf)\nprintln(\"\\nNorm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html#Indirect-shooting","page":"Goddard: direct, indirect","title":"Indirect shooting","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We aggregate the data to define the initial guess vector.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"ξ = [ p0 ; t1 ; t2 ; t3 ; tf ] # initial guess","category":"page"},{"location":"tutorial-goddard.html#NonlinearSolve.jl","page":"Goddard: direct, indirect","title":"NonlinearSolve.jl","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We first use the NonlinearSolve.jl package to solve the shooting equation. Let us define the problem.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# auxiliary function with aggregated inputs\nnle! = (s, ξ, λ) -> shoot!(s, ξ[1:3], ξ[4], ξ[5], ξ[6], ξ[7])\n\n# NLE problem with initial guess\nprob = NonlinearProblem(nle!, ξ)\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Let us do some benchmarking.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"using BenchmarkTools\n@benchmark solve(prob; abstol=1e-8, reltol=1e-8, show_trace=Val(false))","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"For small nonlinear systems, it could be faster to use the  SimpleNewtonRaphson() descent algorithm.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"@benchmark solve(prob, SimpleNewtonRaphson(); abstol=1e-8, reltol=1e-8, show_trace=Val(false))","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Now, let us solve the problem and retrieve the initial costate solution.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# resolution of S(ξ) = 0\nindirect_sol = solve(prob; abstol=1e-8, reltol=1e-8, show_trace=Val(true))\n\n# we retrieve the costate solution together with the times\np0 = indirect_sol.u[1:3]\nt1 = indirect_sol.u[4]\nt2 = indirect_sol.u[5]\nt3 = indirect_sol.u[6]\ntf = indirect_sol.u[7]\n\nprintln(\"\")\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\ns = similar(p0, 7)\nshoot!(s, p0, t1, t2, t3, tf)\nprintln(\"\\nNorm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html#MINPACK.jl","page":"Goddard: direct, indirect","title":"MINPACK.jl","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"using MINPACK\nfunction fsolve(f, j, x; kwargs...)\n    try\n        MINPACK.fsolve(f, j, x; kwargs...)\n    catch e\n        println(\"Erreur using MINPACK\")\n        println(e)\n        println(\"hybrj not supported. Replaced by hybrd even if it is not visible on the doc.\")\n        MINPACK.fsolve(f, x; kwargs...)\n    end\nend","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Instead of the NonlinearSolve.jl package we can use the  MINPACK.jl package to solve  the shooting equation. To compute the Jacobian of the shooting function we use the  DifferentiationInterface.jl package with  ForwardDiff.jl backend.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"using DifferentiationInterface\nimport ForwardDiff\nbackend = AutoForwardDiff()\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Let us define the problem to solve.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# auxiliary function with aggregated inputs\nnle!  = ( s, ξ) -> shoot!(s, ξ[1:3], ξ[4], ξ[5], ξ[6], ξ[7])\n\n# Jacobian of the (auxiliary) shooting function\njnle! = (js, ξ) -> jacobian!(nle!, similar(ξ), js, backend, ξ)\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We are now in position to solve the problem with the hybrj solver from MINPACK.jl through the fsolve  function, providing the Jacobian. Let us do some benchmarking.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"@benchmark fsolve(nle!, jnle!, ξ; show_trace=false) # initial guess given to the solver","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We can also use the preparation step of DifferentiationInterface.jl.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"extras = prepare_jacobian(nle!, similar(ξ), backend, ξ)\njnle_prepared!(js, ξ) = jacobian!(nle!, similar(ξ), js, backend, ξ, extras)\n@benchmark fsolve(nle!, jnle_prepared!, ξ; show_trace=false)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Now, let us solve the problem and retrieve the initial costate solution.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# resolution of S(ξ) = 0\nindirect_sol = fsolve(nle!, jnle!, ξ, show_trace=true)\n\n# we retrieve the costate solution together with the times\np0 = indirect_sol.x[1:3]\nt1 = indirect_sol.x[4]\nt2 = indirect_sol.x[5]\nt3 = indirect_sol.x[6]\ntf = indirect_sol.x[7]\n\nprintln(\"\")\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\ns = similar(p0, 7)\nshoot!(s, p0, t1, t2, t3, tf)\nprintln(\"\\nNorm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html#goddard-plot","page":"Goddard: direct, indirect","title":"Plot of the solution","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We plot the solution of the indirect solution (in red) over the solution of the direct method  (in blue).","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"f = f1 * (t1, fs) * (t2, fb) * (t3, f0) # concatenation of the flows\nflow_sol = f((t0, tf), x0, p0)          # compute the solution: state, costate, control...\n\nplot!(plt, flow_sol, solution_label=\"(indirect)\")","category":"page"},{"location":"tutorial-goddard.html#References","page":"Goddard: direct, indirect","title":"References","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"[1]: R.H. Goddard. A Method of Reaching Extreme Altitudes, volume 71(2) of Smithsonian Miscellaneous Collections. Smithsonian institution, City of Washington, 1919.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"[2]: H. Seywald and E.M. Cliff. Goddard problem in presence of a dynamic pressure limit. Journal of Guidance, Control, and Dynamics, 16(4):776–781, 1993.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"","category":"page"},{"location":"oc_mam.html#Minimal-Action-Method-using-Optimal-Control","page":"Minimal action","title":"Minimal Action Method using Optimal Control","text":"","category":"section"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"The Minimal Action Method (MAM) is used to find the maximum likelihood transition paths between stable states in dynamical systems.  The Minimal Action Method is a numerical technique for finding the most probable transition pathway between stable states in stochastic dynamical systems. It achieves this by minimizing an action functional that represents the path's deviation from the deterministic dynamics, effectively identifying the path of least resistance through the system's landscape. This tutorial demonstrates how to implement MAM as an optimal control problem.","category":"page"},{"location":"oc_mam.html#Required-Packages","page":"Minimal action","title":"Required Packages","text":"","category":"section"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots, Printf","category":"page"},{"location":"oc_mam.html#Problem-Setup","page":"Minimal action","title":"Problem Setup","text":"","category":"section"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"We'll consider a 2D system with a double-well flow, called the Maier-Stein model. It is a famous benchmark problem as it exhibits non-gradient dynamics with two stable equilibrium points at (-1,0) and (1,0), connected by a non-trivial transition path. The system's deterministic dynamics are given by:","category":"page"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"# Define the vector field\nf(u, v) = [u - u^3 - 10*u*v^2,  -(1 - u^2)*v]\nf(x) = f(x...)\nnothing # hide","category":"page"},{"location":"oc_mam.html#Optimal-Control-Formulation","page":"Minimal action","title":"Optimal Control Formulation","text":"","category":"section"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"The minimal action path minimizes the deviation from the deterministic dynamics:","category":"page"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"mysqrt(x) = sqrt(x + 1e-1)\nfunction ocp(T)\n  action = @def begin\n      t ∈ [0, T], time\n      x ∈ R², state\n      u ∈ R², control\n      x(0) == [-1, 0]    # Starting point (left well)\n      x(T) == [1, 0]     # End point (right well)\n      ẋ(t) == u(t)       # Path dynamics\n      ∫( sum((u(t) - f(x(t))).^2) ) → min  # Minimize deviation from deterministic flow\n  end\n  return action\nend\nnothing # hide","category":"page"},{"location":"oc_mam.html#Initial-Guess","page":"Minimal action","title":"Initial Guess","text":"","category":"section"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"We provide an initial guess for the path using a simple interpolation:","category":"page"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"# Time horizon\nT = 50\n\n# Linear interpolation for x₁\nx1(t) = -(1 - t/T) + t/T\n\n# Parabolic guess for x₂\nx2(t) = 0.3(-x1(t)^2 + 1)\nx(t) = [x1(t), x2(t)]\nu(t) = f(x(t))\n\n# Initial guess\ninit = (state=x, control=u)\nnothing # hide","category":"page"},{"location":"oc_mam.html#Solving-the-Problem","page":"Minimal action","title":"Solving the Problem","text":"","category":"section"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"We solve the problem in two steps for better accuracy:","category":"page"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"# First solve with coarse grid\nsol = solve(ocp(T); init=init, grid_size=50)\n\n# Refine solution with finer grid\nsol = solve(ocp(T); init=sol, grid_size=1000)\n\n# Objective value\nsol.objective","category":"page"},{"location":"oc_mam.html#Visualizing-Results","page":"Minimal action","title":"Visualizing Results","text":"","category":"section"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"Let's plot the solution trajectory and phase space:","category":"page"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"plot(sol)","category":"page"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"# Phase space plot\nMLP = sol.state.(sol.time_grid)\nscatter(first.(MLP), last.(MLP), \n        title=\"Minimal Action Path\",\n        xlabel=\"u\",\n        ylabel=\"v\",\n        label=\"Transition path\")","category":"page"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"The resulting path shows the most likely transition between the two stable states given a transient time T=50, minimizing the action functional while respecting the system's dynamics.","category":"page"},{"location":"oc_mam.html#Minimize-with-respect-to-T","page":"Minimal action","title":"Minimize with respect to T","text":"","category":"section"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"To find the maximum likelihood path, we also need to minimize the transient time T. Hence, we perform a discrete continuation over the parameter T by solving the optimal control problem over a continuous range of final times T, using each solution to initialize the next problem.","category":"page"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"objectives = []\nTs = range(1,100,100)\nsol = solve(ocp(Ts[1]); display=false, init=init, grid_size=50)\nprintln(\" Time   Objective     Iterations\")\nfor T=Ts\n    global sol = solve(ocp(T); display=false, init=sol, grid_size=1000, tol=1e-8)\n    @printf(\"%6.2f  %9.6e  %d\\n\", T, sol.objective, sol.iterations)\n    push!(objectives, sol.objective)\nend","category":"page"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"T_min = Ts[argmin(objectives)]\nplt1 = scatter(Ts, log10.(objectives), xlabel=\"Time\", label=\"Objective (log10)\")\nvline!(plt1, [T_min], label=\"Minimum\", z_order=:back)\nplt2 = scatter(Ts[20:100], log10.(objectives[20:100]), xlabel=\"Time\", label=\"Objective (log10)\")\nvline!(plt2, [T_min], label=\"Minimum\", z_order=:back)\nplot(plt1, plt2, layout=(2,1), size=(800,800))","category":"page"},{"location":"oc_mam.html","page":"Minimal action","title":"Minimal action","text":"","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<img width=\"800\" alt=\"juliaopt2024\" src=\"./assets/zhejiang-2025.jpg\">","category":"page"},{"location":"zhejiang-2025.html#Solving-optimal-control-problems-in-Julia:-the-OptimalControl.jl-package","page":"Zhejiang 2025","title":"Solving optimal control problems in Julia: the OptimalControl.jl package","text":"","category":"section"},{"location":"zhejiang-2025.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://github.com/joseph-gergaud),-[Pierre-Martinon](https://github.com/PierreMartinon),-[Sophia-Sed](https://sed-sam-blog.gitlabpages.inria.fr)","page":"Zhejiang 2025","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"page"},{"location":"zhejiang-2025.html#What-it's-about","page":"Zhejiang 2025","title":"What it's about","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"subject to","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"plus boundary, control and state constraints","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"zhejiang-2025.html#OptimalControl.jl-for-trajectory-optimisation","page":"Zhejiang 2025","title":"OptimalControl.jl for trajectory optimisation","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Basic example\nGoddard problem\nOrbit transfer","category":"page"},{"location":"zhejiang-2025.html#Wrap-up","page":"Zhejiang 2025","title":"Wrap up","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"High level modelling of optimal control problems\nEfficient numerical resolution coupling direct and indirect methods\nCollection of examples","category":"page"},{"location":"zhejiang-2025.html#Future","page":"Zhejiang 2025","title":"Future","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"New applications (pace mechanics, biology, quantum mechanics and more)\nAdditional solvers: optimisation on GPU, direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions! If you like the package, please give us a star ⭐️","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<a href=\"https://github.com/control-toolbox/OptimalControl.jl\"><img width=\"800\" alt=\"OptimalControl.jl\" src=\"./assets/star.jpg\"></a>","category":"page"},{"location":"zhejiang-2025.html#control-toolbox.org","page":"Zhejiang 2025","title":"control-toolbox.org","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"zhejiang-2025.html#Credits-(not-exhaustive!)","page":"Zhejiang 2025","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nIpopt.jl\nMadNLP.jl\nMLStyle.jl","category":"page"},{"location":"zhejiang-2025.html#Stand-up-for-science-2025","page":"Zhejiang 2025","title":"Stand up for science 2025","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<a href=\"https://standupforscience2025.org\"><img width=\"200\" alt=\"stand up for science 2025\" src=\"./assets/standup.jpg\"></a>","category":"page"},{"location":"zhejiang-2025.html#Acknowledgements","page":"Zhejiang 2025","title":"Acknowledgements","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Jean-Baptiste Caillau is partially funded by a France 2030 support managed by the Agence Nationale de la Recherche, under the reference ANR-23-PEIA-0004 (PDE-AI project).","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<img width=\"150\" alt=\"affiliations\" src=\"./assets/france-2030.png\">","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"","category":"page"},{"location":"tutorial-discretisation.html#Discretisation-methods","page":"Discretisation methods","title":"Discretisation methods","text":"","category":"section"},{"location":"tutorial-discretisation.html#Discretisation-formulas","page":"Discretisation methods","title":"Discretisation formulas","text":"","category":"section"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"When calling solve, the option disc_method=... can be used to set the discretisation scheme. In addition to the default implicit :trapeze method (aka Crank-Nicolson), other choices are available, namely implicit :midpoint and the Gauss-Legendre collocations with 2 and  stages, :gauss_legendre_2 and :gauss_legendre_3, of order 4 and 6 respectively.  Note that higher order methods will typically lead to larger NLP problems for the same number of time steps, and that accuracy will also depend on the smoothness of the problem.","category":"page"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"As an example we will use the Goddard problem","category":"page"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"using OptimalControl  # to define the optimal control problem and more\nusing NLPModelsIpopt  # to solve the problem via a direct method\nusing Plots           # to plot the solution\n\nt0 = 0      # initial time\nr0 = 1      # initial altitude\nv0 = 0      # initial speed\nm0 = 1      # initial mass\nvmax = 0.1  # maximal authorized speed\nmf = 0.6    # final mass to target\n\nocp = @def begin # definition of the optimal control problem\n\n    tf ∈ R, variable\n    t ∈ [t0, tf], time\n    x = (r, v, m) ∈ R³, state\n    u ∈ R, control\n\n    x(t0) == [ r0, v0, m0 ]\n    m(tf) == mf,         (1)\n    0 ≤ u(t) ≤ 1\n    r(t) ≥ r0\n    0 ≤ v(t) ≤ vmax\n\n    ẋ(t) == F0(x(t)) + u(t) * F1(x(t))\n\n    r(tf) → max\n\nend;\n\n# Dynamics\nconst Cd = 310\nconst Tmax = 3.5\nconst β = 500\nconst b = 2\n\nF0(x) = begin\n    r, v, m = x\n    D = Cd * v^2 * exp(-β*(r - 1)) # Drag force\n    return [ v, -D/m - 1/r^2, 0 ]\nend\n\nF1(x) = begin\n    r, v, m = x\n    return [ 0, Tmax/m, -b*Tmax ]\nend\nnothing # hide","category":"page"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"Now let us compare different discretisations","category":"page"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"sol_trapeze = solve(ocp; tol=1e-8)\nplot(sol_trapeze)\n\nsol_midpoint = solve(ocp, disc_method=:midpoint; tol=1e-8)\nplot!(sol_midpoint)\n\nsol_gl2 = solve(ocp, disc_method=:gauss_legendre_2; tol=1e-8)\nplot!(sol_gl2)\n\nsol_gl3 = solve(ocp, disc_method=:gauss_legendre_3; tol=1e-8)\nplot!(sol_gl3)","category":"page"},{"location":"tutorial-discretisation.html#Large-problems-and-AD-backend","page":"Discretisation methods","title":"Large problems and AD backend","text":"","category":"section"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"For some large problems, you may notice that solving spends a long time before the iterations actually begin. This is due to the computing of the sparse derivatives, namely the Jacobian of the constraints and the Hessian of the Lagrangian, that can become quite costly. A possible alternative is to set the option adnlp_backend=:manual, which will use more basic sparsity patterns. The resulting matrices are faster to compute but are also less sparse, so this is a trade-off bewteen the AD preparation and the optimization itself.","category":"page"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"solve(ocp, disc_method=:gauss_legendre_3, grid_size=1000, adnlp_backend=:manual)\nnothing # hide","category":"page"},{"location":"tutorial-discretisation.html#Explicit-time-grid","page":"Discretisation methods","title":"Explicit time grid","text":"","category":"section"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"The option time_grid=... allows to pass the complete time grid vector t0, t1, ..., tf, which is typically useful if one wants a non uniform grid.  In the case of a free initial and/or final time, provide a normalised grid between 0 and 1.  Note that time_grid will override grid_size if both are present.","category":"page"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"sol = solve(ocp, time_grid=[0, 0.1, 0.5, 0.9, 1], display=false)\nprintln(time_grid(sol))","category":"page"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"","category":"page"},{"location":"dev-ctflows.html#dev-ctflows","page":"CTFlows.jl","title":"CTFlows.jl private functions","text":"","category":"section"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-ctflows.html#Index","page":"CTFlows.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Pages   = [\"dev-ctflows.md\"]\nModules = [CTFlows]\nOrder   = [:type, :module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctflows.html#Documentation","page":"CTFlows.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Modules = [CTFlows]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{Dynamics, ControlLaw, Lagrange, Real, Real, MixedConstraint, Multiplier}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::Dynamics,\n    u::ControlLaw,\n    f⁰::Lagrange,\n    p⁰::Real,\n    s::Real,\n    g::MixedConstraint,\n    μ::Multiplier\n) -> CTFlows.var\"#H#42\"{Dynamics{TF, TD, VD}, ControlLaw{TF1, TD1, VD1}, Lagrange{TF2, TD2, VD2}, var\"#s182\", var\"#s1821\", MixedConstraint{TF3, TD3, VD3}, Multiplier{TF4, TD4, VD4}} where {TF<:Function, TD<:TimeDependence, VD<:VariableDependence, TF1<:Function, TD1<:TimeDependence, VD1<:VariableDependence, TF2<:Function, TD2<:TimeDependence, VD2<:VariableDependence, var\"#s182\"<:Real, var\"#s1821\"<:Real, TF3<:Function, TD3<:TimeDependence, VD3<:VariableDependence, TF4<:Function, TD4<:TimeDependence, VD4<:VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{Dynamics, ControlLaw, Lagrange, Real, Real}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::Dynamics,\n    u::ControlLaw,\n    f⁰::Lagrange,\n    p⁰::Real,\n    s::Real\n) -> CTFlows.var\"#H#40\"{Dynamics{TF, TD, VD}, ControlLaw{TF1, TD1, VD1}, Lagrange{TF2, TD2, VD2}, <:Real, <:Real} where {TF<:Function, TD<:TimeDependence, VD<:VariableDependence, TF1<:Function, TD1<:TimeDependence, VD1<:VariableDependence, TF2<:Function, TD2<:TimeDependence, VD2<:VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{Dynamics, ControlLaw, MixedConstraint, Multiplier}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::Dynamics,\n    u::ControlLaw,\n    g::MixedConstraint,\n    μ::Multiplier\n) -> CTFlows.var\"#H#41\"{Dynamics{TF, TD, VD}, ControlLaw{TF1, TD1, VD1}, MixedConstraint{TF2, TD2, VD2}, Multiplier{TF3, TD3, VD3}} where {TF<:Function, TD<:TimeDependence, VD<:VariableDependence, TF1<:Function, TD1<:TimeDependence, VD1<:VariableDependence, TF2<:Function, TD2<:TimeDependence, VD2<:VariableDependence, TF3<:Function, TD3<:TimeDependence, VD3<:VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{Dynamics, ControlLaw}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::Dynamics,\n    u::ControlLaw\n) -> CTFlows.var\"#38#39\"{Dynamics{TF, TD, VD}, ControlLaw{TF1, TD1, VD1}} where {TF<:Function, TD<:TimeDependence, VD<:VariableDependence, TF1<:Function, TD1<:TimeDependence, VD1<:VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p f(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"","category":"page"},{"location":"tutorial-functional.html","page":"-","title":"-","text":"","category":"page"},{"location":"api-ctbase/repl.html#api-ctbase-repl","page":"Repl","title":"Repl","text":"","category":"section"},{"location":"api-ctbase/repl.html","page":"Repl","title":"Repl","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/repl.html#Index","page":"Repl","title":"Index","text":"","category":"section"},{"location":"api-ctbase/repl.html","page":"Repl","title":"Repl","text":"Pages   = [\"repl.md\"]\nModules = [CTBase]\nOrder = [:type, :module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/repl.html#Documentation","page":"Repl","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/repl.html","page":"Repl","title":"Repl","text":"Modules = [CTBase]\nOrder = [:type, :module, :constant, :function, :macro]\nPages   = [\"repl.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/repl.html#CTBase.ct_repl-Tuple{}","page":"Repl","title":"CTBase.ct_repl","text":"ct_repl(; debug, verbose)\n\n\nCreate a ct REPL.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/repl.html#CTBase.ct_repl_update_model-Tuple{Expr}","page":"Repl","title":"CTBase.ct_repl_update_model","text":"ct_repl_update_model(e::Expr)\n\n\nUpdate the model adding the expression e. It must be public since in the ct repl, this function  is quoted each time an expression is parsed and is valid. \n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/repl.html","page":"Repl","title":"Repl","text":"","category":"page"},{"location":"tutorial-initial-guess.html#tutorial-initial-guess","page":"Initial guess","title":"Initial guess (or iterate) for the resolution","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"We present in this tutorial the different possibilities to provide an initial guess to solve an  optimal control problem with the OptimalControl.jl package. ","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"For the illustrations, we define the following optimal control problem.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"t0 = 0\ntf = 10\nα  = 5\n\nocp = @def begin\n    t ∈ [t0, tf], time\n    v ∈ R, variable\n    x ∈ R², state\n    u ∈ R, control\n    x(t0) == [ -1, 0 ]\n    x₁(tf) == 0\n    ẋ(t) == [ x₂(t), x₁(t) + α*x₁(t)^2 + u(t) ]\n    x₂(tf)^2 + ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Default-initial-guess","page":"Initial guess","title":"Default initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"We first solve the problem without giving an initial guess. This will default to initialize all variables to 0.1.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# solve the optimal control problem without initial guess\nsol = solve(ocp; display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Let us plot the solution of the optimal control problem.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"plot(sol; size=(600, 450))","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Note that the following formulations are equivalent to not giving an initial guess.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"sol = solve(ocp; init=nothing, display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\nsol = solve(ocp; init=(), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"tip: Interactions with an optimal control solution\nTo get the number of iterations of the solver, check the iterations function.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"To reduce the number of iterations and improve the convergence, we can give an initial guess to the solver.  This initial guess can be built from constant values, interpolated vectors, functions, or existing solutions. Except when initializing from a solution, the arguments are to be passed as a named tuple init=(state=..., control=..., variable=...) whose fields are optional. Missing fields will revert to default initialization (ie constant 0.1).","category":"page"},{"location":"tutorial-initial-guess.html#Constant-initial-guess","page":"Initial guess","title":"Constant initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"We first illustrate the constant initial guess, using vectors or scalars according to the dimension.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# solve the optimal control problem with initial guess with constant values\nsol = solve(ocp; init=(state=[-0.2, 0.1], control=-0.2, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Partial initializations are also valid, as shown below. Note the ending comma when a single argument is passed, since it must be a tuple.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# initialisation only on the state\nsol = solve(ocp; init=(state=[-0.2, 0.1],), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\n# initialisation only on the control\nsol = solve(ocp; init=(control=-0.2,), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\n# initialisation only on the state and the variable\nsol = solve(ocp; init=(state=[-0.2, 0.1], variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Functional-initial-guess","page":"Initial guess","title":"Functional initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"For the state and control, we can also provide functions of time as initial guess.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# initial guess as functions of time\nx(t) = [ -0.2t, 0.1t ]\nu(t) = -0.2t\n\nsol = solve(ocp; init=(state=x, control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Vector-initial-guess-(interpolated)","page":"Initial guess","title":"Vector initial guess (interpolated)","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Initialization can also be provided with vectors / matrices to be interpolated along a given time grid.  In this case the time steps must be given through an additional argument time, which can be a vector or line/column matrix. For the values to be interpolated both matrices and vectors of vectors are allowed, but the shape should be number of time steps x variable dimension. Simple vectors are also allowed for variables of dimension 1.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# initial guess as vector of points\nt_vec = LinRange(t0,tf,4)\nx_vec = [[0, 0], [-0.1, 0.3], [-0.15,0.4], [-0.3, 0.5]]\nu_vec = [0, -0.8,  -0.3, 0]\n\nsol = solve(ocp; init=(time=t_vec, state=x_vec, control=u_vec, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Note: in the free final time case, the given time grid should be consistent with the initial guess provided for the final time (in the optimization variables).","category":"page"},{"location":"tutorial-initial-guess.html#Mixed-initial-guess","page":"Initial guess","title":"Mixed initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"The constant, functional and vector initializations can be mixed, for instance as","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# we can mix constant values with functions of time\nsol = solve(ocp; init=(state=[-0.2, 0.1], control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\n# wa can mix every possibility\nsol = solve(ocp; init=(time=t_vec, state=x_vec, control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Solution-as-initial-guess-(warm-start)","page":"Initial guess","title":"Solution as initial guess (warm start)","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Finally, we can use an existing solution to provide the initial guess.  The dimensions of the state, control and optimization variable must coincide. This particular feature allows an easy implementation of discrete continuations.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# generate the initial solution\nsol_init = solve(ocp; display=false)\n\n# solve the problem using solution as initial guess\nsol = solve(ocp; init=sol_init, display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Note that you can also manually pick and choose which data to reuse from a solution, by recovering the  functions state(sol), control(sol) and the values variable(sol). For instance the following formulation is equivalent to the init=sol one.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# use a previous solution to initialise picking data\nsol = solve(ocp; \n    init = (\n        state    = state(sol), \n        control  = control(sol), \n        variable = variable(sol)\n    ), \n    display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"tip: Interactions with an optimal control solution\nPlease check state, costate, control and variable to get data from the solution. The functions state, costate and control return functions of time and variable returns a vector.","category":"page"},{"location":"tutorial-initial-guess.html#Costate-/-multipliers","page":"Initial guess","title":"Costate / multipliers","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"For the moment there is no option to provide an initial guess for the costate / multipliers.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"","category":"page"},{"location":"api-ctbase/types.html#api-ctbase-types","page":"Types","title":"Types","text":"","category":"section"},{"location":"api-ctbase/types.html","page":"Types","title":"Types","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/types.html#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"api-ctbase/types.html","page":"Types","title":"Types","text":"Pages   = [\"types.md\"]\nModules = [CTBase]\nOrder   = [:type, :module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/types.html#Documentation","page":"Types","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/types.html","page":"Types","title":"Types","text":"Modules = [CTBase]\nOrder   = [:type, :module, :constant, :function, :macro]\nPages   = [\"types.jl\", \"functions.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/types.html#CTBase.AbstractHamiltonian","page":"Types","title":"CTBase.AbstractHamiltonian","text":"abstract type AbstractHamiltonian{TD<:TimeDependence, VD<:VariableDependence}\n\nAbstract type for hamiltonians.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Autonomous","page":"Types","title":"CTBase.Autonomous","text":"abstract type Autonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.BoundaryConstraint","page":"Types","title":"CTBase.BoundaryConstraint","text":"struct BoundaryConstraint{TF<:Function, VD<:VariableDependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor BoundaryConstraint returns a BoundaryConstraint of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar. When the constraint is dimension 1, return a scalar.\n\nCall\n\nThe call returns the evaluation of the BoundaryConstraint for given values. If a variable is given for a non variable dependent boundary constraint, it will be ignored.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.ControlConstraint","page":"Types","title":"CTBase.ControlConstraint","text":"struct ControlConstraint{TF<:Function, TD<:TimeDependence, VD<:VariableDependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlConstraint returns a ControlConstraint of a function. The function must take 1 to 3 arguments, u to (t, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the control is of dimension 1, consider u as a scalar.\n\nCall\n\nThe call returns the evaluation of the ControlConstraint for given values.\n\nExamples\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.ControlLaw","page":"Types","title":"CTBase.ControlLaw","text":"struct ControlLaw{TF<:Function, TD<:TimeDependence, VD<:VariableDependence}\n\nFields\n\nf::Function\n\nSimilar to Hamiltonian in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlLaw returns a ControlLaw of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the ControlLaw for given values.\n\nExamples\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Dynamics","page":"Types","title":"CTBase.Dynamics","text":"struct Dynamics{TF<:Function, TD<:TimeDependence, VD<:VariableDependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Dynamics returns a Dynamics of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Dynamics for given values.\n\nExamples\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.FeedbackControl","page":"Types","title":"CTBase.FeedbackControl","text":"struct FeedbackControl{TF<:Function, TD<:TimeDependence, VD<:VariableDependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor FeedbackControl returns a FeedbackControl of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the FeedbackControl for given values.\n\nExamples\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Fixed","page":"Types","title":"CTBase.Fixed","text":"abstract type Fixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Hamiltonian","page":"Types","title":"CTBase.Hamiltonian","text":"struct Hamiltonian{TF<:Function, TD<:TimeDependence, VD<:VariableDependence} <: AbstractHamiltonian{TD<:TimeDependence, VD<:VariableDependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Hamiltonian returns a Hamiltonian of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Hamiltonian for given values.\n\nExamples\n\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.HamiltonianLift","page":"Types","title":"CTBase.HamiltonianLift","text":"struct HamiltonianLift{TV<:VectorField, TD<:TimeDependence, VD<:VariableDependence} <: AbstractHamiltonian{TD<:TimeDependence, VD<:VariableDependence}\n\nLifts\n\nX::VectorField\n\nThe values for time_dependence and variable_dependence are deternimed by the values of those for the VectorField.\n\nConstructor\n\nThe constructor HamiltonianLift returns a HamiltonianLift of a VectorField.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed))\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianLift for given values.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\nAlternatively, it is possible to construct the HamiltonianLift from a Function being the VectorField.\n\njulia> HL1 = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL2 = HamiltonianLift(VectorField((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true))\njulia> HL1([1, 0], [0, 1], 1) == HL2([1, 0], [0, 1], 1)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.HamiltonianVectorField","page":"Types","title":"CTBase.HamiltonianVectorField","text":"struct HamiltonianVectorField{TF<:Function, TD<:TimeDependence, VD<:VariableDependence} <: CTBase.AbstractVectorField{TD<:TimeDependence, VD<:VariableDependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor HamiltonianVectorField returns a HamiltonianVectorField of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianVectorField for given values.\n\nExamples\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Index","page":"Types","title":"CTBase.Index","text":"mutable struct Index\n\nFields\n\nval::Int64\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Lagrange","page":"Types","title":"CTBase.Lagrange","text":"struct Lagrange{TF<:Function, TD<:TimeDependence, VD<:VariableDependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Lagrange returns a Lagrange cost of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], Autonomous, Fixed)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, Autonomous, Fixed)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], Autonomous, NonFixed)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, Fixed)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Lagrange cost for given values.\n\nExamples\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Mayer","page":"Types","title":"CTBase.Mayer","text":"struct Mayer{TF<:Function, VD<:VariableDependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor Mayer returns a Mayer cost of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar.\n\nCall\n\nThe call returns the evaluation of the Mayer cost for given values. If a variable is given for a non variable dependent Mayer cost, it will be ignored.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1],Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.MixedConstraint","page":"Types","title":"CTBase.MixedConstraint","text":"struct MixedConstraint{TF<:Function, TD<:TimeDependence, VD<:VariableDependence}\n\nFields\n\nf::Function\n\nSimilar to Lagrange in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor MixedConstraint returns a MixedConstraint of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the MixedConstraint for given values.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Multiplier","page":"Types","title":"CTBase.Multiplier","text":"struct Multiplier{TF<:Function, TD<:TimeDependence, VD<:VariableDependence}\n\nFields\n\nf::Function\n\nSimilar to ControlLaw in the usage.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Multiplier returns a Multiplier of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Multiplier for given values.\n\nExamples\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.NonAutonomous","page":"Types","title":"CTBase.NonAutonomous","text":"abstract type NonAutonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.NonFixed","page":"Types","title":"CTBase.NonFixed","text":"abstract type NonFixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.StateConstraint","page":"Types","title":"CTBase.StateConstraint","text":"struct StateConstraint{TF<:Function, TD<:TimeDependence, VD<:VariableDependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor StateConstraint returns a StateConstraint of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the StateConstraint for given values.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.TimeDependence","page":"Types","title":"CTBase.TimeDependence","text":"abstract type TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.VariableConstraint","page":"Types","title":"CTBase.VariableConstraint","text":"struct VariableConstraint{TF<:Function}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VariableConstraint returns a VariableConstraint of a function. The function must take 1 argument, v.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\n\nwarning: Warning\nWhen the variable is of dimension 1, consider v as a scalar.\n\nCall\n\nThe call returns the evaluation of the VariableConstraint for given values.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.VariableDependence","page":"Types","title":"CTBase.VariableDependence","text":"abstract type VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.VectorField","page":"Types","title":"CTBase.VectorField","text":"struct VectorField{TF<:Function, TD<:TimeDependence, VD<:VariableDependence} <: CTBase.AbstractVectorField{TD<:TimeDependence, VD<:VariableDependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VectorField returns a VectorField of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the VectorField for given values.\n\nExamples\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.BoundaryConstraint-Tuple{Function, Type{<:VariableDependence}}","page":"Types","title":"CTBase.BoundaryConstraint","text":"BoundaryConstraint(\n    f::Function,\n    VD::Type{<:VariableDependence}\n) -> BoundaryConstraint\n\n\nReturn a BoundaryConstraint of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.BoundaryConstraint-Tuple{Function}","page":"Types","title":"CTBase.BoundaryConstraint","text":"BoundaryConstraint(\n    f::Function;\n    variable\n) -> BoundaryConstraint\n\n\nReturn a BoundaryConstraint of a function. Dependencies are specified with a boolean, variable, false by default.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.BoundaryConstraint","text":"Return the evaluation of the BoundaryConstraint.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlConstraint-Tuple{Function, Type{<:TimeDependence}, Type{<:VariableDependence}}","page":"Types","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function,\n    TD::Type{<:TimeDependence},\n    VD::Type{<:VariableDependence}\n) -> ControlConstraint\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlConstraint-Tuple{Function}","page":"Types","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlConstraint\n\n\nReturn the ControlConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.ControlConstraint","text":"Return the value of the ControlConstraint function.\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlLaw-Tuple{Function, Type{<:TimeDependence}, Type{<:VariableDependence}}","page":"Types","title":"CTBase.ControlLaw","text":"ControlLaw(\n    f::Function,\n    TD::Type{<:TimeDependence},\n    VD::Type{<:VariableDependence}\n) -> ControlLaw\n\n\nReturn the ControlLaw of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlLaw-Tuple{Function}","page":"Types","title":"CTBase.ControlLaw","text":"ControlLaw(f::Function; autonomous, variable) -> ControlLaw\n\n\nReturn the ControlLaw of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlLaw-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.ControlLaw","text":"Return the value of the ControlLaw function.\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Dynamics-Tuple{Function, Type{<:TimeDependence}, Type{<:VariableDependence}}","page":"Types","title":"CTBase.Dynamics","text":"Dynamics(\n    f::Function,\n    TD::Type{<:TimeDependence},\n    VD::Type{<:VariableDependence}\n) -> Dynamics\n\n\nReturn the Dynamics of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Dynamics-Tuple{Function}","page":"Types","title":"CTBase.Dynamics","text":"Dynamics(f::Function; autonomous, variable) -> Dynamics\n\n\nReturn the Dynamics of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Dynamics-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.Dynamics","text":"Return the value of the Dynamics function.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.FeedbackControl-Tuple{Function, Type{<:TimeDependence}, Type{<:VariableDependence}}","page":"Types","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function,\n    TD::Type{<:TimeDependence},\n    VD::Type{<:VariableDependence}\n) -> FeedbackControl\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.FeedbackControl-Tuple{Function}","page":"Types","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function;\n    autonomous,\n    variable\n) -> FeedbackControl\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.FeedbackControl-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.FeedbackControl","text":"Return the value of the FeedbackControl function.\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Hamiltonian-Tuple{Function, Type{<:TimeDependence}, Type{<:VariableDependence}}","page":"Types","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function,\n    TD::Type{<:TimeDependence},\n    VD::Type{<:VariableDependence}\n) -> Hamiltonian\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Hamiltonian-Tuple{Function}","page":"Types","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Hamiltonian-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.Hamiltonian","text":"Return the value of the Hamiltonian.\n\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianLift-Tuple{Function, Type{<:TimeDependence}, Type{<:VariableDependence}}","page":"Types","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function,\n    TD::Type{<:TimeDependence},\n    VD::Type{<:VariableDependence}\n) -> HamiltonianLift{VectorField{TF, TD, VD}} where {TF<:Function, TD<:TimeDependence, VD<:VariableDependence}\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], Autonomous, Fixed)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], Autonomous, NonFixed)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], NonAutonomous, Fixed)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianLift-Tuple{Function}","page":"Types","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianLift{VectorField{TF, TD, VD}} where {TF<:Function, TD<:TimeDependence, VD<:VariableDependence}\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], autonomous=false, variable=false)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianLift-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.HamiltonianLift","text":"Return the value of the HamiltonianLift.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianVectorField-Tuple{Function, Type{<:TimeDependence}, Type{<:VariableDependence}}","page":"Types","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function,\n    TD::Type{<:TimeDependence},\n    VD::Type{<:VariableDependence}\n) -> HamiltonianVectorField\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianVectorField-Tuple{Function}","page":"Types","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianVectorField\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianVectorField-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.HamiltonianVectorField","text":"Return the value of the HamiltonianVectorField.\n\nExamples\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Lagrange-Tuple{Function, Type{<:TimeDependence}, Type{<:VariableDependence}}","page":"Types","title":"CTBase.Lagrange","text":"Lagrange(\n    f::Function,\n    TD::Type{<:TimeDependence},\n    VD::Type{<:VariableDependence}\n) -> Lagrange\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Lagrange-Tuple{Function}","page":"Types","title":"CTBase.Lagrange","text":"Lagrange(f::Function; autonomous, variable) -> Lagrange\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Lagrange-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.Lagrange","text":"Return the value of the Lagrange function.\n\nExamples\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Mayer-Tuple{Function, Type{<:VariableDependence}}","page":"Types","title":"CTBase.Mayer","text":"Mayer(f::Function, VD::Type{<:VariableDependence}) -> Mayer\n\n\nReturn a Mayer cost of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Mayer-Tuple{Function}","page":"Types","title":"CTBase.Mayer","text":"Mayer(f::Function; variable) -> Mayer\n\n\nReturn a Mayer cost of a function. Dependencies are specified with a boolean, variable, false by default.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Mayer-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.Mayer","text":"Return the evaluation of the Mayer cost.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1], Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.MixedConstraint-Tuple{Function, Type{<:TimeDependence}, Type{<:VariableDependence}}","page":"Types","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function,\n    TD::Type{<:TimeDependence},\n    VD::Type{<:VariableDependence}\n) -> MixedConstraint\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.MixedConstraint-Tuple{Function}","page":"Types","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> MixedConstraint\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.MixedConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.MixedConstraint","text":"Return the value of the MixedConstraint function.\n\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Multiplier-Tuple{Function, Type{<:TimeDependence}, Type{<:VariableDependence}}","page":"Types","title":"CTBase.Multiplier","text":"Multiplier(\n    f::Function,\n    TD::Type{<:TimeDependence},\n    VD::Type{<:VariableDependence}\n) -> Multiplier\n\n\nReturn the Multiplier of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Multiplier-Tuple{Function}","page":"Types","title":"CTBase.Multiplier","text":"Multiplier(f::Function; autonomous, variable) -> Multiplier\n\n\nReturn the Multiplier of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Multiplier-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.Multiplier","text":"Return the value of the Multiplier function.\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.StateConstraint-Tuple{Function, Type{<:TimeDependence}, Type{<:VariableDependence}}","page":"Types","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function,\n    TD::Type{<:TimeDependence},\n    VD::Type{<:VariableDependence}\n) -> StateConstraint\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.StateConstraint-Tuple{Function}","page":"Types","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> StateConstraint\n\n\nReturn the StateConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.StateConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.StateConstraint","text":"Return the value of the StateConstraint function.\n\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.VariableConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.VariableConstraint","text":"Return the value of the VariableConstraint function.\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.VectorField-Tuple{Function, Type{<:TimeDependence}, Type{<:VariableDependence}}","page":"Types","title":"CTBase.VectorField","text":"VectorField(\n    f::Function,\n    TD::Type{<:TimeDependence},\n    VD::Type{<:VariableDependence}\n) -> VectorField\n\n\nReturn a VectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.VectorField-Tuple{Function}","page":"Types","title":"CTBase.VectorField","text":"VectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> VectorField\n\n\nReturn a VectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.VectorField-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.VectorField","text":"Return the value of the VectorField.\n\nExamples\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html","page":"Types","title":"Types","text":"","category":"page"},{"location":"api-ctbase/utils.html#api-ctbase-utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"api-ctbase/utils.html","page":"Utils","title":"Utils","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/utils.html#Index","page":"Utils","title":"Index","text":"","category":"section"},{"location":"api-ctbase/utils.html","page":"Utils","title":"Utils","text":"Pages   = [\"utils.md\"]\nModules = [CTBase]\nOrder = [:type, :module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/utils.html#Documentation","page":"Utils","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/utils.html","page":"Utils","title":"Utils","text":"Modules = [CTBase]\nOrder = [:type, :module, :constant, :function, :macro]\nPages   = [\"utils.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/utils.html#CTBase.ctgradient-Tuple{Function, Any}","page":"Utils","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x; backend) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctgradient-Tuple{Function, Real}","page":"Utils","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x::Real; backend) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctgradient-Tuple{VectorField, Any}","page":"Utils","title":"CTBase.ctgradient","text":"ctgradient(X::VectorField, x) -> Any\n\n\nReturn the gradient of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctindices-Tuple{Int64}","page":"Utils","title":"CTBase.ctindices","text":"ctindices(i::Int64) -> String\n\n\nReturn i > 0 as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctinterpolate-Tuple{Any, Any}","page":"Utils","title":"CTBase.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn the interpolation of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctjacobian-Tuple{Function, Any}","page":"Utils","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x; backend) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctjacobian-Tuple{Function, Real}","page":"Utils","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x::Real; backend) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctjacobian-Tuple{VectorField, Any}","page":"Utils","title":"CTBase.ctjacobian","text":"ctjacobian(X::VectorField, x) -> Any\n\n\nReturn the Jacobian of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctupperscripts-Tuple{Int64}","page":"Utils","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Int64) -> String\n\n\nReturn i > 0 as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html","page":"Utils","title":"Utils","text":"","category":"page"},{"location":"index.html#OptimalControl.jl","page":"Introduction","title":"OptimalControl.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The OptimalControl.jl package is the root package of the control-toolbox ecosystem. The control-toolbox ecosystem gathers Julia packages for mathematical control and applications. It aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods.","category":"page"},{"location":"index.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"To install OptimalControl.jl please  open Julia's interactive session (known as REPL) and press ] key in the REPL to use the package mode, then add the package:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"julia> ]\npkg> add OptimalControl","category":"page"},{"location":"index.html#Mathematical-problem","page":"Introduction","title":"Mathematical problem","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"A (nonautonomous) optimal control problem with possibly free initial and final times can be described as minimising the cost functional","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"g(t_0 x(t_0) t_f x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and other constraints such as","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"index.html#Basic-usage","page":"Introduction","title":"Basic usage","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Let us model, solve and plot a simple optimal control problem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots\n\nocp = @def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n    ẋ(t) == [ x₂(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend\n\nsol = solve(ocp)\n\nplot(sol)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"For more details about this problem, please check the basic example tutorial. For a comprehensive introduction to the syntax used above to describe the optimal control problem, check the abstract syntax tutorial. The solve options are described in the solve tutorial.","category":"page"},{"location":"index.html#Citing-us","page":"Introduction","title":"Citing us","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"If you use OptimalControl.jl in your work, please cite us:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Caillau, J.-B., Cots, O., Gergaud, J., Martinon, P., & Sed, S. OptimalControl.jl: a Julia package to model and solve optimal control problems with ODE's. doi.org/10.5281/zenodo.13336563","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"or in bibtex format:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"@software{Caillau_OptimalControl_jl_a_Julia,\nauthor = {Caillau, Jean-Baptiste and Cots, Olivier and Gergaud, Joseph and Martinon, Pierre and Sed, Sophia},\ndoi = {10.5281/zenodo.13336563},\nlicense = {[\"MIT\"]},\ntitle = {{OptimalControl.jl: a Julia package to model and solve optimal control problems with ODE's}},\nurl = {https://control-toolbox.org/OptimalControl.jl}\n}","category":"page"},{"location":"index.html#Contributing","page":"Introduction","title":"Contributing","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"If you think you found a bug or if you have a feature request / suggestion, feel free to open an  issue. Before opening a pull request, please start an issue or a discussion on the topic. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Contributions are welcomed, check out how to contribute to a Github project.  If it is your first contribution, you can also check this first contribution tutorial. You can find first good issues (if any 🙂) here. You may find other packages to contribute to at the control-toolbox organization.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"If you want to ask a question, feel free to start a discussion here. This forum is for general discussion about this repository and the control-toolbox organization.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Note\nIf you want to add an application or a package to the control-toolbox ecosystem, please follow this set up tutorial.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
