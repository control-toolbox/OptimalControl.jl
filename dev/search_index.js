var documenterSearchIndex = {"docs":
[{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<img width=\"800\" alt=\"juliaopt2024\" src=\"./assets/juliacon2024.jpg\">","category":"page"},{"location":"juliacon2024.html#Trajectory-optimisation-in-space-mechanics-with-Julia","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"","category":"section"},{"location":"juliacon2024.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Alesia-Herasimenka](https://www.uni.lu/snt-en/people/alesia-herasimenka)","page":"Trajectory optimisation in space mechanics with Julia","title":"Jean-Baptiste Caillau, Olivier Cots, Alesia Herasimenka","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil-lux.jpg\">","category":"page"},{"location":"juliacon2024.html#What-it's-about","page":"Trajectory optimisation in space mechanics with Julia","title":"What it's about","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"subject to","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"plus boundary conditions, control and state constraints","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"juliacon2024.html#OptimalControl.jl-for-trajectory-optimisation","page":"Trajectory optimisation in space mechanics with Julia","title":"OptimalControl.jl for trajectory optimisation","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Basic example\nGoddard problem\nOrbit transfer","category":"page"},{"location":"juliacon2024.html#Wrap-up","page":"Trajectory optimisation in space mechanics with Julia","title":"Wrap up","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"High level modelling of optimal control problems\nEfficient numerical resolution coupling direct and indirect methods\nCollection of examples","category":"page"},{"location":"juliacon2024.html#Future","page":"Trajectory optimisation in space mechanics with Julia","title":"Future","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"New applications (biology, space mechanics, quantum mechanics and more)\nAdditional solvers: direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions!","category":"page"},{"location":"juliacon2024.html#control-toolbox.org","page":"Trajectory optimisation in space mechanics with Julia","title":"control-toolbox.org","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"juliacon2024.html#Credits-(not-exhaustive!)","page":"Trajectory optimisation in space mechanics with Julia","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nMLStyle.jl","category":"page"},{"location":"juliacon2024.html#Acknowledgements","page":"Trajectory optimisation in space mechanics with Julia","title":"Acknowledgements","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Jean-Baptiste Caillau is partially funded by a France 2030 support managed by the Agence Nationale de la Recherche, under the reference ANR-23-PEIA-0004 (PDE-AI project).","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<img width=\"200\" alt=\"affiliations\" src=\"./assets/france-2030.png\">","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"","category":"page"},{"location":"manual-model.html#manual-model","page":"Problem characteristics","title":"The optimal control problem object: structure and usage","text":"","category":"section"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"In this manual, we'll first recall the main functionalities you can use when working with an optimal control problem (OCP). This includes essential operations like:","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"Solving an OCP: How to find the optimal solution for your defined problem.\nComputing flows from an OCP: Understanding the dynamics and trajectories derived from the optimal solution.\nPrinting an OCP: How to display a summary of your problem's definition.","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"After covering these core functionalities, we'll delve into the structure of an OCP. Since an OCP is structured as a Model struct, we'll first explain how to access its underlying attributes, such as the problem's dynamics, costs, and constraints. Following this, we'll shift our focus to the simple properties inherent to an OCP, learning how to determine aspects like whether the problem:","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"Is autonomous: Does its dynamics depend explicitly on time?\nHas a fixed or free initial/final time: Is the duration of the control problem predetermined or not?","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"Content","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"Main functionalities\nModel struct\nAttributes and properties","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"","category":"page"},{"location":"manual-model.html#manual-model-main-functionalities","page":"Problem characteristics","title":"Main functionalities","text":"","category":"section"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"Let's define a basic optimal control problem.","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"using OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    x(t0) == x0\n    x(tf) == [0, 0]\n    ẋ(t)  == [v(t), u(t)]\n    0.5∫( u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"To print it, simply:","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"ocp","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"We can now solve the problem (for more details, visit the solve manual):","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"using NLPModelsIpopt\nsolve(ocp)\nnothing # hide","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"You can also compute flows (for more details, see the flow manual) from the optimal control problem, providing a control law in feedback form. The pseudo-Hamiltonian of this problem is","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"    H(x p u) = p_q q + p_v v + p^0 u^2 2","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"where p^0 = -1 since we are in the normal case. From the Pontryagin maximum principle, the maximising control is given in feedback form by","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"u(x p) = p_v","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"since partial^2_uu H = p^0 = - 1  0. ","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"u = (x, p) -> p[2]          # control law in feedback form\n\nusing OrdinaryDiffEq        # needed to import numerical integrators\nf = Flow(ocp, u)            # compute the Hamiltonian flow function\n\np0 = [12, 6]                # initial covector solution\nxf, pf = f(t0, x0, p0, tf)  # flow from (x0, p0) at time t0 to tf\nxf                          # should be (0, 0)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"note: Note\nA more advanced feature allows for the discretization of the optimal control problem. From the discretized version, you can obtain a Nonlinear Programming problem (or optimization problem) and solve it using any appropriate NLP solver. For more details, visit the NLP manipulation tutorial.","category":"page"},{"location":"manual-model.html#manual-model-struct","page":"Problem characteristics","title":"Model struct","text":"","category":"section"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"The optimal control problem ocp is a Model struct. ","category":"page"},{"location":"manual-model.html#CTModels.Model-manual-model","page":"Problem characteristics","title":"CTModels.Model","text":"struct Model{TD<:CTModels.TimeDependence, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:CTModels.AbstractConstraintsModel, BuildExaModelType<:Union{Nothing, Function}} <: CTModels.AbstractModel\n\nFields\n\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ndynamics::Function\nobjective::CTModels.AbstractObjectiveModel\nconstraints::CTModels.AbstractConstraintsModel\ndefinition::Expr\nbuild_examodel::Union{Nothing, Function}\n\n\n\n\n\n","category":"type"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"Each field can be accessed directly (ocp.times, etc) or by a getter:","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"times\nstate\ncontrol\nvariable\ndynamics\nobjective\nconstraints\ndefinition\nget_build_examodel","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"For instance, we can retrieve the times and definition values.","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"times(ocp)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"definition(ocp)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"note: Note\nWe refer to CTModels API for more details about this struct and its fields.","category":"page"},{"location":"manual-model.html#manual-model-attributes","page":"Problem characteristics","title":"Attributes and properties","text":"","category":"section"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"Numerous attributes can be retrieved. To illustrate this, a more complex optimal control problem is defined.","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"ocp = @def begin\n    v = (w, tf) ∈ R²,   variable\n    s ∈ [0, tf],        time\n    q = (x, y) ∈ R²,    state\n    u ∈ R,              control\n    0 ≤ tf ≤ 2,         (1)\n    u(s) ≥ 0,           (cons_u)\n    x(s) + u(s) ≤ 10,   (cons_mixed)\n    w == 0\n    x(0) == -1\n    y(0) - tf == 0,     (cons_bound)\n    q(tf) == [0, 0]\n    q̇(s) == [y(s)+w, u(s)]\n    0.5∫( u(s)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"manual-model.html#Control,-state-and-variable","page":"Problem characteristics","title":"Control, state and variable","text":"","category":"section"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"You can access the name of the control, state, and variable, along with the names of their components and their dimensions.","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"using DataFrames\ndata = DataFrame(\n    Data=Vector{Symbol}(),\n    Name=Vector{String}(),\n    Components=Vector{Vector{String}}(), \n    Dimension=Vector{Int}(),\n)\n\n# control\npush!(data,(\n    :control,\n    control_name(ocp),\n    control_components(ocp),\n    control_dimension(ocp),\n))\n\n# state\npush!(data,(\n    :state,\n    state_name(ocp),\n    state_components(ocp),\n    state_dimension(ocp),\n))\n\n# variable\npush!(data,(\n    :variable,\n    variable_name(ocp),\n    variable_components(ocp),\n    variable_dimension(ocp),\n))","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"note: Note\nThe names of the components are used for instance when plotting the solution. See the plot manual.","category":"page"},{"location":"manual-model.html#Constraints","page":"Problem characteristics","title":"Constraints","text":"","category":"section"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"You can retrieve labelled constraints with the constraint function. The constraint(ocp, label) method returns a tuple of the form (type, f, lb, ub). The signature of the function f depends on the symbol type. For :boundary and :variable constraints, the signature is f(x0, xf, v) where x0 is the initial state, xf the final state and v the variable. For other constraints, the signature is f(t, x, u, v). Here, t represents time, x the state, u the control, and v the variable.","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"(type, f, lb, ub) = constraint(ocp, :eq1)\nprintln(\"type: \", type)\nx0 = [0, 1]\nxf = [2, 3]\nv  = [1, 4]\nprintln(\"val: \", f(x0, xf, v))\nprintln(\"lb: \", lb)\nprintln(\"ub: \", ub)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"(type, f, lb, ub) = constraint(ocp, :cons_bound)\nprintln(\"type: \", type)\nprintln(\"val: \", f(x0, xf, v))\nprintln(\"lb: \", lb)\nprintln(\"ub: \", ub)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"(type, f, lb, ub) = constraint(ocp, :cons_u)\nprintln(\"type: \", type)\nt = 0\nx = [1, 2]\nu = 3\nprintln(\"val: \", f(t, x, u, v))\nprintln(\"lb: \", lb)\nprintln(\"ub: \", ub)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"(type, f, lb, ub) = constraint(ocp, :cons_mixed)\nprintln(\"type: \", type)\nprintln(\"val: \", f(t, x, u, v))\nprintln(\"lb: \", lb)\nprintln(\"ub: \", ub)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"note: Note\nTo get the dual variable (or Lagrange multiplier) associated to the constraint, use the dual method.","category":"page"},{"location":"manual-model.html#Dynamics","page":"Problem characteristics","title":"Dynamics","text":"","category":"section"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"The dynamics stored in ocp are an in-place function (the first argument is mutated upon call) of the form f!(dx, t, x, u, v). Here, t represents time, x the state, u the control, and v the variable, with dx being the output value.","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"f! = dynamics(ocp)\nt = 0\nx = [0., 1]\nu = 2\nv = [1, 4]\ndx = similar(x)\nf!(dx, t, x, u, v)\ndx","category":"page"},{"location":"manual-model.html#Criterion-and-objective","page":"Problem characteristics","title":"Criterion and objective","text":"","category":"section"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"The criterion can be :min or :max.","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"criterion(ocp)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"The objective function is either in Mayer, Lagrange or Bolza form. ","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"Mayer:","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"g(x(t_0) x(t_f) v) to min","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"Lagrange:","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"int_t_0^t_f f^0(t x(t) u(t) v) mathrmdt to min","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"Bolza:","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"g(x(t_0) x(t_f) v) + int_t_0^t_f f^0(t x(t) u(t) v) mathrmdt to min","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"The objective of problem ocp is 0.5∫( u(t)^2 ) → min, hence, in Lagrange form. The signature of the Mayer part of the objective is g(x0, xf, v) but in our case, the method mayer will return an error.","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"g = mayer(ocp)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"The signature of the Lagrange part of the objective is f⁰(t, x, u, v).","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"f⁰ = lagrange(ocp)\nf⁰(t, x, u, v)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"To avoid having to capture exceptions, you can check the form of the objective:","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"println(\"Mayer: \", has_mayer_cost(ocp))\nprintln(\"Lagrange: \", has_lagrange_cost(ocp))","category":"page"},{"location":"manual-model.html#Times","page":"Problem characteristics","title":"Times","text":"","category":"section"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"The time variable is not named t but s in ocp.","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"time_name(ocp)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"The initial time is 0.","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"initial_time(ocp)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"Since the initial time has the value 0, its name is string(0). ","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"initial_time_name(ocp)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"In contrast, the final time is tf, since in ocp we have s ∈ [0, tf].","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"final_time_name(ocp)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"To get the value of the final time, since it is part of the variable v = (w, tf) of ocp, we need to provide a variable to the function final_time. ","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"v = [1, 2]\ntf = final_time(ocp, v)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"final_time(ocp)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"To check whether the initial or final time is fixed or free (i.e., part of the variable), you can use the following functions:","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"println(\"Fixed initial time: \", has_fixed_initial_time(ocp))\nprintln(\"Fixed final time: \", has_fixed_final_time(ocp))","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"Or, similarly:","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"println(\"Free initial time: \", has_free_initial_time(ocp))\nprintln(\"Free final time: \", has_free_final_time(ocp))","category":"page"},{"location":"manual-model.html#manual-model-time-dependence","page":"Problem characteristics","title":"Time dependence","text":"","category":"section"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"Optimal control problems can be autonomous or non-autonomous. In an autonomous problem, neither the dynamics nor the Lagrange cost explicitly depends on the time variable.","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"The following problem is autonomous.","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"ocp = @def begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R, state\n    u ∈ R, control\n    ẋ(t)  == u(t)                       # no explicit dependence on t\n    x(1) + 0.5∫( u(t)^2 ) → min         # no explicit dependence on t\nend\nis_autonomous(ocp)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"The following problem is non-autonomous since the dynamics depends on t.","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"ocp = @def begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R, state\n    u ∈ R, control\n    ẋ(t)  == u(t) + t                   # explicit dependence on t\n    x(1) + 0.5∫( u(t)^2 ) → min\nend\nis_autonomous(ocp)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"Finally, this last problem is non-autonomous because the Lagrange part of the cost depends on t.","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"ocp = @def begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R, state\n    u ∈ R, control\n    ẋ(t)  == u(t)\n    x(1) + 0.5∫( t + u(t)^2 ) → min     # explicit dependence on t\nend\nis_autonomous(ocp)","category":"page"},{"location":"manual-model.html","page":"Problem characteristics","title":"Problem characteristics","text":"","category":"page"},{"location":"manual-solve.html#manual-solve","page":"Solve a problem","title":"The solve function","text":"","category":"section"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"In this manual, we explain the solve function from OptimalControl.jl package.","category":"page"},{"location":"manual-solve.html#CommonSolve.solve-Tuple{Model, Vararg{Symbol}}-manual-solve","page":"Solve a problem","title":"CommonSolve.solve","text":"solve(\n    ocp::Model,\n    description::Symbol...;\n    display,\n    kwargs...\n) -> Solution{TimeGridModelType, TimesModelType, StateModelType, ControlModelType, VariableModelType, CostateModelType, Float64, DualModelType, CTModels.SolverInfos{Dict{Symbol, Any}}, ModelType} where {TimeGridModelType<:CTModels.TimeGridModel, TimesModelType<:CTModels.TimesModel, StateModelType<:Union{CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#114#136\", CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#115#137\"}, ControlModelType<:Union{CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#116#138\", CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#117#139\"}, VariableModelType<:Union{CTModels.VariableModelSolution{Vector{Float64}}, CTModels.VariableModelSolution{Float64}}, CostateModelType<:Union{CTModels.var\"#118#140\", CTModels.var\"#119#141\"}, DualModelType<:(CTModels.DualModel{PC_Dual, Vector{Float64}, SC_LB_Dual, SC_UB_Dual, CC_LB_Dual, CC_UB_Dual, Vector{Float64}, Vector{Float64}} where {PC_Dual<:Union{CTModels.var\"#121#143\"{CTModels.var\"#120#142\"}, CTModels.var\"#122#144\"{CTModels.var\"#120#142\"}}, SC_LB_Dual<:Union{CTModels.var\"#124#146\"{CTModels.var\"#123#145\"}, CTModels.var\"#125#147\"{CTModels.var\"#123#145\"}}, SC_UB_Dual<:Union{CTModels.var\"#127#149\"{CTModels.var\"#126#148\"}, CTModels.var\"#128#150\"{CTModels.var\"#126#148\"}}, CC_LB_Dual<:Union{CTModels.var\"#130#152\"{CTModels.var\"#129#151\"}, CTModels.var\"#131#153\"{CTModels.var\"#129#151\"}}, CC_UB_Dual<:Union{CTModels.var\"#133#155\"{CTModels.var\"#132#154\"}, CTModels.var\"#134#156\"{CTModels.var\"#132#154\"}}}), ModelType<:Model}\n\n\nSolve the optimal control problem ocp by the method given by the (optional) description. The get the list of available methods:\n\njulia> available_methods()\n\nThe higher in the list, the higher is the priority. The keyword arguments are specific to the chosen method and represent the options of the solver.\n\nArguments\n\nocp::OptimalControlModel: the optimal control problem to solve.\ndescription::Symbol...: the description of the method used to solve the problem.\nkwargs...: the options of the method.\n\nExamples\n\nThe simplest way to solve the optimal control problem is to call the function without any argument.\n\njulia> sol = solve(ocp)\n\nThe method description is a list of Symbols. The default is\n\njulia> sol = solve(ocp, :direct, :adnlp, :ipopt)\n\nYou can provide a partial description, the function will find the best match.\n\njulia> sol = solve(ocp, :direct)\n\nnote: Note\nSee the resolution methods section for more details about the available methods.\n\nThe keyword arguments are specific to the chosen method and correspond to the options of the different solvers. For example, the keyword max_iter is an Ipopt option that may be used to set the maximum number of iterations.\n\njulia> sol = solve(ocp, :direct, :ipopt, max_iter=100)\n\nnote: Note\nSee the direct method section for more details about associated options. These options also detailed in the CTDirect.solve documentation. This main solve method redirects to CTDirect.solve when the :direct Symbol is given in the description. See also the NLP solvers section for more details about Ipopt or MadNLP options.\n\nTo help the solve converge, an initial guess can be provided within the keyword init. You can provide the initial guess for the state, control, and variable.\n\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5))\n\nnote: Note\nSee how to set an initial guess for more details.\n\n\n\n\n\n","category":"method"},{"location":"manual-solve.html#Basic-usage","page":"Solve a problem","title":"Basic usage","text":"","category":"section"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Let us define a basic optimal control problem.","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"using OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    x(t0) == x0\n    x(tf) == [0, 0]\n    ẋ(t)  == [v(t), u(t)]\n    ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"We can now solve the problem:","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"using NLPModelsIpopt\nsolve(ocp)\nnothing # hide","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Note that we must import NLPModelsIpopt.jl before calling solve.   This is because the default method uses a direct approach, which transforms the optimal control problem into a nonlinear program (NLP) of the form:","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"textminimizequad F(y) quadtextsubject to the constraintsquad g(y) le 0 quad h(y) = 0 ","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"caveat: Caveat\nCalling solve without loading a NLP solver package first will notify the user:julia> solve(ocp)\nERROR: ExtensionError. Please make: julia> using NLPModelsIpopt","category":"page"},{"location":"manual-solve.html#manual-solve-methods","page":"Solve a problem","title":"Resolution methods and algorithms","text":"","category":"section"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"OptimalControl.jl offers a list of methods. To get it, simply call available_methods.","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"available_methods()","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Each line is a method, with priority going from top to bottom. This means that ","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"solve(ocp)","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"is equivalent to ","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"solve(ocp, :direct, :adnlp, :ipopt)","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"The first symbol refers to the general class of method. The only possible value is:\n:direct: currently, only the so-called direct approach is implemented. Direct methods discretise the original optimal control problem and solve the resulting NLP. In this case, the main solve method redirects to CTDirect.solve.\nThe second symbol refers to the NLP modeler. The possible values are:\n:adnlp: the NLP problem is modeled by a ADNLPModels.ADNLPModel. It provides automatic differentiation (AD)-based models that follow the NLPModels.jl API.\nThe third symbol specifies the NLP solver. Possible values are:\n:ipopt: calls NLPModelsIpopt.ipopt to solve the NLP problem.\n:madnlp: creates a MadNLP.MadNLPSolver instance from the NLP problem and solve it. MadNLP.jl is an open-source solver in Julia implementing a filter line-search interior-point algorithm like Ipopt.\n:knitro: uses the Knitro solver (license required).","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"For instance, let us try MadNLP.jl.","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"using MadNLP\nsolve(ocp, :madnlp)\nnothing # hide","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Note that you can provide a partial description. If multiple full descriptions contain it, priority is given to the first one in the list. Hence, all of the following calls are equivalent:","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"solve(ocp)\nsolve(ocp, :direct                )\nsolve(ocp,          :adnlp        )\nsolve(ocp,                  :ipopt)\nsolve(ocp, :direct, :adnlp        )\nsolve(ocp, :direct,         :ipopt)\nsolve(ocp, :direct, :adnlp, :ipopt)","category":"page"},{"location":"manual-solve.html#manual-solve-direct-method","page":"Solve a problem","title":"Direct method","text":"","category":"section"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"The main options for the direct method, with their [default] values, are:","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"display ([true], false): setting display = false disables output.\ninit: information for the initial guess. It can be given as numerical values, functions, or an existing solution. See how to set an initial guess.\ngrid_size ([250]): number of time steps in the (uniform) time discretization grid.   More precisely, if N = grid_size and the initial and final times are t0 and tf, then the step length Δt = (tf - t0) / N.\ntime_grid ([nothing]): explicit time grid (can be non-uniform).   If time_grid = nothing, a uniform grid of length grid_size is used.\ndisc_method ([:trapeze], :midpoint, :euler, :euler_implicit, :gauss_legendre_2, :gauss_legendre_3): the discretisation scheme to transform the dynamics into nonlinear equations. See the discretization method tutorial for more details.\nadnlp_backend ([:optimized], :manual, :default): backend used for automatic differentiation to create the ADNLPModels.ADNLPModel.","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"For advanced usage, see:","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"discrete continuation tutorial,\nNLP manipulation tutorial.","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"note: Note\nThe main solve method from OptimalControl.jl simply redirects to CTDirect.solve in that case.","category":"page"},{"location":"manual-solve.html#manual-solve-solvers-specific-options","page":"Solve a problem","title":"NLP solvers specific options","text":"","category":"section"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"In addition to these options, all remaining keyword arguments passed to solve will be transmitted to the NLP solver used.","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Please check the list of Ipopt options and the NLPModelsIpopt.jl documentation.","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"sol = solve(ocp; max_iter=0, display=false)\niterations(sol)","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Similarly, please check the MadNLP.jl documentation and the list of MadNLP.jl options.","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"sol = solve(ocp, :madnlp; max_iter=0, display=false)\niterations(sol)","category":"page"},{"location":"manual-solve.html","page":"Solve a problem","title":"Solve a problem","text":"","category":"page"},{"location":"api-ctbase.html#CTBase.jl","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"The CTBase.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"flowchart TD\nB(<a href='api-ctbase.html'>CTBase</a>)\nM(<a href='api-ctmodels.html'>CTModels</a>)\nP(<a href='api-ctparser.html'>CTParser</a>)\nO(<a href='api-optimalcontrol-dev.html'>OptimalControl</a>)\nD(<a href='api-ctdirect.html'>CTDirect</a>)\nF(<a href='api-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle B fill:#FBF275","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"OptimalControl heavily relies on CTBase. We refer to CTBase API for more details.","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"page"},{"location":"api-ctdirect.html#CTDirect.jl","page":"CTDirect.jl","title":"CTDirect.jl","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"The CTDirect.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"flowchart TD\nB(<a href='api-ctbase.html'>CTBase</a>)\nM(<a href='api-ctmodels.html'>CTModels</a>)\nP(<a href='api-ctparser.html'>CTParser</a>)\nO(<a href='api-optimalcontrol-dev.html'>OptimalControl</a>)\nD(<a href='api-ctdirect.html'>CTDirect</a>)\nF(<a href='api-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle D fill:#FBF275","category":"page"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"OptimalControl heavily relies on CTDirect. We refer to CTDirect API for more details.","category":"page"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"","category":"page"},{"location":"manual-initial-guess.html#manual-initial-guess","page":"Set an initial guess","title":"Initial guess (or iterate) for the resolution","text":"","category":"section"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"We present the different possibilities to provide an initial guess to solve an  optimal control problem with the OptimalControl.jl package. ","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"First, we need to import OptimalControl.jl to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import Plots.jl to plot solutions.","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"For the illustrations, we define the following optimal control problem.","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"t0 = 0\ntf = 10\nα  = 5\n\nocp = @def begin\n    t ∈ [t0, tf], time\n    v ∈ R, variable\n    x ∈ R², state\n    u ∈ R, control\n    x(t0) == [ -1, 0 ]\n    x₁(tf) == 0\n    ẋ(t) == [ x₂(t), x₁(t) + α*x₁(t)^2 + u(t) ]\n    x₂(tf)^2 + ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"manual-initial-guess.html#Default-initial-guess","page":"Set an initial guess","title":"Default initial guess","text":"","category":"section"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"We first solve the problem without giving an initial guess. This will default to initialize all variables to 0.1.","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# solve the optimal control problem without initial guess\nsol = solve(ocp; display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Let us plot the solution of the optimal control problem.","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"plot(sol; size=(600, 450))","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Note that the following formulations are equivalent to not giving an initial guess.","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"sol = solve(ocp; init=nothing, display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\nsol = solve(ocp; init=(), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"tip: Interactions with an optimal control solution\nTo get the number of iterations of the solver, check the iterations function.","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"To reduce the number of iterations and improve the convergence, we can give an initial guess to the solver.  This initial guess can be built from constant values, interpolated vectors, functions, or existing solutions. Except when initializing from a solution, the arguments are to be passed as a named tuple init=(state=..., control=..., variable=...) whose fields are optional. Missing fields will revert to default initialization (ie constant 0.1).","category":"page"},{"location":"manual-initial-guess.html#Constant-initial-guess","page":"Set an initial guess","title":"Constant initial guess","text":"","category":"section"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"We first illustrate the constant initial guess, using vectors or scalars according to the dimension.","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# solve the optimal control problem with initial guess with constant values\nsol = solve(ocp; init=(state=[-0.2, 0.1], control=-0.2, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Partial initializations are also valid, as shown below. Note the ending comma when a single argument is passed, since it must be a tuple.","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# initialisation only on the state\nsol = solve(ocp; init=(state=[-0.2, 0.1],), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\n# initialisation only on the control\nsol = solve(ocp; init=(control=-0.2,), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\n# initialisation only on the state and the variable\nsol = solve(ocp; init=(state=[-0.2, 0.1], variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"manual-initial-guess.html#Functional-initial-guess","page":"Set an initial guess","title":"Functional initial guess","text":"","category":"section"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"For the state and control, we can also provide functions of time as initial guess.","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# initial guess as functions of time\nx(t) = [ -0.2t, 0.1t ]\nu(t) = -0.2t\n\nsol = solve(ocp; init=(state=x, control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"manual-initial-guess.html#Vector-initial-guess-(interpolated)","page":"Set an initial guess","title":"Vector initial guess (interpolated)","text":"","category":"section"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Initialization can also be provided with vectors / matrices to be interpolated along a given time grid.  In this case the time steps must be given through an additional argument time, which can be a vector or line/column matrix. For the values to be interpolated both matrices and vectors of vectors are allowed, but the shape should be number of time steps x variable dimension. Simple vectors are also allowed for variables of dimension 1.","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# initial guess as vector of points\nt_vec = LinRange(t0,tf,4)\nx_vec = [[0, 0], [-0.1, 0.3], [-0.15,0.4], [-0.3, 0.5]]\nu_vec = [0, -0.8,  -0.3, 0]\n\nsol = solve(ocp; init=(time=t_vec, state=x_vec, control=u_vec, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Note: in the free final time case, the given time grid should be consistent with the initial guess provided for the final time (in the optimization variables).","category":"page"},{"location":"manual-initial-guess.html#Mixed-initial-guess","page":"Set an initial guess","title":"Mixed initial guess","text":"","category":"section"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"The constant, functional and vector initializations can be mixed, for instance as","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# we can mix constant values with functions of time\nsol = solve(ocp; init=(state=[-0.2, 0.1], control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\n# wa can mix every possibility\nsol = solve(ocp; init=(time=t_vec, state=x_vec, control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"manual-initial-guess.html#Solution-as-initial-guess-(warm-start)","page":"Set an initial guess","title":"Solution as initial guess (warm start)","text":"","category":"section"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Finally, we can use an existing solution to provide the initial guess.  The dimensions of the state, control and optimization variable must coincide. This particular feature allows an easy implementation of discrete continuations.","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# generate the initial solution\nsol_init = solve(ocp; display=false)\n\n# solve the problem using solution as initial guess\nsol = solve(ocp; init=sol_init, display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Note that you can also manually pick and choose which data to reuse from a solution, by recovering the  functions state(sol), control(sol) and the values variable(sol). For instance the following formulation is equivalent to the init=sol one.","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# use a previous solution to initialise picking data\nsol = solve(ocp; \n    init = (\n        state    = state(sol), \n        control  = control(sol), \n        variable = variable(sol)\n    ), \n    display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"tip: Interactions with an optimal control solution\nPlease check state, costate, control and variable to get data from the solution. The functions state, costate and control return functions of time and variable returns a vector.","category":"page"},{"location":"manual-initial-guess.html#Costate-/-multipliers","page":"Set an initial guess","title":"Costate / multipliers","text":"","category":"section"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"For the moment there is no option to provide an initial guess for the costate / multipliers.","category":"page"},{"location":"manual-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"","category":"page"},{"location":"example-double-integrator-energy.html#example-double-integrator-energy","page":"Energy minimisation","title":"Double integrator: energy minimisation","text":"","category":"section"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force u. We denote by x = (x_1 x_2) the state of the wagon, that is its position x_1 and its velocity x_2.","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We assume that the mass is constant and unitary and that there is no friction. The dynamics we consider is given by","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t)quad u(t) in R","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"which is simply the double integrator system. Les us consider a transfer starting at time t_0 = 0 and ending at time t_f = 1, for which we want to minimise the transfer energy","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"    frac12int_0^1 u^2(t)  mathrmdt","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"starting from the condition x(0) = (-1 0) and with the goal to reach the target x(1) = (0 0).","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"example-double-integrator-energy.html#Optimal-control-problem","page":"Energy minimisation","title":"Optimal control problem","text":"","category":"section"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"Let us define the problem with the @def macro:","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"ocp = @def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(1) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"note: Nota bene\nFor a comprehensive introduction to the syntax used above to define the optimal control problem, check this abstract syntax tutorial. In particular, there are non-unicode alternatives for derivatives, integrals, etc.","category":"page"},{"location":"example-double-integrator-energy.html#example-double-integrator-energy-solve-plot","page":"Energy minimisation","title":"Solve and plot","text":"","category":"section"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We can solve it simply with:","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"And plot the solution with:","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"plot(sol)","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"note: Nota bene\nThe solve function has options, see the solve tutorial. You can customise the plot, see the plot tutorial.","category":"page"},{"location":"example-double-integrator-energy.html#State-constraint","page":"Energy minimisation","title":"State constraint","text":"","category":"section"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We add the path constraint","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"x_2(t) le 12","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"Let us model, solve and plot the optimal control problem with this constraint.","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"ocp = @def begin\n\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x₂(t) ≤ 1.2\n\n    x(0) == [-1, 0]\n    x(1) == [0, 0]\n\n    ẋ(t) == [x₂(t), u(t)]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\n\nsol = solve(ocp)\n\nplot(sol)","category":"page"},{"location":"example-double-integrator-energy.html#Exporting-and-importing-the-solution","page":"Energy minimisation","title":"Exporting and importing the solution","text":"","category":"section"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We can export (or save) the solution in a Julia .jld2 data file and reload it later, and also export a discretised version of the solution in a more portable JSON format. Note that the optimal control problem is needed when loading a solution.","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"See the two functions:","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"import_ocp_solution,\nexport_ocp_solution.","category":"page"},{"location":"example-double-integrator-energy.html#JLD2","page":"Energy minimisation","title":"JLD2","text":"","category":"section"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"# using JLD2\nusing Suppressor # hide\n@suppress_err begin # hide\n# export_ocp_solution(sol; filename=\"my_solution\")\nend # hide\n# sol_jld = import_ocp_solution(ocp; filename=\"my_solution\")\n# println(\"Objective from computed solution: \", objective(sol))\n# println(\"Objective from imported solution: \", objective(sol_jld))","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"danger: Bug\nThe code above does not work in the documentation but works locally. This bug will be fixed.","category":"page"},{"location":"example-double-integrator-energy.html#JSON","page":"Energy minimisation","title":"JSON","text":"","category":"section"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"using JSON3\nexport_ocp_solution(sol; filename=\"my_solution\", format=:JSON)\nsol_json = import_ocp_solution(ocp; filename=\"my_solution\", format=:JSON)\nprintln(\"Objective from computed solution: \", objective(sol))\nprintln(\"Objective from imported solution: \", objective(sol_json))","category":"page"},{"location":"example-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"","category":"page"},{"location":"example-double-integrator-time.html#example-double-integrator-time","page":"Time mininimisation","title":"Double integrator: time minimisation","text":"","category":"section"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"The problem consists in minimising the final time t_f for the double integrator system","category":"page"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) quad u(t) in -11","category":"page"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"and the limit conditions","category":"page"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"    x(0) = (12) quad x(t_f) = (00)","category":"page"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"This problem can be interpretated as a simple model for a wagon with constant mass moving along a line without fricton.","category":"page"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"example-double-integrator-time.html#Optimal-control-problem","page":"Time mininimisation","title":"Optimal control problem","text":"","category":"section"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"Let us define the problem","category":"page"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"ocp = @def begin\n\n    tf ∈ R,          variable\n    t ∈ [0, tf],     time\n    x = (q, v) ∈ R², state\n    u ∈ R,           control\n\n    -1 ≤ u(t) ≤ 1\n\n    q(0)  == -1\n    v(0)  == 0\n    q(tf) == 0\n    v(tf) == 0\n\n    ẋ(t) == [v(t), u(t)]\n\n    tf → min\n\nend\nnothing # hide","category":"page"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"note: Nota bene\nFor a comprehensive introduction to the syntax used above to define the optimal control problem, check this abstract syntax tutorial. In particular, there are non-unicode alternatives for derivatives, integrals, etc.","category":"page"},{"location":"example-double-integrator-time.html#Solve-and-plot","page":"Time mininimisation","title":"Solve and plot","text":"","category":"section"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"Solve it","category":"page"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"sol = solve(ocp; grid_size=200, print_level=4)\nnothing # hide","category":"page"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"and plot the solution","category":"page"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"plot(sol)","category":"page"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"note: Nota bene\nThe solve function has options, see the solve tutorial. You can customise the plot, see the plot tutorial.","category":"page"},{"location":"example-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"","category":"page"},{"location":"manual-flow-api.html#manual-flow-api","page":"Flow API","title":"API of the Flow function","text":"","category":"section"},{"location":"manual-flow-api.html#CTFlows.Flow-manual-flow-api","page":"Flow API","title":"CTFlows.Flow","text":"Flow(\n    vf::VectorField;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.VectorFieldFlow\n\n\nConstructs a flow object for a classical (non-Hamiltonian) vector field.\n\nThis creates a VectorFieldFlow that integrates the ODE system dx/dt = vf(t, x, v) using DifferentialEquations.jl. It handles both fixed and parametric dynamics, as well as jump discontinuities and event stopping.\n\nKeyword Arguments\n\nalg, abstol, reltol, saveat, internalnorm: Solver options.\nkwargs_Flow...: Additional arguments passed to the solver configuration.\n\nExample\n\njulia> vf(t, x, v) = -v * x\njulia> flow = CTFlows.Flow(CTFlows.VectorField(vf))\njulia> x1 = flow(0.0, 1.0, 1.0)\n\n\n\n\n\nFlow(\n    h::CTFlows.AbstractHamiltonian;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.HamiltonianFlow\n\n\nConstructs a Hamiltonian flow from a scalar Hamiltonian.\n\nThis method builds a numerical integrator that simulates the evolution of a Hamiltonian system given a Hamiltonian function h(t, x, p, l) or h(x, p).\n\nInternally, it computes the right-hand side of Hamilton’s equations via automatic differentiation and returns a HamiltonianFlow object.\n\nKeyword Arguments\n\nalg, abstol, reltol, saveat, internalnorm: solver options.\nkwargs_Flow...: forwarded to the solver.\n\nExample\n\njulia> H(x, p) = dot(p, p) + dot(x, x)\njulia> flow = CTFlows.Flow(CTFlows.Hamiltonian(H))\njulia> xf, pf = flow(0.0, x0, p0, 1.0)\n\n\n\n\n\nFlow(\n    hv::HamiltonianVectorField;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.HamiltonianFlow\n\n\nConstructs a Hamiltonian flow from a precomputed Hamiltonian vector field.\n\nThis method assumes you already provide the Hamiltonian vector field (dx/dt, dp/dt) instead of deriving it from a scalar Hamiltonian.\n\nReturns a HamiltonianFlow object that integrates the given system.\n\nKeyword Arguments\n\nalg, abstol, reltol, saveat, internalnorm: solver options.\nkwargs_Flow...: forwarded to the solver.\n\nExample\n\njulia> hv(t, x, p, l) = (∇ₚH, -∇ₓH)\njulia> flow = CTFlows.Flow(CTFlows.HamiltonianVectorField(hv))\njulia> xf, pf = flow(0.0, x0, p0, 1.0, l)\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::CTFlows.ControlLaw;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConstruct a flow for an optimal control problem using a given control law.\n\nThis method builds the Hamiltonian system associated with the optimal control problem (ocp) and integrates the corresponding state–costate dynamics using the specified control law u.\n\nArguments\n\nocp::CTModels.Model: An optimal control problem defined using CTModels.\nu::CTFlows.ControlLaw: A feedback control law generated by ControlLaw(...) or similar.\nalg: Integration algorithm (default inferred).\nabstol: Absolute tolerance for the ODE solver.\nreltol: Relative tolerance for the ODE solver.\nsaveat: Time points at which to save the solution.\ninternalnorm: Optional norm function used by the integrator.\nkwargs_Flow: Additional keyword arguments passed to the solver.\n\nReturns\n\nA flow object f such that:\n\nf(t0, x0, p0, tf) integrates the state and costate from t0 to tf.\nf((t0, tf), x0, p0) returns the full trajectory over the interval.\n\nExample\n\njulia> u = (x, p) -> p\njulia> f = Flow(ocp, ControlLaw(u))\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::Function;\n    autonomous,\n    variable,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConstruct a flow for an optimal control problem using a control function in feedback form.\n\nThis method constructs the Hamiltonian and integrates the associated state–costate dynamics using a raw function u. It automatically wraps u as a control law.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem.\nu::Function: A feedback control function:\nIf ocp is autonomous: u(x, p)\nIf non-autonomous: u(t, x, p)\nautonomous::Bool: Whether the control law depends on time.\nvariable::Bool: Whether the OCP involves variable time (e.g., free final time).\nalg, abstol, reltol, saveat, internalnorm: ODE solver parameters.\nkwargs_Flow: Additional options.\n\nReturns\n\nA Flow object compatible with function call interfaces for state propagation.\n\nExample\n\njulia> u = (t, x, p) -> t + p\njulia> f = Flow(ocp, u)\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::Union{CTFlows.ControlLaw{<:Function, T, V}, CTFlows.FeedbackControl{<:Function, T, V}},\n    g::Union{CTFlows.MixedConstraint{<:Function, T, V}, CTFlows.StateConstraint{<:Function, T, V}},\n    μ::CTFlows.Multiplier{<:Function, T, V};\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConstruct a flow for an optimal control problem with control and constraint multipliers in feedback form.\n\nThis variant constructs a Hamiltonian system incorporating both the control law and a multiplier law (e.g., for enforcing state or mixed constraints). All inputs must be consistent in time dependence.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem.\nu::ControlLaw or FeedbackControl: Feedback control.\ng::StateConstraint or MixedConstraint: Constraint function.\nμ::Multiplier: Multiplier function.\nalg, abstol, reltol, saveat, internalnorm: Solver settings.\nkwargs_Flow: Additional options.\n\nReturns\n\nA Flow object that integrates the constrained Hamiltonian dynamics.\n\nExample\n\njulia> f = Flow(ocp, (x, p) -> p[1], (x, u) -> x[1] - 1, (x, p) -> x[1]+p[1])\n\nFor non-autonomous cases:\n\njulia> f = Flow(ocp, (t, x, p) -> t + p, (t, x, u) -> x - 1, (t, x, p) -> x+p)\n\nwarning: Warning\nAll input functions must match the autonomous/non-autonomous nature of the problem.\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::Function,\n    g::Function,\n    μ::Function;\n    autonomous,\n    variable,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConstruct a flow from a raw feedback control, constraint, and multiplier.\n\nThis version is for defining flows directly from user functions without wrapping them into ControlLaw, Constraint, or Multiplier types. Automatically wraps and adapts them based on time dependence.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem.\nu::Function: Control law.\ng::Function: Constraint.\nμ::Function: Multiplier.\nautonomous::Bool: Whether the system is autonomous.\nvariable::Bool: Whether time is a free variable.\nalg, abstol, reltol, saveat, internalnorm: Solver parameters.\nkwargs_Flow: Additional options.\n\nReturns\n\nA Flow object ready for trajectory integration.\n\n\n\n\n\nFlow(\n    dyn::Function;\n    autonomous,\n    variable,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.ODEFlow\n\n\nConstructs a Flow from a user-defined dynamical system given as a Julia function.\n\nThis high-level interface handles:\n\nautonomous and non-autonomous systems,\npresence or absence of additional variables (v),\nselection of ODE solvers and tolerances,\nand integrates with the CTFlows event system (e.g., jumps, callbacks).\n\nArguments\n\ndyn: A function defining the vector field. Its signature must match the values of autonomous and variable.\nautonomous: Whether the dynamics are time-independent (false by default).\nvariable: Whether the dynamics depend on a control or parameter v.\nalg, abstol, reltol, saveat, internalnorm: Solver settings passed to OrdinaryDiffEq.solve.\nkwargs_Flow: Additional keyword arguments passed to the solver.\n\nReturns\n\nAn ODEFlow object, wrapping both the full solver and its right-hand side (RHS).\n\nSupported Function Signatures for dyn\n\nDepending on the (autonomous, variable) flags:\n\n(false, false): dyn(x)\n(false, true):  dyn(x, v)\n(true, false):  dyn(t, x)\n(true, true):   dyn(t, x, v)\n\nExample\n\njulia> dyn(t, x, v) = [-x[1] + v[1] * sin(t)]\njulia> flow = CTFlows.Flow(dyn; autonomous=true, variable=true)\njulia> xT = flow((0.0, 1.0), [1.0], [0.1])\n\n\n\n\n\n","category":"function"},{"location":"manual-flow-api.html","page":"Flow API","title":"Flow API","text":"","category":"page"},{"location":"manual-plot.html#manual-plot","page":"Plot a solution","title":"How to plot a solution","text":"","category":"section"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In this tutorial, we explain the different options for plotting the solution of an optimal control problem using the plot and plot! functions, which are extensions of the Plots.jl package. Use plot to create a new plot object, and plot! to add to an existing one:","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(args...; kw...)           # creates a new Plot, and set it to be the `current`\nplot!(args...; kw...)          # modifies Plot `current()`\nplot!(plt, args...; kw...)     # modifies Plot `plt`","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"More precisely, the signature of plot, to plot a solution, is as follows.","category":"page"},{"location":"manual-plot.html#RecipesBase.plot-Tuple{Solution, Vararg{Symbol}}-manual-plot","page":"Plot a solution","title":"RecipesBase.plot","text":"plot(\n    sol::Solution,\n    description::Symbol...;\n    layout,\n    control,\n    time,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    time_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    size,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot the components of an optimal control solution.\n\nThis is the main user-facing function to visualise the solution of an optimal control problem solved with the control-toolbox ecosystem.\n\nIt generates a set of subplots showing the evolution of the state, control, costate, path constraints, and dual variables over time, depending on the problem and the user’s choices.\n\nArguments\n\nsol::CTModels.Solution: The optimal control solution to visualise.\ndescription::Symbol...: A variable number of symbols indicating which components to include in the plot. Common values include:\n:state – plot the state.\n:costate – plot the costate (adjoint).\n:control – plot the control.\n:path – plot the path constraints.\n:dual – plot the dual variables (or Lagrange multipliers) associated with path constraints.\n\nIf no symbols are provided, a default set is used based on the problem and styles.\n\nKeyword Arguments (Optional)\n\nlayout::Symbol = :group: Specifies how to arrange plots.\n:group: Fewer plots, grouping similar variables together (e.g., all states in one subplot).\n:split: One plot per variable component, stacked in a layout.\ncontrol::Symbol = :components: Defines how to represent control inputs.\n:components: One curve per control component.\n:norm: Single curve showing the Euclidean norm ‖u(t)‖.\n:all: Plot both components and norm.\ntime::Symbol = :default: Time normalisation for plots.\n:default: Real time scale.\n:normalize or :normalise: Normalised to the interval [0, 1].\n\nStyle Options (Optional)\n\nAll style-related keyword arguments can be either a NamedTuple of plotting attributes or the Symbol :none referring to not plot the associated element. These allow you to customise color, line style, markers, etc.\n\ntime_style: Style for vertical lines at initial and final times.\nstate_style: Style for state components.\ncostate_style: Style for costate components.\ncontrol_style: Style for control components.\npath_style: Style for path constraint values.\ndual_style: Style for dual variables.\n\nBounds Decorations (Optional)\n\nUse these options to customise bounds on the plots if applicable and defined in the model. Set to :none to hide.\n\nstate_bounds_style: Style for state bounds.\ncontrol_bounds_style: Style for control bounds.\npath_bounds_style: Style for path constraint bounds.\n\nReturns\n\nA Plots.Plot object, which can be displayed, saved, or further customised.\n\nExample\n\n# basic plot\njulia> plot(sol)\n\n# plot only the state and control\njulia> plot(sol, :state, :control)\n\n# customise layout and styles, no costate\njulia> plot(sol;\n       layout = :group,\n       control = :all,\n       state_style = (color=:blue, linestyle=:solid),\n       control_style = (color=:red, linestyle=:dash),\n       costate_style = :none)       \n\n\n\n\n\n","category":"method"},{"location":"manual-plot.html#RecipesBase.plot!-Tuple{Solution, Vararg{Symbol}}-manual-plot","page":"Plot a solution","title":"RecipesBase.plot!","text":"plot!(\n    sol::Solution,\n    description::Symbol...;\n    layout,\n    control,\n    time,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    time_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    kwargs...\n) -> Any\n\n\nModify Plot current() with the optimal control solution sol.\n\nSee plot for full behavior and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"manual-plot.html#RecipesBase.plot!-Tuple{Plots.Plot, Solution, Vararg{Symbol}}-manual-plot","page":"Plot a solution","title":"RecipesBase.plot!","text":"plot!(\n    p::Plots.Plot,\n    sol::Solution,\n    description::Symbol...;\n    layout,\n    control,\n    time,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    time_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    kwargs...\n) -> Plots.Plot\n\n\nModify Plot p with the optimal control solution sol.\n\nSee plot for full behavior and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"manual-plot.html#Argument-Overview","page":"Plot a solution","title":"Argument Overview","text":"","category":"section"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The table below summarizes the main plotting arguments and links to the corresponding documentation sections for detailed explanations:","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Section Relevant Arguments\nBasic concepts size, state_style, costate_style, control_style, time_style, kwargs...\nSplit vs. group layout layout\nPlotting control norm control\nNormalised time time\nConstraints state_bounds_style, control_bounds_style, path_style, path_bounds_style, dual_style\nWhat to plot description...","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can plot solutions obtained from the solve function or from a flow computed using an optimal control problem and a control law. See the Basic Concepts and From Flow function sections for details.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To overlay a new plot on an existing one, use the plot! function (see Add a plot).","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"If you prefer full control over the visualisation, you can extract the state, costate, and control to create your own plots. Refer to the Custom plot section for guidance. You can also access the subplots.","category":"page"},{"location":"manual-plot.html#The-problem-and-the-solution","page":"Plot a solution","title":"The problem and the solution","text":"","category":"section"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Let us start by importing the packages needed to define and solve the problem.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using OptimalControl\nusing NLPModelsIpopt","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We consider the simple optimal control problem from the basic example page.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"t0 = 0          # initial time\ntf = 1          # final time\nx0 = [-1, 0]    # initial condition\nxf = [ 0, 0]    # final condition\n\nocp = @def begin\n    t ∈ [t0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x(t0) == x0\n    x(tf) == xf\n    ẋ(t) == [x₂(t), u(t)]\n    ∫( 0.5u(t)^2 ) → min\nend\n\nsol = solve(ocp, display=false)\nnothing # hide","category":"page"},{"location":"manual-plot.html#manual-plot-basic","page":"Plot a solution","title":"Basic concepts","text":"","category":"section"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The simplest way to plot the solution is to use the plot function with the solution as the only argument.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"caveat: Caveat\nThe plot function for a solution of an optimal control problem extends the plot function from Plots.jl. Therefore, you need to import this package in order to plot a solution.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using Plots\nplot(sol)","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In the figure above, we have a grid of subplots: the left column displays the state component trajectories, the right column shows the costate component trajectories, and the bottom row contains the control component trajectory.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"As in Plots.jl, input data is passed positionally (for example, sol in plot(sol)), and attributes are passed as keyword arguments (for example, plot(sol; color = :blue)). After executing using Plots in the REPL, you can use the plotattr() function to print a list of all available attributes for series, plots, subplots, or axes.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"# Valid Operations\nplotattr(:Plot)\nplotattr(:Series)\nplotattr(:Subplot)\nplotattr(:Axis)","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Once you have the list of attributes, you can either use the aliases of a specific attribute or inspect a specific attribute to display its aliases and description.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plotattr(\"color\") # Specific Attribute Example","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"warning: Warning\nSome attributes have different default values in OptimalControl.jl compared to Plots.jl. For instance, the default figure size is 600x400 in Plots.jl, while in OptimalControl.jl, it depends on the number of states and controls.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can also visit the Plot documentation online to get the descriptions of the attributes:","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To pass attributes to the plot, see the attributes plot documentation. For instance, you can specify the size of the figure.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"<details style=\"margin-left:3em\"><summary>List of plot attributes.</summary>","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"for a in Plots.attributes(:Plot) # hide\n    println(a) # hide\nend # hide","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"</details>","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can pass attributes to all subplots at once by referring to the attributes subplot documentation. For example, you can specify the location of the legends.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"<details style=\"margin-left:3em\"><summary>List of subplot attributes.</summary>","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"for a in Plots.attributes(:Subplot) # hide\n    println(a) # hide\nend # hide","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"</details>","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Similarly, you can pass axis attributes to all subplots. See the attributes axis documentation. For example, you can remove the grid from every subplot.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"<details style=\"margin-left:3em\"><summary>List of axis attributes.</summary>","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"for a in Plots.attributes(:Axis) # hide\n    println(a) # hide\nend # hide","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"</details>","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Finally, you can pass series attributes to all subplots. Refer to the attributes series documentation. For instance, you can set the width of the curves using linewidth.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"<details style=\"margin-left:3em\"><summary>List of series attributes.</summary>","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"for a in Plots.attributes(:Series) # hide\n    println(a) # hide\nend # hide","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"</details>\n</br>","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, size=(700, 450), label=\"sol\", legend=:bottomright, grid=false, linewidth=2)","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To specify series attributes for a specific group of subplots (state, costate or control), you can use the optional keyword arguments state_style, costate_style, and control_style, which correspond to the state, costate, and control trajectories, respectively.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; \n     state_style   = (color=:blue,),                  # style: state trajectory\n     costate_style = (color=:black, linestyle=:dash), # style: costate trajectory\n     control_style = (color=:red, linewidth=2))       # style: control trajectory","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Vertical axes at the initial and final times are automatically plotted. The style can me modified with the time_style keyword argument.  Additionally, you can choose not to display for instance the state and the costate trajectories by setting their styles to :none. You can set to :none any style.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; \n     state_style    = :none,             # do not plot the state\n     costate_style  = :none,             # do not plot the costate\n     control_style  = (color = :red,),   # plot the control in red\n     time_style     = (color = :green,)) # vertical axes at initial and final times in green","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To select what to display, you can also use the description argument by providing a list of symbols such as :state, :costate, and :control.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, :state, :control)  # plot the state and the control","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Select what to plot\nFor more details on how to choose what to plot, see the What to plot section.","category":"page"},{"location":"manual-plot.html#manual-plot-flow","page":"Plot a solution","title":"From Flow function","text":"","category":"section"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The previous solution of the optimal control problem was obtained using the solve function. If you prefer using an indirect shooting method and solving shooting equations, you may also want to plot the associated solution. To do this, you need to use the Flow function to reconstruct the solution. See the manual on how to compute flows for more details. In our case, you must provide the maximizing control (x p) mapsto p_2 along with the optimal control problem. For an introduction to simple indirect shooting, see the indirect simple shooting tutorial for an example.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"tip: Interactions with an optimal control solution\nPlease check state, costate, control, and variable to retrieve data from the solution. The functions state, costate, and control return functions of time, while variable returns a vector.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using OrdinaryDiffEq\n\np  = costate(sol)                # costate as a function of time\np0 = p(t0)                       # costate solution at the initial time\nf  = Flow(ocp, (x, p) -> p[2])   # flow from an ocp and a control law in feedback form\n\nsol_flow = f((t0, tf), x0, p0)   # compute the solution\nplot(sol_flow)                   # plot the solution from a flow","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We may notice that the time grid contains very few points. This is evident from the subplot of x_2, or by retrieving the time grid directly from the solution.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"time_grid(sol_flow)","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To improve visualisation (without changing the accuracy), you can provide a finer grid.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"fine_grid = range(t0, tf, 100)\nsol_flow = f((t0, tf), x0, p0; saveat=fine_grid)\nplot(sol_flow)","category":"page"},{"location":"manual-plot.html#manual-plot-layout","page":"Plot a solution","title":"Split vs. group layout","text":"","category":"section"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"If you prefer to get a more compact figure, you can use the layout optional keyword argument with :group value. It will group the state, costate and control trajectories in one subplot for each.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; layout=:group)","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The default layout value is :split which corresponds to the grid of subplots presented above.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; layout=:split)","category":"page"},{"location":"manual-plot.html#manual-plot-add","page":"Plot a solution","title":"Add a plot","text":"","category":"section"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can plot the solution of a second optimal control problem on the same figure if it has the same number of states, costates and controls. For instance, consider the same optimal control problem but with a different initial condition.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"ocp = @def begin\n    t ∈ [t0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x(t0) == [-0.5, -0.5]\n    x(tf) == xf\n    ẋ(t) == [x₂(t), u(t)]\n    ∫( 0.5u(t)^2 ) → min\nend\nsol2 = solve(ocp; display=false)\nnothing # hide","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We first plot the solution of the first optimal control problem, then, we plot the solution of the second optimal control problem on the same figure, but with dashed lines.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plt = plot(sol; label=\"sol1\", size=(700, 500))\nplot!(plt, sol2; label=\"sol2\", linestyle=:dash)","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can also, implicitely, use the current plot.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; label=\"sol1\", size=(700, 500))\nplot!(sol2; label=\"sol2\", linestyle=:dash)","category":"page"},{"location":"manual-plot.html#manual-plot-control","page":"Plot a solution","title":"Plotting the control norm","text":"","category":"section"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"For some problem, it is interesting to plot the (Euclidean) norm of the control. You can do it by using the control optional keyword argument with :norm value.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; control=:norm, size=(800, 300), layout=:group)","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The default value is :components.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; control=:components, size=(800, 300), layout=:group)","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can also plot the control and is norm.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; control=:all, layout=:group)","category":"page"},{"location":"manual-plot.html#manual-plot-custom","page":"Plot a solution","title":"Custom plot and subplots","text":"","category":"section"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can, of course, create your own plots by extracting the state, costate, and control from the optimal control solution. For instance, let us plot the norm of the control.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using LinearAlgebra\nt = time_grid(sol)\nu = control(sol)\nplot(t, norm∘u; label=\"‖u‖\", xlabel=\"t\") ","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can also get access to the subplots. The order is as follows: state, costate, control, path constraints (if any) and their dual variables.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plt = plot(sol)\nplot(plt[1]) # x₁","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plt = plot(sol)\nplot(plt[2]) # x₂","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plt = plot(sol)\nplot(plt[3]) # p₁","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(plt[4]) # p₂","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(plt[5]) # u","category":"page"},{"location":"manual-plot.html#manual-plot-time","page":"Plot a solution","title":"Normalised time","text":"","category":"section"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We consider a LQR example and solve the problem for different values of the final time tf. Then, we plot the solutions on the same figure using a normalised time s = (t - t_0)  (t_f - t_0), enabled by the keyword argument time = :normalize (or :normalise) in the plot function.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"# definition of the problem, parameterised by the final time\nfunction lqr(tf)\n\n    ocp = @def begin\n        t ∈ [0, tf], time\n        x ∈ R², state\n        u ∈ R, control\n        x(0) == [0, 1]\n        ẋ(t) == [x₂(t), - x₁(t) + u(t)]\n        ∫( 0.5(x₁(t)^2 + x₂(t)^2 + u(t)^2) ) → min\n    end\n\n    return ocp\nend\n\n# solve the problems and store them\nsolutions = []\ntfs = [3, 5, 30]\nfor tf ∈ tfs\n    solution = solve(lqr(tf); display=false)\n    push!(solutions, solution)\nend\n\n# create plots\nplt = plot()\nfor (tf, sol) ∈ zip(tfs, solutions)\n    plot!(plt, sol; time=:normalize, label=\"tf = $tf\", xlabel=\"s\")\nend\n\n# make a custom plot: keep only state and control\npx1 = plot(plt[1]; legend=false) # x₁\npx2 = plot(plt[2]; legend=true)  # x₂\npu  = plot(plt[5]; legend=false) # u    \n\nusing Plots.PlotMeasures # for leftmargin, bottommargin\nplot(px1, px2, pu; layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"page"},{"location":"manual-plot.html#manual-plot-constraints","page":"Plot a solution","title":"Constraints","text":"","category":"section"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We define an optimal control problem with constraints, solve it and plot the solution.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"ocp = @def begin\n    tf ∈ R,          variable\n    t ∈ [0, tf],     time\n    x = (q, v) ∈ R², state\n    u ∈ R,           control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q(0)  == -1\n    v(0)  == 0\n    q(tf) == 0\n    v(tf) == 0\n    1 ≤ v(t)+1 ≤ 1.8, (1)\n    ẋ(t) == [v(t), u(t)]\n    tf → min\nend\nsol = solve(ocp)\nplot(sol)","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"On the plot, you can see the lower and upper bounds of the path constraint. Additionally, the dual variable associated with the path constraint is displayed alongside it.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can customise the plot styles. For style options related to the state, costate, and control, refer to the Basic Concepts section.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; \n     state_bounds_style = (linestyle = :dash,),\n     control_bounds_style = (linestyle = :dash,),\n     path_style = (color = :green,),\n     path_bounds_style = (linestyle = :dash,),\n     dual_style = (color = :red,),\n     time_style = :none, # do not plot axes at t0 and tf\n)","category":"page"},{"location":"manual-plot.html#manual-plot-select","page":"Plot a solution","title":"What to plot","text":"","category":"section"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can choose what to plot using the description argument. To plot only one subgroup:","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, :state)   # plot only the state\nplot(sol, :costate) # plot only the costate\nplot(sol, :control) # plot only the control\nplot(sol, :path)    # plot only the path constraint\nplot(sol, :dual)    # plot only the path constraint dual variable","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can combine elements to plot exactly what you need:","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, :state, :control, :path)","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Similarly, you can choose what not to plot passing :none to the corresponding style.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; state_style=:none)   # do not plot the state\nplot(sol; costate_style=:none) # do not plot the costate\nplot(sol; control_style=:none) # do not plot the control\nplot(sol; path_style=:none)    # do not plot the path constraint\nplot(sol; dual_style=:none)    # do not plot the path constraint dual variable","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"For instance, let's plot everything except the dual variable associated with the path constraint.","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; dual_style=:none)","category":"page"},{"location":"manual-plot.html","page":"Plot a solution","title":"Plot a solution","text":"","category":"page"},{"location":"manual-abstract.html#manual-abstract-syntax","page":"Define a problem","title":"The syntax to define an optimal control problem","text":"","category":"section"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"The full grammar of OptimalControl.jl small Domain Specific Language is given below. The idea is to use a syntax that is","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"pure Julia (and, as such, effortlessly analysed by the standard Julia parser),\nas close as possible to the mathematical description of an optimal control problem. ","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"While the syntax will be transparent to those users familiar with Julia expressions (Expr's), we provide examples for every case that should be widely understandable. We rely heavily on MLStyle.jl and its pattern matching abilities 👍🏽 for the semantic pass. Abstract definitions use the macro @def.","category":"page"},{"location":"manual-abstract.html#manual-abstract-variable","page":"Define a problem","title":"Variable","text":"","category":"section"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $v ∈ R^$q, variable ) \n:( $v ∈ R   , variable ) ","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"A variable (only one is allowed) is a finite dimensional vector or reals that will be optimised along with state and control values. To define an (almost empty!) optimal control problem, named ocp, having a dimension two variable named v, do the following:","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    v ∈ R², variable\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nNote that the full code of the definition above is not provided (hence the ...) The same is true for most examples below (only those without ... are indeed complete). Also note that problem definitions must at least include definitions for time, state, control, and dynamics.","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"Aliases v₁, v₂ (and v1, v2) are automatically defined and can be used in subsequent expressions instead of v[1] and v[2]. The user can also define her own aliases for the components (one alias per dimension):","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    v = (a, b) ∈ R², variable\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"A one dimensional variable can be declared according to","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    v ∈ R, variable\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"note: Note\nIt is also possible to use the following syntax@def ocp begin\n    v ∈ R, variable\n    ...\nendthat is equivalent toocp = @def begin\n    v ∈ R, variable\n    ...\nend","category":"page"},{"location":"manual-abstract.html#Time","page":"Define a problem","title":"Time","text":"","category":"section"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $t ∈ [$t0, $tf], time ) ","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"The independent variable or time is a scalar bound to a given interval. Its name is arbitrary.","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"t0 = 1\ntf = 5\n@def begin\n    t ∈ [t0, tf], time\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"One (or even the two bounds) can be variable, typically for minimum time problems (see Mayer cost section):","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    v = (T, λ) ∈ R², variable\n    t ∈ [0, T], time\n    ...\nend","category":"page"},{"location":"manual-abstract.html#manual-abstract-state","page":"Define a problem","title":"State","text":"","category":"section"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $x ∈ R^$n, state ) \n:( $x ∈ R   , state ) ","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"The state declaration defines the name and the dimension of the state:","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    x ∈ R⁴, state\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"As for the variable, there are automatic aliases (x₁ and x1 for x[1], etc.) and the user can define her own aliases (one per scalar component of the state):","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    x = (q₁, q₂, v₁, v₂) ∈ R⁴, state\n    ...\nend","category":"page"},{"location":"manual-abstract.html#manual-abstract-control","page":"Define a problem","title":"Control","text":"","category":"section"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $u ∈ R^$m, control ) \n:( $u ∈ R   , control ) ","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"The control declaration defines the name and the dimension of the control:","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    u ∈ R², control\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"As before, there are automatic aliases (u₁ and u1 for u[1], etc.) and the user can define her own aliases (one per scalar component of the state):","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    u = (α, β) ∈ R², control\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"note: Note\nOne dimensional variable, state or control are treated as scalars (Real), not vectors (Vector). In Julia, for x::Real, it is possible to write x[1] (and x[1][1]...) so it is OK (though useless) to write x₁, x1 or x[1] instead of simply x to access the corresponding value. Conversely it is not OK to use such an x as a vector, for instance as in ...f(x)... where f(x::Vector{T}) where {T <: Real}.","category":"page"},{"location":"manual-abstract.html#manual-abstract-dynamics","page":"Define a problem","title":"Dynamics","text":"","category":"section"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":":( ∂($x)($t) == $e1 ) ","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"The dynamics is given in the standard vectorial ODE form:","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"    dotx(t) = f(t x(t) u(t) v)","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"depending on whether it is autonomous / with a variable or not (the parser will detect time and variable dependences, which entails that time, state and variable must be declared prior to dynamics - an error will be issued otherwise). The symbol ∂, or the dotted state name (ẋ), or the keyword derivative can be used:","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    ∂(x)(t) == [x₂(t), u(t)]\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"or","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    ẋ(t) == [x₂(t), u(t)]\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"or","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    derivative(x)(t) == [x₂(t), u(t)]\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"Any Julia code can be used, so the following is also OK: ","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"ocp = @def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    ẋ(t) == F₀(x(t)) + u(t) * F₁(x(t))\n    ...\nend\n\nF₀(x) = [x[2], 0]\nF₁(x) = [0, 1]","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"note: Note\nThe vector fields F₀ and F₁ can be defined afterwards, as they only need to be available when the dynamics will be evaluated.","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"Currently, it is not possible to declare the dynamics component after component, but a simple workaround is to use aliases (check the relevant aliases section below):","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    q̇ = v(t)\n    v̇ = u(t) - c(t)\n    ẋ(t) == [q̇, v̇]\n    ...\nend","category":"page"},{"location":"manual-abstract.html#Constraints","page":"Define a problem","title":"Constraints","text":"","category":"section"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $e1 == $e2        ) \n:( $e1 ≤  $e2 ≤  $e3 ) \n:(        $e2 ≤  $e3 ) \n:( $e3 ≥  $e2 ≥  $e1 ) \n:( $e2 ≥  $e1        ) ","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"Admissible constraints can be","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"five types: boundary, control, state, mixed, variable,\nlinear (ranges) or nonlinear (not ranges),\nequalities or (one or two-sided) inequalities.","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"Boundary conditions are detected when the expression contains evaluations of the state at initial and / or final time bounds (e.g., x(0)), and may not involve the control. Conversely control, state or mixed constraints will involve control, state or both evaluated at the declared time (e.g., x(t) + u(t)).  Other combinations should be detected as incorrect by the parser 🤞🏾. The variable may be involved in any of the four previous constraints. Constraints involving the variable only are variable constraints, either linear or nonlinear. In the example below, there are","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"two linear boundary constraints,\none linear variable constraint,\none linear state constraint,\none (two-sided) nonlinear control constraint.","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(tf) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    tf ≥ 0 \n    x₂(t) ≤ 1\n    u(t)^2 ≤ 1\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"note: Note\nSymbols like <= or >= are also authorised:","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(tf) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    tf >= 0 \n    x₂(t) <= 1\n    u(t)^2 <= 1\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nWrite either u(t)^2 or (u^2)(t), not u^2(t) since in Julia the latter means u^(2t). Moreover, in the case of equalities or of one-sided inequalities, the control and / or the state must belong to the left-hand side. The following will error:","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ∈ [0, 2], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(2) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    1 ≤ x₂(t)\n    -1 ≤ u(t) ≤ 1\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nConstraint bounds must be effective, that is must not depend on a variable. For instance, instead of","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"o = @def begin\n    v ∈ R, variable\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    -1 ≤ v ≤ 1\n    x₁(0) == -1\n    x₂(0) == v # wrong: the bound is not effective (as it depends on the variable)\n    x(1) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    ∫( 0.5u(t)^2 ) → min\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"write","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"o = @def begin\n    v ∈ R, variable\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    -1 ≤ v ≤ 1\n    x₁(0) == -1\n    x₂(0) - v == 0 # OK: the boundary contraint may involve the variable\n    x(1) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    ∫( 0.5u(t)^2 ) → min\nend","category":"page"},{"location":"manual-abstract.html#manual-abstract-mayer","page":"Define a problem","title":"Mayer cost","text":"","category":"section"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $e1 → min ) \n:( $e1 → max ) ","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"Mayer costs are defined in a similar way to boundary conditions and follow the same rules. The symbol → is used to denote minimisation or maximisation, the latter being treated by minimising the opposite cost. (The symbol => can also be used.)","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5\n   -2 ≤ v(t) ≤ 3\n    ẋ(t) == [v(t), u(t)]\n    tf → min\nend","category":"page"},{"location":"manual-abstract.html#Lagrange-cost","page":"Define a problem","title":"Lagrange cost","text":"","category":"section"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":":(       ∫($e1) → min ) \n:(     - ∫($e1) → min ) \n:( $e1 * ∫($e2) → min ) \n:(       ∫($e1) → max ) \n:(     - ∫($e1) → max ) \n:( $e1 * ∫($e2) → max ) ","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"Lagrange (integral) costs are defined used the symbol ∫, with parentheses. The keyword integral can also be used:","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ∈ [0, 1], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    0.5∫(q(t) + u(t)^2) → min\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"or","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ∈ [0, 1], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    0.5integral(q(t) + u(t)^2) → min\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"The integration range is implicitly equal to the time range, so the cost above is to be understood as","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"frac12 int_0^1 left( q(t) + u^2(t) right) mathrmdt to min","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"As for the dynamics, the parser will detect whether the integrand depends or not on time (autonomous / non-autonomous case).","category":"page"},{"location":"manual-abstract.html#Bolza-cost","page":"Define a problem","title":"Bolza cost","text":"","category":"section"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $e1 +       ∫($e2)       → min ) \n:( $e1 + $e2 * ∫($e3)       → min ) \n:( $e1 -       ∫($e2)       → min ) \n:( $e1 - $e2 * ∫($e3)       → min ) \n:( $e1 +       ∫($e2)       → max ) \n:( $e1 + $e2 * ∫($e3)       → max ) \n:( $e1 -       ∫($e2)       → max ) \n:( $e1 - $e2 * ∫($e3)       → max ) \n:(             ∫($e2) + $e1 → min ) \n:(       $e2 * ∫($e3) + $e1 → min ) \n:(             ∫($e2) - $e1 → min ) \n:(       $e2 * ∫($e3) - $e1 → min ) \n:(             ∫($e2) + $e1 → max ) \n:(       $e2 * ∫($e3) + $e1 → max ) \n:(             ∫($e2) - $e1 → max ) \n:(       $e2 * ∫($e3) - $e1 → max ) ","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"Quite readily, Mayer and Lagrange costs can be combined into general Bolza costs. For instance as follows:","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    p = (t0, tf) ∈ R², variable\n    t ∈ [t0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R², control\n    (tf - t0) + 0.5∫(c(t) * u(t)^2) → min\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nThe expression must be the sum of two terms (plus, possibly, a scalar factor before the integral), not more, so mind the parentheses. For instance, the following errors:","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    p = (t0, tf) ∈ R², variable\n    t ∈ [t0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R², control\n    (tf - t0) + q(tf) + 0.5∫( c(t) * u(t)^2 ) → min\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"The correct syntax is","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    p = (t0, tf) ∈ R², variable\n    t ∈ [t0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R², control\n    ((tf - t0) + q(tf)) + 0.5∫( c(t) * u(t)^2 ) → min\n    ...\nend","category":"page"},{"location":"manual-abstract.html#manual-abstract-aliases","page":"Define a problem","title":"Aliases","text":"","category":"section"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $a = $e1 )","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"The single = symbol is used to define not a constraint but an alias, that is a purely syntactic replacement. There are some automatic aliases, e.g. x₁ for x[1] if x is the state, and we have also seen that the user can define her own aliases when declaring the variable, state and control. Arbitrary aliases can be further defined, as below (compare with previous examples in the dynamics section):","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    F₀ = [x₂(t), 0]\n    F₁ = [0, 1]\n    ẋ(t) == F₀ + u(t) * F₁\n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nSuch aliases do not define any additional function and are just replaced textually by the parser. In particular, they cannot be used outside the @def begin ... end block.","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"hint: Hint\nYou can rely on a trace mode for the macro @def to look at your code after expansions of the aliases using the @def ocp ... syntax and adding true after your begin ... end block:","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    q̇ = v(t)\n    v̇ = u(t) - c(t)\n    ẋ(t) == [q̇, v̇]\nend true;","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nThe dynamics of an OCP is indeed a particular constraint, be careful to use == and not a single = that would try to define an alias:","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"double_integrator = @def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    q̇ = v\n    v̇ = u\n    ẋ(t) = [q̇, v̇]\nend","category":"page"},{"location":"manual-abstract.html#Misc","page":"Define a problem","title":"Misc","text":"","category":"section"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"Declarations (of variable - if any -, time, state and control) must be done first. Then, dynamics, constraints and cost can be introduced in an arbitrary order.\nIt is possible to provide numbers / labels (as in math equations) for the constraints to improve readability (this is mostly for future use, typically to retrieve the Lagrange multiplier associated with the discretisation of a given constraint):","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    tf ≥ 0, (1)\n    q(0) == 2, (♡)\n    q̇ = v(t)\n    v̇ = u(t) - c(t)\n    ẋ(t) == [q̇, v̇]\n    x(t).^2  ≤ [1, 2], (state_con) \n    ...\nend","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"Parsing errors should be explicit enough (with line number in the @def begin ... end block indicated) 🤞🏾\nCheck tutorials and applications in the documentation for further use.","category":"page"},{"location":"manual-abstract.html#Known-issues","page":"Define a problem","title":"Known issues","text":"","category":"section"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"Constants and (reverse over forward) AD","category":"page"},{"location":"manual-abstract.html","page":"Define a problem","title":"Define a problem","text":"","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"<img width=\"800\" alt=\"jlesc17\" src=\"./assets/jlesc17.jpg\">","category":"page"},{"location":"jlesc17.html#Solving-optimal-control-problems-on-GPU-with-Julia","page":"JLESC17","title":"Solving optimal control problems on GPU with Julia","text":"","category":"section"},{"location":"jlesc17.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://github.com/joseph-gergaud),-[Pierre-Martinon](https://github.com/PierreMartinon),-[Sophia-Sed](https://sed-sam-blog.gitlabpages.inria.fr)","page":"JLESC17","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"","category":"section"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"page"},{"location":"jlesc17.html#What-it's-about","page":"JLESC17","title":"What it's about","text":"","category":"section"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"subject to","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"plus boundary, control and state constraints","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"Our core interests: numerical & geometrical methods in control, applications\nWhy Julia: fast (+ JIT), strongly typed, high-level (AD, macros), fast optimisation and ODE solvers available, rapidly growing community","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"<img width=\"800\" alt=\"juliacon2025\" src=\"./assets/juliacon2025.jpg\">","category":"page"},{"location":"jlesc17.html#Discretise-then-solve-strategy-(*aka*-direct-methods)","page":"JLESC17","title":"Discretise then solve strategy (aka direct methods)","text":"","category":"section"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"Discretising an OCP into an NLP: h_i = t_i+1-t_i,","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"g(X_0X_N) + sum_i=0^N h_i f^0(X_iU_i) to min","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"subject to ","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"X_i+1 - X_i - h_i f(X_i U_i) = 0quad i = 0dotsN-1","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"plus other constraints on X = (X_i)_i=0N and U = (U_i)_i=0N such as boundary and path (state and / or control) constraints :","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"b(t_0 X_0 t_N X_N) = 0","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"c(X_i U_i) = 0quad i = 0dotsN","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"SIMD parallelism (f_0, f, g) + sparsity: Kernels for GPU (KernelAbstraction.jl) and sparse linear algebra (CUDSS.jl)\nModelling and optimising for GPU: ExaModels.jl  + MadNLP.jl, with built-in AD\nSimple example, DSL\nCompile into an ExaModel (one pass compiler, syntax + semantics)","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"<details><summary>Simple example, generated code</summary>","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"begin\n    #= /data/caillau/CTParser.jl/src/onepass.jl:1003 =#\n    function (; scheme = :trapezoidal, grid_size = 200, backend = nothing, init = (0.1, 0.1, 0.1), base_type = Float64)\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1003 =#\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1004 =#\n        LineNumberNode(0, \"box constraints: variable\")\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1005 =#\n        begin\n            LineNumberNode(0, \"box constraints: state\")\n            begin\n                var\"##235\" = -Inf * ones(3)\n                #= /data/caillau/CTParser.jl/src/onepass.jl:461 =#\n                var\"##236\" = Inf * ones(3)\n            end\n        end\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1006 =#\n        begin\n            LineNumberNode(0, \"box constraints: control\")\n            begin\n                var\"##237\" = -Inf * ones(1)\n                #= /data/caillau/CTParser.jl/src/onepass.jl:512 =#\n                var\"##238\" = Inf * ones(1)\n            end\n        end\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1007 =#\n        var\"##230\" = ExaModels.ExaCore(base_type; backend = backend)\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1008 =#\n        begin\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:23 =#\n            var\"##232\" = begin\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                    local ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                    try\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                        (1 - 0) / grid_size\n                    catch ex\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                        println(\"Line \", 1, \": \", \"(t ∈ [0, 1], time)\")\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                        throw(ex)\n                    end\n                end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:24 =#\n            x = begin\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                    local ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                    try\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                        ExaModels.variable(var\"##230\", 3, 0:grid_size; lvar = [var\"##235\"[i] for (i, j) = Base.product(1:3, 0:grid_size)], uvar = [var\"##236\"[i] for (i, j) = Base.product(1:3, 0:grid_size)], start = init[2])\n                    catch ex\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                        println(\"Line \", 2, \": \", \"(x ∈ R ^ 3, state)\")\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                        throw(ex)\n                    end\n                end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:25 =#\n            var\"u##239\" = begin\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                    local ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                    try\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                        ExaModels.variable(var\"##230\", 1, 0:grid_size; lvar = [var\"##237\"[i] for (i, j) = Base.product(1:1, 0:grid_size)], uvar = [var\"##238\"[i] for (i, j) = Base.product(1:1, 0:grid_size)], start = init[3])\n                    catch ex\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                        println(\"Line \", 3, \": \", \"(u ∈ R, control)\")\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                        throw(ex)\n                    end\n                end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:26 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    ExaModels.constraint(var\"##230\", (x[i, 0] for i = 1:3); lcon = [-1, 0, 0], ucon = [-1, 0, 0])\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 4, \": \", \"x(0) == [-1, 0, 0]\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:27 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    ExaModels.constraint(var\"##230\", (x[i, grid_size] for i = 1:2); lcon = [0, 0], ucon = [0, 0])\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 5, \": \", \"(x[1:2])(1) == [0, 0]\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:28 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    begin\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:735 =#\n                        if scheme == :trapezoidal\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:736 =#\n                            ExaModels.constraint(var\"##230\", ((x[1, j + 1] - x[1, j]) - (var\"##232\" * (x[2, j] + x[2, j + 1])) / 2 for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:737 =# scheme == :euler\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:738 =#\n                            ExaModels.constraint(var\"##230\", ((x[1, j + 1] - x[1, j]) - var\"##232\" * x[2, j] for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:739 =# scheme == :euler_b\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:740 =#\n                            ExaModels.constraint(var\"##230\", ((x[1, j + 1] - x[1, j]) - var\"##232\" * x[2, j + 1] for j = 0:grid_size - 1))\n                        else\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:742 =#\n                            throw(\"unknown numerical scheme\")\n                        end\n                    end\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 6, \": \", \"(∂(x₁))(t) == x₂(t)\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:29 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    begin\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:735 =#\n                        if scheme == :trapezoidal\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:736 =#\n                            ExaModels.constraint(var\"##230\", ((x[2, j + 1] - x[2, j]) - (var\"##232\" * (var\"u##239\"[1, j] + var\"u##239\"[1, j + 1])) / 2 for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:737 =# scheme == :euler\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:738 =#\n                            ExaModels.constraint(var\"##230\", ((x[2, j + 1] - x[2, j]) - var\"##232\" * var\"u##239\"[1, j] for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:739 =# scheme == :euler_b\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:740 =#\n                            ExaModels.constraint(var\"##230\", ((x[2, j + 1] - x[2, j]) - var\"##232\" * var\"u##239\"[1, j + 1] for j = 0:grid_size - 1))\n                        else\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:742 =#\n                            throw(\"unknown numerical scheme\")\n                        end\n                    end\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 7, \": \", \"(∂(x₂))(t) == u(t)\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:30 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    begin\n                        #= /data/caillau/CTParser.jl/src/onepass.jl:735 =#\n                        if scheme == :trapezoidal\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:736 =#\n                            ExaModels.constraint(var\"##230\", ((x[3, j + 1] - x[3, j]) - (var\"##232\" * (0.5 * var\"u##239\"[1, j] ^ 2 + 0.5 * var\"u##239\"[1, j + 1] ^ 2)) / 2 for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:737 =# scheme == :euler\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:738 =#\n                            ExaModels.constraint(var\"##230\", ((x[3, j + 1] - x[3, j]) - var\"##232\" * (0.5 * var\"u##239\"[1, j] ^ 2) for j = 0:grid_size - 1))\n                        elseif #= /data/caillau/CTParser.jl/src/onepass.jl:739 =# scheme == :euler_b\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:740 =#\n                            ExaModels.constraint(var\"##230\", ((x[3, j + 1] - x[3, j]) - var\"##232\" * (0.5 * var\"u##239\"[1, j + 1] ^ 2) for j = 0:grid_size - 1))\n                        else\n                            #= /data/caillau/CTParser.jl/src/onepass.jl:742 =#\n                            throw(\"unknown numerical scheme\")\n                        end\n                    end\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 8, \": \", \"(∂(x₃))(t) == 0.5 * u(t) ^ 2\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n            #= /data/caillau/CTParser.jl/test/test_onepass_exa.jl:31 =#\n            begin\n                #= /data/caillau/CTParser.jl/src/onepass.jl:111 =#\n                local ex\n                #= /data/caillau/CTParser.jl/src/onepass.jl:112 =#\n                try\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:113 =#\n                    ExaModels.objective(var\"##230\", x[3, grid_size])\n                catch ex\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:115 =#\n                    println(\"Line \", 9, \": \", \"x₃(1) → min\")\n                    #= /data/caillau/CTParser.jl/src/onepass.jl:116 =#\n                    throw(ex)\n                end\n            end\n        end\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1009 =#\n        begin\n            #= /data/caillau/CTParser.jl/src/onepass.jl:994 =#\n            !(isempty([1, 2, 3])) || throw(CTBase.ParsingError(\"dynamics not defined\"))\n            #= /data/caillau/CTParser.jl/src/onepass.jl:995 =#\n            sort([1, 2, 3]) == 1:3 || throw(CTBase.ParsingError(\"some coordinates of dynamics undefined\"))\n        end\n        #= /data/caillau/CTParser.jl/src/onepass.jl:1010 =#\n        return ExaModels.ExaModel(var\"##230\")\n    end\nend","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"</details>","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"Solving (MadNLP + CUDSS)","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"This is MadNLP version v0.8.7, running with cuDSS v0.4.0\n\nNumber of nonzeros in constraint Jacobian............:    12005\nNumber of nonzeros in Lagrangian Hessian.............:     9000\n\nTotal number of variables............................:     4004\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:        0\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     3005\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  1.0000000e-01 1.10e+00 1.00e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.0001760e-01 1.10e+00 3.84e-03  -1.0 6.88e+02  -4.0 1.00e+00 2.00e-07h  2\n   2 -5.2365072e-03 1.89e-02 1.79e-07  -1.0 6.16e+00  -4.5 1.00e+00 1.00e+00h  1\n   3  5.9939621e+00 2.28e-03 1.66e-04  -3.8 6.00e+00  -5.0 9.99e-01 1.00e+00h  1\n   4  5.9996210e+00 2.94e-06 8.38e-07  -3.8 7.70e-02    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 4\n\n                                   (scaled)                 (unscaled)\nObjective...............:   5.9996210189633494e+00    5.9996210189633494e+00\nDual infeasibility......:   8.3756005011360529e-07    8.3756005011360529e-07\nConstraint violation....:   2.9426923277963834e-06    2.9426923277963834e-06\nComplementarity.........:   2.0007459547789288e-06    2.0007459547789288e-06\nOverall NLP error.......:   2.9426923277963834e-06    2.9426923277963834e-06\n\nNumber of objective function evaluations             = 6\nNumber of objective gradient evaluations             = 5\nNumber of constraint evaluations                     = 6\nNumber of constraint Jacobian evaluations            = 5\nNumber of Lagrangian Hessian evaluations             = 4\nTotal wall-clock secs in solver (w/o fun. eval./lin. alg.)  =  0.072\nTotal wall-clock secs in linear solver                      =  0.008\nTotal wall-clock secs in NLP function evaluations           =  0.003\nTotal wall-clock secs                                       =  0.083","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"Goddard problem","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"This is MadNLP version v0.8.4, running with cuDSS v0.3.0\n\nNumber of nonzeros in constraint Jacobian............:   135017\nNumber of nonzeros in Lagrangian Hessian.............:   130008\n\nTotal number of variables............................:    35008\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:        0\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:    30007\nTotal number of inequality constraints...............:    15004\n        inequality constraints with only lower bounds:     5002\n   inequality constraints with lower and upper bounds:    10002\n        inequality constraints with only upper bounds:        0\n\n[...]\n\nNumber of Iterations....: 35\n\n                                   (scaled)                 (unscaled)\nObjective...............:  -1.0142336978192805e+00   -1.0142336978192805e+00\nDual infeasibility......:   4.7384318691001681e-13    4.7384318691001681e-13\nConstraint violation....:   1.4068322357215250e-09    1.4068322357215250e-09\nComplementarity.........:   9.0909295306344959e-09    9.0909295306344959e-09\nOverall NLP error.......:   9.0909295306344959e-09    9.0909295306344959e-09\n\nNumber of objective function evaluations             = 36\nNumber of objective gradient evaluations             = 36\nNumber of constraint evaluations                     = 36\nNumber of constraint Jacobian evaluations            = 36\nNumber of Lagrangian Hessian evaluations             = 35\nTotal wall-clock secs in solver (w/o fun. eval./lin. alg.)  =  0.911\nTotal wall-clock secs in linear solver                      =  0.227\nTotal wall-clock secs in NLP function evaluations           =  0.059\nTotal wall-clock secs                                       =  1.198","category":"page"},{"location":"jlesc17.html#Wrap-up","page":"JLESC17","title":"Wrap up","text":"","category":"section"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"High level modelling of optimal control problems\nSolving on CPU and GPU","category":"page"},{"location":"jlesc17.html#Future","page":"JLESC17","title":"Future","text":"","category":"section"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"New applications (space mechanics, biology, quantum mechanics and more)\nAdditional solvers: benchmarking on CPU / GPU for optimisation, Hamiltonian shooting and pathfollowing\nImproved AD: collab between Argonne and Inria, JLESC Shared Infra AD project...\n... and open to contributions! If you like the package, please give us a star ⭐️","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"<a href=\"https://github.com/control-toolbox/OptimalControl.jl\"><img width=\"800\" alt=\"OptimalControl.jl\" src=\"./assets/star.jpg\"></a>","category":"page"},{"location":"jlesc17.html#control-toolbox.org","page":"JLESC17","title":"control-toolbox.org","text":"","category":"section"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"jlesc17.html#Credits-(not-exhaustive!)","page":"JLESC17","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nExaModels.jl\nIpopt.jl\nMadNLP.jl\nMLStyle.jl","category":"page"},{"location":"jlesc17.html#Acknowledgements","page":"JLESC17","title":"Acknowledgements","text":"","category":"section"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"Jean-Baptiste Caillau is partially funded by a France 2030 support managed by the Agence Nationale de la Recherche, under the reference ANR-23-PEIA-0004 (PDE-AI project).","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"<img width=\"150\" alt=\"affiliations\" src=\"./assets/france-2030.png\">","category":"page"},{"location":"jlesc17.html","page":"JLESC17","title":"JLESC17","text":"","category":"page"},{"location":"manual-flow-ocp.html#manual-flow-ocp","page":"From optimal control problems","title":"How to compute flows from optimal control problems","text":"","category":"section"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"In this tutorial, we explain the Flow function, in particular to compute flows from an optimal control problem.","category":"page"},{"location":"manual-flow-ocp.html#Basic-usage","page":"From optimal control problems","title":"Basic usage","text":"","category":"section"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"Les us define a basic optimal control problem.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"using OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == [0, 0]\n    ẋ(t)  == [v(t), u(t)]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nnothing # hide","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"The pseudo-Hamiltonian of this problem is","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"    H(x p u) = p_q q + p_v v + p^0 u^2 2","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"where p^0 = -1 since we are in the normal case. From the Pontryagin maximum principle, the maximising control is given in feedback form by","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"u(x p) = p_v","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"since partial^2_uu H = p^0 = - 1  0. ","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"u(x, p) = p[2]\nnothing # hide","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"Actually, if (x u) is a solution of the optimal control problem,  then, the Pontryagin maximum principle tells us that there exists a costate p such that u(t) = u(x(t) p(t)) and such that the pair (x p) satisfies:","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"beginarrayl\n    dotx(t) = displaystylephantom-nabla_p H(x(t) p(t) u(x(t) p(t))) 05em\n    dotp(t) = displaystyle         - nabla_x H(x(t) p(t) u(x(t) p(t)))\nendarray","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"The Flow function aims to compute t mapsto (x(t) p(t)) from the optimal control problem ocp and the control in feedback form u(x, p).","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"note: Nota bene\nActually, writing z = (x p), then the pair (x p) is also solution of    dotz(t) = vecmathbfH(z(t))where mathbfH(z) = H(z u(z)) and vecmathbfH = (nabla_p mathbfH -nabla_x mathbfH). This is what is actually computed by Flow.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"Let us try to get the associated flow:","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"julia> f = Flow(ocp, u)\nERROR: ExtensionError. Please make: julia> using OrdinaryDiffEq","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"As you can see, an error occured since we need the package OrdinaryDiffEq.jl. This package provides numerical integrators to compute solutions of the ordinary differential equation  dotz(t) = vecmathbfH(z(t)).","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"note: OrdinaryDiffEq.jl\nThe package OrdinaryDiffEq.jl is part of DifferentialEquations.jl. You can either use one or the other.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"using OrdinaryDiffEq\nf = Flow(ocp, u)\nnothing # hide","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"Now we have the flow of the associated Hamiltonian vector field, we can use it. Some simple calculations shows that the initial covector p(0) solution of the Pontryagin maximum principle is 12 6. Let us check that integrating the flow from (t_0 x_0 p_0) = (0 -1 0 12 6) to the final time t_f we reach the target x_f = 0 0.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"p0 = [12, 6]\nxf, pf = f(t0, x0, p0, tf)\nxf","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"If you prefer to get the state, costate and control trajectories at any time, you can call the flow like this:","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"sol = f((t0, tf), x0, p0)\nnothing # hide","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"In this case, you obtain a data that you can plot exactly like when solving the optimal control problem  with the function solve. See for instance the basic example or the  plot tutorial.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"using Plots\nplot(sol)","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"You can notice from the graph of v that the integrator has made very few steps:","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"time_grid(sol)","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"note: Time grid\nThe function time_grid returns the discretised time grid returned by the solver. In this case, the solution has been computed by numerical integration with an adaptive step-length Runge-Kutta scheme.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"To have a better visualisation (the accuracy won't change), you can provide a fine grid.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"sol = f((t0, tf), x0, p0; saveat=range(t0, tf, 100))\nplot(sol)","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"The argument saveat is an option from OrdinaryDiffEq.jl. Please check the  list of common options. For instance, one can change the integrator with the keyword argument alg or the absolute tolerance with  abstol. Note that you can set an option when declaring the flow or set an option in a particular call of the flow.  In the following example, the integrator will be BS5() and the absolute tolerance will be abstol=1e-8.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"f = Flow(ocp, u; alg=BS5(), abstol=1)   # alg=BS5(), abstol=1\nxf, pf = f(t0, x0, p0, tf; abstol=1e-8) # alg=BS5(), abstol=1e-8","category":"page"},{"location":"manual-flow-ocp.html#Non-autonomous-case","page":"From optimal control problems","title":"Non-autonomous case","text":"","category":"section"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"Let us consider the following optimal control problem:","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"t0 = 0\ntf = π/4\nx0 = 0\nxf = tan(π/4) - 2log(√(2)/2)\n\nocp = @def begin\n\n    t ∈ [t0, tf], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == xf\n    ẋ(t) == u(t) * (1 + tan(t)) # The dynamics depend explicitly on t\n\n    0.5∫( u(t)^2 ) → min\n\nend\nnothing # hide","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"The pseudo-Hamiltonian of this problem is","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"    H(t x p u) = p u (1+tan t) + p^0 u^2 2","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"where p^0 = -1 since we are in the normal case. We can notice that the pseudo-Hamiltonian is non-autonomous since it explicitely depends on the time t. ","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"is_autonomous(ocp)","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"From the Pontryagin maximum principle, the maximising control is given in feedback form by","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"u(t x p) = p (1+tan t)","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"since partial^2_uu H = p^0 = - 1  0. ","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"u(t, x, p) = p * (1 + tan(t))\nnothing # hide","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"As before, the Flow function aims to compute (x p) from the optimal control problem ocp and the control in feedback form u(t, x, p).  Since the problem is non-autonomous, we must provide a control law that depends on time.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"f = Flow(ocp, u)\nnothing # hide","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"Now we have the flow of the associated Hamiltonian vector field, we can use it. Some simple calculations shows that the initial covector p(0) solution of the Pontryagin maximum principle is 1. Let us check that integrating the flow from (t_0 x_0) = (0 0) to the final time t_f = pi4 we reach the target x_f = tan(pi4) - 2 log(sqrt22).","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"p0 = 1\nxf, pf = f(t0, x0, p0, tf)\nxf - (tan(π/4) - 2log(√(2)/2))","category":"page"},{"location":"manual-flow-ocp.html#Variable","page":"From optimal control problems","title":"Variable","text":"","category":"section"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"Let us consider an optimal control problem with a (decision / optimisation) variable.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"t0 = 0\nx0 = 0\n\nocp = @def begin\n\n    tf ∈ R, variable # the optimisation variable is tf\n    t ∈ [t0, tf], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == 1\n    ẋ(t) == tf * u(t)\n\n    tf + 0.5∫(u(t)^2) → min\n\nend\nnothing # hide","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"As you can see, the variable is the final time tf. Note that the dynamics depends on tf. From the Pontryagin maximum principle, the solution is given by:","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"tf = (3/2)^(1/4)\np0 = 2tf/3\nnothing # hide","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"The input arguments of the maximising control are now the state x, the costate p and the variable tf.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"u(x, p, tf) = tf * p\nnothing # hide","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"Let us check that the final condition x(tf) = 1 is satisfied.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"f = Flow(ocp, u)\nxf, pf = f(t0, x0, p0, tf, tf)","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"The usage of the flow f is the following: f(t0, x0, p0, tf, v) where v is the variable. If one wants to compute the state at time t1 = 0.5, then, one must write:","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"t1 = 0.5\nx1, p1 = f(t0, x0, p0, t1, tf)","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"note: Free times\nIn the particular cases: the initial time t0 is the only variable, the final time tf is the only variable, or the initial and final times t0 and tf are the only variables and are in order v=(t0, tf), the times do not need to be repeated in the call of the flow:xf, pf = f(t0, x0, p0, tf)","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"Since the variable is the final time, we can make the time-reparameterisation t = s t_f to normalise the time s in 0 1.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"ocp = @def begin\n\n    tf ∈ R, variable\n    s ∈ [0, 1], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(0) == 0\n    x(1) == 1\n    ẋ(s) == tf^2 * u(s)\n\n    tf + (0.5*tf)*∫(u(s)^2) → min\n\nend\n\nf = Flow(ocp, u)\nxf, pf = f(0, x0, p0, 1, tf)","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"Another possibility is to add a new state variable t_f(s). The problem has no variable anymore.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"ocp = @def begin\n\n    s ∈ [0, 1], time\n    y = (x, tf) ∈ R², state\n    u ∈ R, control\n\n    x(0) == 0\n    x(1) == 1\n    dx = tf(s)^2 * u(s)\n    dtf = 0 * u(s) # 0\n    ẏ(s) == [dx, dtf]\n\n    tf(1) + 0.5∫(tf(s) * u(s)^2) → min\n\nend\n\nu(y, q) = y[2] * q[1]\n\nf = Flow(ocp, u)\nyf, pf = f(0, [x0, tf], [p0, 0], 1)","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"danger: Bug\nNote that in the previous optimal control problem, we have dtf = 0 * u(s) instead of dtf = 0. The latter does not work.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"note: Goddard problem\nIn the Goddard problem, you may find other constructions of flows, especially for singular and boundary arcs.","category":"page"},{"location":"manual-flow-ocp.html#Concatenation-of-arcs","page":"From optimal control problems","title":"Concatenation of arcs","text":"","category":"section"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"In this part, we present how to concatenate several flows. Let us consider the following problem.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"t0 =  0\ntf =  1\nx0 = -1\nxf =  0\n\n@def ocp begin\n\n    t ∈ [ t0, tf ], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == xf\n    -1 ≤ u(t) ≤ 1\n    ẋ(t) == -x(t) + u(t)\n\n    ∫( abs(u(t)) ) → min\n\nend\nnothing # hide","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"From the Pontryagin maximum principle, the optimal control is a concatenation of an off arc (u=0) followed by a  positive bang arc (u=1). The initial costate is ","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"p_0 = frac1x_0 - (x_f-1) e^t_f","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"and the switching time is t_1 = -ln(p_0).","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"p0 = 1/( x0 - (xf-1) * exp(tf) )\nt1 = -log(p0)\nnothing  # hide","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"Let us define the two flows and the concatenation. Note that the concatenation of two flows is a flow.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"f0 = Flow(ocp, (x, p) -> 0)     # off arc: u = 0\nf1 = Flow(ocp, (x, p) -> 1)     # positive bang arc: u = 1\n\nf = f0 * (t1, f1)               # f0 followed by f1 whenever t ≥ t1\nnothing # hide","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"Now, we can check that the state reach the target.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"sol = f((t0, tf), x0, p0)\nplot(sol)","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"note: Goddard problem\nIn the Goddard problem, you may find more complex concatenations.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"For the moment, this concatenation is not equivalent to an exact concatenation.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"f = Flow(x ->  x)\ng = Flow(x -> -x)\n\nx0 = 1\nφ(t) = (f * (t/2, g))(0, x0, t)\nψ(t) = g(t/2, f(0, x0, t/2), t)\n\nprintln(\"φ(t) = \", abs(φ(1)-x0))\nprintln(\"ψ(t) = \", abs(ψ(1)-x0))\n\nt = range(1, 5e2, 201)\n\nplt = plot(yaxis=:log, legend=:bottomright, title=\"Comparison of concatenations\", xlabel=\"t\")\nplot!(plt, t, t->abs(φ(t)-x0), label=\"OptimalControl\")\nplot!(plt, t, t->abs(ψ(t)-x0), label=\"Classical\")","category":"page"},{"location":"manual-flow-ocp.html#State-constraints","page":"From optimal control problems","title":"State constraints","text":"","category":"section"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"We consider an optimal control problem with a state constraints of order 1.[1] ","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"[1]: B. Bonnard, L. Faubourg, G. Launay & E. Trélat, Optimal Control With State Constraints And The Space Shuttle Re-entry Problem, J. Dyn. Control Syst., 9 (2003), no. 2, 155–199.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"t0 = 0\ntf = 2\nx0 = 1\nxf = 1/2\nlb = 0.1\n\nocp = @def begin\n\n    t ∈ [t0, tf], time\n    x ∈ R, state\n    u ∈ R, control\n\n    -1 ≤ u(t) ≤ 1\n    x(t0) == x0\n    x(tf) == xf\n    x(t) - lb ≥ 0 # state constraint\n    ẋ(t) == u(t)\n\n    ∫( x(t)^2 ) → min\n\nend\nnothing # hide","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"The pseudo-Hamiltonian of this problem is","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"    H(x p u mu) = p u + p^0 x^2 + mu c(x)","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"where $ p^0 = -1 $ since we are in the normal case, and where c(x) = x - l_b. Along a boundary arc, when c(x(t)) = 0, we have x(t) = l_b, so $ x(\\cdot) $ is constant. Differentiating, we obtain dotx(t) = u(t) = 0. Hence, along a boundary arc, the control in feedback form is:","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"u(x) = 0","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"From the maximizing condition, along a boundary arc, we have p(t) = 0. Differentiating, we obtain dotp(t) = 2 x(t) - mu(t) = 0. Hence, along a boundary arc, the dual variable mu is given in feedback form by:","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"mu(x) = 2x","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"note: Note\nWithin OptimalControl.jl, the constraint must be given in the form:c([t, ]x, u[, v])the control law in feedback form must be given as:u([t, ]x, p[, v])and the dual variable:μ([t, ]x, p[, v])The time t must be provided when the problem is non-autonomous and the variable v must be given when the optimal control problem contains a variable to optimise.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"The optimal control is a concatenation of 3 arcs: a negative bang arc followed by a boundary arc, followed by a positive bang arc. The initial covector is approximately p(0)=-0982237546583301, the first switching time is t_1 = 09, and the exit time of the boundary is t_2 = 16. Let us check this by concatenating the three flows.","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"u(x) = 0     # boundary control\nc(x) = x-lb  # constraint\nμ(x) = 2x    # dual variable\n\nf1 = Flow(ocp, (x, p) -> -1)\nf2 = Flow(ocp, (x, p) -> u(x), (x, u) -> c(x), (x, p) -> μ(x))\nf3 = Flow(ocp, (x, p) -> +1)\n\nt1 = 0.9\nt2 = 1.6\nf = f1 * (t1, f2) * (t2, f3)\n\np0 = -0.982237546583301\nxf, pf = f(t0, x0, p0, tf)\nxf","category":"page"},{"location":"manual-flow-ocp.html","page":"From optimal control problems","title":"From optimal control problems","text":"","category":"page"},{"location":"api-optimalcontrol-user.html#OptimalControl.jl","page":"OptimalControl.jl - User","title":"OptimalControl.jl","text":"","category":"section"},{"location":"api-optimalcontrol-user.html","page":"OptimalControl.jl - User","title":"OptimalControl.jl - User","text":"OptimalControl.jl is the core package of the control-toolbox ecosystem. Below, we group together the documentation of all the functions and types exported by OptimalControl.","category":"page"},{"location":"api-optimalcontrol-user.html","page":"OptimalControl.jl - User","title":"OptimalControl.jl - User","text":"tip: Beware!\nEven if the following functions are prefixed by another package, such as CTFlows.Lift, they can all be used with OptimalControl. In fact, all functions prefixed with another package are simply reexported. For example, Lift is defined in CTFlows but accessible from OptimalControl.julia> using OptimalControl\njulia> F(x) = 2x\njulia> H = Lift(F)\njulia> x = 1\njulia> p = 2\njulia> H(x, p)\n4","category":"page"},{"location":"api-optimalcontrol-user.html#Exported-functions-and-types","page":"OptimalControl.jl - User","title":"Exported functions and types","text":"","category":"section"},{"location":"api-optimalcontrol-user.html#OptimalControl.OptimalControl","page":"OptimalControl.jl - User","title":"OptimalControl.OptimalControl","text":"OptimalControl module.\n\nList of all the exported names:\n\n*\nFlow\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\n@Lie\nLie\nLift\nModel\nParsingError\nPoisson\nSolution\nVectorField\navailable_methods\nbuild_OCP_solution\nconstraint\nconstraints\nconstraints_violation\ncontrol\ncontrol_components\ncontrol_dimension\ncontrol_name\ncostate\ncriterion\n@def\ndefinition\ndirect_transcription\ndual\ndynamics\nexport_ocp_solution\nfinal_time\nfinal_time_name\nget_build_examodel\nhas_fixed_final_time\nhas_fixed_initial_time\nhas_free_final_time\nhas_free_initial_time\nhas_lagrange_cost\nhas_mayer_cost\nimport_ocp_solution\ninfos\ninitial_time\ninitial_time_name\nis_autonomous\niterations\nlagrange\nmayer\nmessage\nmodel\nobjective\nset_initial_guess\nsolve\nstate\nstate_components\nstate_dimension\nstate_name\nstatus\nsuccessful\ntime_grid\ntime_name\ntimes\nvariable\nvariable_components\nvariable_dimension\nvariable_name\n⋅\n\n\n\n\n\n","category":"module"},{"location":"api-optimalcontrol-user.html#Documentation","page":"OptimalControl.jl - User","title":"Documentation","text":"","category":"section"},{"location":"api-optimalcontrol-user.html#Base.:*-Tuple{CTFlowsODE.AbstractFlow}","page":"OptimalControl.jl - User","title":"Base.:*","text":"*(x, y...)\n\nMultiplication operator.\n\nInfix x*y*z*... calls this function with all arguments, i.e. *(x, y, z, ...), which by default then calls (x*y) * z * ... starting from the left.\n\nJuxtaposition such as 2pi also calls *(2, pi). Note that this operation has higher precedence than a literal *. Note also that juxtaposition \"0x...\" (integer zero times a variable whose name starts with x) is forbidden as it clashes with unsigned integer literals: 0x01 isa UInt8.\n\nNote that overflow is possible for most integer types, including the default Int, when multiplying large numbers.\n\nExamples\n\njulia> 2 * 7 * 8\n112\n\njulia> *(2, 7, 8)\n112\n\njulia> [2 0; 0 3] * [1, 10]  # matrix * vector\n2-element Vector{Int64}:\n  2\n 30\n\njulia> 1/2pi, 1/2*pi  # juxtaposition has higher precedence\n(0.15915494309189535, 1.5707963267948966)\n\njulia> x = [1, 2]; x'x  # adjoint vector * vector\n5\n\n\n\n\n\n*(\n    F::CTFlowsODE.AbstractFlow,\n    g::Tuple{Real, TF<:CTFlowsODE.AbstractFlow}\n) -> Any\n\n\nShorthand for concatenate(F, g) when g is a tuple (t_switch, G).\n\nArguments\n\nF::AbstractFlow: The first flow.\ng::Tuple{ctNumber, AbstractFlow}: Tuple containing the switching time and second flow.\n\nReturns\n\nA new flow that switches from F to G at t_switch.\n\nExample\n\njulia> F * (1.0, G)\n\n\n\n\n\n*(\n    F::CTFlowsODE.AbstractFlow,\n    g::Tuple{Real, Any, TF<:CTFlowsODE.AbstractFlow}\n) -> Any\n\n\nShorthand for concatenate(F, g) when g is a tuple (t_switch, η_switch, G) including a jump.\n\nArguments\n\nF::AbstractFlow: The first flow.\ng::Tuple{ctNumber, Any, AbstractFlow}: Tuple with switching time, jump value, and second flow.\n\nReturns\n\nA flow with a jump at t_switch and a switch from F to G.\n\nExample\n\njulia> F * (1.0, η, G)\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-user.html#CTFlows.Flow","page":"OptimalControl.jl - User","title":"CTFlows.Flow","text":"Flow(\n    vf::VectorField;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.VectorFieldFlow\n\n\nConstructs a flow object for a classical (non-Hamiltonian) vector field.\n\nThis creates a VectorFieldFlow that integrates the ODE system dx/dt = vf(t, x, v) using DifferentialEquations.jl. It handles both fixed and parametric dynamics, as well as jump discontinuities and event stopping.\n\nKeyword Arguments\n\nalg, abstol, reltol, saveat, internalnorm: Solver options.\nkwargs_Flow...: Additional arguments passed to the solver configuration.\n\nExample\n\njulia> vf(t, x, v) = -v * x\njulia> flow = CTFlows.Flow(CTFlows.VectorField(vf))\njulia> x1 = flow(0.0, 1.0, 1.0)\n\n\n\n\n\nFlow(\n    h::CTFlows.AbstractHamiltonian;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.HamiltonianFlow\n\n\nConstructs a Hamiltonian flow from a scalar Hamiltonian.\n\nThis method builds a numerical integrator that simulates the evolution of a Hamiltonian system given a Hamiltonian function h(t, x, p, l) or h(x, p).\n\nInternally, it computes the right-hand side of Hamilton’s equations via automatic differentiation and returns a HamiltonianFlow object.\n\nKeyword Arguments\n\nalg, abstol, reltol, saveat, internalnorm: solver options.\nkwargs_Flow...: forwarded to the solver.\n\nExample\n\njulia> H(x, p) = dot(p, p) + dot(x, x)\njulia> flow = CTFlows.Flow(CTFlows.Hamiltonian(H))\njulia> xf, pf = flow(0.0, x0, p0, 1.0)\n\n\n\n\n\nFlow(\n    hv::HamiltonianVectorField;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.HamiltonianFlow\n\n\nConstructs a Hamiltonian flow from a precomputed Hamiltonian vector field.\n\nThis method assumes you already provide the Hamiltonian vector field (dx/dt, dp/dt) instead of deriving it from a scalar Hamiltonian.\n\nReturns a HamiltonianFlow object that integrates the given system.\n\nKeyword Arguments\n\nalg, abstol, reltol, saveat, internalnorm: solver options.\nkwargs_Flow...: forwarded to the solver.\n\nExample\n\njulia> hv(t, x, p, l) = (∇ₚH, -∇ₓH)\njulia> flow = CTFlows.Flow(CTFlows.HamiltonianVectorField(hv))\njulia> xf, pf = flow(0.0, x0, p0, 1.0, l)\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::CTFlows.ControlLaw;\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConstruct a flow for an optimal control problem using a given control law.\n\nThis method builds the Hamiltonian system associated with the optimal control problem (ocp) and integrates the corresponding state–costate dynamics using the specified control law u.\n\nArguments\n\nocp::CTModels.Model: An optimal control problem defined using CTModels.\nu::CTFlows.ControlLaw: A feedback control law generated by ControlLaw(...) or similar.\nalg: Integration algorithm (default inferred).\nabstol: Absolute tolerance for the ODE solver.\nreltol: Relative tolerance for the ODE solver.\nsaveat: Time points at which to save the solution.\ninternalnorm: Optional norm function used by the integrator.\nkwargs_Flow: Additional keyword arguments passed to the solver.\n\nReturns\n\nA flow object f such that:\n\nf(t0, x0, p0, tf) integrates the state and costate from t0 to tf.\nf((t0, tf), x0, p0) returns the full trajectory over the interval.\n\nExample\n\njulia> u = (x, p) -> p\njulia> f = Flow(ocp, ControlLaw(u))\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::Function;\n    autonomous,\n    variable,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConstruct a flow for an optimal control problem using a control function in feedback form.\n\nThis method constructs the Hamiltonian and integrates the associated state–costate dynamics using a raw function u. It automatically wraps u as a control law.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem.\nu::Function: A feedback control function:\nIf ocp is autonomous: u(x, p)\nIf non-autonomous: u(t, x, p)\nautonomous::Bool: Whether the control law depends on time.\nvariable::Bool: Whether the OCP involves variable time (e.g., free final time).\nalg, abstol, reltol, saveat, internalnorm: ODE solver parameters.\nkwargs_Flow: Additional options.\n\nReturns\n\nA Flow object compatible with function call interfaces for state propagation.\n\nExample\n\njulia> u = (t, x, p) -> t + p\njulia> f = Flow(ocp, u)\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::Union{CTFlows.ControlLaw{<:Function, T, V}, CTFlows.FeedbackControl{<:Function, T, V}},\n    g::Union{CTFlows.MixedConstraint{<:Function, T, V}, CTFlows.StateConstraint{<:Function, T, V}},\n    μ::CTFlows.Multiplier{<:Function, T, V};\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConstruct a flow for an optimal control problem with control and constraint multipliers in feedback form.\n\nThis variant constructs a Hamiltonian system incorporating both the control law and a multiplier law (e.g., for enforcing state or mixed constraints). All inputs must be consistent in time dependence.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem.\nu::ControlLaw or FeedbackControl: Feedback control.\ng::StateConstraint or MixedConstraint: Constraint function.\nμ::Multiplier: Multiplier function.\nalg, abstol, reltol, saveat, internalnorm: Solver settings.\nkwargs_Flow: Additional options.\n\nReturns\n\nA Flow object that integrates the constrained Hamiltonian dynamics.\n\nExample\n\njulia> f = Flow(ocp, (x, p) -> p[1], (x, u) -> x[1] - 1, (x, p) -> x[1]+p[1])\n\nFor non-autonomous cases:\n\njulia> f = Flow(ocp, (t, x, p) -> t + p, (t, x, u) -> x - 1, (t, x, p) -> x+p)\n\nwarning: Warning\nAll input functions must match the autonomous/non-autonomous nature of the problem.\n\n\n\n\n\nFlow(\n    ocp::Model,\n    u::Function,\n    g::Function,\n    μ::Function;\n    autonomous,\n    variable,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.OptimalControlFlow\n\n\nConstruct a flow from a raw feedback control, constraint, and multiplier.\n\nThis version is for defining flows directly from user functions without wrapping them into ControlLaw, Constraint, or Multiplier types. Automatically wraps and adapts them based on time dependence.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem.\nu::Function: Control law.\ng::Function: Constraint.\nμ::Function: Multiplier.\nautonomous::Bool: Whether the system is autonomous.\nvariable::Bool: Whether time is a free variable.\nalg, abstol, reltol, saveat, internalnorm: Solver parameters.\nkwargs_Flow: Additional options.\n\nReturns\n\nA Flow object ready for trajectory integration.\n\n\n\n\n\nFlow(\n    dyn::Function;\n    autonomous,\n    variable,\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    internalnorm,\n    kwargs_Flow...\n) -> CTFlowsODE.ODEFlow\n\n\nConstructs a Flow from a user-defined dynamical system given as a Julia function.\n\nThis high-level interface handles:\n\nautonomous and non-autonomous systems,\npresence or absence of additional variables (v),\nselection of ODE solvers and tolerances,\nand integrates with the CTFlows event system (e.g., jumps, callbacks).\n\nArguments\n\ndyn: A function defining the vector field. Its signature must match the values of autonomous and variable.\nautonomous: Whether the dynamics are time-independent (false by default).\nvariable: Whether the dynamics depend on a control or parameter v.\nalg, abstol, reltol, saveat, internalnorm: Solver settings passed to OrdinaryDiffEq.solve.\nkwargs_Flow: Additional keyword arguments passed to the solver.\n\nReturns\n\nAn ODEFlow object, wrapping both the full solver and its right-hand side (RHS).\n\nSupported Function Signatures for dyn\n\nDepending on the (autonomous, variable) flags:\n\n(false, false): dyn(x)\n(false, true):  dyn(x, v)\n(true, false):  dyn(t, x)\n(true, true):   dyn(t, x, v)\n\nExample\n\njulia> dyn(t, x, v) = [-x[1] + v[1] * sin(t)]\njulia> flow = CTFlows.Flow(dyn; autonomous=true, variable=true)\njulia> xT = flow((0.0, 1.0), [1.0], [0.1])\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTFlows.Hamiltonian","page":"OptimalControl.jl - User","title":"CTFlows.Hamiltonian","text":"struct Hamiltonian{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence} <: CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nEncodes the Hamiltonian function H = ⟨p, f⟩ + L in optimal control.\n\nFields\n\nf: a callable of the form:\nf(x, p)\nf(t, x, p)\nf(x, p, v)\nf(t, x, p, v)\n\nType Parameters\n\nTD: Autonomous or NonAutonomous\nVD: Fixed or NonFixed\n\nExample\n\njulia> Hf(x, p) = dot(p, [x[2], -x[1]])\njulia> H = Hamiltonian{typeof(Hf), Autonomous, Fixed}(Hf)\njulia> H([1.0, 0.0], [1.0, 1.0])\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTFlows.HamiltonianLift","page":"OptimalControl.jl - User","title":"CTFlows.HamiltonianLift","text":"struct HamiltonianLift{TV<:VectorField, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence} <: CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nLifts a vector field X into a Hamiltonian function using the canonical symplectic structure.\n\nThis is useful to convert a vector field into a Hamiltonian via the identity: H(x, p) = ⟨p, X(x)⟩.\n\nConstructor\n\nUse HamiltonianLift(X::VectorField) where X is a VectorField{...}.\n\nExample\n\nf(x) = [x[2], -x[1]]\njulia> X = VectorField{typeof(f), Autonomous, Fixed}(f)\njulia> H = HamiltonianLift(X)\njulia> H([1.0, 0.0], [0.5, 0.5])\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTFlows.HamiltonianVectorField","page":"OptimalControl.jl - User","title":"CTFlows.HamiltonianVectorField","text":"struct HamiltonianVectorField{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence} <: CTFlows.AbstractVectorField{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nRepresents the Hamiltonian vector field associated to a Hamiltonian function, typically defined as (∂H/∂p, -∂H/∂x).\n\nFields\n\nf: a callable implementing the Hamiltonian vector field.\n\nExample\n\njulia> f(x, p) = [p[2], -p[1], -x[1], -x[2]]\njulia> XH = HamiltonianVectorField{typeof(f), Autonomous, Fixed}(f)\njulia> XH([1.0, 0.0], [0.5, 0.5])\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTFlows.@Lie","page":"OptimalControl.jl - User","title":"CTFlows.@Lie","text":"Compute Lie or Poisson brackets.\n\nThis macro provides a unified notation to define recursively nested Lie brackets (for vector fields) or Poisson brackets (for Hamiltonians).\n\nSyntax\n\n@Lie [F, G]: computes the Lie bracket [F, G] of two vector fields.\n@Lie [[F, G], H]: supports arbitrarily nested Lie brackets.\n@Lie {H, K}: computes the Poisson bracket {H, K} of two Hamiltonians.\n@Lie {{H, K}, L}: supports arbitrarily nested Poisson brackets.\n@Lie expr autonomous = false: specifies a non-autonomous system.\n@Lie expr variable = true: indicates presence of an auxiliary variable v.\n\nKeyword-like arguments can be provided to control the evaluation context for Poisson brackets with raw functions:\n\nautonomous = Bool: whether the system is time-independent (default: true).\nvariable = Bool: whether the system depends on an extra variable v (default: false).\n\nBracket type detection\n\nSquare brackets [...] denote Lie brackets between VectorField objects.\nCurly brackets {...} denote Poisson brackets between Hamiltonian objects or between raw functions.\nThe macro automatically dispatches to Lie or Poisson depending on the input pattern.\n\nReturn\n\nA callable object representing the specified Lie or Poisson bracket expression. The returned function can be evaluated like any other vector field or Hamiltonian.\n\n\n\nExamples\n\n■ Lie brackets with VectorField (autonomous)\n\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> F2 = VectorField(x -> [x[3], 0, -x[1]])\njulia> L = @Lie [F1, F2]\njulia> L([1.0, 2.0, 3.0])\n3-element Vector{Float64}:\n  2.0\n -1.0\n  0.0\n\n■ Lie brackets with VectorField (non-autonomous, with auxiliary variable)\n\njulia> F1 = VectorField((t, x, v) -> [0, -x[3], x[2]]; autonomous=false, variable=true)\njulia> F2 = VectorField((t, x, v) -> [x[3], 0, -x[1]]; autonomous=false, variable=true)\njulia> L = @Lie [F1, F2]\njulia> L(0.0, [1.0, 2.0, 3.0], 1.0)\n3-element Vector{Float64}:\n  2.0\n -1.0\n  0.0\n\n■ Poisson brackets with Hamiltonian (autonomous)\n\njulia> H1 = Hamiltonian((x, p) -> x[1]^2 + p[2]^2)\njulia> H2 = Hamiltonian((x, p) -> x[2]^2 + p[1]^2)\njulia> P = @Lie {H1, H2}\njulia> P([1.0, 1.0], [3.0, 2.0])\n-4.0\n\n■ Poisson brackets with Hamiltonian (non-autonomous, with variable)\n\njulia> H1 = Hamiltonian((t, x, p, v) -> x[1]^2 + p[2]^2 + v; autonomous=false, variable=true)\njulia> H2 = Hamiltonian((t, x, p, v) -> x[2]^2 + p[1]^2 + v; autonomous=false, variable=true)\njulia> P = @Lie {H1, H2}\njulia> P(1.0, [1.0, 3.0], [4.0, 2.0], 3.0)\n8.0\n\n■ Poisson brackets from raw functions\n\njulia> H1 = (x, p) -> x[1]^2 + p[2]^2\njulia> H2 = (x, p) -> x[2]^2 + p[1]^2\njulia> P = @Lie {H1, H2}\njulia> P([1.0, 1.0], [3.0, 2.0])\n-4.0\n\n■ Poisson bracket with non-autonomous raw functions\n\njulia> H1 = (t, x, p) -> x[1]^2 + p[2]^2 + t\njulia> H2 = (t, x, p) -> x[2]^2 + p[1]^2 + t\njulia> P = @Lie {H1, H2} autonomous = false\njulia> P(3.0, [1.0, 2.0], [4.0, 1.0])\n-8.0\n\n■ Nested brackets\n\njulia> F = VectorField(x -> [-x[1], x[2], x[3]])\njulia> G = VectorField(x -> [x[3], -x[2], 0])\njulia> H = VectorField(x -> [0, 0, -x[1]])\njulia> nested = @Lie [[F, G], H]\njulia> nested([1.0, 2.0, 3.0])\n3-element Vector{Float64}:\n  2.0\n  0.0\n -6.0\n\njulia> H1 = (x, p) -> x[2]*x[1]^2 + p[1]^2\njulia> H2 = (x, p) -> x[1]*p[2]^2\njulia> H3 = (x, p) -> x[1]*p[2] + x[2]*p[1]\njulia> nested_poisson = @Lie {{H1, H2}, H3}\njulia> nested_poisson([1.0, 2.0], [0.5, 1.0])\n14.0\n\n■ Mixed expressions with arithmetic\n\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> F2 = VectorField(x -> [x[3], 0, -x[1]])\njulia> x = [1.0, 2.0, 3.0]\njulia> @Lie [F1, F2](x) + 3 * [F1, F2](x)\n3-element Vector{Float64}:\n  8.0\n -4.0\n  0.0\n\njulia> H1 = (x, p) -> x[1]^2\njulia> H2 = (x, p) -> p[1]^2\njulia> H3 = (x, p) -> x[1]*p[1]\njulia> x = [1.0, 2.0, 3.0]\njulia> p = [3.0, 2.0, 1.0]\njulia> @Lie {H1, H2}(x, p) + 2 * {H2, H3}(x, p)\n24.0\n\n\n\n\n\n","category":"macro"},{"location":"api-optimalcontrol-user.html#CTFlows.Lie","page":"OptimalControl.jl - User","title":"CTFlows.Lie","text":"Lie derivative of a scalar function along a vector field.\n\nExample:\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\nLie derivative of a scalar function along a function with specified dependencies.\n\nExample:\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\nLie bracket of two vector fields in the autonomous case.\n\nExample:\n\njulia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]\n\n\n\n\n\nLie bracket of two vector fields in the nonautonomous case.\n\nExample:\n\njulia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7, 12]\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTFlows.Lift","page":"OptimalControl.jl - User","title":"CTFlows.Lift","text":"Lift(\n    X::VectorField\n) -> HamiltonianLift{VectorField{TF, TD, VD}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\n\nConstruct the Hamiltonian lift of a VectorField.\n\nArguments\n\nX::VectorField: The vector field to lift. Its signature determines if it is autonomous and/or variable.\n\nReturns\n\nA HamiltonianLift callable object representing the Hamiltonian lift of X.\n\nExamples\n\njulia> HL = Lift(VectorField(x -> [x[1]^2, x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])  # returns 0\n\njulia> HL2 = Lift(VectorField((t, x, v) -> [t + x[1]^2, x[2]^2 + v], autonomous=false, variable=true))\njulia> HL2(1, [1, 0], [0, 1], 1)  # returns 1\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)  # returns 2\n\njulia> H2 = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H2(1, 1, 1, 1)  # returns 2\n\n# Alternative syntax using symbols for autonomy and variability\njulia> H3 = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H3(1, 1, 1, 1)  # returns 2\n\n\n\n\n\nLift(\n    X::Function;\n    autonomous,\n    variable\n) -> CTFlows.var\"#19#23\"{<:Function}\n\n\nConstruct the Hamiltonian lift of a function.\n\nArguments\n\nX::Function: The function representing the vector field.\nautonomous::Bool=true: Whether the function is autonomous (time-independent).\nvariable::Bool=false: Whether the function depends on an additional variable argument.\n\nReturns\n\nA callable function computing the Hamiltonian lift, \n\n(and variants depending on autonomous and variable).\n\nDetails\n\nDepending on the autonomous and variable flags, the returned function has one of the following call signatures:\n\n(x, p) if autonomous=true and variable=false\n(x, p, v) if autonomous=true and variable=true\n(t, x, p) if autonomous=false and variable=false\n(t, x, p, v) if autonomous=false and variable=true\n\nExamples\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)  # returns 2\n\njulia> H2 = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H2(1, 1, 1, 1)  # returns 2\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.Model","page":"OptimalControl.jl - User","title":"CTModels.Model","text":"struct Model{TD<:CTModels.TimeDependence, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:CTModels.AbstractConstraintsModel, BuildExaModelType<:Union{Nothing, Function}} <: CTModels.AbstractModel\n\nFields\n\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ndynamics::Function\nobjective::CTModels.AbstractObjectiveModel\nconstraints::CTModels.AbstractConstraintsModel\ndefinition::Expr\nbuild_examodel::Union{Nothing, Function}\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTBase.ParsingError","page":"OptimalControl.jl - User","title":"CTBase.ParsingError","text":"struct ParsingError <: CTBase.CTException\n\nException thrown during parsing when a syntax error or invalid structure is detected.\n\nFields\n\nvar::String: A message describing the parsing error.\n\nExample\n\njulia> throw(ParsingError(\"unexpected token\"))\nERROR: ParsingError: unexpected token\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTFlows.Poisson","page":"OptimalControl.jl - User","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V<:CTFlows.VariableDependence},\n    g::CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian). Autonomous case.\n\nReturns a Hamiltonian representing the Poisson bracket {f, g} of two autonomous Hamiltonian functions f and g.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])     # -20\njulia> Poisson(f, G)([1, 2], [2, 1])     # -20\njulia> Poisson(F, g)([1, 2], [2, 1])     # -20\n\n\n\n\n\nPoisson(\n    f::CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V<:CTFlows.VariableDependence},\n    g::CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions. Non-autonomous case.\n\nReturns a Hamiltonian representing {f, g} where f and g are time-dependent.\n\nExample\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])     # -76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])     # -76\n\n\n\n\n\nPoisson(\n    f::HamiltonianLift{T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence},\n    g::HamiltonianLift{T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence}\n)\n\n\nPoisson bracket of two HamiltonianLift vector fields.\n\nReturns the HamiltonianLift corresponding to the Lie bracket of vector fields f.X and g.X.\n\nExample\n\njulia> f = x -> [x[1]^2 + x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2] - x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])     # -64\n\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 - x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])     # 100\n\n\n\n\n\nPoisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n\n\nPoisson bracket of two functions. The time and variable dependence are specified with keyword arguments.\n\nReturns a Hamiltonian computed from the functions promoted as Hamiltonians.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])     # -20\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])     # -76\n\n\n\n\n\nPoisson(\n    f::Function,\n    g::CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n) -> Hamiltonian\n\n\nPoisson bracket of a function and a Hamiltonian.\n\nReturns a Hamiltonian representing {f, g} where g is already a Hamiltonian.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)\njulia> Poisson(f, G)([1, 2], [2, 1])     # -20\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])     # -76\n\n\n\n\n\nPoisson(\n    f::CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence},\n    g::Function\n) -> Hamiltonian\n\n\nPoisson bracket of a Hamiltonian and a function.\n\nReturns a Hamiltonian representing {f, g} where f is already a Hamiltonian.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])     # -20\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 - x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])     # -76\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.Solution","page":"OptimalControl.jl - User","title":"CTModels.Solution","text":"struct Solution{TimeGridModelType<:CTModels.AbstractTimeGridModel, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, CostateModelType<:Function, ObjectiveValueType<:Real, DualModelType<:CTModels.AbstractDualModel, SolverInfosType<:CTModels.AbstractSolverInfos, ModelType<:CTModels.AbstractModel} <: CTModels.AbstractSolution\n\nFields\n\ntime_grid::CTModels.AbstractTimeGridModel\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ncostate::Function\nobjective::Real\ndual::CTModels.AbstractDualModel\nsolver_infos::CTModels.AbstractSolverInfos\nmodel::CTModels.AbstractModel\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#CTFlows.VectorField","page":"OptimalControl.jl - User","title":"CTFlows.VectorField","text":"struct VectorField{TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence} <: CTFlows.AbstractVectorField{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\nRepresents a dynamical system dx/dt = f(...) as a vector field.\n\nFields\n\nf: a callable of the form:\nf(x)\nf(t, x)\nf(x, v)\nf(t, x, v)\n\nExample\n\nf(x) = [x[2], -x[1]]\nvf = VectorField{typeof(f), Autonomous, Fixed}(f)\nvf([1.0, 0.0])\n\n\n\n\n\n","category":"type"},{"location":"api-optimalcontrol-user.html#OptimalControl.available_methods","page":"OptimalControl.jl - User","title":"OptimalControl.available_methods","text":"available_methods(\n\n) -> Tuple{Vararg{Tuple{Symbol, Symbol, Symbol}}}\n\n\nReturn the list of available methods that can be used to solve optimal control problems.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTDirect.build_OCP_solution","page":"OptimalControl.jl - User","title":"CTDirect.build_OCP_solution","text":"build_OCP_solution(\n    docp,\n    docp_solution\n) -> Solution{TimeGridModelType, TimesModelType, StateModelType, ControlModelType, VariableModelType, CostateModelType, Float64, DualModelType, CTModels.SolverInfos{Dict{Symbol, Any}}, ModelType} where {TimeGridModelType<:CTModels.TimeGridModel, TimesModelType<:CTModels.TimesModel, StateModelType<:Union{CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#114#136\", CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#115#137\"}, ControlModelType<:Union{CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#116#138\", CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#117#139\"}, VariableModelType<:Union{CTModels.VariableModelSolution{Vector{Float64}}, CTModels.VariableModelSolution{Float64}}, CostateModelType<:Union{CTModels.var\"#118#140\", CTModels.var\"#119#141\"}, DualModelType<:(CTModels.DualModel{PC_Dual, BC_Dual, SC_LB_Dual, SC_UB_Dual, CC_LB_Dual, CC_UB_Dual, VC_LB_Dual, VC_UB_Dual} where {PC_Dual<:Union{Nothing, CTModels.var\"#121#143\", CTModels.var\"#122#144\"}, BC_Dual<:Union{Nothing, Vector{Float64}}, SC_LB_Dual<:Union{Nothing, CTModels.var\"#124#146\", CTModels.var\"#125#147\"}, SC_UB_Dual<:Union{Nothing, CTModels.var\"#127#149\", CTModels.var\"#128#150\"}, CC_LB_Dual<:Union{Nothing, CTModels.var\"#130#152\", CTModels.var\"#131#153\"}, CC_UB_Dual<:Union{Nothing, CTModels.var\"#133#155\", CTModels.var\"#134#156\"}, VC_LB_Dual<:Union{Nothing, Vector{Float64}}, VC_UB_Dual<:Union{Nothing, Vector{Float64}}}), ModelType<:Model}\n\n\nBuild OCP functional solution from DOCP discrete solution  (given as a SolverCore.GenericExecutionStats)\n\n\n\n\n\nbuild_OCP_solution(docp; primal, dual, mult_LB, mult_UB)\n\n\nBuild OCP functional solution from DOCP discrete solution  (given as array for primal variables, optionally dual variables and bounds multipliers)\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.constraint","page":"OptimalControl.jl - User","title":"CTModels.constraint","text":"constraint(\n    model::Model,\n    label::Symbol\n) -> Tuple{Symbol, Any, Any, Any}\n\n\nGet a labelled constraint from the model. Returns a tuple of the form (type, f, lb, ub) where type is the type of the constraint, f is the function,  lb is the lower bound and ub is the upper bound. \n\nThe function returns an exception if the label is not found in the model.\n\nArguments\n\nmodel: The model from which to retrieve the constraint.\nlabel: The label of the constraint to retrieve.\n\nReturns\n\nTuple: A tuple containing the type, function, lower bound, and upper bound of the constraint.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.constraints","page":"OptimalControl.jl - User","title":"CTModels.constraints","text":"constraints(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, C<:CTModels.AbstractConstraintsModel}\n) -> CTModels.AbstractConstraintsModel\n\n\nReturn the constraints struct.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.constraints_violation","page":"OptimalControl.jl - User","title":"CTModels.constraints_violation","text":"constraints_violation(sol::Solution) -> Float64\n\n\nReturn the constraints violation.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.control","page":"OptimalControl.jl - User","title":"CTModels.control","text":"control(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, T<:CTModels.AbstractControlModel}\n) -> CTModels.AbstractControlModel\n\n\nReturn the control struct.\n\n\n\n\n\ncontrol(\n    sol::Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.ControlModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the control as a function of time.\n\njulia> u  = control(sol)\njulia> t0 = time_grid(sol)[1]\njulia> u0 = u(t0) # control at the initial time\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.control_components","page":"OptimalControl.jl - User","title":"CTModels.control_components","text":"control_components(ocp::Model) -> Vector{String}\n\n\nReturn the names of the components of the control.\n\n\n\n\n\ncontrol_components(sol::Solution) -> Vector{String}\n\n\nReturn the names of the components of the control.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.control_dimension","page":"OptimalControl.jl - User","title":"CTModels.control_dimension","text":"control_dimension(ocp::Model) -> Int64\n\n\nReturn the control dimension.\n\n\n\n\n\ncontrol_dimension(sol::Solution) -> Int64\n\n\nReturn the dimension of the control.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.control_name","page":"OptimalControl.jl - User","title":"CTModels.control_name","text":"control_name(ocp::Model) -> String\n\n\nReturn the name of the control.\n\n\n\n\n\ncontrol_name(sol::Solution) -> String\n\n\nReturn the name of the control.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.costate","page":"OptimalControl.jl - User","title":"CTModels.costate","text":"costate(\n    sol::Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, Co<:Function}\n) -> Function\n\n\nReturn the costate as a function of time.\n\njulia> p  = costate(sol)\njulia> t0 = time_grid(sol)[1]\njulia> p0 = p(t0) # costate at the initial time\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.criterion","page":"OptimalControl.jl - User","title":"CTModels.criterion","text":"criterion(model::CTModels.MayerObjectiveModel) -> Symbol\n\n\nReturn the criterion (:min or :max).\n\n\n\n\n\ncriterion(model::CTModels.LagrangeObjectiveModel) -> Symbol\n\n\nReturn the criterion (:min or :max).\n\n\n\n\n\ncriterion(model::CTModels.BolzaObjectiveModel) -> Symbol\n\n\nReturn the criterion (:min or :max).\n\n\n\n\n\ncriterion(ocp::Model) -> Symbol\n\n\nReturn the type of criterion (:min or :max).\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTParser.@def","page":"OptimalControl.jl - User","title":"CTParser.@def","text":"Define an optimal control problem. One pass parsing of the definition. Can be used writing either ocp = @def begin ... end or @def ocp begin ... end. In the second case, setting log to true will display the parsing steps.\n\nExample\n\nocp = @def begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend\n\n@def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend true # final boolean to show parsing log\n\n\n\n\n\n","category":"macro"},{"location":"api-optimalcontrol-user.html#CTModels.definition","page":"OptimalControl.jl - User","title":"CTModels.definition","text":"definition(ocp::Model) -> Expr\n\n\nReturn the model definition of the optimal control problem.\n\n\n\n\n\ndefinition(ocp::CTModels.PreModel) -> Union{Nothing, Expr}\n\n\nReturn the model definition of the optimal control problem or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTDirect.direct_transcription","page":"OptimalControl.jl - User","title":"CTDirect.direct_transcription","text":"direct_transcription(\n    ocp::Model,\n    description...;\n    grid_size,\n    disc_method,\n    time_grid,\n    init,\n    kwargs...\n) -> CTDirect.DOCP{_A, Model{TD, TimesModelType, StateModelType, ControlModelType, VariableModelType, DynamicsModelType, ObjectiveModelType, ConstraintsModelType, BuildExaModelType}} where {_A<:CTDirect.Discretization, TD<:CTModels.TimeDependence, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:CTModels.AbstractConstraintsModel, BuildExaModelType<:Union{Nothing, Function}}\n\n\nDiscretize an optimal control problem into a nonlinear optimization problem.\n\nArguments\n\nocp: optimal control problem as defined in CTModels\n[description]: set the NLP model ([:adnlp] or exa) and / or solver ([:ipopt], :madnlp or :knitro)\n\nKeyword arguments (optional)\n\ngrid_size: number of time steps for the discretized problem ([250])\ndisc_method: discretization method ([:trapeze], :euler, :euler_implicit, :midpoint, gauss_legendre_2, gauss_legendre_3)\ntime_grid: explicit time grid (can be non uniform)\ninit: info for the starting guess (values as named tuple or existing solution)\n\nOther kewwords arguments are passed down to the NLP modeler\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.dual","page":"OptimalControl.jl - User","title":"CTModels.dual","text":"dual(sol::Solution, model::Model, label::Symbol) -> Any\n\n\nReturn the dual variable associated with a constraint identified by its label.\n\nSearches through all constraint types (path, boundary, state, control, and variable constraints) defined in the model and returns the corresponding dual value from the solution.\n\nArguments\n\nsol::Solution: Solution object containing dual variables.\nmodel::Model: Model containing constraint definitions.\nlabel::Symbol: Symbol corresponding to a constraint label.\n\nReturns\n\nA function of time t for time-dependent constraints, or a scalar/vector for time-invariant duals. If the label is not found, throws an IncorrectArgument exception.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.dynamics","page":"OptimalControl.jl - User","title":"CTModels.dynamics","text":"dynamics(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, D<:Function}\n) -> Function\n\n\nReturn the dynamics.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.export_ocp_solution","page":"OptimalControl.jl - User","title":"CTModels.export_ocp_solution","text":"export_ocp_solution(\n    sol::CTModels.AbstractSolution;\n    format,\n    filename\n)\n\n\nExport a solution in JLD or JSON formats. Redirect to one of the methods:\n\nexport_ocp_solution(JLD2Tag(), sol, filename=filename)\nexport_ocp_solution(JSON3Tag(), sol, filename=filename)\n\nExamples\n\njulia> using JSON3\njulia> export_ocp_solution(sol; filename=\"solution\", format=:JSON)\njulia> using JLD2\njulia> export_ocp_solution(sol; filename=\"solution\", format=:JLD)  # JLD is the default\n\n\n\n\n\nexport_ocp_solution(\n    ::CTModels.JSON3Tag,\n    sol::Solution;\n    filename\n)\n\n\nExport an optimal control solution to a .json file using the JSON3 format.\n\nThis function serializes a CTModels.Solution into a structured JSON dictionary, including all primal and dual information, which can be read by external tools.\n\nArguments\n\n::CTModels.JSON3Tag: A tag used to dispatch the export method for JSON3.\nsol::CTModels.Solution: The solution to be saved.\n\nKeyword Arguments\n\nfilename::String = \"solution\": Base filename. The .json extension is automatically appended.\n\nNotes\n\nThe exported JSON includes the time grid, state, control, costate, objective, solver info, and all constraint duals (if available).\n\nExample\n\njulia> using JSON3\njulia> export_ocp_solution(JSON3Tag(), sol; filename=\"mysolution\")\n# → creates \"mysolution.json\"\n\n\n\n\n\nexport_ocp_solution(\n    ::CTModels.JLD2Tag,\n    sol::Solution;\n    filename\n)\n\n\nExport an optimal control solution to a .jld2 file using the JLD2 format.\n\nThis function serializes and saves a CTModels.Solution object to disk, allowing it to be reloaded later.\n\nArguments\n\n::CTModels.JLD2Tag: A tag used to dispatch the export method for JLD2.\nsol::CTModels.Solution: The optimal control solution to be saved.\n\nKeyword Arguments\n\nfilename::String = \"solution\": Base name of the file. The .jld2 extension is automatically appended.\n\nExample\n\njulia> using JLD2\njulia> export_ocp_solution(JLD2Tag(), sol; filename=\"mysolution\")\n# → creates \"mysolution.jld2\"\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.final_time","page":"OptimalControl.jl - User","title":"CTModels.final_time","text":"final_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the final time from the times model, from a fixed final time model.\n\n\n\n\n\nfinal_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the final time from the times model, from a free final time model.\n\n\n\n\n\nfinal_time(ocp::CTModels.AbstractModel) -> Real\n\n\n\n\n\n\nfinal_time(\n    ocp::CTModels.AbstractModel,\n    variable::AbstractVector\n) -> Any\n\n\n\n\n\n\nfinal_time(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nReturn the final time, for a fixed final time.\n\n\n\n\n\nfinal_time(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nReturn the final time, for a free final time.\n\n\n\n\n\nfinal_time(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}},\n    variable::Real\n) -> Real\n\n\nReturn the final time, for a free final time.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.final_time_name","page":"OptimalControl.jl - User","title":"CTModels.final_time_name","text":"final_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the final time from the times model.\n\n\n\n\n\nfinal_time_name(ocp::Model) -> String\n\n\nReturn the name of the final time.\n\n\n\n\n\nfinal_time_name(sol::Solution) -> String\n\n\nReturn the name of the final time.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.get_build_examodel","page":"OptimalControl.jl - User","title":"CTModels.get_build_examodel","text":"get_build_examodel(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.AbstractConstraintsModel, BE<:Function}\n) -> Function\n\n\nReturn the build_examodel.\n\n\n\n\n\nget_build_examodel(\n    _::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.AbstractConstraintsModel, <:Nothing}\n)\n\n\nReturn an error (UnauthorizedCall) since the model is not built with the :exa backend.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.has_fixed_final_time","page":"OptimalControl.jl - User","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the final time is fixed. Return true.\n\n\n\n\n\nhas_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the final time is free. Return false.\n\n\n\n\n\nhas_fixed_final_time(ocp::Model) -> Bool\n\n\nCheck if the final time is fixed.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.has_fixed_initial_time","page":"OptimalControl.jl - User","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(\n    times::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the initial time is fixed. Return true.\n\n\n\n\n\nhas_fixed_initial_time(\n    times::CTModels.TimesModel{CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the initial time is free. Return false.\n\n\n\n\n\nhas_fixed_initial_time(ocp::Model) -> Bool\n\n\nCheck if the initial time is fixed.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.has_free_final_time","page":"OptimalControl.jl - User","title":"CTModels.has_free_final_time","text":"has_free_final_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\nhas_free_final_time(ocp::Model) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.has_free_initial_time","page":"OptimalControl.jl - User","title":"CTModels.has_free_initial_time","text":"has_free_initial_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\nhas_free_initial_time(ocp::Model) -> Bool\n\n\nCheck if the initial time is free.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.has_lagrange_cost","page":"OptimalControl.jl - User","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(_::CTModels.MayerObjectiveModel) -> Bool\n\n\nReturn false.\n\n\n\n\n\nhas_lagrange_cost(\n    _::CTModels.LagrangeObjectiveModel\n) -> Bool\n\n\nReturn true.\n\n\n\n\n\nhas_lagrange_cost(_::CTModels.BolzaObjectiveModel) -> Bool\n\n\nReturn true.\n\n\n\n\n\nhas_lagrange_cost(ocp::Model) -> Bool\n\n\nCheck if the model has a Lagrange cost.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.has_mayer_cost","page":"OptimalControl.jl - User","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(_::CTModels.MayerObjectiveModel) -> Bool\n\n\nReturn true.\n\n\n\n\n\nhas_mayer_cost(_::CTModels.LagrangeObjectiveModel) -> Bool\n\n\nReturn false.\n\n\n\n\n\nhas_mayer_cost(_::CTModels.BolzaObjectiveModel) -> Bool\n\n\nReturn true.\n\n\n\n\n\nhas_mayer_cost(ocp::Model) -> Bool\n\n\nCheck if the model has a Mayer cost.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.import_ocp_solution","page":"OptimalControl.jl - User","title":"CTModels.import_ocp_solution","text":"import_ocp_solution(\n    ocp::CTModels.AbstractModel;\n    format,\n    filename\n) -> Any\n\n\nImport a solution from a JLD or JSON file. Redirect to one of the methods:\n\nimport_ocp_solution(JLD2Tag(), ocp, filename=filename)\nimport_ocp_solution(JSON3Tag(), ocp, filename=filename)\n\nExamples\n\njulia> using JSON3\njulia> sol = import_ocp_solution(ocp; filename=\"solution\", format=:JSON)\njulia> using JLD2\njulia> sol = import_ocp_solution(ocp; filename=\"solution\", format=:JLD)  # JLD is the default\n\n\n\n\n\nimport_ocp_solution(\n    ::CTModels.JSON3Tag,\n    ocp::Model;\n    filename\n)\n\n\nImport an optimal control solution from a .json file exported with export_ocp_solution.\n\nThis function reads the JSON contents and reconstructs a CTModels.Solution object, including the discretized primal and dual trajectories.\n\nArguments\n\n::CTModels.JSON3Tag: A tag used to dispatch the import method for JSON3.\nocp::CTModels.Model: The model associated with the optimal control problem. Used to rebuild the full solution.\n\nKeyword Arguments\n\nfilename::String = \"solution\": Base filename. The .json extension is automatically appended.\n\nReturns\n\nCTModels.Solution: A reconstructed solution instance.\n\nNotes\n\nHandles both vector and matrix encodings of signals. If dual fields are missing or null, the corresponding attributes are set to nothing.\n\nExample\n\njulia> using JSON3\njulia> sol = import_ocp_solution(JSON3Tag(), model; filename=\"mysolution\")\n\n\n\n\n\nimport_ocp_solution(\n    ::CTModels.JLD2Tag,\n    ocp::Model;\n    filename\n)\n\n\nImport an optimal control solution from a .jld2 file.\n\nThis function loads a previously saved CTModels.Solution from disk.\n\nArguments\n\n::CTModels.JLD2Tag: A tag used to dispatch the import method for JLD2.\nocp::CTModels.Model: The associated model (used for dispatch consistency; not used internally).\n\nKeyword Arguments\n\nfilename::String = \"solution\": Base name of the file. The .jld2 extension is automatically appended.\n\nReturns\n\nCTModels.Solution: The loaded solution object.\n\nExample\n\njulia> using JLD2\njulia> sol = import_ocp_solution(JLD2Tag(), model; filename=\"mysolution\")\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.infos","page":"OptimalControl.jl - User","title":"CTModels.infos","text":"infos(sol::Solution) -> Dict{Symbol, Any}\n\n\nReturn a dictionary of additional infos depending on the solver or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.initial_time","page":"OptimalControl.jl - User","title":"CTModels.initial_time","text":"initial_time(\n    model::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the initial time from the times model, from a fixed initial time model.\n\n\n\n\n\ninitial_time(\n    model::CTModels.TimesModel{CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the initial time from the times model, from a free initial time model.\n\n\n\n\n\ninitial_time(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nReturn the initial time, for a fixed initial time.\n\n\n\n\n\ninitial_time(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nReturn the initial time, for a free initial time.\n\n\n\n\n\ninitial_time(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel{CTModels.FreeTimeModel}},\n    variable::Real\n) -> Real\n\n\nReturn the initial time, for a free initial time.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.initial_time_name","page":"OptimalControl.jl - User","title":"CTModels.initial_time_name","text":"initial_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the initial time from the times model.\n\n\n\n\n\ninitial_time_name(ocp::Model) -> String\n\n\nReturn the name of the initial time.\n\n\n\n\n\ninitial_time_name(sol::Solution) -> String\n\n\nReturn the name of the initial time.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.is_autonomous-Tuple{Model{CTModels.Autonomous, <:CTModels.TimesModel}}","page":"OptimalControl.jl - User","title":"CTModels.is_autonomous","text":"is_autonomous(\n    _::Model{CTModels.Autonomous, <:CTModels.TimesModel}\n) -> Bool\n\n\nReturn true.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-user.html#CTModels.iterations","page":"OptimalControl.jl - User","title":"CTModels.iterations","text":"iterations(sol::Solution) -> Int64\n\n\nReturn the number of iterations (if solved by an iterative method).\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.lagrange","page":"OptimalControl.jl - User","title":"CTModels.lagrange","text":"lagrange(\n    model::CTModels.LagrangeObjectiveModel{L<:Function}\n) -> Function\n\n\nReturn the Lagrange function.\n\n\n\n\n\nlagrange(\n    model::CTModels.BolzaObjectiveModel{<:Function, L<:Function}\n) -> Function\n\n\nReturn the Lagrange function.\n\n\n\n\n\nlagrange(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, CTModels.LagrangeObjectiveModel{L<:Function}}\n) -> Function\n\n\nReturn the Lagrange cost.\n\n\n\n\n\nlagrange(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{<:Function, L<:Function}}\n) -> Any\n\n\nReturn the Lagrange cost.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.mayer","page":"OptimalControl.jl - User","title":"CTModels.mayer","text":"mayer(\n    model::CTModels.MayerObjectiveModel{M<:Function}\n) -> Function\n\n\nReturn the Mayer function.\n\n\n\n\n\nmayer(\n    model::CTModels.BolzaObjectiveModel{M<:Function}\n) -> Function\n\n\nReturn the Mayer function.\n\n\n\n\n\nmayer(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.MayerObjectiveModel{M<:Function}}\n) -> Any\n\n\nReturn the Mayer cost.\n\n\n\n\n\nmayer(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{M<:Function}}\n) -> Any\n\n\nReturn the Mayer cost.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.message","page":"OptimalControl.jl - User","title":"CTModels.message","text":"message(sol::Solution) -> String\n\n\nReturn the message associated to the status criterion.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.objective","page":"OptimalControl.jl - User","title":"CTModels.objective","text":"objective(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O<:CTModels.AbstractObjectiveModel}\n) -> CTModels.AbstractObjectiveModel\n\n\nReturn the objective struct.\n\n\n\n\n\nobjective(\n    sol::Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O<:Real}\n) -> Real\n\n\nReturn the objective value.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#RecipesBase.plot-Tuple{Solution, Vararg{Symbol}}","page":"OptimalControl.jl - User","title":"RecipesBase.plot","text":"plot(\n    sol::Solution,\n    description::Symbol...;\n    layout,\n    control,\n    time,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    time_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    size,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot the components of an optimal control solution.\n\nThis is the main user-facing function to visualise the solution of an optimal control problem solved with the control-toolbox ecosystem.\n\nIt generates a set of subplots showing the evolution of the state, control, costate, path constraints, and dual variables over time, depending on the problem and the user’s choices.\n\nArguments\n\nsol::CTModels.Solution: The optimal control solution to visualise.\ndescription::Symbol...: A variable number of symbols indicating which components to include in the plot. Common values include:\n:state – plot the state.\n:costate – plot the costate (adjoint).\n:control – plot the control.\n:path – plot the path constraints.\n:dual – plot the dual variables (or Lagrange multipliers) associated with path constraints.\n\nIf no symbols are provided, a default set is used based on the problem and styles.\n\nKeyword Arguments (Optional)\n\nlayout::Symbol = :group: Specifies how to arrange plots.\n:group: Fewer plots, grouping similar variables together (e.g., all states in one subplot).\n:split: One plot per variable component, stacked in a layout.\ncontrol::Symbol = :components: Defines how to represent control inputs.\n:components: One curve per control component.\n:norm: Single curve showing the Euclidean norm ‖u(t)‖.\n:all: Plot both components and norm.\ntime::Symbol = :default: Time normalisation for plots.\n:default: Real time scale.\n:normalize or :normalise: Normalised to the interval [0, 1].\n\nStyle Options (Optional)\n\nAll style-related keyword arguments can be either a NamedTuple of plotting attributes or the Symbol :none referring to not plot the associated element. These allow you to customise color, line style, markers, etc.\n\ntime_style: Style for vertical lines at initial and final times.\nstate_style: Style for state components.\ncostate_style: Style for costate components.\ncontrol_style: Style for control components.\npath_style: Style for path constraint values.\ndual_style: Style for dual variables.\n\nBounds Decorations (Optional)\n\nUse these options to customise bounds on the plots if applicable and defined in the model. Set to :none to hide.\n\nstate_bounds_style: Style for state bounds.\ncontrol_bounds_style: Style for control bounds.\npath_bounds_style: Style for path constraint bounds.\n\nReturns\n\nA Plots.Plot object, which can be displayed, saved, or further customised.\n\nExample\n\n# basic plot\njulia> plot(sol)\n\n# plot only the state and control\njulia> plot(sol, :state, :control)\n\n# customise layout and styles, no costate\njulia> plot(sol;\n       layout = :group,\n       control = :all,\n       state_style = (color=:blue, linestyle=:solid),\n       control_style = (color=:red, linestyle=:dash),\n       costate_style = :none)       \n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-user.html#RecipesBase.plot!-Tuple{Plots.Plot, Solution, Vararg{Symbol}}","page":"OptimalControl.jl - User","title":"RecipesBase.plot!","text":"plot!(\n    p::Plots.Plot,\n    sol::Solution,\n    description::Symbol...;\n    layout,\n    control,\n    time,\n    state_style,\n    state_bounds_style,\n    control_style,\n    control_bounds_style,\n    costate_style,\n    time_style,\n    path_style,\n    path_bounds_style,\n    dual_style,\n    kwargs...\n) -> Plots.Plot\n\n\nModify Plot p with the optimal control solution sol.\n\nSee plot for full behavior and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-user.html#CTDirect.set_initial_guess","page":"OptimalControl.jl - User","title":"CTDirect.set_initial_guess","text":"set_initial_guess(docp::CTDirect.DOCP, init) -> Any\n\n\nSet initial guess in the DOCP\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CommonSolve.solve-Tuple{Model, Vararg{Symbol}}","page":"OptimalControl.jl - User","title":"CommonSolve.solve","text":"solve(\n    ocp::Model,\n    description::Symbol...;\n    display,\n    kwargs...\n) -> Solution{TimeGridModelType, TimesModelType, StateModelType, ControlModelType, VariableModelType, CostateModelType, Float64, DualModelType, CTModels.SolverInfos{Dict{Symbol, Any}}, ModelType} where {TimeGridModelType<:CTModels.TimeGridModel, TimesModelType<:CTModels.TimesModel, StateModelType<:Union{CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#114#136\", CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#115#137\"}, ControlModelType<:Union{CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#116#138\", CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#117#139\"}, VariableModelType<:Union{CTModels.VariableModelSolution{Vector{Float64}}, CTModels.VariableModelSolution{Float64}}, CostateModelType<:Union{CTModels.var\"#118#140\", CTModels.var\"#119#141\"}, DualModelType<:(CTModels.DualModel{PC_Dual, Vector{Float64}, SC_LB_Dual, SC_UB_Dual, CC_LB_Dual, CC_UB_Dual, Vector{Float64}, Vector{Float64}} where {PC_Dual<:Union{CTModels.var\"#121#143\"{CTModels.var\"#120#142\"}, CTModels.var\"#122#144\"{CTModels.var\"#120#142\"}}, SC_LB_Dual<:Union{CTModels.var\"#124#146\"{CTModels.var\"#123#145\"}, CTModels.var\"#125#147\"{CTModels.var\"#123#145\"}}, SC_UB_Dual<:Union{CTModels.var\"#127#149\"{CTModels.var\"#126#148\"}, CTModels.var\"#128#150\"{CTModels.var\"#126#148\"}}, CC_LB_Dual<:Union{CTModels.var\"#130#152\"{CTModels.var\"#129#151\"}, CTModels.var\"#131#153\"{CTModels.var\"#129#151\"}}, CC_UB_Dual<:Union{CTModels.var\"#133#155\"{CTModels.var\"#132#154\"}, CTModels.var\"#134#156\"{CTModels.var\"#132#154\"}}}), ModelType<:Model}\n\n\nSolve the optimal control problem ocp by the method given by the (optional) description. The get the list of available methods:\n\njulia> available_methods()\n\nThe higher in the list, the higher is the priority. The keyword arguments are specific to the chosen method and represent the options of the solver.\n\nArguments\n\nocp::OptimalControlModel: the optimal control problem to solve.\ndescription::Symbol...: the description of the method used to solve the problem.\nkwargs...: the options of the method.\n\nExamples\n\nThe simplest way to solve the optimal control problem is to call the function without any argument.\n\njulia> sol = solve(ocp)\n\nThe method description is a list of Symbols. The default is\n\njulia> sol = solve(ocp, :direct, :adnlp, :ipopt)\n\nYou can provide a partial description, the function will find the best match.\n\njulia> sol = solve(ocp, :direct)\n\nnote: Note\nSee the resolution methods section for more details about the available methods.\n\nThe keyword arguments are specific to the chosen method and correspond to the options of the different solvers. For example, the keyword max_iter is an Ipopt option that may be used to set the maximum number of iterations.\n\njulia> sol = solve(ocp, :direct, :ipopt, max_iter=100)\n\nnote: Note\nSee the direct method section for more details about associated options. These options also detailed in the CTDirect.solve documentation. This main solve method redirects to CTDirect.solve when the :direct Symbol is given in the description. See also the NLP solvers section for more details about Ipopt or MadNLP options.\n\nTo help the solve converge, an initial guess can be provided within the keyword init. You can provide the initial guess for the state, control, and variable.\n\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5))\n\nnote: Note\nSee how to set an initial guess for more details.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-user.html#CTModels.state","page":"OptimalControl.jl - User","title":"CTModels.state","text":"state(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, T<:CTModels.AbstractStateModel}\n) -> CTModels.AbstractStateModel\n\n\nReturn the state struct.\n\n\n\n\n\nstate(\n    sol::Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.StateModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the state as a function of time.\n\njulia> x  = state(sol)\njulia> t0 = time_grid(sol)[1]\njulia> x0 = x(t0) # state at the initial time\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.state_components","page":"OptimalControl.jl - User","title":"CTModels.state_components","text":"state_components(ocp::Model) -> Vector{String}\n\n\nReturn the names of the components of the state.\n\n\n\n\n\nstate_components(sol::Solution) -> Vector{String}\n\n\nReturn the names of the components of the state.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.state_dimension","page":"OptimalControl.jl - User","title":"CTModels.state_dimension","text":"state_dimension(ocp::CTModels.PreModel) -> Int64\n\n\n\n\n\n\nstate_dimension(ocp::Model) -> Int64\n\n\nReturn the state dimension.\n\n\n\n\n\nstate_dimension(sol::Solution) -> Int64\n\n\nReturn the dimension of the state.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.state_name","page":"OptimalControl.jl - User","title":"CTModels.state_name","text":"state_name(ocp::Model) -> String\n\n\nReturn the name of the state.\n\n\n\n\n\nstate_name(sol::Solution) -> String\n\n\nReturn the name of the state.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.status","page":"OptimalControl.jl - User","title":"CTModels.status","text":"status(sol::Solution) -> Symbol\n\n\nReturn the status criterion (a Symbol).\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.successful","page":"OptimalControl.jl - User","title":"CTModels.successful","text":"successful(sol::Solution) -> Bool\n\n\nReturn the successful status.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.time_grid","page":"OptimalControl.jl - User","title":"CTModels.time_grid","text":"time_grid(\n    sol::Solution{<:CTModels.TimeGridModel{T<:Union{StepRangeLen, AbstractVector{<:Real}}}}\n) -> Union{StepRangeLen, AbstractVector{<:Real}}\n\n\nReturn the time grid.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.time_name","page":"OptimalControl.jl - User","title":"CTModels.time_name","text":"time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the time variable from the times model.\n\n\n\n\n\ntime_name(ocp::Model) -> String\n\n\nReturn the name of the time.\n\n\n\n\n\ntime_name(sol::Solution) -> String\n\n\nReturn the name of the time component.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.times","page":"OptimalControl.jl - User","title":"CTModels.times","text":"times(\n    ocp::Model{<:CTModels.TimeDependence, T<:CTModels.TimesModel}\n) -> CTModels.TimesModel\n\n\nReturn the times struct.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.variable","page":"OptimalControl.jl - User","title":"CTModels.variable","text":"variable(\n    ocp::Model{<:CTModels.TimeDependence, <:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, T<:CTModels.AbstractVariableModel}\n) -> CTModels.AbstractVariableModel\n\n\nReturn the variable struct.\n\n\n\n\n\nvariable(\n    sol::Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}}}\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the variable or nothing.\n\njulia> v  = variable(sol)\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.variable_components","page":"OptimalControl.jl - User","title":"CTModels.variable_components","text":"variable_components(ocp::Model) -> Vector{String}\n\n\nReturn the names of the components of the variable.\n\n\n\n\n\nvariable_components(sol::Solution) -> Vector{String}\n\n\nReturn the names of the components of the variable.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.variable_dimension","page":"OptimalControl.jl - User","title":"CTModels.variable_dimension","text":"variable_dimension(ocp::Model) -> Int64\n\n\nReturn the variable dimension.\n\n\n\n\n\nvariable_dimension(sol::Solution) -> Int64\n\n\nReturn the dimension of the variable.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTModels.variable_name","page":"OptimalControl.jl - User","title":"CTModels.variable_name","text":"variable_name(ocp::Model) -> String\n\n\nReturn the name of the variable.\n\n\n\n\n\nvariable_name(sol::Solution) -> String\n\n\nReturn the name of the variable.\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html#CTFlows.:⋅","page":"OptimalControl.jl - User","title":"CTFlows.:⋅","text":"Lie derivative of a scalar function along a vector field in the autonomous case.\n\nExample:\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0\n\n\n\n\n\nLie derivative of a scalar function along a vector field in the nonautonomous case.\n\nExample:\n\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\nLie derivative of a scalar function along a function (considered autonomous and non-variable).\n\nExample:\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError\n\n\n\n\n\n","category":"function"},{"location":"api-optimalcontrol-user.html","page":"OptimalControl.jl - User","title":"OptimalControl.jl - User","text":"","category":"page"},{"location":"api-ctflows.html#CTFlows.jl","page":"CTFlows.jl","title":"CTFlows.jl","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"The CTFlows.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"flowchart TD\nB(<a href='api-ctbase.html'>CTBase</a>)\nM(<a href='api-ctmodels.html'>CTModels</a>)\nP(<a href='api-ctparser.html'>CTParser</a>)\nO(<a href='api-optimalcontrol-dev.html'>OptimalControl</a>)\nD(<a href='api-ctdirect.html'>CTDirect</a>)\nF(<a href='api-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle F fill:#FBF275","category":"page"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"OptimalControl heavily relies on CTFlows. We refer to CTFlows API for more details.","category":"page"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"","category":"page"},{"location":"api-ctparser.html#CTParser.jl","page":"CTParser.jl","title":"CTParser.jl","text":"","category":"section"},{"location":"api-ctparser.html","page":"CTParser.jl","title":"CTParser.jl","text":"The CTParser.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-ctparser.html","page":"CTParser.jl","title":"CTParser.jl","text":"flowchart TD\nB(<a href='api-ctbase.html'>CTBase</a>)\nM(<a href='api-ctmodels.html'>CTModels</a>)\nP(<a href='api-ctparser.html'>CTParser</a>)\nO(<a href='api-optimalcontrol-dev.html'>OptimalControl</a>)\nD(<a href='api-ctdirect.html'>CTDirect</a>)\nF(<a href='api-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle P fill:#FBF275","category":"page"},{"location":"api-ctparser.html","page":"CTParser.jl","title":"CTParser.jl","text":"OptimalControl heavily relies on CTParser. We refer to CTParser API for more details.","category":"page"},{"location":"api-ctparser.html","page":"CTParser.jl","title":"CTParser.jl","text":"","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<img width=\"800\" alt=\"juliaopt2024\" src=\"./assets/zhejiang-2025.jpg\">","category":"page"},{"location":"zhejiang-2025.html#Solving-optimal-control-problems-in-Julia:-the-OptimalControl.jl-package","page":"Zhejiang 2025","title":"Solving optimal control problems in Julia: the OptimalControl.jl package","text":"","category":"section"},{"location":"zhejiang-2025.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://github.com/joseph-gergaud),-[Pierre-Martinon](https://github.com/PierreMartinon),-[Sophia-Sed](https://sed-sam-blog.gitlabpages.inria.fr)","page":"Zhejiang 2025","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"page"},{"location":"zhejiang-2025.html#What-it's-about","page":"Zhejiang 2025","title":"What it's about","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"subject to","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"plus boundary, control and state constraints","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"zhejiang-2025.html#OptimalControl.jl-for-trajectory-optimisation","page":"Zhejiang 2025","title":"OptimalControl.jl for trajectory optimisation","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Basic example\nGoddard problem\nOrbit transfer","category":"page"},{"location":"zhejiang-2025.html#Wrap-up","page":"Zhejiang 2025","title":"Wrap up","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"High level modelling of optimal control problems\nEfficient numerical resolution coupling direct and indirect methods\nCollection of examples","category":"page"},{"location":"zhejiang-2025.html#Future","page":"Zhejiang 2025","title":"Future","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"New applications (pace mechanics, biology, quantum mechanics and more)\nAdditional solvers: optimisation on GPU, direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions! If you like the package, please give us a star ⭐️","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<a href=\"https://github.com/control-toolbox/OptimalControl.jl\"><img width=\"800\" alt=\"OptimalControl.jl\" src=\"./assets/star.jpg\"></a>","category":"page"},{"location":"zhejiang-2025.html#control-toolbox.org","page":"Zhejiang 2025","title":"control-toolbox.org","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"zhejiang-2025.html#Credits-(not-exhaustive!)","page":"Zhejiang 2025","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nIpopt.jl\nMadNLP.jl\nMLStyle.jl","category":"page"},{"location":"zhejiang-2025.html#Stand-up-for-science-2025","page":"Zhejiang 2025","title":"Stand up for science 2025","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<a href=\"https://standupforscience2025.org\"><img width=\"200\" alt=\"stand up for science 2025\" src=\"./assets/standup.jpg\"></a>","category":"page"},{"location":"zhejiang-2025.html#Acknowledgements","page":"Zhejiang 2025","title":"Acknowledgements","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Jean-Baptiste Caillau is partially funded by a France 2030 support managed by the Agence Nationale de la Recherche, under the reference ANR-23-PEIA-0004 (PDE-AI project).","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<img width=\"150\" alt=\"affiliations\" src=\"./assets/france-2030.png\">","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"","category":"page"},{"location":"api-optimalcontrol-dev.html#OptimalControl.jl-(Private)","page":"OptimalControl.jl","title":"OptimalControl.jl (Private)","text":"","category":"section"},{"location":"api-optimalcontrol-dev.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"OptimalControl.jl is the root package of the control-toolbox ecosystem.","category":"page"},{"location":"api-optimalcontrol-dev.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"flowchart TD\nB(<a href='api-ctbase.html'>CTBase</a>)\nM(<a href='api-ctmodels.html'>CTModels</a>)\nP(<a href='api-ctparser.html'>CTParser</a>)\nO(<a href='api-optimalcontrol-dev.html'>OptimalControl</a>)\nD(<a href='api-ctdirect.html'>CTDirect</a>)\nF(<a href='api-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle O fill:#FBF275","category":"page"},{"location":"api-optimalcontrol-dev.html#Index","page":"OptimalControl.jl","title":"Index","text":"","category":"section"},{"location":"api-optimalcontrol-dev.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Pages   = [\"api-optimalcontrol-dev.md\"]\nModules = [OptimalControl]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-optimalcontrol-dev.html#Documentation","page":"OptimalControl.jl","title":"Documentation","text":"","category":"section"},{"location":"api-optimalcontrol-dev.html#OptimalControl.__display-Tuple{}","page":"OptimalControl.jl","title":"OptimalControl.__display","text":"__display() -> Bool\n\n\nUsed to set the default display toggle. The default value is true.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-dev.html#OptimalControl.clean-Tuple{Tuple{Vararg{Symbol}}}","page":"OptimalControl.jl","title":"OptimalControl.clean","text":"clean(d::Tuple{Vararg{Symbol}}) -> Tuple{Vararg{Symbol}}\n\n\nWhen calling the function solve, the user can provide a description of the method to use to solve the optimal control problem. The description can be a partial description or a full description. The function solve will find the best match from the available methods, thanks to the function getFullDescription. Then, the description is cleaned by the function clean to remove the Symbols that are specific to  OptimalControl.jl and so must not be passed to the solver. For instance, the Symbol :direct is specific to OptimalControl.jl and must be removed. It must not be passed to the CTDirect.jl solver.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-dev.html#OptimalControl.version-Tuple{}","page":"OptimalControl.jl","title":"OptimalControl.version","text":"Return the version of the current module as a string.\n\nThis function returns the version number defined in the Project.toml of the package to which the current module belongs. It uses @__MODULE__ to infer the calling context.\n\nExample\n\njulia> version()   # e.g., \"1.2.3\"\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol-dev.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"","category":"page"},{"location":"api-ctmodels.html#CTModels.jl","page":"CTModels.jl","title":"CTModels.jl","text":"","category":"section"},{"location":"api-ctmodels.html","page":"CTModels.jl","title":"CTModels.jl","text":"The CTModels.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-ctmodels.html","page":"CTModels.jl","title":"CTModels.jl","text":"flowchart TD\nB(<a href='api-ctbase.html'>CTBase</a>)\nM(<a href='api-ctmodels.html'>CTModels</a>)\nP(<a href='api-ctparser.html'>CTParser</a>)\nO(<a href='api-optimalcontrol-dev.html'>OptimalControl</a>)\nD(<a href='api-ctdirect.html'>CTDirect</a>)\nF(<a href='api-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle M fill:#FBF275","category":"page"},{"location":"api-ctmodels.html","page":"CTModels.jl","title":"CTModels.jl","text":"OptimalControl heavily relies on CTModels. We refer to CTModels API for more details.","category":"page"},{"location":"api-ctmodels.html","page":"CTModels.jl","title":"CTModels.jl","text":"","category":"page"},{"location":"manual-flow-others.html#manual-flow-others","page":"From Hamiltonians and others","title":"How to compute Hamiltonian flows and trajectories","text":"","category":"section"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"In this tutorial, we explain the Flow function, in particular to compute flows from a Hamiltonian vector fields, but also from general vector fields.","category":"page"},{"location":"manual-flow-others.html#Introduction","page":"From Hamiltonians and others","title":"Introduction","text":"","category":"section"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"Consider the simple optimal control problem from the basic example page. The pseudo-Hamiltonian is","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"    H(x p u) = p_q q + p_v v + p^0 u^2 2","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"where p^0 = -1 since we are in the normal case. From the Pontryagin maximum principle, the maximising control is given in feedback form by","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"u(x p) = p_v","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"since partial^2_uu H = p^0 = - 1  0. ","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"u(x, p) = p[2]\nnothing # hide","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"Actually, if (x u) is a solution of the optimal control problem,  then, the Pontryagin maximum principle tells us that there exists a costate p such that u(t) = u(x(t) p(t)) and such that the pair (x p) satisfies:","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"beginarrayl\n    dotx(t) = displaystylephantom-nabla_p H(x(t) p(t) u(x(t) p(t))) 05em\n    dotp(t) = displaystyle         - nabla_x H(x(t) p(t) u(x(t) p(t)))\nendarray","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"note: Nota bene\nActually, writing z = (x p), then the pair (x p) is also solution of    dotz(t) = vecmathbfH(z(t))where mathbfH(z) = H(z u(z)) and vecmathbfH = (nabla_p mathbfH -nabla_x mathbfH).","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"Let us import the necessary packages.","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"using OptimalControl\nusing OrdinaryDiffEq","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"The package OrdinaryDiffEq.jl provides numerical integrators to compute solutions of ordinary differential equations.","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"note: OrdinaryDiffEq.jl\nThe package OrdinaryDiffEq.jl is part of DifferentialEquations.jl. You can either use one or the other.","category":"page"},{"location":"manual-flow-others.html#Extremals-from-the-Hamiltonian","page":"From Hamiltonians and others","title":"Extremals from the Hamiltonian","text":"","category":"section"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"The pairs (x p) solution of the Hamitonian vector field are called extremals. We can compute some constructing the flow from the optimal control problem and the control in feedback form. Another way to compute extremals is to define explicitely the Hamiltonian.","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"H(x, p, u) = p[1] * x[2] + p[2] * u - 0.5 * u^2     # pseudo-Hamiltonian\nH(x, p) = H(x, p, u(x, p))                          # Hamiltonian\n\nz = Flow(Hamiltonian(H))\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\np0 = [12, 6]\nxf, pf = z(t0, x0, p0, tf)","category":"page"},{"location":"manual-flow-others.html#Extremals-from-the-Hamiltonian-vector-field","page":"From Hamiltonians and others","title":"Extremals from the Hamiltonian vector field","text":"","category":"section"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"You can also provide the Hamiltonian vector field.","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"Hv(x, p) = [x[2], p[2]], [0.0, -p[1]]     # Hamiltonian vector field\n\nz = Flow(HamiltonianVectorField(Hv))\nxf, pf = z(t0, x0, p0, tf)","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"Note that if you call the flow on tspan=(t0, tf), then you obtain the output solution  from OrdinaryDiffEq.jl.","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"sol = z((t0, tf), x0, p0)\nxf, pf = sol(tf)[1:2], sol(tf)[3:4]","category":"page"},{"location":"manual-flow-others.html#Trajectories","page":"From Hamiltonians and others","title":"Trajectories","text":"","category":"section"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"You can also compute trajectories from the control dynamics (x u) mapsto (v u) and a control law  t mapsto u(t).","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"u(t) = 6-12t\nx = Flow((t, x) -> [x[2], u(t)]; autonomous=false) # the vector field depends on t\nx(t0, x0, tf)","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"Again, giving a tspan you get an output solution from OrdinaryDiffEq.jl.","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"using Plots\nsol = x((t0, tf), x0)\nplot(sol)","category":"page"},{"location":"manual-flow-others.html","page":"From Hamiltonians and others","title":"From Hamiltonians and others","text":"","category":"page"},{"location":"manual-solution.html#manual-solution","page":"Solution characteristics","title":"The optimal control solution object: structure and usage","text":"","category":"section"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"In this manual, we'll first recall the main functionalities you can use when working with a solution of an optimal control problem (SOL). This includes essential operations like:","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"Plotting a SOL: How to plot the optimal solution for your defined problem.\nPrinting a SOL: How to display a summary of your solution.","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"After covering these core functionalities, we'll delve into the structure of a SOL. Since a SOL is structured as a Solution struct, we'll first explain how to access its underlying attributes. Following this, we'll shift our focus to the simple properties inherent to a SOL.","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"Content","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"Main functionalities\nSolution struct\nAttributes and properties","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"","category":"page"},{"location":"manual-solution.html#manual-solution-main-functionalities","page":"Solution characteristics","title":"Main functionalities","text":"","category":"section"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"Let's define a basic optimal control problem.","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"using OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    x(t0) == x0\n    x(tf) == [0, 0]\n    ẋ(t)  == [v(t), u(t)]\n    0.5∫( u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"We can now solve the problem (for more details, visit the solve manual):","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"using NLPModelsIpopt\nsol = solve(ocp)\nnothing # hide","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"note: Note\nYou can export (or save) the solution in a Julia .jld2 data file and reload it later, and also export a discretised version of the solution in a more portable JSON format. Note that the optimal control problem is needed when loading a solution.See the two functions:import_ocp_solution,\nexport_ocp_solution.","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"To print sol, simply:","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"sol","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"For complementary information, you can plot the solution:","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"using Plots\nplot(sol)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"note: Note\nFor more details about plotting a solution, visit the plot manual.","category":"page"},{"location":"manual-solution.html#manual-solution-struct","page":"Solution characteristics","title":"Solution struct","text":"","category":"section"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"The solution sol is a Solution struct.","category":"page"},{"location":"manual-solution.html#CTModels.Solution-manual-solution","page":"Solution characteristics","title":"CTModels.Solution","text":"struct Solution{TimeGridModelType<:CTModels.AbstractTimeGridModel, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, CostateModelType<:Function, ObjectiveValueType<:Real, DualModelType<:CTModels.AbstractDualModel, SolverInfosType<:CTModels.AbstractSolverInfos, ModelType<:CTModels.AbstractModel} <: CTModels.AbstractSolution\n\nFields\n\ntime_grid::CTModels.AbstractTimeGridModel\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ncostate::Function\nobjective::Real\ndual::CTModels.AbstractDualModel\nsolver_infos::CTModels.AbstractSolverInfos\nmodel::CTModels.AbstractModel\n\n\n\n\n\n","category":"type"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"Each field can be accessed directly (ocp.times, etc) but we recommend to use the sophisticated getters we proveide: the state(sol::Solution) method does not return sol.state but a function of time that can be called at any time, not only on the grid time_grid.","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"0.25 ∈ time_grid(sol)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"x = state(sol)\nx(0.25)","category":"page"},{"location":"manual-solution.html#manual-solution-attributes","page":"Solution characteristics","title":"Attributes and properties","text":"","category":"section"},{"location":"manual-solution.html#State,-costate,-control,-variable-and-objective-value","page":"Solution characteristics","title":"State, costate, control, variable and objective value","text":"","category":"section"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"You can access the values of the state, costate, control and variable by eponymous functions. The returned values are functions of time for the state, costate and control and a scalar or a vector for the variable.","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"t = 0.25\nx = state(sol)\np = costate(sol)\nu = control(sol)\nnothing # hide","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"Since the state is of dimension 2, evaluating x(t) returns a vector:","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"x(t)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"It is the same for the costate:","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"p(t)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"But the control is one-dimensional:","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"u(t)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"There is no variable, hence, an empty vector is returned:","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"v = variable(sol)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"The objective value is accessed by:","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"objective(sol)","category":"page"},{"location":"manual-solution.html#Infos-from-the-solver","page":"Solution characteristics","title":"Infos from the solver","text":"","category":"section"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"The problem ocp is solved via a direct method (see solve manual for details). The solver stores data in sol, including the success of the optimization, the iteration count, the time grid used for discretisation, and other specific details within the solver_infos field.","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"time_grid(sol)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"constraints_violation(sol)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"infos(sol)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"iterations(sol)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"message(sol)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"status(sol)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"successful(sol)","category":"page"},{"location":"manual-solution.html#Dual-variables","page":"Solution characteristics","title":"Dual variables","text":"","category":"section"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"You can retrieved dual variables (or Lagrange multipliers) associated to labelled constraint. To illustrate this, we define a problem with constraints:","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"ocp = @def begin\n\n    tf ∈ R,             variable\n    t ∈ [0, tf],        time\n    x = (q, v) ∈ R²,    state\n    u ∈ R,              control\n\n    tf ≥ 0,             (eq_tf)\n    -1 ≤ u(t) ≤ 1,      (eq_u)\n    v(t) ≤ 0.75,        (eq_v)\n\n    x(0)  == [-1, 0],   (eq_x0)\n    q(tf) == 0\n    v(tf) == 0\n\n    ẋ(t) == [v(t), u(t)]\n\n    tf → min\n\nend\nsol = solve(ocp; display=false)\nnothing # hide","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"Dual variables corresponding to variable and boundary constraints are given as scalar or vectors.","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"dual(sol, ocp, :eq_tf)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"dual(sol, ocp, :eq_x0)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"The other type of constraints are associated to dual variables given as functions of time.","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"μ_u = dual(sol, ocp, :eq_u)\nplot(time_grid(sol), μ_u)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"μ_v = dual(sol, ocp, :eq_v)\nplot(time_grid(sol), μ_v)","category":"page"},{"location":"manual-solution.html","page":"Solution characteristics","title":"Solution characteristics","text":"","category":"page"},{"location":"index.html#OptimalControl.jl","page":"Getting Started","title":"OptimalControl.jl","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"The OptimalControl.jl package is the root package of the control-toolbox ecosystem. The control-toolbox ecosystem gathers Julia packages for mathematical control and applications. It aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods.","category":"page"},{"location":"index.html#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"To install OptimalControl.jl, please open Julia's interactive session (known as REPL) and use the Julia package manager:","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"OptimalControl\")","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"tip: Tip\nIf you are new to Julia, please follow this guidelines.","category":"page"},{"location":"index.html#Basic-usage","page":"Getting Started","title":"Basic usage","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"Let us model, solve and plot a simple optimal control problem.","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots\n\nocp = @def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(1) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    ∫( 0.5u(t)^2 ) → min\nend\n\nsol = solve(ocp)\nplot(sol)","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"For more details, see the basic example tutorial.  \nThe @def macro defines the problem. See the abstract syntax tutorial.  \nThe solve function has many options. See the solve tutorial.  \nThe plot function is flexible. See the plot tutorial.","category":"page"},{"location":"index.html#Citing-us","page":"Getting Started","title":"Citing us","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"If you use OptimalControl.jl in your work, please cite us:","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"Caillau, J.-B., Cots, O., Gergaud, J., Martinon, P., & Sed, S. OptimalControl.jl: a Julia package to model and solve optimal control problems with ODE's. doi.org/10.5281/zenodo.13336563","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"or in bibtex format:","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"@software{Caillau_OptimalControl_jl_a_Julia,\nauthor = {Caillau, Jean-Baptiste and Cots, Olivier and Gergaud, Joseph and Martinon, Pierre and Sed, Sophia},\ndoi = {10.5281/zenodo.13336563},\nlicense = {[\"MIT\"]},\ntitle = {{OptimalControl.jl: a Julia package to model and solve optimal control problems with ODE's}},\nurl = {https://control-toolbox.org/OptimalControl.jl}\n}","category":"page"},{"location":"index.html#Contributing","page":"Getting Started","title":"Contributing","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"If you think you found a bug or if you have a feature request / suggestion, feel free to open an issue. Before opening a pull request, please start an issue or a discussion on the topic. ","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"Contributions are welcomed, check out how to contribute to a Github project. If it is your first contribution, you can also check this first contribution tutorial. You can find first good issues (if any 🙂) here. You may find other packages to contribute to at the control-toolbox organization.","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"If you want to ask a question, feel free to start a discussion here. This forum is for general discussion about this repository and the control-toolbox organization.","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"note: Note\nIf you want to add an application or a package to the control-toolbox ecosystem, please follow this set up tutorial.","category":"page"},{"location":"index.html#Reproducibility","page":"Getting Started","title":"Reproducibility","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"<details><summary>The documentation of this package was built using these direct dependencies,</summary>","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"</details>","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"</details>","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"</details>","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/control-toolbox/\" *\n                name *\n                \".jl/tree/gh-pages/v\" *\n                version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/control-toolbox/\" *\n               name *\n               \".jl/tree/gh-pages/v\" *\n               version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"","category":"page"}]
}
