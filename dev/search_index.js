var documenterSearchIndex = {"docs":
[{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<img width=\"800\" alt=\"juliaopt2024\" src=\"./assets/juliacon2024.jpg\">","category":"page"},{"location":"juliacon2024.html#Trajectory-optimisation-in-space-mechanics-with-Julia","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"","category":"section"},{"location":"juliacon2024.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Alesia-Herasimenka](https://www.uni.lu/snt-en/people/alesia-herasimenka)","page":"Trajectory optimisation in space mechanics with Julia","title":"Jean-Baptiste Caillau, Olivier Cots, Alesia Herasimenka","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil-lux.jpg\">","category":"page"},{"location":"juliacon2024.html#What-it's-about","page":"Trajectory optimisation in space mechanics with Julia","title":"What it's about","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"subject to","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"plus boundary conditions, control and state constraints","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"juliacon2024.html#OptimalControl.jl-for-trajectory-optimisation","page":"Trajectory optimisation in space mechanics with Julia","title":"OptimalControl.jl for trajectory optimisation","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Basic example\nGoddard problem\nOrbit transfer","category":"page"},{"location":"juliacon2024.html#Wrap-up","page":"Trajectory optimisation in space mechanics with Julia","title":"Wrap up","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"High level modelling of optimal control problems\nEfficient numerical resolution coupling direct and indirect methods\nCollection of examples","category":"page"},{"location":"juliacon2024.html#Future","page":"Trajectory optimisation in space mechanics with Julia","title":"Future","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"New applications (biology, space mechanics, quantum mechanics and more)\nAdditional solvers: direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions!","category":"page"},{"location":"juliacon2024.html#control-toolbox.org","page":"Trajectory optimisation in space mechanics with Julia","title":"control-toolbox.org","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"juliacon2024.html#Credits-(not-exhaustive!)","page":"Trajectory optimisation in space mechanics with Julia","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nMLStyle.jl","category":"page"},{"location":"juliacon2024.html#Acknowledgements","page":"Trajectory optimisation in space mechanics with Julia","title":"Acknowledgements","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Jean-Baptiste Caillau is partially funded by a France 2030 support managed by the Agence Nationale de la Recherche, under the reference ANR-23-PEIA-0004 (PDE-AI project).","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<img width=\"200\" alt=\"affiliations\" src=\"./assets/france-2030.png\">","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"","category":"page"},{"location":"dev-optimalcontrol.html#OptimalControl.jl","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"The OptimalControl.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"flowchart TD\nB(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctbase.html'>CTBase</a>)\nM(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctmodels.html'>CTModels</a>)\nP(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctparser.html'>CTParser</a>)\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-optimalcontrol.html'>OptimalControl</a>)\nD(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctdirect.html'>CTDirect</a>)\nF(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle O fill:#FBF275","category":"page"},{"location":"dev-optimalcontrol.html#Index","page":"OptimalControl.jl","title":"Index","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Pages   = [\"dev-optimalcontrol.md\"]\nModules = [OptimalControl]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-optimalcontrol.html#Available-methods","page":"OptimalControl.jl","title":"Available methods","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"using OptimalControl\navailable_methods()","category":"page"},{"location":"dev-optimalcontrol.html#Documentation","page":"OptimalControl.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-optimalcontrol.html#Public","page":"OptimalControl.jl","title":"Public","text":"","category":"section"},{"location":"dev-optimalcontrol.html#OptimalControl.OptimalControl","page":"OptimalControl.jl","title":"OptimalControl.OptimalControl","text":"OptimalControl module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\n\nList of all the exported names:\n\n*\nFlow\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\n@Lie\nLie\nLift\nModel\nParsingError\nPoisson\nVectorField\navailable_methods\nbuild_OCP_solution\nconstraint\ncontrol\ncontrol_components\ncontrol_dimension\ncontrol_name\ncostate\ncriterion\n@def\ndirect_transcription\ndynamics\nexport_ocp_solution\nfinal_time\nimport_ocp_solution\ninfos\ninitial_time\niterations\nlagrange\nmayer\nmessage\nobjective\nset_initial_guess\nsolve\nstate\nstate_components\nstate_dimension\nstate_name\nstopping\ntime_grid\ntime_name\nvariable\nvariable_components\nvariable_dimension\nvariable_name\n‚ãÖ\n\n\n\n\n\n","category":"module"},{"location":"dev-optimalcontrol.html#CommonSolve.solve-Tuple{Model, Vararg{Symbol}}","page":"OptimalControl.jl","title":"CommonSolve.solve","text":"solve(ocp::Model, description::Symbol...; kwargs...)\n\n\nSolve the the optimal control problem ocp by the method given by the (optional) description. The available methods are given by available_methods(). The higher in the list, the higher is the priority. The keyword arguments are specific to the chosen method and represent the options of the solver.\n\nnote: Note\nSee the tutorial on solving optimal control problems for more information.\n\nArguments\n\nocp::OptimalControlModel: the optimal control problem to solve.\ndescription::Symbol...: the description of the method to use to solve the problem.\nkwargs...: the options of the solver.\n\nExamples\n\nThe simplest way to solve the optimal control problem is to call the function without any argument.\n\njulia> sol = solve(ocp)\n\nThe method can be specified by passing the description as a Symbol. You can provide a partial description, the function will  find the best match.\n\njulia> sol = solve(ocp, :direct)\n\nThe method can be specified by passing the full description as a list of Symbols.\n\njulia> sol = solve(ocp, :direct, :adnlp, :ipopt)\n\nThe keyword arguments are specific to the chosen method and represent the options of the solver. For example, the keyword display is used to display the information of the solver. The default value is true.\n\njulia> sol = solve(ocp, :direct, :ipopt, display=false)\n\nThe initial guess can be provided by the keyword init. You can provide the initial guess for the state, control, and variable.\n\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5))\n\ntip: Tip\nFor more information on how to provide the initial guess, see the tutorial on the initial guess.\n\n\n\n\n\n","category":"method"},{"location":"dev-optimalcontrol.html#OptimalControl.available_methods-Tuple{}","page":"OptimalControl.jl","title":"OptimalControl.available_methods","text":"available_methods(\n\n) -> Tuple{Vararg{Tuple{Symbol, Symbol, Symbol}}}\n\n\nReturn the list of available methods that can be used to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-optimalcontrol.html#Private","page":"OptimalControl.jl","title":"Private","text":"","category":"section"},{"location":"dev-optimalcontrol.html#OptimalControl.clean-Tuple{Tuple{Vararg{Symbol}}}","page":"OptimalControl.jl","title":"OptimalControl.clean","text":"clean(d::Tuple{Vararg{Symbol}}) -> Tuple{Vararg{Symbol}}\n\n\nWhen calling the function solve, the user can provide a description of the method to use to solve the optimal control problem. The description can be a partial description or a full description. The function solve will find the best match from the available methods, thanks to the function getFullDescription. Then, the description is cleaned by the function clean to remove the Symbols that are specific to  OptimalControl.jl and so must not be passed to the solver. For instance, the Symbol :direct is specific to OptimalControl.jl and must be removed. It must not be passed to the CTDirect.jl solver.\n\n\n\n\n\n","category":"method"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"","category":"page"},{"location":"tutorial-abstract.html#tutorial-abstract-syntax","page":"Define a problem","title":"The syntax to define an optimal control problem","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The full grammar of OptimalControl.jl small Domain Specific Language is given below. The idea is to use a syntax that is","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"pure Julia (and, as such, effortlessly analysed by the standard Julia parser),\nas close as possible to the mathematical description of an optimal control problem. ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"While the syntax will be transparent to those users familiar with Julia expressions (Expr's), we provide examples for every case that should be widely understandable. We rely heavily on MLStyle.jl and its pattern matching abilities üëçüèΩ for the semantic pass. Abstract definitions use the macro @def.","category":"page"},{"location":"tutorial-abstract.html#tutorial-abstract-variable","page":"Define a problem","title":"Variable","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $v ‚àà R^$q, variable ) \n:( $v ‚àà R   , variable ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"A variable (only one is allowed) is a finite dimensional vector or reals that will be optimised along with state and control values. To define an (almost empty!) optimal control problem, named ocp, having a dimension two variable named v, do the following:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    v ‚àà R¬≤, variable\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nNote that the full code of the definition above is not provided (hence the ...) The same is true for most examples below (only those without ... are indeed complete). Also note that problem definitions must at least include definitions for time, state, control, and dynamics.","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Aliases v‚ÇÅ, v‚ÇÇ (and v1, v2) are automatically defined and can be used in subsequent expressions instead of v[1] and v[2]. The user can also define her own aliases for the components (one alias per dimension):","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    v = (a, b) ‚àà R¬≤, variable\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"A one dimensional variable can be declared according to","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    v ‚àà R, variable\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"note: Note\nIt is also possible to use the following syntax@def ocp begin\n    v ‚àà R, variable\n    ...\nendthat is equivalent toocp = @def begin\n    v ‚àà R, variable\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html#Time","page":"Define a problem","title":"Time","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $t ‚àà [$t0, $tf], time ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The independent variable or time is a scalar bound to a given interval. Its name is arbitrary.","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"t0 = 1\ntf = 5\n@def begin\n    t ‚àà [t0, tf], time\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"One (or even the two bounds) can be variable, typically for minimum time problems (see Mayer cost section):","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    v = (T, Œª) ‚àà R¬≤, variable\n    t ‚àà [0, T], time\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html#tutorial-abstract-state","page":"Define a problem","title":"State","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $x ‚àà R^$n, state ) \n:( $x ‚àà R   , state ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The state declaration defines the name and the dimension of the state:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    x ‚àà R‚Å¥, state\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"As for the variable, there are automatic aliases (x‚ÇÅ and x1 for x[1], etc.) and the user can define her own aliases (one per scalar component of the state):","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    x = (q‚ÇÅ, q‚ÇÇ, v‚ÇÅ, v‚ÇÇ) ‚àà R‚Å¥, state\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html#tutorial-abstract-control","page":"Define a problem","title":"Control","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $u ‚àà R^$m, control ) \n:( $u ‚àà R   , control ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The control declaration defines the name and the dimension of the control:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    u ‚àà R¬≤, control\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"As before, there are automatic aliases (u‚ÇÅ and u1 for u[1], etc.) and the user can define her own aliases (one per scalar component of the state):","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    u = (Œ±, Œ≤) ‚àà R¬≤, control\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"note: Note\nOne dimensional variable, state or control are treated as scalars (Real), not vectors (Vector). In Julia, for x::Real, it is possible to write x[1] (and x[1][1]...) so it is OK (though useless) to write x‚ÇÅ, x1 or x[1] instead of simply x to access the corresponding value. Conversely it is not OK to use such an x as a vector, for instance as in ...f(x)... where f(x::Vector{T}) where {T <: Real}.","category":"page"},{"location":"tutorial-abstract.html#tutorial-abstract-dynamics","page":"Define a problem","title":"Dynamics","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( ‚àÇ($x)($t) == $e1 ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The dynamics is given in the standard vectorial ODE form:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"    dotx(t) = f(t x(t) u(t) v)","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"depending on whether it is autonomous / with a variable or not (the parser will detect time and variable dependences, which entails that time, state and variable must be declared prior to dynamics - an error will be issued otherwise). The symbol ‚àÇ, or the dotted state name (·∫ã), or the keyword derivative can be used:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ‚àà [0, 1], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n    ‚àÇ(x)(t) == [x‚ÇÇ(t), u(t)]\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"or","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ‚àà [0, 1], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n    ·∫ã(t) == [x‚ÇÇ(t), u(t)]\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"or","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ‚àà [0, 1], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n    derivative(x)(t) == [x‚ÇÇ(t), u(t)]\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Any Julia code can be used, so the following is also OK: ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"ocp = @def begin\n    t ‚àà [0, 1], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n    ·∫ã(t) == F‚ÇÄ(x(t)) + u(t) * F‚ÇÅ(x(t))\n    ...\nend\n\nF‚ÇÄ(x) = [x[2], 0]\nF‚ÇÅ(x) = [0, 1]","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"note: Note\nThe vector fields F‚ÇÄ and F‚ÇÅ can be defined afterwards, as they only need to be available when the dynamics will be evaluated.","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Currently, it is not possible to declare the dynamics component after component, but a simple workaround is to use aliases (check the relevant aliases section below):","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def damped_integrator begin\n    tf ‚àà R, variable\n    t ‚àà [0, tf], time\n    x = (q, v) ‚àà R¬≤, state\n    u ‚àà R, control\n    qÃá = v(t)\n    vÃá = u(t) - c(t)\n    ·∫ã(t) == [qÃá, vÃá]\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html#Constraints","page":"Define a problem","title":"Constraints","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $e1 == $e2        ) \n:( $e1 ‚â§  $e2 ‚â§  $e3 ) \n:(        $e2 ‚â§  $e3 ) \n:( $e3 ‚â•  $e2 ‚â•  $e1 ) \n:( $e2 ‚â•  $e1        ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Admissible constraints can be","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"five types: boundary, control, state, mixed, variable,\nlinear (ranges) or nonlinear (not ranges),\nequalities or (one or two-sided) inequalities.","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Boundary conditions are detected when the expression contains evaluations of the state at initial and / or final time bounds (e.g., x(0)), and may not involve the control. Conversely control, state or mixed constraints will involve control, state or both evaluated at the declared time (e.g., x(t) + u(t)).  Other combinations should be detected as incorrect by the parser ü§ûüèæ. The variable may be involved in any of the four previous constraints. Constraints involving the variable only are variable constraints, either linear or nonlinear. In the example below, there are","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"two linear boundary constraints,\none linear variable constraint,\none linear state constraint,\none (two-sided) nonlinear control constraint.","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    tf ‚àà R, variable\n    t ‚àà [0, tf], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n    x(0) == [-1, 0]\n    x(tf) == [0, 0]\n    ·∫ã(t) == [x‚ÇÇ(t), u(t)]\n    tf ‚â• 0 \n    x‚ÇÇ(t) ‚â§ 1\n    u(t)^2 ‚â§ 1\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"note: Note\nSymbols like <= or >= are also authorised:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    tf ‚àà R, variable\n    t ‚àà [0, tf], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n    x(0) == [-1, 0]\n    x(tf) == [0, 0]\n    ·∫ã(t) == [x‚ÇÇ(t), u(t)]\n    tf >= 0 \n    x‚ÇÇ(t) <= 1\n    u(t)^2 <= 1\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nWrite either u(t)^2 or (u^2)(t), not u^2(t) since in Julia the latter means u^(2t). Moreover, in the case of equalities or of one-sided inequalities, the control and / or the state must belong to the left-hand side. The following will error:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ‚àà [0, 2], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n    x(0) == [-1, 0]\n    x(2) == [0, 0]\n    ·∫ã(t) == [x‚ÇÇ(t), u(t)]\n    1 ‚â§ x‚ÇÇ(t)\n    -1 ‚â§ u(t) ‚â§ 1\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nConstraint bounds must be effective, that is must not depend on a variable. For instance, instead of","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"o = @def begin\n    v ‚àà R, variable\n    t ‚àà [0, 1], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n    -1 ‚â§ v ‚â§ 1\n    x‚ÇÅ(0) == -1\n    x‚ÇÇ(0) == v # wrong: the bound is not effective (as it depends on the variable)\n    x(1) == [0, 0]\n    ·∫ã(t) == [x‚ÇÇ(t), u(t)]\n    ‚à´( 0.5u(t)^2 ) ‚Üí min\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"write","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"o = @def begin\n    v ‚àà R, variable\n    t ‚àà [0, 1], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n    -1 ‚â§ v ‚â§ 1\n    x‚ÇÅ(0) == -1\n    x‚ÇÇ(0) - v == 0 # OK: the boundary contraint may involve the variable\n    x(1) == [0, 0]\n    ·∫ã(t) == [x‚ÇÇ(t), u(t)]\n    ‚à´( 0.5u(t)^2 ) ‚Üí min\nend","category":"page"},{"location":"tutorial-abstract.html#tutorial-abstract-mayer","page":"Define a problem","title":"Mayer cost","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $e1 ‚Üí min ) \n:( $e1 ‚Üí max ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Mayer costs are defined in a similar way to boundary conditions and follow the same rules. The symbol ‚Üí is used to denote minimisation or maximisation, the latter being treated by minimising the opposite cost. (The symbol => can also be used.)","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    tf ‚àà R, variable\n    t ‚àà [0, tf], time\n    x = (q, v) ‚àà R¬≤, state\n    u ‚àà R, control\n    tf ‚â• 0\n    -1 ‚â§ u(t) ‚â§ 1\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ‚â§ q(t) ‚â§ 5\n   -2 ‚â§ v(t) ‚â§ 3\n    ·∫ã(t) == [v(t), u(t)]\n    tf ‚Üí min\nend","category":"page"},{"location":"tutorial-abstract.html#Lagrange-cost","page":"Define a problem","title":"Lagrange cost","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":(       ‚à´($e1) ‚Üí min ) \n:(     - ‚à´($e1) ‚Üí min ) \n:( $e1 * ‚à´($e2) ‚Üí min ) \n:(       ‚à´($e1) ‚Üí max ) \n:(     - ‚à´($e1) ‚Üí max ) \n:( $e1 * ‚à´($e2) ‚Üí max ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Lagrange (integral) costs are defined used the symbol ‚à´, with parentheses. The keyword integral can also be used:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ‚àà [0, 1], time\n    x = (q, v) ‚àà R¬≤, state\n    u ‚àà R, control\n    0.5‚à´(q(t) + u(t)^2) ‚Üí min\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"or","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ‚àà [0, 1], time\n    x = (q, v) ‚àà R¬≤, state\n    u ‚àà R, control\n    0.5integral(q(t) + u(t)^2) ‚Üí min\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The integration range is implicitly equal to the time range, so the cost above is to be understood as","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"frac12 int_0^1 left( q(t) + u^2(t) right) mathrmdt to min","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"As for the dynamics, the parser will detect whether the integrand depends or not on time (autonomous / non-autonomous case).","category":"page"},{"location":"tutorial-abstract.html#Bolza-cost","page":"Define a problem","title":"Bolza cost","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $e1 +       ‚à´($e2)       ‚Üí min ) \n:( $e1 + $e2 * ‚à´($e3)       ‚Üí min ) \n:( $e1 -       ‚à´($e2)       ‚Üí min ) \n:( $e1 - $e2 * ‚à´($e3)       ‚Üí min ) \n:( $e1 +       ‚à´($e2)       ‚Üí max ) \n:( $e1 + $e2 * ‚à´($e3)       ‚Üí max ) \n:( $e1 -       ‚à´($e2)       ‚Üí max ) \n:( $e1 - $e2 * ‚à´($e3)       ‚Üí max ) \n:(             ‚à´($e2) + $e1 ‚Üí min ) \n:(       $e2 * ‚à´($e3) + $e1 ‚Üí min ) \n:(             ‚à´($e2) - $e1 ‚Üí min ) \n:(       $e2 * ‚à´($e3) - $e1 ‚Üí min ) \n:(             ‚à´($e2) + $e1 ‚Üí max ) \n:(       $e2 * ‚à´($e3) + $e1 ‚Üí max ) \n:(             ‚à´($e2) - $e1 ‚Üí max ) \n:(       $e2 * ‚à´($e3) - $e1 ‚Üí max ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Quite readily, Mayer and Lagrange costs can be combined into general Bolza costs. For instance as follows:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    p = (t0, tf) ‚àà R¬≤, variable\n    t ‚àà [t0, tf], time\n    x = (q, v) ‚àà R¬≤, state\n    u ‚àà R¬≤, control\n    (tf - t0) + 0.5‚à´(c(t) * u(t)^2) ‚Üí min\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nThe expression must be the sum of two terms (plus, possibly, a scalar factor before the integral), not more, so mind the parentheses. For instance, the following errors:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    p = (t0, tf) ‚àà R¬≤, variable\n    t ‚àà [t0, tf], time\n    x = (q, v) ‚àà R¬≤, state\n    u ‚àà R¬≤, control\n    (tf - t0) + q(tf) + 0.5‚à´( c(t) * u(t)^2 ) ‚Üí min\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The correct syntax is","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    p = (t0, tf) ‚àà R¬≤, variable\n    t ‚àà [t0, tf], time\n    x = (q, v) ‚àà R¬≤, state\n    u ‚àà R¬≤, control\n    ((tf - t0) + q(tf)) + 0.5‚à´( c(t) * u(t)^2 ) ‚Üí min\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html#tutorial-abstract-aliases","page":"Define a problem","title":"Aliases","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $a = $e1 )","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The single = symbol is used to define not a constraint but an alias, that is a purely syntactic replacement. There are some automatic aliases, e.g. x‚ÇÅ for x[1] if x is the state, and we have also seen that the user can define her own aliases when declaring the variable, state and control. Arbitrary aliases can be further defined, as below (compare with previous examples in the dynamics section):","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ‚àà [0, 1], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n    F‚ÇÄ = [x‚ÇÇ(t), 0]\n    F‚ÇÅ = [0, 1]\n    ·∫ã(t) == F‚ÇÄ + u(t) * F‚ÇÅ\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nSuch aliases do not define any additional function and are just replaced textually by the parser. In particular, they cannot be used outside the @def begin ... end block.","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"hint: Hint\nYou can rely on a trace mode for the macro @def to look at your code after expansions of the aliases using the @def ocp ... syntax and adding true after your begin ... end block:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def damped_integrator begin\n    tf ‚àà R, variable\n    t ‚àà [0, tf], time\n    x = (q, v) ‚àà R¬≤, state\n    u ‚àà R, control\n    qÃá = v(t)\n    vÃá = u(t) - c(t)\n    ·∫ã(t) == [qÃá, vÃá]\nend true;","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nThe dynamics of an OCP is indeed a particular constraint, be careful to use == and not a single = that would try to define an alias:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"double_integrator = @def begin\n    tf ‚àà R, variable\n    t ‚àà [0, tf], time\n    x = (q, v) ‚àà R¬≤, state\n    u ‚àà R, control\n    qÃá = v\n    vÃá = u\n    ·∫ã(t) = [qÃá, vÃá]\nend","category":"page"},{"location":"tutorial-abstract.html#Misc","page":"Define a problem","title":"Misc","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Declarations (of variable - if any -, time, state and control) must be done first. Then, dynamics, constraints and cost can be introduced in an arbitrary order.\nIt is possible to provide numbers / labels (as in math equations) for the constraints to improve readability (this is mostly for future use, typically to retrieve the Lagrange multiplier associated with the discretisation of a given constraint):","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def damped_integrator begin\n    tf ‚àà R, variable\n    t ‚àà [0, tf], time\n    x = (q, v) ‚àà R¬≤, state\n    u ‚àà R, control\n    tf ‚â• 0, (1)\n    q(0) == 2, (‚ô°)\n    qÃá = v(t)\n    vÃá = u(t) - c(t)\n    ·∫ã(t) == [qÃá, vÃá]\n    x(t).^2  ‚â§ [1, 2], (state_con) \n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Parsing errors should be explicit enough (with line number in the @def begin ... end block indicated) ü§ûüèæ\nCheck tutorials and applications in the documentation for further use.","category":"page"},{"location":"tutorial-abstract.html#Known-issues","page":"Define a problem","title":"Known issues","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Constants and (reverse over forward) AD","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"","category":"page"},{"location":"tutorial-double-integrator-energy.html#tutorial-double-integrator-energy","page":"Energy minimisation","title":"Double integrator: energy minimisation","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force u. We denote by x = (x_1 x_2) the state of the wagon, that is its position x_1 and its velocity x_2.","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We assume that the mass is constant and unitary and that there is no friction. The dynamics we consider is given by","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t)quad u(t) in R","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"which is simply the double integrator system. Les us consider a transfer starting at time t_0 = 0 and ending at time t_f = 1, for which we want to minimise the transfer energy","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"    frac12int_0^1 u^2(t)  mathrmdt","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"starting from the condition x(0) = (-1 0) and with the goal to reach the target x(1) = (0 0).","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-double-integrator-energy.html#Optimal-control-problem","page":"Energy minimisation","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"Let us define the problem","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"ocp = @def begin\n    t ‚àà [0, 1], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n    x(0) == [-1, 0]\n    x(1) == [0, 0]\n    xÃá(t) == [x‚ÇÇ(t), u(t)]\n    ‚à´( 0.5u(t)^2 ) ‚Üí min\nend\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"note: Nota bene\nFor a comprehensive introduction to the syntax used above to define the optimal control problem, check this abstract syntax tutorial. In particular, there are non-unicode alternatives for derivatives, integrals, etc.","category":"page"},{"location":"tutorial-double-integrator-energy.html#tutorial-basic-solve-plot","page":"Energy minimisation","title":"Solve and plot","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We can solve it simply with:","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"And plot the solution with:","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"plot(sol)","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"note: Nota bene\nThe solve function has options, see the solve tutorial. You can customise the plot, see the plot tutorial.","category":"page"},{"location":"tutorial-double-integrator-energy.html#State-constraint","page":"Energy minimisation","title":"State constraint","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We add the path constraint","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"x_2(t) le 12","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"Let us model, solve and plot the optimal control problem with this constraint.","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"ocp = @def begin\n\n    t ‚àà [0, 1], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n\n    x‚ÇÇ(t) ‚â§ 1.2\n\n    x(0) == [-1, 0]\n    x(1) == [0, 0]\n\n    xÃá(t) == [x‚ÇÇ(t), u(t)]\n\n    ‚à´( 0.5u(t)^2 ) ‚Üí min\n\nend\n\nsol = solve(ocp)\n\nplot(sol)","category":"page"},{"location":"tutorial-double-integrator-energy.html#Exporting-and-importing-the-solution","page":"Energy minimisation","title":"Exporting and importing the solution","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We can export (or save) the solution in a Julia .jld2 data file and reload it later, and also export a discretised version of the solution in a more portable JSON format. Note that the optimal control problem is needed when loading a solution.","category":"page"},{"location":"tutorial-double-integrator-energy.html#JLD2","page":"Energy minimisation","title":"JLD2","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"using JLD2\nusing Suppressor # hide\n@suppress_err begin # hide\nexport_ocp_solution(sol; filename=\"my_solution\")\nend # hide\nsol_jld = import_ocp_solution(ocp; filename=\"my_solution\")\nprintln(\"Objective from computed solution: \", objective(sol))\nprintln(\"Objective from imported solution: \", objective(sol_jld))","category":"page"},{"location":"tutorial-double-integrator-energy.html#JSON","page":"Energy minimisation","title":"JSON","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"using JSON3\nexport_ocp_solution(sol; filename=\"my_solution\", format=:JSON)\nsol_json = import_ocp_solution(ocp; filename=\"my_solution\", format=:JSON)\nprintln(\"Objective from computed solution: \", objective(sol))\nprintln(\"Objective from imported solution: \", objective(sol_json))","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"","category":"page"},{"location":"tutorial-solve.html#tutorial-solve","page":"Solve a problem","title":"The solve function","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"In this tutorial, we explain the solve function from OptimalControl.jl package.","category":"page"},{"location":"tutorial-solve.html#Basic-usage","page":"Solve a problem","title":"Basic usage","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Let us define a basic optimal control problem.","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"using OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n    t ‚àà [ t0, tf ], time\n    x = (q, v) ‚àà R¬≤, state\n    u ‚àà R, control\n    x(t0) == x0\n    x(tf) == [ 0, 0 ]\n    xÃá(t)  == [ v(t), u(t) ]\n    ‚à´( 0.5u(t)^2 ) ‚Üí min\nend\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"We can now solve the problem:","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"using NLPModelsIpopt\nsolve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Notice that we need to load the NLPModelsIpopt package before calling solve. This is because the method currently implements a direct approach, where the optimal control problem is transcribed to a nonlinear optimization problem (NLP) of the form","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"textminimizequad F(y) quadtextsubject to the constraintsquad g(y)=0 quad h(y)le 0 ","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Calling solve without loading a NLP solver package first will notify the user:","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"julia> solve(ocp)\nERROR: ExtensionError. Please make: julia> using NLPModelsIpopt","category":"page"},{"location":"tutorial-solve.html#Resolution-methods-and-algorithms","page":"Solve a problem","title":"Resolution methods and algorithms","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"OptimalControl offers a list of methods to solve your optimal control problem. To get the list of methods, simply call available_methods.","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"available_methods()","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Each line is a method, with priority going from top to bottom. This means that ","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"solve(ocp)","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"is equivalent to ","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"solve(ocp, :direct, :adnlp, :ipopt)","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"The first symbol :direct refers to the general class of method, with only the so-called direct approach currently implemented. Direct methods discretize the original optimal control problem and solve the resulting NLP problem. The second symbol :adnlp is for the choice of NLP modeler.  We currently use ADNLPModels.jl which provides an automatic differentiation (AD)-based model implementations that conform to the NLPModels.jl API. The third symbol corresponds to the NLP solver, with the possible values:","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":":ipopt (default value) for Ipopt (via the NLPModelsIpopt.jl package).\n:madnlp is MadNLP.jl, an open-source nonlinear programming solver purely implemented in Julia, which implements a filter line-search interior-point algorithm, as the one in Ipopt.\n:knitro for the Knitro solver (requires a license).","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"For instance, let us try MadNLP.jl.","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"using MadNLP\nsolve(ocp, :madnlp)\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Note that you can provide a partial description. If multiple full descriptions contain it, priority is given to the first one in the list. Hence, all of the following calls are equivalent:","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"solve(ocp)\nsolve(ocp, :direct                )\nsolve(ocp,          :adnlp        )\nsolve(ocp,                  :ipopt)\nsolve(ocp, :direct, :adnlp        )\nsolve(ocp, :direct,         :ipopt)\nsolve(ocp, :direct, :adnlp, :ipopt)","category":"page"},{"location":"tutorial-solve.html#Direct-method","page":"Solve a problem","title":"Direct method","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"The options for the direct method are listed here. The main options, with their [default values], are:","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"display ([true], false): setting display to false will disable output.\ninit: info for the starting guess, which can be provided as numerical values, functions, or an existing solution. See initial guess tutorial.\ngrid_size ([250]): size of the (uniform) time discretization grid. More precisely, it is the number of time steps, that is if N = grid_size and if the initial and final times are denoted respectively t0 and tf, then we have Œît = (tf - t0) / N.\ntime_grid ([nothing]): explicit time grid (can be non uniform). If time_grid is nothing then, a uniform grid is built of length grid_size.\ndisc_method ([:trapeze], :midpoint, :euler, :euler_implicit, :gauss_legendre_2, :gauss_legendre_3): see discretisation methods.\nadnlp_backend: backend for automatic differentiation in ADNLPModels ([:optimized], :manual, :default).","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"For examples of more advanced use, see ","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"discrete continuation,\nNLP direct handling.","category":"page"},{"location":"tutorial-solve.html#NLP-solver-specific-options","page":"Solve a problem","title":"NLP solver specific options","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"In addition to these options, all remaining keyword arguments passed to solve will be transmitted to the NLP solver used.","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Please check the list of Ipopt options and the NLPModelsIpopt.jl documentation.","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"sol = solve(ocp; max_iter=0, display=false)\niterations(sol)","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Similarly, please check the MadNLP.jl documentation and the list of MadNLP.jl options.","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"sol = solve(ocp, :madnlp; max_iter=0, display=false)\niterations(sol)","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"","category":"page"},{"location":"tutorial-plot.html#tutorial-plot","page":"Plot a solution","title":"How to plot a solution","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In this tutorial, we explain the different options for plotting the solution of an optimal control problem using the plot and plot! functions, which are extensions of the Plots.jl package. Use plot to create a new plot object, and plot! to add to an existing one:","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(args...; kw...)           # creates a new Plot, and set it to be the `current`\nplot!(args...; kw...)          # modifies Plot `current()`\nplot!(plt, args...; kw...)     # modifies Plot `plt`","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"More precisely, the signature of plot, to plot a solution, is as follows.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"# only sol is required\nfunction plot(\n    sol::CTModels.Solution,                   # optimal control solution\n    description::Symbol...;                   # description to choose what to plot\n    layout::Symbol,                           # layout of the subplots\n    control::Symbol,                          # plot the norm or components of the control\n    time::Symbol,                             # normalise the time or not\n    size::Tuple,                              # size of the figure\n    state_style::Union{NamedTuple,Symbol},    # style: state trajectory\n    costate_style::Union{NamedTuple,Symbol},  # style: costate trajectory\n    control_style::Union{NamedTuple,Symbol},  # style: control trajectory\n    kwargs...,                                # other attributes from Plots\n)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can provide additional information to the plot function by supplying the optimal control problem: plot(sol, ocp). The function signature when including the optimal control problem is as follows:","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"# only sol and model are required\nfunction Plots.plot(\n    sol::CTModels.Solution,\n    ocp::CTModels.Model,                            # optimal control problem\n    description::Symbol...;\n    layout::Symbol,\n    control::Symbol,\n    time::Symbol,\n    size::Tuple,\n    time_style::Union{NamedTuple,Symbol},           # style: vertical time axes\n    state_style::Union{NamedTuple,Symbol},\n    state_bounds_style::Union{NamedTuple,Symbol},   # style: state bounds\n    control_style::Union{NamedTuple,Symbol},\n    control_bounds_style::Union{NamedTuple,Symbol}, # style: control bounds\n    costate_style::Union{NamedTuple,Symbol},\n    path_style::Union{NamedTuple,Symbol},           # style: path constraints\n    path_bounds_style::Union{NamedTuple,Symbol},    # style: path constraints bounds\n    dual_style::Union{NamedTuple,Symbol},           # style: path constraints dual variable\n    kwargs...,\n)","category":"page"},{"location":"tutorial-plot.html#Argument-Overview","page":"Plot a solution","title":"Argument Overview","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The table below summarizes the main plotting arguments and links to the corresponding documentation sections for detailed explanations:","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Section Relevant Arguments\nBasic concepts size, state_style, costate_style, control_style, time_style, kwargs...\nSplit vs. group layout layout\nPlotting control norm control\nNormalized time time\nConstraints state_bounds_style, control_bounds_style, path_style, path_bounds_style, dual_style\nWhat to plot description...","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can plot solutions obtained from the solve function or from a flow computed using an optimal control problem and a control law. See the Basic Concepts and From Flow function sections for details.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To overlay a new plot on an existing one, use the plot! function (see Add a plot).","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"If you prefer full control over the visualization, you can extract the state, costate, and control to create your own plots. Refer to the Custom plot section for guidance.","category":"page"},{"location":"tutorial-plot.html#The-problem-and-the-solution","page":"Plot a solution","title":"The problem and the solution","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Let us start by importing the packages needed to define and solve the problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using OptimalControl\nusing NLPModelsIpopt","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We consider the simple optimal control problem from the basic example tutorial.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"t0 = 0            # initial time\ntf = 1            # final time\nx0 = [ -1, 0 ]    # initial condition\nxf = [  0, 0 ]    # final condition\n\nocp = @def begin\n\n    t ‚àà [t0, tf], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n\n    x(t0) == x0\n    x(tf) == xf\n\n    xÃá(t) == [x‚ÇÇ(t), u(t)]\n\n    ‚à´( 0.5u(t)^2 ) ‚Üí min\n\nend\n\nsol = solve(ocp, display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html#tutorial-plot-basic","page":"Plot a solution","title":"Basic concepts","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The simplest way to plot the solution is to use the plot function with the solution as the only argument.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"warning: Warning\nThe plot function for a solution of an optimal control problem extends the plot function from Plots. Therefore, you need to import this package in order to plot a solution.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using Plots\nplot(sol)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In the figure above, we have a grid of subplots: the left column displays the state component trajectories, the right column shows the costate component trajectories, and the bottom row contains the control component trajectories.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"As in Plots, input data is passed positionally (for example, sol in plot(sol)), and attributes are passed as keyword arguments (for example, plot(sol; color = :blue)). After executing using Plots in the REPL, you can use the plotattr() function to print a list of all available attributes for series, plots, subplots, or axes.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"# Valid Operations\nplotattr(:Plot)\nplotattr(:Series)\nplotattr(:Subplot)\nplotattr(:Axis)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Once you have the list of attributes, you can either use the aliases of a specific attribute or inspect a specific attribute to display its aliases and description.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plotattr(\"color\") # Specific Attribute Example","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"warning: Warning\nSome attributes have different default values in OptimalControl compared to Plots. For instance, the default figure size is 600x400 in Plots, while in OptimalControl, it depends on the number of states and controls.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can also visit the Plot documentation online to get the descriptions of the attributes:","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To pass attributes to the plot, see the attributes plot documentation. For instance, you can specify the size of the figure.\nYou can pass attributes to all subplots at once by referring to the attributes subplot documentation. For example, you can specify the location of the legends.\nSimilarly, you can pass axis attributes to all subplots. See the attributes axis documentation. For example, you can remove the grid from every subplot.\nFinally, you can pass series attributes to all subplots. Refer to the attributes series documentation. For instance, you can set the width of the curves using linewidth.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, size=(700, 450), legend=:bottomright, grid=false, linewidth=2)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To specify series attributes for a specific group of subplots (state, costate or control), you can use the optional keyword arguments state_style, costate_style, and control_style, which correspond to the state, costate, and control trajectories, respectively.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; \n     state_style   = (color=:blue,),                  # style: state trajectory\n     costate_style = (color=:black, linestyle=:dash), # style: costate trajectory\n     control_style = (color=:red, linewidth=2))       # style: control trajectory","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"If you provide the optimal control problem, vertical axes at the initial and final times are automatically plotted.   Additionally, you can choose not to display the state and costate trajectories by setting their styles to :none.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, ocp; \n     state_style    = :none,             # do not plot the state\n     costate_style  = :none,             # do not plot the costate\n     control_style  = (color = :red,),   # plot the control in red\n     time_style     = (color = :green,)) # vertical axes at initial and final times in green","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To select what to display, you can also use the description argument by providing a list of symbols such as :state, :costate, and :control.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, ocp, :state, :control)  # plot the state and the control","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Select what to plot\nFor more details on how to choose what to plot, see the What to plot section.","category":"page"},{"location":"tutorial-plot.html#tutorial-plot-flow","page":"Plot a solution","title":"From Flow function","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The previous solution of the optimal control problem was obtained using the solve function. If you prefer using an indirect shooting method and solving shooting equations, you may also want to plot the associated solution. To do this, you need to use the Flow function to reconstruct the solution. See the manual on how to compute flows for more details. In our case, you must provide the maximizing control (x p) mapsto p_2 along with the optimal control problem. For an introduction to simple indirect shooting, see the indirect simple shooting tutorial for an example.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"tip: Interactions with an optimal control solution\nPlease check state, costate, control, and variable to retrieve data from the solution. The functions state, costate, and control return functions of time, while variable returns a vector.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using OrdinaryDiffEq\n\np  = costate(sol)                # costate as a function of time\np0 = p(t0)                       # costate solution at the initial time\nf  = Flow(ocp, (x, p) -> p[2])   # flow from an ocp and a control law\n\nsol_flow = f( (t0, tf), x0, p0 ) # compute the solution\nplot(sol_flow)                   # plot the solution from a flow","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We may notice that the time grid contains very few points. This is evident from the subplot of x_2, or by retrieving the time grid directly from the solution.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"time_grid(sol_flow)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To improve visualization (without changing the accuracy), you can provide a finer grid.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"fine_grid = range(t0, tf, 100)\nsol_flow = f( (t0, tf), x0, p0; saveat=fine_grid )\nplot(sol_flow)","category":"page"},{"location":"tutorial-plot.html#tutorial-plot-layout","page":"Plot a solution","title":"Split vs. group layout","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"If you prefer to get a more compact figure, you can use the layout optional keyword argument with :group value. It will group the state, costate and control trajectories in one subplot for each.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; layout=:group)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The default layout value is :split which corresponds to the grid of subplots presented above.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; layout=:split)","category":"page"},{"location":"tutorial-plot.html#tutorial-plot-add","page":"Plot a solution","title":"Add a plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can plot the solution of a second optimal control problem on the same figure if it has the same number of states, costates and controls. For instance, consider the same optimal control problem but with a different initial condition.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"ocp = @def begin\n\n    t ‚àà [t0, tf], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n\n    x(t0) == [-0.5, -0.5]\n    x(tf) == xf\n\n    xÃá(t) == [x‚ÇÇ(t), u(t)]\n\n    ‚à´( 0.5u(t)^2 ) ‚Üí min\n\nend\nsol2 = solve(ocp; display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We first plot the solution of the first optimal control problem, then, we plot the solution of the second optimal control problem on the same figure, but with dashed lines.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plt = plot(sol; label=\"sol1\", size=(700, 500))\nplot!(plt, sol2; label=\"sol2\", linestyle=:dash)","category":"page"},{"location":"tutorial-plot.html#tutorial-plot-control","page":"Plot a solution","title":"Plotting control norm","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"For some problem, it is interesting to plot the (Euclidean) norm of the control. You can do it by using the control optional keyword argument with :norm value.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; control=:norm, size=(800, 300), layout=:group)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The default value is :components.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; control=:components, size=(800, 300), layout=:group)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can also plot the control and is norm.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; control=:all, layout=:group)","category":"page"},{"location":"tutorial-plot.html#tutorial-plot-custom","page":"Plot a solution","title":"Custom plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can, of course, create your own plots by extracting the state, costate, and control from the optimal control solution. For instance, let us plot the norm of the control.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using LinearAlgebra\nt = time_grid(sol)\nu = control(sol)\nplot(t, norm‚àòu; label=\"‚Äñu‚Äñ\", xlabel=\"t\") ","category":"page"},{"location":"tutorial-plot.html#tutorial-plot-time","page":"Plot a solution","title":"Normalised time","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We consider a LQR example and solve the problem for different values of the final time tf. Then, we plot the solutions on the same figure using a normalized time s = (t - t_0)  (t_f - t_0), enabled by the keyword argument time = :normalize (or :normalise) in the plot function.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"# definition of the problem, parameterised by the final time\nfunction lqr(tf)\n\n    ocp = @def begin\n        t ‚àà [0, tf], time\n        x ‚àà R¬≤, state\n        u ‚àà R, control\n        x(0) == [0, 1]\n        ·∫ã(t) == [x‚ÇÇ(t), - x‚ÇÅ(t) + u(t)]\n        ‚à´( 0.5(x‚ÇÅ(t)^2 + x‚ÇÇ(t)^2 + u(t)^2) ) ‚Üí min\n    end\n\n    return ocp\nend;\n\n# solve the problems and store them\nsolutions = []\ntfs = [3, 5, 30]\nfor tf ‚àà tfs\n    solution = solve(lqr(tf); display=false)\n    push!(solutions, solution)\nend\n\n# create plots\nplt = plot(solutions[1]; time=:normalize)\nfor sol ‚àà solutions[2:end]\n    plot!(plt, sol; time=:normalize)\nend\n\n# make a custom plot: keep only state and control\nN = length(tfs)\npx1 = plot(plt[1]; legend=false, xlabel=\"s\", ylabel=\"x‚ÇÅ\")\npx2 = plot(plt[2]; label=reshape([\"tf = $tf\" for tf ‚àà tfs], (1, N)), xlabel=\"s\", ylabel=\"x‚ÇÇ\")\npu  = plot(plt[5]; legend=false, xlabel=\"s\", ylabel=\"u\")\n\nusing Plots.PlotMeasures # for leftmargin, bottommargin\nplot(px1, px2, pu; layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"page"},{"location":"tutorial-plot.html#tutorial-plot-constraints","page":"Plot a solution","title":"Constraints","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We define an optimal control problem with constraints, solve it and plot the solution.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"ocp = @def begin\n    tf ‚àà R,          variable\n    t ‚àà [0, tf],     time\n    x = (q, v) ‚àà R¬≤, state\n    u ‚àà R,           control\n    tf ‚â• 0\n    -1 ‚â§ u(t) ‚â§ 1\n    q(0)  == -1\n    v(0)  == 0\n    q(tf) == 0\n    v(tf) == 0\n    1 ‚â§ v(t)+1 ‚â§ 1.8, (1)\n    xÃá(t) == [v(t), u(t)]\n    tf ‚Üí min\nend\nsol = solve(ocp)\nplot(sol, ocp)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"On the plot, you can see the lower and upper bounds of the path constraint. Additionally, the dual variable associated with the path constraint is displayed alongside it.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can customize the plot styles. For style options related to the state, costate, and control, refer to the Basic Concepts section.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, ocp; \n     state_bounds_style = (linestyle = :dash,),\n     control_bounds_style = (linestyle = :dash,),\n     path_style = (color = :green,),\n     path_bounds_style = (linestyle = :dash,),\n     dual_style = (color = :red,),\n     time_style = :none, # do not plot axes at t0 and tf\n)","category":"page"},{"location":"tutorial-plot.html#tutorial-plot-select","page":"Plot a solution","title":"What to plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can choose what to plot using the description argument. To plot only one subgroup:","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, ocp, :state)   # plot only the state\nplot(sol, ocp, :costate) # plot only the costate\nplot(sol, ocp, :control) # plot only the control\nplot(sol, ocp, :path)    # plot only the path constraint\nplot(sol, ocp, :dual)    # plot only the path constraint dual variable","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can combine elements to plot exactly what you need:","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, ocp, :state, :control, :path)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Similarly, you can choose what not to plot passing :none to the corresponding style.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, ocp; state_style=:none)   # do not plot the state\nplot(sol, ocp; costate_style=:none) # do not plot the costate\nplot(sol, ocp; control_style=:none) # do not plot the control\nplot(sol, ocp; path_style=:none)    # do not plot the path constraint\nplot(sol, ocp; dual_style=:none)    # do not plot the path constraint dual variable","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"For instance, let's plot everything except the dual variable associated with the path constraint.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, ocp; dual_style=:none)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"","category":"page"},{"location":"dev-ctdirect.html#CTDirect.jl","page":"CTDirect.jl","title":"CTDirect.jl","text":"","category":"section"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"The CTDirect.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"flowchart TD\nB(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctbase.html'>CTBase</a>)\nM(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctmodels.html'>CTModels</a>)\nP(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctparser.html'>CTParser</a>)\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-optimalcontrol.html'>OptimalControl</a>)\nD(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctdirect.html'>CTDirect</a>)\nF(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle D fill:#FBF275","category":"page"},{"location":"dev-ctdirect.html#Index","page":"CTDirect.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Pages   = [\"dev-ctdirect.md\"]\nModules = [CTDirect]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctdirect.html#Documentation","page":"CTDirect.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctdirect.html#Public","page":"CTDirect.jl","title":"Public","text":"","category":"section"},{"location":"dev-ctdirect.html#Private","page":"CTDirect.jl","title":"Private","text":"","category":"section"},{"location":"dev-ctdirect.html#CTDirect.DOCP","page":"CTDirect.jl","title":"CTDirect.DOCP","text":"Struct for discretized optimal control problem DOCP\n\nContains:\n\na copy of the original OCP\ndata required to link the OCP with the discretized DOCP\n\n\n\n\n\n","category":"type"},{"location":"dev-ctdirect.html#CTDirect.Gauss_Legendre_1","page":"CTDirect.jl","title":"CTDirect.Gauss_Legendre_1","text":"Implicit Midpoint discretization, formulated as a generic IRK (ie Gauss Legendre 1) For testing purpose only, use :midpoint instead (cf midpoint.jl) !\n\n\n\n\n\n","category":"type"},{"location":"dev-ctdirect.html#CTDirect.Gauss_Legendre_2","page":"CTDirect.jl","title":"CTDirect.Gauss_Legendre_2","text":"Gauss Legendre 2 discretization, formulated as a generic IRK\n\n\n\n\n\n","category":"type"},{"location":"dev-ctdirect.html#CTDirect.Gauss_Legendre_3","page":"CTDirect.jl","title":"CTDirect.Gauss_Legendre_3","text":"Gauss Legendre 3 discretization, formulated as a generic IRK\n\n\n\n\n\n","category":"type"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Euler}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Euler}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Midpoint}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Midpoint}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Trapeze}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Trapeze}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Hessian_pattern-Union{Tuple{CTDirect.DOCP{D}}, Tuple{D}} where D<:CTDirect.Discretization","page":"CTDirect.jl","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{D<:CTDirect.Discretization}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Euler}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Euler}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Midpoint}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Midpoint}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Trapeze}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Trapeze}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Jacobian_pattern-Union{Tuple{CTDirect.DOCP{D}}, Tuple{D}} where D<:CTDirect.Discretization","page":"CTDirect.jl","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{D<:CTDirect.Discretization}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_constraints!-Tuple{Any, Any, CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.DOCP_constraints!","text":"DOCP_constraints!(c, xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the constraints C for the DOCP problem (modeled as LB <= C(X) <= UB).\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_initial_guess","page":"CTDirect.jl","title":"CTDirect.DOCP_initial_guess","text":"DOCP_initial_guess(docp::CTDirect.DOCP) -> Vector{Float64}\nDOCP_initial_guess(\n    docp::CTDirect.DOCP,\n    init::CTModels.Init\n) -> Vector{Float64}\n\n\nBuild initial guess for discretized problem\n\n\n\n\n\n","category":"function"},{"location":"dev-ctdirect.html#CTDirect.DOCP_objective-Tuple{Any, CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.DOCP_objective","text":"DOCP_objective(xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the objective for the DOCP problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.IRK_dims-NTuple{7, Any}","page":"CTDirect.jl","title":"CTDirect.IRK_dims","text":"IRK_dims(\n    dim_NLP_steps,\n    dim_NLP_x,\n    dim_NLP_u,\n    dim_NLP_v,\n    dim_path_cons,\n    dim_boundary_cons,\n    stage\n) -> NTuple{5, Any}\n\n\nReturn the dimension of the NLP variables and constraints for a generic IRK discretizion, with the control taken constant per step (ie not distinct controls at time stages)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.SolverInfos-Tuple{}","page":"CTDirect.jl","title":"CTDirect.SolverInfos","text":"SolverInfos() -> Tuple{Int64, Float64, String, Symbol, Bool}\n\n\nRetrieve convergence information (Ipopt version)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__adnlp_backend-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__adnlp_backend","text":"__adnlp_backend() -> Symbol\n\n\nUsed to set the default backend for AD in ADNLPModels. The default value is :optimized.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__disc_method-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__disc_method","text":"__disc_method() -> Symbol\n\n\nUsed to set the default discretization method. The default value is trapeze.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__display-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__display","text":"__display() -> Bool\n\n\nUsed to set the default display toggle. The default value is true.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__grid_size-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__grid_size","text":"__grid_size() -> Int64\n\n\nUsed to set the default grid size. The default value is 250.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__ipopt_linear_solver-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__ipopt_linear_solver","text":"__ipopt_linear_solver() -> String\n\n\nUsed to set the default value of the linear solver of Ipopt for the direct method. The default value is mumps.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__ipopt_mu_strategy-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__ipopt_mu_strategy","text":"__ipopt_mu_strategy() -> String\n\n\nUsed to set the default value of the Œº strategy of Ipopt for the direct method. The default value is adaptive.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__ipopt_print_level-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__ipopt_print_level","text":"__ipopt_print_level() -> Int64\n\n\nUsed to set the default value of the print level of Ipopt for the direct method. The default value is 5.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__knitro_print_level-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__knitro_print_level","text":"__knitro_print_level() -> Int64\n\n\nUsed to set the default value of the print level of Knitro for the direct method. The default value is 3.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__madnlp_linear_solver-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__madnlp_linear_solver","text":"__madnlp_linear_solver() -> String\n\n\nUsed to set the default value of the linear solver of MadNLP for the direct method. The default value is umfpack.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__max_iterations-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__max_iterations","text":"__max_iterations() -> Int64\n\n\nUsed to set the default maximum of iterations. The default value is 1000.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__ocp_init-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__ocp_init","text":"__ocp_init()\n\n\nUsed to set the default initial guess. The default value is nothing and will correspond to 0.1 for all variables.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__time_grid-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__time_grid","text":"__time_grid()\n\n\nUsed to set the default time grid. The default value is nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__tolerance-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__tolerance","text":"__tolerance() -> Float64\n\n\nUsed to set the default tolerance. The default value is 1e-8.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.add_nonzero_block!-NTuple{5, Any}","page":"CTDirect.jl","title":"CTDirect.add_nonzero_block!","text":"add_nonzero_block!(M, i_start, i_end, j_start, j_end; sym)\n\n\nAdd block of nonzeros elements to a sparsity pattern  Format: boolean matrix (M) or index vectors (Is, Js)  Includes a more compact method for single element case Option to add the symmetric block also (eg for Hessian) Note: independent from discretization scheme\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.available_methods-Tuple{}","page":"CTDirect.jl","title":"CTDirect.available_methods","text":"available_methods(\n\n) -> Tuple{Tuple{Symbol, Symbol}, Tuple{Symbol, Symbol}, Tuple{Symbol, Symbol}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.build_OCP_solution-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTDirect.build_OCP_solution","text":"build_OCP_solution(\n    docp,\n    docp_solution\n) -> CTModels.Solution{TimeGridModelType, TimesModelType, StateModelType, ControlModelType, VariableModelType, CostateModelType, Float64, DualModelType, CTModels.SolverInfos{Dict{Symbol, Any}}} where {TimeGridModelType<:CTModels.TimeGridModel, TimesModelType<:CTModels.TimesModel, StateModelType<:Union{CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#111#133\", CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#112#134\"}, ControlModelType<:Union{CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#113#135\", CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#114#136\"}, VariableModelType<:Union{CTModels.VariableModelSolution{Vector{Float64}}, CTModels.VariableModelSolution{Float64}}, CostateModelType<:Union{CTModels.var\"#115#137\", CTModels.var\"#116#138\"}, DualModelType<:(CTModels.DualModel{PC_Dual, BC_Dual, SC_LB_Dual, SC_UB_Dual, CC_LB_Dual, CC_UB_Dual, VC_LB_Dual, VC_UB_Dual} where {PC_Dual<:Union{Nothing, CTModels.var\"#118#140\", CTModels.var\"#119#141\"}, BC_Dual<:Union{Nothing, Vector{Float64}}, SC_LB_Dual<:Union{Nothing, CTModels.var\"#121#143\", CTModels.var\"#122#144\"}, SC_UB_Dual<:Union{Nothing, CTModels.var\"#124#146\", CTModels.var\"#125#147\"}, CC_LB_Dual<:Union{Nothing, CTModels.var\"#127#149\", CTModels.var\"#128#150\"}, CC_UB_Dual<:Union{Nothing, CTModels.var\"#130#152\", CTModels.var\"#131#153\"}, VC_LB_Dual<:Union{Nothing, Vector{Float64}}, VC_UB_Dual<:Union{Nothing, Vector{Float64}}})}\n\n\nBuild OCP functional solution from DOCP discrete solution (given as a SolverCore.GenericExecutionStats)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.build_OCP_solution-Tuple{Any}","page":"CTDirect.jl","title":"CTDirect.build_OCP_solution","text":"build_OCP_solution(docp; primal, dual, mult_LB, mult_UB)\n\n\nBuild OCP functional solution from DOCP discrete solution (given as a SolverCore.GenericExecutionStats)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.build_bounds-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.build_bounds","text":"build_bounds(\n    dim_var,\n    dim_box,\n    box_triplet\n) -> Tuple{Any, Any}\n\n\nBuild full, ordered sets of bounds for state, control or optimization variables\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.constraints_bounds!-Tuple{CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.constraints_bounds!","text":"constraints_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP nonlinear constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.direct_transcription-Tuple{Model, Vararg{Any}}","page":"CTDirect.jl","title":"CTDirect.direct_transcription","text":"direct_transcription(\n    ocp::Model,\n    description...;\n    grid_size,\n    disc_method,\n    time_grid,\n    init,\n    adnlp_backend,\n    solver_backend,\n    show_time,\n    matrix_free\n) -> Tuple{CTDirect.DOCP{_A, Model{TimesModelType, StateModelType, ControlModelType, VariableModelType, DynamicsModelType, ObjectiveModelType, ConstraintsModelType}} where {_A<:CTDirect.Discretization, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:CTModels.AbstractConstraintsModel}, ADNLPModels.ADNLPModel{Float64, Vector{Float64}, Vector{Int64}}}\n\n\nDiscretize an optimal control problem into a nonlinear optimization problem (ie direct transcription)\n\nArguments\n\nocp: optimal control problem as defined in CTModels\n[description]: can specifiy for instance the NLP model and / or solver (:ipopt, :madnlp or :knitro)\n\nKeyword arguments (optional)\n\ngrid_size: number of time steps for the discretized problem ([250])\ndisc_method: discretization method ([:trapeze], :euler, :euler_implicit, :midpoint, gauss_legendre_2, gauss_legendre_3)\ntime_grid: explicit time grid (can be non uniform)\ninit: info for the starting guess (values as named tuple or existing solution)\nadnlp_backend: backend for automatic differentiation in ADNLPModels ([:optimized], :manual, :default)\nshow_time: (:true, [:false]) show timing details from ADNLPModels\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_OCP_control_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"CTDirect.jl","title":"CTDirect.get_OCP_control_at_time_step","text":"get_OCP_control_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve control variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps(+1), with convention u(tf) = U_N Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_OCP_control_at_time_step-Tuple{Any, CTDirect.DOCP{CTDirect.Euler}, Any}","page":"CTDirect.jl","title":"CTDirect.get_OCP_control_at_time_step","text":"get_OCP_control_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    i\n) -> Any\n\n\nRetrieve control variables at given time step from the NLP variables. Convention: see above for explicit / implicit versions Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_OCP_state_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"CTDirect.jl","title":"CTDirect.get_OCP_state_at_time_step","text":"get_OCP_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve state variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1 Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_OCP_variable-Tuple{Any, CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.get_OCP_variable","text":"get_OCP_variable(xu, docp::CTDirect.DOCP) -> Any\n\n\nRetrieve optimization variables from the NLP variables. Convention: stored at the end, hence not dependent on the discretization method Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_lagrange_state_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"CTDirect.jl","title":"CTDirect.get_lagrange_state_at_time_step","text":"get_lagrange_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve state variable for lagrange cost at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1   (no check for actual lagrange cost presence !)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_stagevars_at_time_step-Tuple{Any, CTDirect.DOCP, Any, Any}","page":"CTDirect.jl","title":"CTDirect.get_stagevars_at_time_step","text":"get_stagevars_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i,\n    j\n) -> Any\n\n\nRetrieve stage variables at given time step/stage from the NLP variables. Convention: 1 <= i <= dimNLPsteps(+1),\t1 <= j <= s Vector output Note that passing correct indices is up to the caller, no checks are made here.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_time_grid-Tuple{Any, CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.get_time_grid","text":"get_time_grid(xu, docp::CTDirect.DOCP) -> Any\n\n\nReturn time grid for variable time problems (times are then dependent on NLP variables)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.is_solvable-Tuple{Any}","page":"CTDirect.jl","title":"CTDirect.is_solvable","text":"is_solvable(ocp) -> Bool\n\n\nCheck if an OCP is solvable by the method solve.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.parse_DOCP_solution_dual-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTDirect.parse_DOCP_solution_dual","text":"parse_DOCP_solution_dual(\n    docp,\n    multipliers\n) -> Tuple{Any, Any, Any}\n\n\nRecover OCP costate and constraints multipliers from DOCP multipliers\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.parse_DOCP_solution_primal-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTDirect.parse_DOCP_solution_primal","text":"parse_DOCP_solution_primal(\n    docp,\n    solution;\n    mult_LB,\n    mult_UB\n) -> Tuple{Any, Any, Any, NTuple{6, Any}}\n\n\nRecover OCP primal variables from DOCP solution\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setPointConstraints!-Tuple{CTDirect.DOCP, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setPointConstraints!","text":"setPointConstraints!(docp::CTDirect.DOCP, c, xu, v) -> Any\n\n\nSet the boundary and variable constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Vararg{Any, 6}}","page":"CTDirect.jl","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps (+1)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Euler}, Vararg{Any, 6}}","page":"CTDirect.jl","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Vararg{Any, 6}}","page":"CTDirect.jl","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Vararg{Any, 6}}","page":"CTDirect.jl","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setWorkArray","text":"setWorkArray(docp::CTDirect.DOCP, xu, time_grid, v) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Euler}, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_control_at_time_step!-Tuple{Any, Any, CTDirect.DOCP, Any}","page":"CTDirect.jl","title":"CTDirect.set_control_at_time_step!","text":"set_control_at_time_step!(\n    xu,\n    u_init,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nSet initial guess for control variables at given time step Convention: 1 <= i <= dimNLPsteps(+1)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_initial_guess-Tuple{CTDirect.DOCP, Any, Any}","page":"CTDirect.jl","title":"CTDirect.set_initial_guess","text":"set_initial_guess(docp::CTDirect.DOCP, nlp, init) -> Any\n\n\nSet initial guess in the DOCP\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_optim_variable!-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.set_optim_variable!","text":"set_optim_variable!(xu, v_init, docp) -> Any\n\n\nSet optimization variables in the NLP variables (for initial guess)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_state_at_time_step!-Tuple{Any, Any, CTDirect.DOCP, Any}","page":"CTDirect.jl","title":"CTDirect.set_state_at_time_step!","text":"set_state_at_time_step!(\n    xu,\n    x_init,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nSet initial guess for state variables at given time step Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.solve-Tuple{Model, Vararg{Symbol}}","page":"CTDirect.jl","title":"CTDirect.solve","text":"solve(\n    ocp::Model,\n    description::Symbol...;\n    display,\n    grid_size,\n    disc_method,\n    time_grid,\n    init,\n    adnlp_backend,\n    kwargs...\n)\n\n\nSolve an OCP with a direct method\n\nArguments\n\nocp: optimal control problem as defined in CTBase\n[description]: can specifiy for instance the NLP model and / or solver (:ipopt, :madnlp or :knitro)\n\nKeyword arguments (optional)\n\ndisplay: ([true], false) will disable output if set to false\ngrid_size: number of time steps for the discretized problem ([250])\ndisc_method: discretization method ([:trapeze], :midpoint, gauss_legendre_2)\ntime_grid: explicit time grid (can be non uniform)\ninit: info for the starting guess (values or existing solution)\nadnlp_backend: backend for automatic differentiation in ADNLPModels ([:optimized], :manual, :default)\n\nAll further keywords are passed to the inner call of solve_docp\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.variables_bounds!-Tuple{CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.variables_bounds!","text":"variables_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP variable box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"","category":"page"},{"location":"dev-ctmodels.html#CTModels.jl","page":"CTModels.jl","title":"CTModels.jl","text":"","category":"section"},{"location":"dev-ctmodels.html","page":"CTModels.jl","title":"CTModels.jl","text":"The CTModels.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"dev-ctmodels.html","page":"CTModels.jl","title":"CTModels.jl","text":"flowchart TD\nB(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctbase.html'>CTBase</a>)\nM(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctmodels.html'>CTModels</a>)\nP(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctparser.html'>CTParser</a>)\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-optimalcontrol.html'>OptimalControl</a>)\nD(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctdirect.html'>CTDirect</a>)\nF(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle M fill:#FBF275","category":"page"},{"location":"dev-ctmodels.html#Index","page":"CTModels.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctmodels.html","page":"CTModels.jl","title":"CTModels.jl","text":"Pages   = [\"dev-ctmodels.md\"]\nModules = [CTModels]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctmodels.html#Documentation","page":"CTModels.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctmodels.html#Public","page":"CTModels.jl","title":"Public","text":"","category":"section"},{"location":"dev-ctmodels.html#CTModels.CTModels","page":"CTModels.jl","title":"CTModels.CTModels","text":"CTModels module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\nInterpolations\nMLStyle\nParameters\nPrettyTables\n\nList of all the exported names:\n\nplot\nplot!\n\n\n\n\n\n","category":"module"},{"location":"dev-ctmodels.html#RecipesBase.plot-Tuple{CTModels.AbstractSolution}","page":"CTModels.jl","title":"RecipesBase.plot","text":"plot(sol::CTModels.AbstractSolution; kwargs...)\n\n\nPlot a solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#Private","page":"CTModels.jl","title":"Private","text":"","category":"section"},{"location":"dev-ctmodels.html#CTModels.TimesDisc","page":"CTModels.jl","title":"CTModels.TimesDisc","text":"Type alias for a grid of times. This is used to define a discretization of time interval given to solvers.\n\njulia> const TimesDisc = Union{Times, StepRangeLen}\n\nSee also: Time, Times.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractConstraintsModel","page":"CTModels.jl","title":"CTModels.AbstractConstraintsModel","text":"abstract type AbstractConstraintsModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractControlModel","page":"CTModels.jl","title":"CTModels.AbstractControlModel","text":"abstract type AbstractControlModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractDualModel","page":"CTModels.jl","title":"CTModels.AbstractDualModel","text":"abstract type AbstractDualModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractModel","page":"CTModels.jl","title":"CTModels.AbstractModel","text":"abstract type AbstractModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractObjectiveModel","page":"CTModels.jl","title":"CTModels.AbstractObjectiveModel","text":"abstract type AbstractObjectiveModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractSolution","page":"CTModels.jl","title":"CTModels.AbstractSolution","text":"abstract type AbstractSolution\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractSolverInfos","page":"CTModels.jl","title":"CTModels.AbstractSolverInfos","text":"abstract type AbstractSolverInfos\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractStateModel","page":"CTModels.jl","title":"CTModels.AbstractStateModel","text":"abstract type AbstractStateModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractTag","page":"CTModels.jl","title":"CTModels.AbstractTag","text":"abstract type AbstractTag\n\nAbstract type for export/import functions, used to choose between JSON or JLD extensions.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractTimeGridModel","page":"CTModels.jl","title":"CTModels.AbstractTimeGridModel","text":"abstract type AbstractTimeGridModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractTimeModel","page":"CTModels.jl","title":"CTModels.AbstractTimeModel","text":"abstract type AbstractTimeModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractTimesModel","page":"CTModels.jl","title":"CTModels.AbstractTimesModel","text":"abstract type AbstractTimesModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractVariableModel","page":"CTModels.jl","title":"CTModels.AbstractVariableModel","text":"abstract type AbstractVariableModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.BolzaObjectiveModel","page":"CTModels.jl","title":"CTModels.BolzaObjectiveModel","text":"struct BolzaObjectiveModel{TM<:Function, TL<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nmayer::Function\nlagrange::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.ConstraintsDictType","page":"CTModels.jl","title":"CTModels.ConstraintsDictType","text":"Type alias for a dictionnary of constraints. This is used to store constraints before building the model.\n\njulia> const TimesDisc = Union{Times, StepRangeLen}\n\nSee also: ConstraintsModel, PreModel and Model.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.ConstraintsModel","page":"CTModels.jl","title":"CTModels.ConstraintsModel","text":"struct ConstraintsModel{TP<:Tuple, TB<:Tuple, TS<:Tuple, TC<:Tuple, TV<:Tuple} <: CTModels.AbstractConstraintsModel\n\nFields\n\npath_nl::Tuple\nboundary_nl::Tuple\nstate_box::Tuple\ncontrol_box::Tuple\nvariable_box::Tuple\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.ControlModel","page":"CTModels.jl","title":"CTModels.ControlModel","text":"struct ControlModel <: CTModels.AbstractControlModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.ControlModelSolution","page":"CTModels.jl","title":"CTModels.ControlModelSolution","text":"struct ControlModelSolution{TS<:Function} <: CTModels.AbstractControlModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Function\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.Dimension","page":"CTModels.jl","title":"CTModels.Dimension","text":"Type alias for a dimension. This is used to define the dimension of the state space,  the costate space, the control space, etc.\n\njulia> const Dimension = Integer\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.DualModel","page":"CTModels.jl","title":"CTModels.DualModel","text":"struct DualModel{PC_Dual<:Union{Nothing, Function}, BC_Dual<:Union{Nothing, AbstractVector{<:Real}}, SC_LB_Dual<:Union{Nothing, Function}, SC_UB_Dual<:Union{Nothing, Function}, CC_LB_Dual<:Union{Nothing, Function}, CC_UB_Dual<:Union{Nothing, Function}, VC_LB_Dual<:Union{Nothing, AbstractVector{<:Real}}, VC_UB_Dual<:Union{Nothing, AbstractVector{<:Real}}} <: CTModels.AbstractDualModel\n\nFields\n\npath_constraints_dual::Union{Nothing, Function}\nboundary_constraints_dual::Union{Nothing, AbstractVector{<:Real}}\nstate_constraints_lb_dual::Union{Nothing, Function}\nstate_constraints_ub_dual::Union{Nothing, Function}\ncontrol_constraints_lb_dual::Union{Nothing, Function}\ncontrol_constraints_ub_dual::Union{Nothing, Function}\nvariable_constraints_lb_dual::Union{Nothing, AbstractVector{<:Real}}\nvariable_constraints_ub_dual::Union{Nothing, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.EmptyTimeGridModel","page":"CTModels.jl","title":"CTModels.EmptyTimeGridModel","text":"struct EmptyTimeGridModel <: CTModels.AbstractTimeGridModel\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.EmptyVariableModel","page":"CTModels.jl","title":"CTModels.EmptyVariableModel","text":"struct EmptyVariableModel <: CTModels.AbstractVariableModel\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.FixedTimeModel","page":"CTModels.jl","title":"CTModels.FixedTimeModel","text":"struct FixedTimeModel{T<:Real} <: CTModels.AbstractTimeModel\n\nFields\n\ntime::Real\nname::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.FreeTimeModel","page":"CTModels.jl","title":"CTModels.FreeTimeModel","text":"struct FreeTimeModel <: CTModels.AbstractTimeModel\n\nFields\n\nindex::Int64\nname::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.Init","page":"CTModels.jl","title":"CTModels.Init","text":"Initial guess for OCP, contains\n\nfunctions of time for the state and control variables\nvector for optimization variables\n\nInitialization data for each field can be left to default or: \n\nvector for optimization variables\nconstant / vector / function for state and control  \nexisting solution ('warm start') for all fields\n\nConstructors:\n\nInit(): default initialization\nInit(state, control, variable, time): constant vector, function handles and / or matrices / vectors interpolated along given time grid\nInit(sol): from existing solution\n\nExamples\n\njulia> init = Init()\njulia> init = Init(state=[0.1, 0.2], control=0.3)\njulia> init = Init(state=[0.1, 0.2], control=0.3, variable=0.5)\njulia> init = Init(state=[0.1, 0.2], controlt=t->sin(t), variable=0.5)\njulia> init = Init(state=[[0, 0], [1, 2], [5, -1]], time=[0, .3, 1.], controlt=t->sin(t))\njulia> init = Init(sol)\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.JLD2Tag","page":"CTModels.jl","title":"CTModels.JLD2Tag","text":"struct JLD2Tag <: CTModels.AbstractTag\n\nJLD tag for export/import functions.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.JSON3Tag","page":"CTModels.jl","title":"CTModels.JSON3Tag","text":"struct JSON3Tag <: CTModels.AbstractTag\n\nJSON tag for export/import functions.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.LagrangeObjectiveModel","page":"CTModels.jl","title":"CTModels.LagrangeObjectiveModel","text":"struct LagrangeObjectiveModel{TL<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nlagrange::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.MayerObjectiveModel","page":"CTModels.jl","title":"CTModels.MayerObjectiveModel","text":"struct MayerObjectiveModel{TM<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nmayer::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.Model","page":"CTModels.jl","title":"CTModels.Model","text":"struct Model{TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:CTModels.AbstractConstraintsModel} <: CTModels.AbstractModel\n\nFields\n\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ndynamics::Function\nobjective::CTModels.AbstractObjectiveModel\nconstraints::CTModels.AbstractConstraintsModel\ndefinition::Expr\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.PreModel","page":"CTModels.jl","title":"CTModels.PreModel","text":"mutable struct PreModel <: CTModels.AbstractModel\n\nFields\n\ntimes::Union{Nothing, CTModels.AbstractTimesModel}: Default: nothing\nstate::Union{Nothing, CTModels.AbstractStateModel}: Default: nothing\ncontrol::Union{Nothing, CTModels.AbstractControlModel}: Default: nothing\nvariable::CTModels.AbstractVariableModel: Default: EmptyVariableModel()\ndynamics::Union{Nothing, Function}: Default: nothing\nobjective::Union{Nothing, CTModels.AbstractObjectiveModel}: Default: nothing\nconstraints::OrderedCollections.OrderedDict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}: Default: ConstraintsDictType()\ndefinition::Union{Nothing, Expr}: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.Solution","page":"CTModels.jl","title":"CTModels.Solution","text":"struct Solution{TimeGridModelType<:CTModels.AbstractTimeGridModel, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, CostateModelType<:Function, ObjectiveValueType<:Real, DualModelType<:CTModels.AbstractDualModel, SolverInfosType<:CTModels.AbstractSolverInfos} <: CTModels.AbstractSolution\n\nFields\n\ntime_grid::CTModels.AbstractTimeGridModel\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ncostate::Function\nobjective::Real\ndual::CTModels.AbstractDualModel\nsolver_infos::CTModels.AbstractSolverInfos\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.SolverInfos","page":"CTModels.jl","title":"CTModels.SolverInfos","text":"struct SolverInfos{TI<:Dict{Symbol, Any}} <: CTModels.AbstractSolverInfos\n\nFields\n\niterations::Int64\nstopping::Symbol\nmessage::String\nsuccess::Bool\nconstraints_violation::Float64\ninfos::Dict{Symbol, Any}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.StateModel","page":"CTModels.jl","title":"CTModels.StateModel","text":"struct StateModel <: CTModels.AbstractStateModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.StateModelSolution","page":"CTModels.jl","title":"CTModels.StateModelSolution","text":"struct StateModelSolution{TS<:Function} <: CTModels.AbstractStateModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Function\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.Time","page":"CTModels.jl","title":"CTModels.Time","text":"Type alias for a time.\n\njulia> const Time = ctNumber\n\nSee also: ctNumber, Times, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.TimeGridModel","page":"CTModels.jl","title":"CTModels.TimeGridModel","text":"struct TimeGridModel{T<:Union{StepRangeLen, AbstractVector{<:Real}}} <: CTModels.AbstractTimeGridModel\n\nFields\n\nvalue::Union{StepRangeLen, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.Times","page":"CTModels.jl","title":"CTModels.Times","text":"Type alias for a vector of times.\n\njulia> const Times = AbstractVector{<:Time}\n\nSee also: Time, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.TimesModel","page":"CTModels.jl","title":"CTModels.TimesModel","text":"struct TimesModel{TI<:CTModels.AbstractTimeModel, TF<:CTModels.AbstractTimeModel} <: CTModels.AbstractTimesModel\n\nFields\n\ninitial::CTModels.AbstractTimeModel\nfinal::CTModels.AbstractTimeModel\ntime_name::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.VariableModel","page":"CTModels.jl","title":"CTModels.VariableModel","text":"struct VariableModel <: CTModels.AbstractVariableModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.VariableModelSolution","page":"CTModels.jl","title":"CTModels.VariableModelSolution","text":"struct VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}} <: CTModels.AbstractVariableModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Union{Real, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.ctNumber","page":"CTModels.jl","title":"CTModels.ctNumber","text":"Type alias for a real number.\n\njulia> const ctNumber = Real\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.ctVector","page":"CTModels.jl","title":"CTModels.ctVector","text":"Type alias for a vector of real numbers.\n\njulia> const ctVector = AbstractVector{<:ctNumber}\n\nSee also: ctNumber.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#Base.isempty-Tuple{CTModels.ConstraintsModel}","page":"CTModels.jl","title":"Base.isempty","text":"isempty(model::CTModels.ConstraintsModel) -> Bool\n\n\nReturn if the constraints model is empty or not.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTModels.PreModel}","page":"CTModels.jl","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::CTModels.PreModel\n)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTModels.Solution}","page":"CTModels.jl","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    sol::CTModels.Solution\n)\n\n\nPrints the solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Model}","page":"CTModels.jl","title":"Base.show","text":"show(io::IO, _::MIME{Symbol(\"text/plain\")}, ocp::Model)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#Base.show_default-Tuple{IO, CTModels.PreModel}","page":"CTModels.jl","title":"Base.show_default","text":"show_default(io::IO, ocp::CTModels.PreModel)\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#Base.show_default-Tuple{IO, CTModels.Solution}","page":"CTModels.jl","title":"Base.show_default","text":"show_default(io::IO, sol::CTModels.Solution)\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__constraint!-Tuple{OrderedCollections.OrderedDict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}, Symbol, Int64, Int64, Int64}","page":"CTModels.jl","title":"CTModels.__constraint!","text":"__constraint!(\n    ocp_constraints::OrderedCollections.OrderedDict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}},\n    type::Symbol,\n    n::Int64,\n    m::Int64,\n    q::Int64;\n    rg,\n    f,\n    lb,\n    ub,\n    label\n)\n\n\nAdd a constraint to a dictionary of constraints.\n\nArguments\n\nocp_constraints: The dictionary of constraints to which the constraint will be added.\ntype: The type of the constraint. It can be :state, :control, :variable, :boundary or :path.\nn: The dimension of the state.\nm: The dimension of the control.\nq: The dimension of the variable.\nrg: The range of the constraint. It can be an integer or a range of integers.\nf: The function that defines the constraint. It must return a vector of the same dimension as the constraint.\nlb: The lower bound of the constraint. It can be a number or a vector.\nub: The upper bound of the constraint. It can be a number or a vector.\nlabel: The label of the constraint. It must be unique in the dictionary of constraints.\n\nRequirements\n\nThe constraint must not be set before.\nThe lower bound lb and the upper bound ub cannot be both nothing.\nThe lower bound lb and the upper bound ub must have the same length, if both provided.\n\nIf rg and f are not provided then, \n\ntype must be :state, :control or :variable\nlb and ub must be of dimension n, m or q respectively, when provided.\n\nIf rg is provided, then:\n\nf must not be provided.\ntype must be :state, :control or :variable.\nrg must be a range of integers, and must be contained in 1:n, 1:m or 1:q respectively.\n\nIf f is provided, then:\n\nrg must not be provided.\ntype must be :boundary or :path.\nf must be a function that returns a vector of the same dimension as the constraint.\nlb and ub must be of the same dimension as the output of f, when provided.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__constraint_label-Tuple{}","page":"CTModels.jl","title":"CTModels.__constraint_label","text":"__constraint_label() -> Symbol\n\n\nUsed to set the default value of the label of a constraint. A unique value is given to each constraint using the gensym function and prefixing by :unamed.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__constraints-Tuple{}","page":"CTModels.jl","title":"CTModels.__constraints","text":"__constraints()\n\n\nUsed to set the default value for the constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__control_components-Tuple{Int64, String}","page":"CTModels.jl","title":"CTModels.__control_components","text":"__control_components(\n    m::Int64,\n    name::String\n) -> Vector{String}\n\n\nUsed to set the default value of the names of the controls. The default value is [\"u\"] for a one dimensional control, and [\"u‚ÇÅ\", \"u‚ÇÇ\", ...] for a multi dimensional control.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__control_name-Tuple{}","page":"CTModels.jl","title":"CTModels.__control_name","text":"__control_name() -> String\n\n\nUsed to set the default value of the names of the control. The default value is \"u\".\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__criterion_type-Tuple{}","page":"CTModels.jl","title":"CTModels.__criterion_type","text":"__criterion_type() -> Symbol\n\n\nUsed to set the default value of the type of criterion. Either :min or :max. The default value is :min. The other possible criterion type is :max.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__format-Tuple{}","page":"CTModels.jl","title":"CTModels.__format","text":"__format() -> Symbol\n\n\nUsed to set the default value of the format of the file to be used for export and import.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_consistent-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_consistent","text":"__is_consistent(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_control_set-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_control_set","text":"__is_control_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_control_set-Tuple{Model}","page":"CTModels.jl","title":"CTModels.__is_control_set","text":"__is_control_set(ocp::Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_definition_set-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_definition_set","text":"__is_definition_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_definition_set-Tuple{Model}","page":"CTModels.jl","title":"CTModels.__is_definition_set","text":"__is_definition_set(ocp::Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_dynamics_set-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_dynamics_set","text":"__is_dynamics_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_dynamics_set-Tuple{Model}","page":"CTModels.jl","title":"CTModels.__is_dynamics_set","text":"__is_dynamics_set(ocp::Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_empty-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_empty","text":"__is_empty(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_objective_set-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_objective_set","text":"__is_objective_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_objective_set-Tuple{Model}","page":"CTModels.jl","title":"CTModels.__is_objective_set","text":"__is_objective_set(ocp::Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_state_set-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_state_set","text":"__is_state_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_state_set-Tuple{Model}","page":"CTModels.jl","title":"CTModels.__is_state_set","text":"__is_state_set(ocp::Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_times_set-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_times_set","text":"__is_times_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_times_set-Tuple{Model}","page":"CTModels.jl","title":"CTModels.__is_times_set","text":"__is_times_set(ocp::Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_variable_set-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_variable_set","text":"__is_variable_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_variable_set-Tuple{Model}","page":"CTModels.jl","title":"CTModels.__is_variable_set","text":"__is_variable_set(ocp::Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__matrix_dimension_storage-Tuple{}","page":"CTModels.jl","title":"CTModels.__matrix_dimension_storage","text":"__matrix_dimension_storage() -> Int64\n\n\nUsed to set the default value of the storage of elements in a matrix. The default value is 1.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__state_components-Tuple{Int64, String}","page":"CTModels.jl","title":"CTModels.__state_components","text":"__state_components(n::Int64, name::String) -> Vector{String}\n\n\nUsed to set the default value of the names of the states. The default value is [\"x\"] for a one dimensional state, and [\"x‚ÇÅ\", \"x‚ÇÇ\", ...] for a multi dimensional state.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__state_name-Tuple{}","page":"CTModels.jl","title":"CTModels.__state_name","text":"__state_name() -> String\n\n\nUsed to set the default value of the name of the state. The default value is \"x\".\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__time_name-Tuple{}","page":"CTModels.jl","title":"CTModels.__time_name","text":"__time_name() -> String\n\n\nUsed to set the default value of the name of the time. The default value is t.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__variable_components-Tuple{Int64, String}","page":"CTModels.jl","title":"CTModels.__variable_components","text":"__variable_components(\n    q::Int64,\n    name::String\n) -> Vector{String}\n\n\nUsed to set the default value of the names of the variables. The default value is [\"v\"] for a one dimensional variable, and [\"v‚ÇÅ\", \"v‚ÇÇ\", ...] for a multi dimensional variable.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__variable_name-Tuple{Int64}","page":"CTModels.jl","title":"CTModels.__variable_name","text":"__variable_name(q::Int64) -> String\n\n\nUsed to set the default value of the names of the variables. The default value is \"v\".\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.boundary_constraints_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.boundary_constraints_dual","text":"boundary_constraints_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\nReturn the dual of the boundary constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.boundary_constraints_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, BC_Dual}}, Tuple{BC_Dual}} where BC_Dual<:Union{Nothing, AbstractVector{<:Real}}","page":"CTModels.jl","title":"CTModels.boundary_constraints_dual","text":"boundary_constraints_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, BC_Dual<:Union{Nothing, AbstractVector{<:Real}}}\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.boundary_constraints_nl-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, TB}}, Tuple{TB}} where TB","page":"CTModels.jl","title":"CTModels.boundary_constraints_nl","text":"boundary_constraints_nl(\n    model::CTModels.ConstraintsModel{<:Tuple, TB}\n) -> Any\n\n\nGet the nonlinear boundary constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.boundary_constraints_nl-Union{Tuple{Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, TB}}}, Tuple{TB}} where TB<:Tuple","page":"CTModels.jl","title":"CTModels.boundary_constraints_nl","text":"boundary_constraints_nl(\n    ocp::Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, TB<:Tuple}}\n) -> Any\n\n\nGet the nonlinear boundary constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.buildFunctionalInit-Tuple{Any, Any, Any}","page":"CTModels.jl","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(data, time, dim) -> CTModels.var\"#25#26\"\n\n\nBuild functional initialization: general interpolation case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.buildFunctionalInit-Tuple{Function, Any, Any}","page":"CTModels.jl","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Function,\n    time,\n    dim\n) -> CTModels.var\"#27#28\"{<:Function}\n\n\nBuild functional initialization: function case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.buildFunctionalInit-Tuple{Nothing, Any, Any}","page":"CTModels.jl","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Nothing,\n    time,\n    dim\n) -> CTModels.var\"#25#26\"\n\n\nBuild functional initialization: default case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.buildFunctionalInit-Tuple{Union{Real, AbstractVector{<:Real}}, Any, Any}","page":"CTModels.jl","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Union{Real, AbstractVector{<:Real}},\n    time,\n    dim\n) -> Union{CTModels.var\"#29#31\", CTModels.var\"#30#32\"}\n\n\nBuild functional initialization: constant / 1D interpolation\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.buildVectorInit-Tuple{Any, Any}","page":"CTModels.jl","title":"CTModels.buildVectorInit","text":"buildVectorInit(data, dim) -> Any\n\n\nBuild vector initialization: default / vector case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.build_constraints-Tuple{OrderedCollections.OrderedDict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}}","page":"CTModels.jl","title":"CTModels.build_constraints","text":"build_constraints(\n    constraints::OrderedCollections.OrderedDict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}\n) -> CTModels.ConstraintsModel{TP, TB, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}, Vector{Symbol}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}, Vector{Symbol}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}, Vector{Symbol}}} where {TP<:Tuple{Vector{Real}, Any, Vector{Real}, Vector{Symbol}}, TB<:Tuple{Vector{Real}, Any, Vector{Real}, Vector{Symbol}}}\n\n\nBuild a concrete type constraints model from a dictionary of constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.build_model-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.build_model","text":"build_model(\n    pre_ocp::CTModels.PreModel\n) -> Model{TimesModelType, StateModelType, ControlModelType, VariableModelType, DynamicsModelType, ObjectiveModelType, ConstraintsModelType} where {TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:(CTModels.ConstraintsModel{TP, TB, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}, Vector{Symbol}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}, Vector{Symbol}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}, Vector{Symbol}}} where {TP<:Tuple{Vector{Real}, Any, Vector{Real}, Vector{Symbol}}, TB<:Tuple{Vector{Real}, Any, Vector{Real}, Vector{Symbol}}})}\n\n\nBuild a concrete type model from a pre-model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.build_solution-Union{Tuple{TPCD}, Tuple{TP}, Tuple{TU}, Tuple{TX}, Tuple{Model, Vector{Float64}, TX, TU, Vector{Float64}, TP}} where {TX<:Union{Function, Matrix{Float64}}, TU<:Union{Function, Matrix{Float64}}, TP<:Union{Function, Matrix{Float64}}, TPCD<:Union{Nothing, Function, Matrix{Float64}}}","page":"CTModels.jl","title":"CTModels.build_solution","text":"build_solution(\n    ocp::Model,\n    T::Vector{Float64},\n    X::Union{Function, Matrix{Float64}},\n    U::Union{Function, Matrix{Float64}},\n    v::Vector{Float64},\n    P::Union{Function, Matrix{Float64}};\n    objective,\n    iterations,\n    constraints_violation,\n    message,\n    stopping,\n    success,\n    path_constraints_dual,\n    boundary_constraints_dual,\n    state_constraints_lb_dual,\n    state_constraints_ub_dual,\n    control_constraints_lb_dual,\n    control_constraints_ub_dual,\n    variable_constraints_lb_dual,\n    variable_constraints_ub_dual\n)\n\n\nBuild a solution from the optimal control problem, the time grid, the state, control, variable, and dual variables.\n\nArguments\n\nocp::Model: the optimal control problem.\nT::Vector{Float64}: the time grid.\nX::Matrix{Float64}: the state trajectory.\nU::Matrix{Float64}: the control trajectory.\nv::Vector{Float64}: the variable trajectory.\nP::Matrix{Float64}: the costate trajectory.\nobjective::Float64: the objective value.\niterations::Int: the number of iterations.\nconstraints_violation::Float64: the constraints violation.\nmessage::String: the message associated to the stopping criterion.\nstopping::Symbol: the stopping criterion.\nsuccess::Bool: the success status.\npath_constraints_dual::Matrix{Float64}: the dual of the path constraints.\nboundary_constraints_dual::Vector{Float64}: the dual of the boundary constraints.\nstate_constraints_lb_dual::Matrix{Float64}: the lower bound dual of the state constraints.\nstate_constraints_ub_dual::Matrix{Float64}: the upper bound dual of the state constraints.\ncontrol_constraints_lb_dual::Matrix{Float64}: the lower bound dual of the control constraints.\ncontrol_constraints_ub_dual::Matrix{Float64}: the upper bound dual of the control constraints.\nvariable_constraints_lb_dual::Vector{Float64}: the lower bound dual of the variable constraints.\nvariable_constraints_ub_dual::Vector{Float64}: the upper bound dual of the variable constraints.\n\nReturns\n\nsol::Solution: the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.checkDim-Tuple{Any, Any}","page":"CTModels.jl","title":"CTModels.checkDim","text":"checkDim(actual_dim, target_dim)\n\n\nCheck if actual dimension is equal to target dimension, error otherwise\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.components-Tuple{CTModels.ControlModelSolution}","page":"CTModels.jl","title":"CTModels.components","text":"components(\n    model::CTModels.ControlModelSolution\n) -> Vector{String}\n\n\nGet the components names of the control from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.components-Tuple{CTModels.ControlModel}","page":"CTModels.jl","title":"CTModels.components","text":"components(model::CTModels.ControlModel) -> Vector{String}\n\n\nGet the components names of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.components-Tuple{CTModels.EmptyVariableModel}","page":"CTModels.jl","title":"CTModels.components","text":"components(_::CTModels.EmptyVariableModel) -> Vector{String}\n\n\nGet the components names of the variable from the empty variable model. Return an empty vector.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.components-Tuple{CTModels.StateModelSolution}","page":"CTModels.jl","title":"CTModels.components","text":"components(\n    model::CTModels.StateModelSolution\n) -> Vector{String}\n\n\nGet the components names of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.components-Tuple{CTModels.StateModel}","page":"CTModels.jl","title":"CTModels.components","text":"components(model::CTModels.StateModel) -> Vector{String}\n\n\nGet the components names of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.components-Tuple{CTModels.VariableModelSolution}","page":"CTModels.jl","title":"CTModels.components","text":"components(\n    model::CTModels.VariableModelSolution\n) -> Vector{String}\n\n\nGet the components names of the variable from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.components-Tuple{CTModels.VariableModel}","page":"CTModels.jl","title":"CTModels.components","text":"components(model::CTModels.VariableModel) -> Vector{String}\n\n\nGet the components names of the variable from the variable model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.constraint!-Tuple{CTModels.PreModel, Symbol}","page":"CTModels.jl","title":"CTModels.constraint!","text":"constraint!(\n    ocp::CTModels.PreModel,\n    type::Symbol;\n    rg,\n    f,\n    lb,\n    ub,\n    label\n)\n\n\nAdd a constraint to a pre-model. See [__constraint!](@ref) for more details.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.constraint-Tuple{Model, Symbol}","page":"CTModels.jl","title":"CTModels.constraint","text":"constraint(\n    model::Model,\n    label::Symbol\n) -> Tuple{Symbol, Any, Any, Any}\n\n\nGet a labelled constraint from the model. Returns a tuple of the form (type, f, lb, ub) where type is the type of the constraint, f is the function of the constraint, lb is the lower bound of the constraint and ub is the upper bound of the constraint. \n\nThe function returns an exception if the label is not found in the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.constraints-Union{Tuple{Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, C}}, Tuple{C}} where C<:CTModels.AbstractConstraintsModel","page":"CTModels.jl","title":"CTModels.constraints","text":"constraints(\n    ocp::Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, C<:CTModels.AbstractConstraintsModel}\n) -> CTModels.AbstractConstraintsModel\n\n\nGet the constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.constraints_violation-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.constraints_violation","text":"constraints_violation(sol::CTModels.Solution) -> Float64\n\n\nReturn the constraints violation of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"CTModels.jl","title":"CTModels.control!","text":"control!(ocp::CTModels.PreModel, m::Int64)\ncontrol!(\n    ocp::CTModels.PreModel,\n    m::Int64,\n    name::Union{String, Symbol}\n)\ncontrol!(\n    ocp::CTModels.PreModel,\n    m::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the control dimension and possibly the names of each coordinate.\n\nnote: Note\nYou must use control! only once to set the control dimension.\n\nExamples\n\njulia> control!(ocp, 1)\njulia> control_dimension(ocp)\n1\njulia> control_components(ocp)\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> control_dimension(ocp)\n1\njulia> control_components(ocp)\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"u‚ÇÅ\", \"u‚ÇÇ\"]\n\njulia> control!(ocp, 2, :v)\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"v‚ÇÅ\", \"v‚ÇÇ\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"v‚ÇÅ\", \"v‚ÇÇ\"]\n\njulia> control!(ocp, 2, \"v\", [\"a\", \"b\"])\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"a\", \"b\"]\n\njulia> control!(ocp, 2, \"v\", [:a, :b])\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"a\", \"b\"]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.ControlModelSolution{TS}}}, Tuple{TS}} where TS<:Function","page":"CTModels.jl","title":"CTModels.control","text":"control(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.ControlModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the control (function of time) of the optimal control solution.\n\njulia> t0 = time_grid(sol)[1]\njulia> u  = control(sol)\njulia> u0 = u(t0) # control at initial time\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control-Union{Tuple{Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, T}}, Tuple{T}} where T<:CTModels.AbstractControlModel","page":"CTModels.jl","title":"CTModels.control","text":"control(\n    ocp::Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, T<:CTModels.AbstractControlModel}\n) -> CTModels.AbstractControlModel\n\n\nGet the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_components-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.control_components","text":"control_components(sol::CTModels.Solution) -> Vector{String}\n\n\nReturn the names of the components of the control of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_components-Tuple{Model}","page":"CTModels.jl","title":"CTModels.control_components","text":"control_components(ocp::Model) -> Vector{String}\n\n\nGet the components names of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_constraints_box-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}}, Tuple{TC}} where TC","page":"CTModels.jl","title":"CTModels.control_constraints_box","text":"control_constraints_box(\n    model::CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}\n) -> Any\n\n\nGet the control box constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_constraints_box-Union{Tuple{Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}}}, Tuple{TC}} where TC<:Tuple","page":"CTModels.jl","title":"CTModels.control_constraints_box","text":"control_constraints_box(\n    ocp::Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC<:Tuple}}\n) -> Any\n\n\nGet the box constraints on control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_constraints_lb_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.control_constraints_lb_dual","text":"control_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the lower bound dual of the control constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_constraints_lb_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_LB_Dual}}, Tuple{CC_LB_Dual}} where CC_LB_Dual<:Union{Nothing, Function}","page":"CTModels.jl","title":"CTModels.control_constraints_lb_dual","text":"control_constraints_lb_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_LB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_constraints_ub_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.control_constraints_ub_dual","text":"control_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the upper bound dual of the control constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_constraints_ub_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_UB_Dual}}, Tuple{CC_UB_Dual}} where CC_UB_Dual<:Union{Nothing, Function}","page":"CTModels.jl","title":"CTModels.control_constraints_ub_dual","text":"control_constraints_ub_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, CC_UB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_dimension-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.control_dimension","text":"control_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the control of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_dimension-Tuple{Model}","page":"CTModels.jl","title":"CTModels.control_dimension","text":"control_dimension(ocp::Model) -> Int64\n\n\nGet the control dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_name-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.control_name","text":"control_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the control of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_name-Tuple{Model}","page":"CTModels.jl","title":"CTModels.control_name","text":"control_name(ocp::Model) -> String\n\n\nGet the name of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.costate-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, Co}}, Tuple{Co}} where Co<:Function","page":"CTModels.jl","title":"CTModels.costate","text":"costate(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, Co<:Function}\n) -> Function\n\n\nReturn the costate of the optimal control solution.\n\njulia> t0 = time_grid(sol)[1]\njulia> p  = costate(sol)\njulia> p0 = p(t0)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.criterion-Tuple{CTModels.BolzaObjectiveModel}","page":"CTModels.jl","title":"CTModels.criterion","text":"criterion(model::CTModels.BolzaObjectiveModel) -> Symbol\n\n\nGet the criterion (:min or :max) of the Bolza objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.criterion-Tuple{CTModels.LagrangeObjectiveModel}","page":"CTModels.jl","title":"CTModels.criterion","text":"criterion(model::CTModels.LagrangeObjectiveModel) -> Symbol\n\n\nGet the criterion (:min or :max) of the Lagrange objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.criterion-Tuple{CTModels.MayerObjectiveModel}","page":"CTModels.jl","title":"CTModels.criterion","text":"criterion(model::CTModels.MayerObjectiveModel) -> Symbol\n\n\nGet the criterion (:min or :max) of the Mayer objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.criterion-Tuple{Model}","page":"CTModels.jl","title":"CTModels.criterion","text":"criterion(ocp::Model) -> Symbol\n\n\nGet the type of criterion (:min or :max) from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.ctinterpolate-Tuple{Any, Any}","page":"CTModels.jl","title":"CTModels.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn the interpolation of f at x.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.definition!-Tuple{CTModels.PreModel, Expr}","page":"CTModels.jl","title":"CTModels.definition!","text":"definition!(ocp::CTModels.PreModel, definition::Expr)\n\n\nSet the model definition of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.definition-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.definition","text":"definition(ocp::CTModels.PreModel) -> Union{Nothing, Expr}\n\n\nReturn the model definition of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.definition-Tuple{Model}","page":"CTModels.jl","title":"CTModels.definition","text":"definition(ocp::Model) -> Expr\n\n\nReturn the model definition of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_boundary_constraints_nl-Tuple{CTModels.ConstraintsModel}","page":"CTModels.jl","title":"CTModels.dim_boundary_constraints_nl","text":"dim_boundary_constraints_nl(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of nonlinear boundary constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_boundary_constraints_nl-Tuple{Model}","page":"CTModels.jl","title":"CTModels.dim_boundary_constraints_nl","text":"dim_boundary_constraints_nl(ocp::Model) -> Int64\n\n\nReturn the dimension of the boundary constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_control_constraints_box-Tuple{CTModels.ConstraintsModel}","page":"CTModels.jl","title":"CTModels.dim_control_constraints_box","text":"dim_control_constraints_box(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of control box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_control_constraints_box-Tuple{Model}","page":"CTModels.jl","title":"CTModels.dim_control_constraints_box","text":"dim_control_constraints_box(ocp::Model) -> Int64\n\n\nReturn the dimension of box constraints on control.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_path_constraints_nl-Tuple{CTModels.ConstraintsModel}","page":"CTModels.jl","title":"CTModels.dim_path_constraints_nl","text":"dim_path_constraints_nl(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of nonlinear path constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_path_constraints_nl-Tuple{Model}","page":"CTModels.jl","title":"CTModels.dim_path_constraints_nl","text":"dim_path_constraints_nl(ocp::Model) -> Int64\n\n\nReturn the dimension of nonlinear path constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_state_constraints_box-Tuple{CTModels.ConstraintsModel}","page":"CTModels.jl","title":"CTModels.dim_state_constraints_box","text":"dim_state_constraints_box(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of state box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_state_constraints_box-Tuple{Model}","page":"CTModels.jl","title":"CTModels.dim_state_constraints_box","text":"dim_state_constraints_box(ocp::Model) -> Int64\n\n\nReturn the dimension of box constraints on state.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_variable_constraints_box-Tuple{CTModels.ConstraintsModel}","page":"CTModels.jl","title":"CTModels.dim_variable_constraints_box","text":"dim_variable_constraints_box(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of variable box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_variable_constraints_box-Tuple{Model}","page":"CTModels.jl","title":"CTModels.dim_variable_constraints_box","text":"dim_variable_constraints_box(ocp::Model) -> Int64\n\n\nReturn the dimension of box constraints on variable.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dimension-Tuple{CTModels.ControlModelSolution}","page":"CTModels.jl","title":"CTModels.dimension","text":"dimension(model::CTModels.ControlModelSolution) -> Int64\n\n\nGet the control dimension from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dimension-Tuple{CTModels.ControlModel}","page":"CTModels.jl","title":"CTModels.dimension","text":"dimension(model::CTModels.ControlModel) -> Int64\n\n\nGet the control dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dimension-Tuple{CTModels.EmptyVariableModel}","page":"CTModels.jl","title":"CTModels.dimension","text":"dimension(_::CTModels.EmptyVariableModel) -> Int64\n\n\nGet the variable dimension from the empty variable model. Return 0.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dimension-Tuple{CTModels.StateModelSolution}","page":"CTModels.jl","title":"CTModels.dimension","text":"dimension(model::CTModels.StateModelSolution) -> Int64\n\n\nGet the dimension of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dimension-Tuple{CTModels.StateModel}","page":"CTModels.jl","title":"CTModels.dimension","text":"dimension(model::CTModels.StateModel) -> Int64\n\n\nGet the dimension of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dimension-Tuple{CTModels.VariableModelSolution}","page":"CTModels.jl","title":"CTModels.dimension","text":"dimension(model::CTModels.VariableModelSolution) -> Int64\n\n\nGet the variable dimension from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dimension-Tuple{CTModels.VariableModel}","page":"CTModels.jl","title":"CTModels.dimension","text":"dimension(model::CTModels.VariableModel) -> Int64\n\n\nGet the variable dimension from the variable model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dual-Tuple{CTModels.Solution, Model, Symbol}","page":"CTModels.jl","title":"CTModels.dual","text":"dual(\n    sol::CTModels.Solution,\n    model::Model,\n    label::Symbol\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dual_model-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:Real, DM}}, Tuple{DM}} where DM<:CTModels.AbstractDualModel","page":"CTModels.jl","title":"CTModels.dual_model","text":"dual_model(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:Real, DM<:CTModels.AbstractDualModel}\n) -> CTModels.AbstractDualModel\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dynamics!-Tuple{CTModels.PreModel, Function}","page":"CTModels.jl","title":"CTModels.dynamics!","text":"dynamics!(ocp::CTModels.PreModel, f::Function)\n\n\nSet the dynamics of the optimal control problem, in a pre-model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dynamics-Union{Tuple{Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, D}}, Tuple{D}} where D<:Function","page":"CTModels.jl","title":"CTModels.dynamics","text":"dynamics(\n    ocp::Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, D<:Function}\n) -> Function\n\n\nGet the dynamics from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.export_ocp_solution-Tuple","page":"CTModels.jl","title":"CTModels.export_ocp_solution","text":"export_ocp_solution(args...; format, kwargs...)\n\n\nExport a solution in JLD or JSON formats.\n\nExamples\n\njulia> CTModels.export_ocp_solution(sol; filename=\"solution\", format=:JSON)\njulia> CTModels.export_ocp_solution(sol; filename=\"solution\", format=:JLD)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.export_ocp_solution-Tuple{CTModels.JLD2Tag, Vararg{Any}}","page":"CTModels.jl","title":"CTModels.export_ocp_solution","text":"export_ocp_solution(::CTModels.JLD2Tag, args...; kwargs...)\n\n\nExport a solution in JLD format.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.export_ocp_solution-Tuple{CTModels.JSON3Tag, Vararg{Any}}","page":"CTModels.jl","title":"CTModels.export_ocp_solution","text":"export_ocp_solution(::CTModels.JSON3Tag, args...; kwargs...)\n\n\nExport a solution in JSON format.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, TF}}, Tuple{TF}} where TF<:CTModels.AbstractTimeModel","page":"CTModels.jl","title":"CTModels.final","text":"final(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, TF<:CTModels.AbstractTimeModel}\n) -> CTModels.AbstractTimeModel\n\n\nGet the final time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time-Tuple{CTModels.AbstractModel, AbstractVector}","page":"CTModels.jl","title":"CTModels.final_time","text":"final_time(\n    ocp::CTModels.AbstractModel,\n    variable::AbstractVector\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time-Tuple{CTModels.AbstractModel}","page":"CTModels.jl","title":"CTModels.final_time","text":"final_time(ocp::CTModels.AbstractModel) -> Real\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"CTModels.jl","title":"CTModels.final_time","text":"final_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the final time from the times model, from a fixed final time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time-Union{Tuple{Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FixedTimeModel{T}}}}, Tuple{T}} where T<:Real","page":"CTModels.jl","title":"CTModels.final_time","text":"final_time(\n    ocp::Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nGet the final time from the model, for a fixed final time.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time-Union{Tuple{T}, Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}, AbstractVector{T}}} where T<:Real","page":"CTModels.jl","title":"CTModels.final_time","text":"final_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the final time from the times model, from a free final time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time-Union{Tuple{T}, Tuple{Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}}, AbstractVector{T}}} where T<:Real","page":"CTModels.jl","title":"CTModels.final_time","text":"final_time(\n    ocp::Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the final time from the model, for a free final time.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time-Union{Tuple{T}, Tuple{Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}}, T}} where T<:Real","page":"CTModels.jl","title":"CTModels.final_time","text":"final_time(\n    ocp::Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}},\n    variable::Real\n) -> Real\n\n\nGet the final time from the model, for a free final time.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time_name-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.final_time_name","text":"final_time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the final time of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time_name-Tuple{CTModels.TimesModel}","page":"CTModels.jl","title":"CTModels.final_time_name","text":"final_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the final time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time_name-Tuple{Model}","page":"CTModels.jl","title":"CTModels.final_time_name","text":"final_time_name(ocp::Model) -> String\n\n\nGet the name of the final time from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.formatData-Tuple{Any}","page":"CTModels.jl","title":"CTModels.formatData","text":"formatData(data) -> Any\n\n\nConvert matrix to vector of vectors (could be expanded)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.formatTimeGrid-Tuple{Any}","page":"CTModels.jl","title":"CTModels.formatTimeGrid","text":"formatTimeGrid(time) -> Any\n\n\nConvert matrix time-grid to vector\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_fixed_final_time-Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}}","page":"CTModels.jl","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the final time is free. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_fixed_final_time-Tuple{Model}","page":"CTModels.jl","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(ocp::Model) -> Bool\n\n\nCheck if the final time is fixed.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_fixed_final_time-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"CTModels.jl","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the final time is fixed. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_fixed_initial_time-Tuple{CTModels.TimesModel{CTModels.FreeTimeModel}}","page":"CTModels.jl","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(\n    times::CTModels.TimesModel{CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the initial time is free. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_fixed_initial_time-Tuple{Model}","page":"CTModels.jl","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(ocp::Model) -> Bool\n\n\nCheck if the initial time is fixed.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_fixed_initial_time-Union{Tuple{CTModels.TimesModel{<:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"CTModels.jl","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(\n    times::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the initial time is fixed. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_free_final_time-Tuple{CTModels.TimesModel}","page":"CTModels.jl","title":"CTModels.has_free_final_time","text":"has_free_final_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_free_final_time-Tuple{Model}","page":"CTModels.jl","title":"CTModels.has_free_final_time","text":"has_free_final_time(ocp::Model) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_free_initial_time-Tuple{CTModels.TimesModel}","page":"CTModels.jl","title":"CTModels.has_free_initial_time","text":"has_free_initial_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_free_initial_time-Tuple{Model}","page":"CTModels.jl","title":"CTModels.has_free_initial_time","text":"has_free_initial_time(ocp::Model) -> Bool\n\n\nCheck if the initial time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_lagrange_cost-Tuple{CTModels.BolzaObjectiveModel}","page":"CTModels.jl","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    model::CTModels.BolzaObjectiveModel\n) -> Bool\n\n\nCheck if the Bolza objective model has a Lagrange function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_lagrange_cost-Tuple{CTModels.LagrangeObjectiveModel}","page":"CTModels.jl","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    model::CTModels.LagrangeObjectiveModel\n) -> Bool\n\n\nCheck if the Lagrange objective model has a Lagrange function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_lagrange_cost-Tuple{CTModels.MayerObjectiveModel}","page":"CTModels.jl","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    model::CTModels.MayerObjectiveModel\n) -> Bool\n\n\nCheck if the Mayer objective model has a Lagrange function. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_lagrange_cost-Tuple{Model}","page":"CTModels.jl","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(ocp::Model) -> Bool\n\n\nCheck if the model has a Lagrange cost.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_mayer_cost-Tuple{CTModels.BolzaObjectiveModel}","page":"CTModels.jl","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(model::CTModels.BolzaObjectiveModel) -> Bool\n\n\nCheck if the Bolza objective model has a Mayer function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_mayer_cost-Tuple{CTModels.LagrangeObjectiveModel}","page":"CTModels.jl","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(\n    model::CTModels.LagrangeObjectiveModel\n) -> Bool\n\n\nCheck if the Lagrange objective model has a Mayer function. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_mayer_cost-Tuple{CTModels.MayerObjectiveModel}","page":"CTModels.jl","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(model::CTModels.MayerObjectiveModel) -> Bool\n\n\nCheck if the Mayer objective model has a Mayer function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_mayer_cost-Tuple{Model}","page":"CTModels.jl","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(ocp::Model) -> Bool\n\n\nCheck if the model has a Mayer cost.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.import_ocp_solution-Tuple","page":"CTModels.jl","title":"CTModels.import_ocp_solution","text":"import_ocp_solution(args...; format, kwargs...)\n\n\nImport a solution from a JLD or JSON file.\n\nExamples\n\njulia> sol = CTModels.import_ocp_solution(ocp; filename=\"solution\", format=:JSON)\njulia> sol = CTModels.import_ocp_solution(ocp; filename=\"solution\", format=:JLD)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.import_ocp_solution-Tuple{CTModels.JLD2Tag, Vararg{Any}}","page":"CTModels.jl","title":"CTModels.import_ocp_solution","text":"import_ocp_solution(::CTModels.JLD2Tag, args...; kwargs...)\n\n\nImport a solution from a JLD file.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.import_ocp_solution-Tuple{CTModels.JSON3Tag, Vararg{Any}}","page":"CTModels.jl","title":"CTModels.import_ocp_solution","text":"import_ocp_solution(::CTModels.JSON3Tag, args...; kwargs...)\n\n\nImport a solution from a JLD file.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.index-Tuple{CTModels.FreeTimeModel}","page":"CTModels.jl","title":"CTModels.index","text":"index(model::CTModels.FreeTimeModel) -> Int64\n\n\nGet the index of the time variable from the free time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.infos-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.infos","text":"infos(sol::CTModels.Solution) -> Dict{Symbol, Any}\n\n\nReturn a dictionary of additional infos depending on the solver or nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial-Union{Tuple{CTModels.TimesModel{TI}}, Tuple{TI}} where TI<:CTModels.AbstractTimeModel","page":"CTModels.jl","title":"CTModels.initial","text":"initial(\n    model::CTModels.TimesModel{TI<:CTModels.AbstractTimeModel}\n) -> CTModels.AbstractTimeModel\n\n\nGet the initial time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial_time-Union{Tuple{CTModels.TimesModel{<:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"CTModels.jl","title":"CTModels.initial_time","text":"initial_time(\n    model::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the initial time from the times model, from a fixed initial time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial_time-Union{Tuple{Model{<:CTModels.TimesModel{CTModels.FixedTimeModel{T}}}}, Tuple{T}} where T<:Real","page":"CTModels.jl","title":"CTModels.initial_time","text":"initial_time(\n    ocp::Model{<:CTModels.TimesModel{CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nGet the initial time from the model, for a fixed initial time.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial_time-Union{Tuple{T}, Tuple{CTModels.TimesModel{CTModels.FreeTimeModel}, AbstractVector{T}}} where T<:Real","page":"CTModels.jl","title":"CTModels.initial_time","text":"initial_time(\n    model::CTModels.TimesModel{CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the initial time from the times model, from a free initial time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial_time-Union{Tuple{T}, Tuple{Model{<:CTModels.TimesModel{CTModels.FreeTimeModel}}, AbstractVector{T}}} where T<:Real","page":"CTModels.jl","title":"CTModels.initial_time","text":"initial_time(\n    ocp::Model{<:CTModels.TimesModel{CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the initial time from the model, for a free initial time.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial_time-Union{Tuple{T}, Tuple{Model{<:CTModels.TimesModel{CTModels.FreeTimeModel}}, T}} where T<:Real","page":"CTModels.jl","title":"CTModels.initial_time","text":"initial_time(\n    ocp::Model{<:CTModels.TimesModel{CTModels.FreeTimeModel}},\n    variable::Real\n) -> Real\n\n\nGet the initial time from the model, for a free initial time.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial_time_name-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.initial_time_name","text":"initial_time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the initial time of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial_time_name-Tuple{CTModels.TimesModel}","page":"CTModels.jl","title":"CTModels.initial_time_name","text":"initial_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the initial time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial_time_name-Tuple{Model}","page":"CTModels.jl","title":"CTModels.initial_time_name","text":"initial_time_name(ocp::Model) -> String\n\n\nGet the name of the initial time from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.is_empty_time_grid-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.is_empty_time_grid","text":"is_empty_time_grid(sol::CTModels.Solution) -> Bool\n\n\nCheck if the time grid is empty from the solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.isaVectVect-Tuple{Any}","page":"CTModels.jl","title":"CTModels.isaVectVect","text":"isaVectVect(data) -> Bool\n\n\nReturn true if argument is a vector of vectors\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.isempty_constraints-Tuple{Model}","page":"CTModels.jl","title":"CTModels.isempty_constraints","text":"isempty_constraints(ocp::Model) -> Bool\n\n\nReturn true if the model has constraints or false if not.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.iterations-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.iterations","text":"iterations(sol::CTModels.Solution) -> Int64\n\n\nReturn the number of iterations (if solved by an iterative method) of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.lagrange-Union{Tuple{CTModels.BolzaObjectiveModel{<:Function, L}}, Tuple{L}} where L<:Function","page":"CTModels.jl","title":"CTModels.lagrange","text":"lagrange(\n    model::CTModels.BolzaObjectiveModel{<:Function, L<:Function}\n) -> Function\n\n\nGet the Lagrange function of the Bolza objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.lagrange-Union{Tuple{CTModels.LagrangeObjectiveModel{L}}, Tuple{L}} where L<:Function","page":"CTModels.jl","title":"CTModels.lagrange","text":"lagrange(\n    model::CTModels.LagrangeObjectiveModel{L<:Function}\n) -> Function\n\n\nGet the Lagrange function of the Lagrange objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.lagrange-Union{Tuple{Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{<:Function, L}}}, Tuple{L}} where L<:Function","page":"CTModels.jl","title":"CTModels.lagrange","text":"lagrange(\n    ocp::Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{<:Function, L<:Function}}\n) -> Any\n\n\nGet the Lagrange cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.lagrange-Union{Tuple{Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, CTModels.LagrangeObjectiveModel{L}}}, Tuple{L}} where L<:Function","page":"CTModels.jl","title":"CTModels.lagrange","text":"lagrange(\n    ocp::Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, CTModels.LagrangeObjectiveModel{L<:Function}}\n) -> Function\n\n\nGet the Lagrange cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.matrix2vec","page":"CTModels.jl","title":"CTModels.matrix2vec","text":"matrix2vec(A::Matrix{<:Real}) -> Vector{<:Vector{<:Real}}\nmatrix2vec(\n    A::Matrix{<:Real},\n    dim::Int64\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms A to a Vector{<:Vector{<:ctNumber}}.\n\nNote. dim ‚àà {1, 2} is the dimension along which the matrix is transformed.\n\n\n\n\n\n","category":"function"},{"location":"dev-ctmodels.html#CTModels.mayer-Union{Tuple{CTModels.BolzaObjectiveModel{M}}, Tuple{M}} where M<:Function","page":"CTModels.jl","title":"CTModels.mayer","text":"mayer(\n    model::CTModels.BolzaObjectiveModel{M<:Function}\n) -> Function\n\n\nGet the Mayer function of the Bolza objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.mayer-Union{Tuple{CTModels.MayerObjectiveModel{M}}, Tuple{M}} where M<:Function","page":"CTModels.jl","title":"CTModels.mayer","text":"mayer(\n    model::CTModels.MayerObjectiveModel{M<:Function}\n) -> Function\n\n\nGet the Mayer function of the Mayer objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.mayer-Union{Tuple{Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{M}}}, Tuple{M}} where M<:Function","page":"CTModels.jl","title":"CTModels.mayer","text":"mayer(\n    ocp::Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{M<:Function}}\n) -> Any\n\n\nGet the Mayer cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.mayer-Union{Tuple{Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.MayerObjectiveModel{M}}}, Tuple{M}} where M<:Function","page":"CTModels.jl","title":"CTModels.mayer","text":"mayer(\n    ocp::Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.MayerObjectiveModel{M<:Function}}\n) -> Any\n\n\nGet the Mayer cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.message-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.message","text":"message(sol::CTModels.Solution) -> String\n\n\nReturn the message associated to the stopping criterion of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.ControlModelSolution}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.ControlModelSolution) -> String\n\n\nGet the name of the control from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.ControlModel}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.ControlModel) -> String\n\n\nGet the name of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.EmptyVariableModel}","page":"CTModels.jl","title":"CTModels.name","text":"name(_::CTModels.EmptyVariableModel) -> String\n\n\nGet the variable name from the empty variable model. Return an empty string.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.FixedTimeModel}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.FixedTimeModel) -> String\n\n\nGet the name of the time from the fixed time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.FreeTimeModel}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.FreeTimeModel) -> String\n\n\nGet the name of the time from the free time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.StateModelSolution}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.StateModelSolution) -> String\n\n\nGet the name of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.StateModel}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.StateModel) -> String\n\n\nGet the name of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.VariableModelSolution}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.VariableModelSolution) -> String\n\n\nGet the variable name from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.VariableModel}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.VariableModel) -> String\n\n\nGet the variable name from the variable model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.objective!","page":"CTModels.jl","title":"CTModels.objective!","text":"objective!(ocp::CTModels.PreModel; ...)\nobjective!(\n    ocp::CTModels.PreModel,\n    criterion::Symbol;\n    mayer,\n    lagrange\n)\n\n\nSet the objective of the optimal control problem.\n\nArguments\n\nocp::PreModel: the optimal control problem.\ncriterion::Symbol: the type of criterion. Either :min or :max. Default is :min.\nmayer::Union{Function, Nothing}: the Mayer function (inplace). Default is nothing.\nlagrange::Union{Function, Nothing}: the Lagrange function (inplace). Default is nothing.\n\nnote: Note\nThe state, control and variable must be set before the objective.\nThe objective must not be set before.\nAt least one of the two functions must be given. Please provide a Mayer or a Lagrange function.\n\nExamples\n\n```@example julia> function mayer(x0, xf, v)            return x0[1] + xf[1] + v[1]        end juila> function lagrange(t, x, u, v)            return x[1] + u[1] + v[1]        end julia> objective!(ocp, :min, mayer=mayer, lagrange=lagrange)\n\n\n\n\n\n","category":"function"},{"location":"dev-ctmodels.html#CTModels.objective-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O}}, Tuple{O}} where O<:Real","page":"CTModels.jl","title":"CTModels.objective","text":"objective(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O<:Real}\n) -> Real\n\n\nReturn the objective value of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.objective-Union{Tuple{Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O}}, Tuple{O}} where O<:CTModels.AbstractObjectiveModel","page":"CTModels.jl","title":"CTModels.objective","text":"objective(\n    ocp::Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O<:CTModels.AbstractObjectiveModel}\n) -> CTModels.AbstractObjectiveModel\n\n\nGet the objective from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.path_constraints_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.path_constraints_dual","text":"path_constraints_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the dual of the path constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.path_constraints_dual-Union{Tuple{CTModels.DualModel{PC_Dual}}, Tuple{PC_Dual}} where PC_Dual<:Union{Nothing, Function}","page":"CTModels.jl","title":"CTModels.path_constraints_dual","text":"path_constraints_dual(\n    model::CTModels.DualModel{PC_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.path_constraints_nl-Union{Tuple{CTModels.ConstraintsModel{TP}}, Tuple{TP}} where TP","page":"CTModels.jl","title":"CTModels.path_constraints_nl","text":"path_constraints_nl(\n    model::CTModels.ConstraintsModel{TP}\n) -> Any\n\n\nGet the nonlinear path constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.path_constraints_nl-Union{Tuple{Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{TP}}}, Tuple{TP}} where TP<:Tuple","page":"CTModels.jl","title":"CTModels.path_constraints_nl","text":"path_constraints_nl(\n    ocp::Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{TP<:Tuple}}\n) -> Any\n\n\nGet the nonlinear path constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"CTModels.jl","title":"CTModels.state!","text":"state!(ocp::CTModels.PreModel, n::Int64)\nstate!(\n    ocp::CTModels.PreModel,\n    n::Int64,\n    name::Union{String, Symbol}\n)\nstate!(\n    ocp::CTModels.PreModel,\n    n::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the state dimension and possibly the names of each component.\n\nnote: Note\nYou must use state! only once to set the state dimension.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> state_dimension(ocp)\n1\njulia> state_components(ocp)\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> state_dimension(ocp)\n1\njulia> state_components(ocp)\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"x‚ÇÅ\", \"x‚ÇÇ\"]\n\njulia> state!(ocp, 2, :y)\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"y‚ÇÅ\", \"y‚ÇÇ\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"y‚ÇÅ\", \"y‚ÇÇ\"]\n\njulia> state!(ocp, 2, \"y\", [\"u\", \"v\"])\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"u\", \"v\"]\n\njulia> state!(ocp, 2, \"y\", [:u, :v])\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"u\", \"v\"]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.StateModelSolution{TS}}}, Tuple{TS}} where TS<:Function","page":"CTModels.jl","title":"CTModels.state","text":"state(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.StateModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the state (function of time) of the optimal control solution.\n\njulia> t0 = time_grid(sol)[1]\njulia> x  = state(sol)\njulia> x0 = x(t0)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state-Union{Tuple{Model{<:CTModels.TimesModel, T}}, Tuple{T}} where T<:CTModels.AbstractStateModel","page":"CTModels.jl","title":"CTModels.state","text":"state(\n    ocp::Model{<:CTModels.TimesModel, T<:CTModels.AbstractStateModel}\n) -> CTModels.AbstractStateModel\n\n\nGet the state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_components-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.state_components","text":"state_components(sol::CTModels.Solution) -> Vector{String}\n\n\nReturn the names of the components of the state of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_components-Tuple{Model}","page":"CTModels.jl","title":"CTModels.state_components","text":"state_components(ocp::Model) -> Vector{String}\n\n\nGet the components names of the state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_constraints_box-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}}, Tuple{TS}} where TS","page":"CTModels.jl","title":"CTModels.state_constraints_box","text":"state_constraints_box(\n    model::CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}\n) -> Any\n\n\nGet the state box constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_constraints_box-Union{Tuple{Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}}}, Tuple{TS}} where TS<:Tuple","page":"CTModels.jl","title":"CTModels.state_constraints_box","text":"state_constraints_box(\n    ocp::Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS<:Tuple}}\n) -> Any\n\n\nGet the box constraints on state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_constraints_lb_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.state_constraints_lb_dual","text":"state_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the lower bound dual of the state constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_constraints_lb_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, SC_LB_Dual}}, Tuple{SC_LB_Dual}} where SC_LB_Dual<:Union{Nothing, Function}","page":"CTModels.jl","title":"CTModels.state_constraints_lb_dual","text":"state_constraints_lb_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, SC_LB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_constraints_ub_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.state_constraints_ub_dual","text":"state_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, Function}\n\n\nReturn the upper bound dual of the state constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_constraints_ub_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, SC_UB_Dual}}, Tuple{SC_UB_Dual}} where SC_UB_Dual<:Union{Nothing, Function}","page":"CTModels.jl","title":"CTModels.state_constraints_ub_dual","text":"state_constraints_ub_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, SC_UB_Dual<:Union{Nothing, Function}}\n) -> Union{Nothing, Function}\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_dimension-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.state_dimension","text":"state_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the state of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_dimension-Tuple{Model}","page":"CTModels.jl","title":"CTModels.state_dimension","text":"state_dimension(ocp::Model) -> Int64\n\n\nGet the state dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_name-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.state_name","text":"state_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the state of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_name-Tuple{Model}","page":"CTModels.jl","title":"CTModels.state_name","text":"state_name(ocp::Model) -> String\n\n\nGet the name of the state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.stopping-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.stopping","text":"stopping(sol::CTModels.Solution) -> Symbol\n\n\nReturn the stopping criterion (a Symbol) of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.success-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.success","text":"success(sol::CTModels.Solution) -> Bool\n\n\nReturn the success status of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.time!-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.time!","text":"time!(ocp::CTModels.PreModel; t0, tf, ind0, indf, time_name)\n\n\nSet the initial and final times. We denote by t0 the initial time and tf the final time. The optimal control problem is denoted ocp. When a time is free, then, one must provide the corresponding index of the ocp variable.\n\nnote: Note\nYou must use time! only once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, t0=0,   tf=1  ) # Fixed t0 and fixed tf\njulia> time!(ocp, t0=0,   indf=2) # Fixed t0 and free  tf\njulia> time!(ocp, ind0=2, tf=1  ) # Free  t0 and fixed tf\njulia> time!(ocp, ind0=2, indf=3) # Free  t0 and free  tf\n\nWhen you plot a solution of an optimal control problem, the name of the time variable appears. By default, the name is \"t\". Consider you want to set the name of the time variable to \"s\".\n\njulia> time!(ocp, t0=0, tf=1, time_name=\"s\") # time_name is a String\n# or\njulia> time!(ocp, t0=0, tf=1, time_name=:s ) # time_name is a Symbol  \n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.time-Union{Tuple{CTModels.FixedTimeModel{T}}, Tuple{T}} where T<:Real","page":"CTModels.jl","title":"CTModels.time","text":"time(model::CTModels.FixedTimeModel{T<:Real}) -> Real\n\n\nGet the time from the fixed time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.time-Union{Tuple{T}, Tuple{CTModels.FreeTimeModel, AbstractVector{T}}} where T<:Real","page":"CTModels.jl","title":"CTModels.time","text":"time(\n    model::CTModels.FreeTimeModel,\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the time from the free time model.\n\nExceptions\n\nIf the index of the time variable is not in [1, length(variable)], throw an error.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.time_grid-Union{Tuple{CTModels.Solution{<:CTModels.TimeGridModel{T}}}, Tuple{T}} where T<:Union{StepRangeLen, AbstractVector{<:Real}}","page":"CTModels.jl","title":"CTModels.time_grid","text":"time_grid(\n    sol::CTModels.Solution{<:CTModels.TimeGridModel{T<:Union{StepRangeLen, AbstractVector{<:Real}}}}\n) -> Union{StepRangeLen, AbstractVector{<:Real}}\n\n\nReturn the time grid of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.time_name-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.time_name","text":"time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the time component of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.time_name-Tuple{CTModels.TimesModel}","page":"CTModels.jl","title":"CTModels.time_name","text":"time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the time variable from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.time_name-Tuple{Model}","page":"CTModels.jl","title":"CTModels.time_name","text":"time_name(ocp::Model) -> String\n\n\nGet the name of the time from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.times-Union{Tuple{Model{T}}, Tuple{T}} where T<:CTModels.TimesModel","page":"CTModels.jl","title":"CTModels.times","text":"times(\n    ocp::Model{T<:CTModels.TimesModel}\n) -> CTModels.TimesModel\n\n\nGet the times from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.to_out_of_place-Tuple{Any, Any}","page":"CTModels.jl","title":"CTModels.to_out_of_place","text":"to_out_of_place(\n    f!,\n    n;\n    T\n) -> Union{Nothing, CTModels.var\"#f#19\"{CTModels.var\"#f#18#20\"{DataType, _A, _B}} where {_A, _B}}\n\n\nTransform an in-place function f! to an out-of-place function f. The function f will return a vector of the same type as T and size n.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.value-Union{Tuple{CTModels.ControlModelSolution{TS}}, Tuple{TS}} where TS<:Function","page":"CTModels.jl","title":"CTModels.value","text":"value(\n    model::CTModels.ControlModelSolution{TS<:Function}\n) -> Function\n\n\nGet the control function value from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.value-Union{Tuple{CTModels.StateModelSolution{TS}}, Tuple{TS}} where TS<:Function","page":"CTModels.jl","title":"CTModels.value","text":"value(\n    model::CTModels.StateModelSolution{TS<:Function}\n) -> Function\n\n\nGet the state function from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.value-Union{Tuple{CTModels.VariableModelSolution{TS}}, Tuple{TS}} where TS<:Union{Real, AbstractVector{<:Real}}","page":"CTModels.jl","title":"CTModels.value","text":"value(\n    model::CTModels.VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}}\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nGet the variable from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"CTModels.jl","title":"CTModels.variable!","text":"variable!(ocp::CTModels.PreModel, q::Int64)\nvariable!(\n    ocp::CTModels.PreModel,\n    q::Int64,\n    name::Union{String, Symbol}\n)\nvariable!(\n    ocp::CTModels.PreModel,\n    q::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the variable dimension and possibly the names of each component.\n\nnote: Note\nYou can use variable! once to set the variable dimension.\n\nExamples\n\njulia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"v‚ÇÅ\", \"v‚ÇÇ\" ])\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.VariableModelSolution{TS}}}, Tuple{TS}} where TS<:Union{Real, AbstractVector{<:Real}}","page":"CTModels.jl","title":"CTModels.variable","text":"variable(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}}}\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the variable of the optimal control solution or nothing.\n\njulia> v  = variable(sol)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable-Union{Tuple{Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, T}}, Tuple{T}} where T<:CTModels.AbstractVariableModel","page":"CTModels.jl","title":"CTModels.variable","text":"variable(\n    ocp::Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, T<:CTModels.AbstractVariableModel}\n) -> CTModels.AbstractVariableModel\n\n\nGet the variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_components-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.variable_components","text":"variable_components(\n    sol::CTModels.Solution\n) -> Vector{String}\n\n\nReturn the names of the components of the variable of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_components-Tuple{Model}","page":"CTModels.jl","title":"CTModels.variable_components","text":"variable_components(ocp::Model) -> Vector{String}\n\n\nGet the components names of the variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_constraints_box-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}}, Tuple{TV}} where TV","page":"CTModels.jl","title":"CTModels.variable_constraints_box","text":"variable_constraints_box(\n    model::CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}\n) -> Any\n\n\nGet the variable box constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_constraints_box-Union{Tuple{Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}}}, Tuple{TV}} where TV<:Tuple","page":"CTModels.jl","title":"CTModels.variable_constraints_box","text":"variable_constraints_box(\n    ocp::Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV<:Tuple}}\n) -> Any\n\n\nGet the box constraints on variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_constraints_lb_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.variable_constraints_lb_dual","text":"variable_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\nReturn the lower bound dual of the variable constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_constraints_lb_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, VC_LB_Dual}}, Tuple{VC_LB_Dual}} where VC_LB_Dual<:Union{Nothing, AbstractVector{<:Real}}","page":"CTModels.jl","title":"CTModels.variable_constraints_lb_dual","text":"variable_constraints_lb_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, VC_LB_Dual<:Union{Nothing, AbstractVector{<:Real}}}\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_constraints_ub_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.variable_constraints_ub_dual","text":"variable_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\nReturn the upper bound dual of the variable constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_constraints_ub_dual-Union{Tuple{CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, VC_UB_Dual}}, Tuple{VC_UB_Dual}} where VC_UB_Dual<:Union{Nothing, AbstractVector{<:Real}}","page":"CTModels.jl","title":"CTModels.variable_constraints_ub_dual","text":"variable_constraints_ub_dual(\n    model::CTModels.DualModel{<:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, Function}, <:Union{Nothing, AbstractVector{<:Real}}, VC_UB_Dual<:Union{Nothing, AbstractVector{<:Real}}}\n) -> Union{Nothing, AbstractVector{<:Real}}\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_dimension-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.variable_dimension","text":"variable_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the variable of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_dimension-Tuple{Model}","page":"CTModels.jl","title":"CTModels.variable_dimension","text":"variable_dimension(ocp::Model) -> Int64\n\n\nGet the variable dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_name-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.variable_name","text":"variable_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the variable of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_name-Tuple{Model}","page":"CTModels.jl","title":"CTModels.variable_name","text":"variable_name(ocp::Model) -> String\n\n\nGet the name of the variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html","page":"CTModels.jl","title":"CTModels.jl","text":"","category":"page"},{"location":"dev-ctparser.html#CTParser.jl","page":"CTParser.jl","title":"CTParser.jl","text":"","category":"section"},{"location":"dev-ctparser.html","page":"CTParser.jl","title":"CTParser.jl","text":"The CTParser.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"dev-ctparser.html","page":"CTParser.jl","title":"CTParser.jl","text":"flowchart TD\nB(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctbase.html'>CTBase</a>)\nM(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctmodels.html'>CTModels</a>)\nP(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctparser.html'>CTParser</a>)\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-optimalcontrol.html'>OptimalControl</a>)\nD(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctdirect.html'>CTDirect</a>)\nF(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle P fill:#FBF275","category":"page"},{"location":"dev-ctparser.html#Index","page":"CTParser.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctparser.html","page":"CTParser.jl","title":"CTParser.jl","text":"Pages   = [\"dev-ctparser.md\"]\nModules = [CTParser]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctparser.html#Documentation","page":"CTParser.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctparser.html#Public","page":"CTParser.jl","title":"Public","text":"","category":"section"},{"location":"dev-ctparser.html#CTParser.CTParser","page":"CTParser.jl","title":"CTParser.CTParser","text":"CTParser module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\nMLStyle\nOrderedCollections\nParameters\nUnicode\n\nList of all the exported names:\n\n\n\n\n\n","category":"module"},{"location":"dev-ctparser.html#Private","page":"CTParser.jl","title":"Private","text":"","category":"section"},{"location":"dev-ctparser.html#CTParser.ParsingInfo","page":"CTParser.jl","title":"CTParser.ParsingInfo","text":"mutable struct ParsingInfo\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"dev-ctparser.html#CTParser.constraint_type-NTuple{7, Any}","page":"CTParser.jl","title":"CTParser.constraint_type","text":"constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n\n\nReturn the type constraint among :initial, :final, :boundary, :control_range, :control_fun, :state_range, :state_fun, :mixed, :variable_range, :variable_fun (:other otherwise), together with the appropriate value (range, updated expression...) Expressions like u(t0) where u is the control and t0 the initial time return :other.\n\nExample\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( yÃá(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( xÃá(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, 1)\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, 1)\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, 1)\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, 1)\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, 2)\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n:variable_fun\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n:variable_fun\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.expr_it-Tuple{Any, Any, Any}","page":"CTParser.jl","title":"CTParser.expr_it","text":"expr_it(e, _Expr, f) -> Any\n\n\nExpr iterator: apply _Expr to nodes and f to leaves of the AST.\n\nExample\n\njulia> id(e) = expr_it(e, Expr, x -> x)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.has-Tuple{Any, Any, Any}","page":"CTParser.jl","title":"CTParser.has","text":"has(e, x, t) -> Union{Missing, Bool}\n\n\nReturn true if e contains a (...x...)(t) call.\n\nExample\n\njulia> e = :( ‚à´( x[1](t)^2 + 2*u(t) ) ‚Üí min )\n:(‚à´((x[1])(t) ^ 2 + 2 * u(t)) ‚Üí min)\n\njulia> has(e, :x, :t)\ntrue\n\njulia> has(e, :u, :t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.has-Tuple{Any, Any}","page":"CTParser.jl","title":"CTParser.has","text":"has(e, e1) -> Union{Missing, Bool}\n\n\nReturn true if e contains e1.\n\nExample\n\njulia> e = :( ‚à´( x[1](t)^2 + 2*u(t) ) ‚Üí min )\n:(‚à´((x[1])(t) ^ 2 + 2 * u(t)) ‚Üí min)\n\njulia> has(e, 2)\ntrue\n\njulia> has(e, :x)\ntrue\n\njulia> has(e, :min)\ntrue\n\njulia> has(e, :( x[1](t)^2 ))\ntrue\n\njulia> !has(e, :( x[1](t)^3 ))\ntrue\n\njulia> !has(e, 3)\ntrue\n\njulia> !has(e, :max)\ntrue\n\njulia> has(:x, :x)\ntrue\n\njulia> !has(:x, 2)\ntrue\n\njulia> !has(:x, :y)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.parse!-Tuple{Any, Any, Any}","page":"CTParser.jl","title":"CTParser.parse!","text":"parse!(p, p_ocp, e; log) -> Union{Expr, LineNumberNode}\n\n\nParse the expression e and update the ParsingInfo structure p.\n\nExample\n\nparse!(p, :p_ocp, :(v ‚àà R, variable))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.replace_call-Tuple{Any, Symbol, Any, Any}","page":"CTParser.jl","title":"CTParser.replace_call","text":"replace_call(e, x::Symbol, t, y) -> Any\n\n\nReplace calls in e of the form (...x...)(t) by (...y...).\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","page":"CTParser.jl","title":"CTParser.replace_call","text":"replace_call(e, x::Vector{Symbol}, t, y) -> Any\n\n\nReplace calls in e of the form (...x1...x2...)(t) by (...y1...y2...) for all symbols x1, x2... in the vector x.\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.subs-Tuple{Any, Union{Real, Symbol}, Any}","page":"CTParser.jl","title":"CTParser.subs","text":"subs(e, e1::Union{Real, Symbol}, e2) -> Any\n\n\nSubstitute expression e1 by expression e2 in expression e.\n\nExamples\n\njulia> e = :( ‚à´( r(t)^2 + 2u‚ÇÅ(t)) ‚Üí min )\n:(‚à´(r(t) ^ 2 + 2 * u‚ÇÅ(t)) ‚Üí min)\n\njulia> subs(e, :r, :( x[1] ))\n:(‚à´((x[1])(t) ^ 2 + 2 * u‚ÇÅ(t)) ‚Üí min)\n\njulia> e = :( ‚à´( u‚ÇÅ(t)^2 + 2u‚ÇÇ(t)) ‚Üí min )\n:(‚à´(u‚ÇÅ(t) ^ 2 + 2 * u‚ÇÇ(t)) ‚Üí min)\n\njulia> for i ‚àà 1:2\n       e = subs(e, Symbol(:u, Char(8320+i)), :( u[$i] ))\n       end; e\n:(‚à´((u[1])(t) ^ 2 + 2 * (u[2])(t)) ‚Üí min)\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); subs(e, :( $x[1]($(t0)) ), :( $x0[1] ))\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.@def-Tuple{Any}","page":"CTParser.jl","title":"CTParser.@def","text":"Define an optimal control problem. One pass parsing of the definition. Can be used writing either ocp = @def begin ... end or @def ocp begin ... end. In the second case, setting log to true will display the parsing steps.\n\nExample\n\nocp = @def begin\n    tf ‚àà R, variable\n    t ‚àà [ 0, tf ], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n    tf ‚â• 0\n    -1 ‚â§ u(t) ‚â§ 1\n    q = x‚ÇÅ\n    v = x‚ÇÇ\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ‚â§ q(t) ‚â§ 5,       (1)\n    -2 ‚â§ v(t) ‚â§ 3,      (2)\n    xÃá(t) == [ v(t), u(t) ]\n    tf ‚Üí min\nend\n\n@def ocp begin\n    tf ‚àà R, variable\n    t ‚àà [ 0, tf ], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n    tf ‚â• 0\n    -1 ‚â§ u(t) ‚â§ 1\n    q = x‚ÇÅ\n    v = x‚ÇÇ\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ‚â§ q(t) ‚â§ 5,       (1)\n    -2 ‚â§ v(t) ‚â§ 3,      (2)\n    xÃá(t) == [ v(t), u(t) ]\n    tf ‚Üí min\nend true # final boolean to show parsing log\n\n\n\n\n\n","category":"macro"},{"location":"dev-ctparser.html","page":"CTParser.jl","title":"CTParser.jl","text":"","category":"page"},{"location":"dev-ctbase.html#CTBase.jl","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"section"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"The CTBase.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"flowchart TD\nB(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctbase.html'>CTBase</a>)\nM(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctmodels.html'>CTModels</a>)\nP(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctparser.html'>CTParser</a>)\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-optimalcontrol.html'>OptimalControl</a>)\nD(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctdirect.html'>CTDirect</a>)\nF(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle B fill:#FBF275","category":"page"},{"location":"dev-ctbase.html#Index","page":"CTBase.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Pages   = [\"dev-ctbase.md\"]\nModules = [CTBase]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctbase.html#Documentation","page":"CTBase.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctbase.html#Public","page":"CTBase.jl","title":"Public","text":"","category":"section"},{"location":"dev-ctbase.html#CTBase.CTBase","page":"CTBase.jl","title":"CTBase.CTBase","text":"CTBase module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\n\n\n\n\n\n","category":"module"},{"location":"dev-ctbase.html#Private","page":"CTBase.jl","title":"Private","text":"","category":"section"},{"location":"dev-ctbase.html#CTBase.DescVarArg","page":"CTBase.jl","title":"CTBase.DescVarArg","text":"DescVarArg is a Vararg of symbols. DescVarArg is a type alias for a Vararg of symbols.\n\njulia> const DescVarArg = Vararg{Symbol}\n\nSee also: Description.\n\n\n\n\n\n","category":"constant"},{"location":"dev-ctbase.html#CTBase.AmbiguousDescription","page":"CTBase.jl","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTBase.CTException\n\nException thrown when the description is ambiguous / incorrect.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}\n\nExample\n\njulia> complete(:f; descriptions=((:a, :b), (:a, :b, :c))\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.CTException","page":"CTBase.jl","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract type for exceptions.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.Description","page":"CTBase.jl","title":"CTBase.Description","text":"A description is a tuple of symbols. Description is a type alias for a tuple of symbols.\n\njulia> const Description = Tuple{DescVarArg}\n\nSee also: DescVarArg.\n\nExample\n\nBase.show is overloaded for descriptions, that is tuple of descriptions are printed as follows:\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.ExtensionError","page":"CTBase.jl","title":"CTBase.ExtensionError","text":"struct ExtensionError <: CTBase.CTException\n\nException thrown when an extension is not loaded but the user tries to call a function of it.\n\nFields\n\nweakdeps::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.IncorrectArgument","page":"CTBase.jl","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTBase.CTException\n\nException thrown when an argument is inconsistent.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.IncorrectMethod","page":"CTBase.jl","title":"CTBase.IncorrectMethod","text":"struct IncorrectMethod <: CTBase.CTException\n\nException thrown when a method is incorrect.\n\nFields\n\nvar::Symbol\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.IncorrectOutput","page":"CTBase.jl","title":"CTBase.IncorrectOutput","text":"struct IncorrectOutput <: CTBase.CTException\n\nException thrown when the output is incorrect.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.NotImplemented","page":"CTBase.jl","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTBase.CTException\n\nException thrown when a method is not implemented.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.ParsingError","page":"CTBase.jl","title":"CTBase.ParsingError","text":"struct ParsingError <: CTBase.CTException\n\nException thrown for syntax error during abstract parsing.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.UnauthorizedCall","page":"CTBase.jl","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTBase.CTException\n\nException thrown when a call to a function is not authorized.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.ctNumber","page":"CTBase.jl","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\njulia> const ctNumber = Real\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"CTBase.jl","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    descriptions::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n)\n\n\nPrint a tuple of descriptions.\n\nExample\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, CTBase.AmbiguousDescription}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.AmbiguousDescription)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, CTBase.ExtensionError}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.ExtensionError)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, CTBase.IncorrectArgument}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.IncorrectArgument)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, CTBase.IncorrectMethod}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.IncorrectMethod)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, CTBase.IncorrectOutput}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.IncorrectOutput)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, CTBase.NotImplemented}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.NotImplemented)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, CTBase.UnauthorizedCall}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.UnauthorizedCall)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, ParsingError}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::ParsingError)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__display-Tuple{}","page":"CTBase.jl","title":"CTBase.__display","text":"__display() -> Bool\n\n\nUsed to set the default value of the display argument. The default value is true, which means that the output is printed during execution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","page":"CTBase.jl","title":"CTBase.add","text":"add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nAdd the description y to the tuple of descriptions x if x does not contain y and return the new tuple of descriptions. \n\nThrow an exception (IncorrectArgument) if the description y is already contained in x.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> descriptions = add(descriptions, (:b,))\n(:a,)\n(:b,)\njulia> descriptions = add(descriptions, (:b,))\nERROR: IncorrectArgument: the description (:b,) is already in ((:a,), (:b,))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","page":"CTBase.jl","title":"CTBase.add","text":"add(\n    _::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> print(descriptions)\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.complete-Tuple{Vararg{Symbol}}","page":"CTBase.jl","title":"CTBase.complete","text":"complete(list::Symbol...; descriptions)\n\n\nReturn one description from a list of Symbols list and a set of descriptions D.  If multiple descriptions are possible, then the first one is selected.\n\nIf the list is not contained in any of the descriptions, then an exception is thrown.\n\nExample\n\njulia> D = ((:a, :b), (:a, :b, :c), (:b, :c), (:a, :c))\n(:a, :b)\n(:b, :c)\n(:a, :c)\njulia> complete(:a; descriptions=D)\n(:a, :b)\njulia> complete(:a, :c; descriptions=D)\n(:a, :b, :c)\njulia> complete((:a, :c); descriptions=D)\n(:a, :b, :c)\njulia> complete(:f; descriptions=D)\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.ctindice-Tuple{Int64}","page":"CTBase.jl","title":"CTBase.ctindice","text":"ctindice(i::Int64) -> Char\n\n\nReturn i ‚àà [0, 9] as a subscript.\n\nIf i is not in the range, an exception is thrown.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.ctindices-Tuple{Int64}","page":"CTBase.jl","title":"CTBase.ctindices","text":"ctindices(i::Int64) -> String\n\n\nReturn i > 0 as a subscript.\n\nIf i is not in the range, an exception is thrown.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.ctupperscript-Tuple{Int64}","page":"CTBase.jl","title":"CTBase.ctupperscript","text":"ctupperscript(i::Int64) -> Char\n\n\nReturn i ‚àà [0, 9] as an upperscript.\n\nIf i is not in the range, an exception is thrown.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.ctupperscripts-Tuple{Int64}","page":"CTBase.jl","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Int64) -> String\n\n\nReturn i > 0 as an upperscript.\n\nIf i is not in the range, an exception is thrown.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.remove-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Symbol}}}","page":"CTBase.jl","title":"CTBase.remove","text":"remove(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn the difference between the description x and the description y.\n\nExample\n\njulia> remove((:a, :b), (:a,))\n(:b,)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"page"},{"location":"tutorial-flow.html#manual-flow","page":"Compute flows","title":"How to compute flows","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"In this tutorial, we explain the Flow function from OptimalControl.jl package.","category":"page"},{"location":"tutorial-flow.html#Basic-usage","page":"Compute flows","title":"Basic usage","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Les us define a basic optimal control problem.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"using OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n\n    t ‚àà [ t0, tf ], time\n    x = (q, v) ‚àà R¬≤, state\n    u ‚àà R, control\n\n    x(t0) == x0\n    x(tf) == [ 0, 0 ]\n\n    xÃá(t)  == [ v(t), u(t) ]\n\n    ‚à´( 0.5u(t)^2 ) ‚Üí min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"The pseudo-Hamiltonian of this problem is","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"    H(x p u) = p_q q + p_v v + p^0 u^2 2","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"where p^0 = -1 since we are in the normal case. From the Pontryagin maximum principle, the maximising control is given in feedback form by","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"u(x p) = p_v","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"since partial^2_uu H = p^0 = - 1  0. ","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"u(x, p) = p[2]\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Actually, if (x u) is a solution of the optimal control problem,  then, the Pontryagin maximum principle tells us that there exists a costate p such that u(t) = u(x(t) p(t)) and such that the pair (x p) satisfies:","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"beginarrayl\n    dotx(t) = displaystylephantom-nabla_p H(x(t) p(t) u(x(t) p(t))) 05em\n    dotp(t) = displaystyle         - nabla_x H(x(t) p(t) u(x(t) p(t)))\nendarray","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"The Flow function aims to compute (x p) from the optimal control problem ocp and the control in  feedback form u(x, p).","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"note: Nota bene\nActually, writing z = (x p), then the pair (x p) is also solution of    dotz(t) = vecmathbfH(z(t))where mathbfH(z) = H(z u(z)) and vecmathbfH = (nabla_p mathbfH -nabla_x mathbfH). This is what is actually computed by Flow.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Let us try to get the associated flow:","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"julia> f = Flow(ocp, u)\nERROR: ExtensionError. Please make: julia> using OrdinaryDiffEq","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"As you can see, an error occured since we need the package OrdinaryDiffEq.jl. This package provides numerical integrators to compute solutions of the ordinary differential equation  dotz(t) = vecmathbfH(z(t)).","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"note: OrdinaryDiffEq.jl\nThe package OrdinaryDiffEq.jl is part of DifferentialEquations.jl. You can either use one or the other.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"using OrdinaryDiffEq\nf = Flow(ocp, u)\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Now we have the flow of the associated Hamiltonian vector field, we can use it. Some simple calculations shows that the initial covector p(0) solution of the Pontryagin maximum principle is 12 6. Let us check that integrating the flow from (t_0 x_0) = (0 -1 0) to the final time t_f we reach the target x_f = 0 0.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"p0 = [12, 6]\nxf, pf = f(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"If you prefer to get the state, costate and control trajectories at any time, you can call the flow:","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"sol = f((t0, tf), x0, p0)\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"In this case, you obtain a data that you can plot exactly like when solving the optimal control problem  with the function solve. See for instance the basic example or the  plot tutorial.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"using Plots\nplot(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"You can notice from the graph of v that the integrator has made very few steps:","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"time_grid(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"note: Time grid\nThe function time_grid returns the discretized time grid returned by the solver. In this case, the solution has been computed by numerical integration with an adaptive step-length Runge-Kutta scheme.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"To have a better visualisation (the accuracy won't change), you can provide a fine grid.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"sol = f((t0, tf), x0, p0; saveat=range(t0, tf, 100))\nplot(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"The argument saveat is an option from OrdinaryDiffEq.jl. Please check the  list of common options. For instance, one can change the integrator with the keyword argument alg or the absolute tolerance with  abstol. Note that you can set an option when declaring the flow or set an option in a particular call of the flow.  In the following example, the integrator will be BS5() and the absolute tolerance will be abstol=1e-8.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"f = Flow(ocp, u; alg=BS5(), abstol=1)   # alg=BS5(), abstol=1\nxf, pf = f(t0, x0, p0, tf; abstol=1e-8) # alg=BS5(), abstol=1e-8","category":"page"},{"location":"tutorial-flow.html#Extremals-and-trajectories","page":"Compute flows","title":"Extremals and trajectories","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"The pairs (x p) solution of the Hamitonian vector field are called extremals. We can compute some constructing the flow from the optimal control problem and the control in feedback form. Another way to compute extremals is  to define explicitely the Hamiltonian.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"H(x, p, u) = p[1] * x[2] + p[2] * u - 0.5 * u^2     # pseudo-Hamiltonian\nH(x, p) = H(x, p, u(x, p))                          # Hamiltonian\n\nz = Flow(Hamiltonian(H))\nxf, pf = z(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"You can also provide the Hamiltonian vector field.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Hv(x, p) = [x[2], p[2]], [0.0, -p[1]]     # Hamiltonian vector field\n\nz = Flow(HamiltonianVectorField(Hv))\nxf, pf = z(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Note that if you call the flow on tspan=(t0, tf), then you obtain the output solution  from OrdinaryDiffEq.jl.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"sol = z((t0, tf), x0, p0)\nxf, pf = sol(tf)[1:2], sol(tf)[3:4]","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"You can also compute trajectories from the control dynamics (x u) mapsto (v u) and a control law  t mapsto u(t).","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"u(t) = 6-12t\nx = Flow((t, x) -> [x[2], u(t)]; autonomous=false) # the vector field depends on t\nx(t0, x0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Again, giving a tspan you get an output solution from OrdinaryDiffEq.jl.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"sol = x((t0, tf), x0)\nplot(sol)","category":"page"},{"location":"tutorial-flow.html#Variable","page":"Compute flows","title":"Variable","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Let us consider an optimal control problem with a (decision / optimisation) variable.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"t0 = 0\nx0 = 0\n\nocp = @def begin\n\n    tf ‚àà R, variable             # the optimisation variable is tf\n    t ‚àà [t0, tf], time\n    x ‚àà R, state\n    u ‚àà R, control\n\n    x(t0) == x0\n    x(tf) == 1\n    \n    ·∫ã(t) == tf * u(t)\n\n    tf + 0.5‚à´(u(t)^2) ‚Üí min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"As you can see, the variable is the final time tf. Note that the dynamics depends on tf. From the Pontryagin maximum principle, the solution is given by:","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"tf = (3/2)^(1/4)\np0 = 2tf/3\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"The input arguments of the maximising control are now the state x, the costate p and the variable tf.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"u(x, p, tf) = tf * p\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Let us check that the final condition x(tf) = 1 is satisfied.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"f = Flow(ocp, u)\nxf, pf = f(t0, x0, p0, tf, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"The usage of the flow f is the following: f(t0, x0, p0, tf, v) where v is the variable. If one wants to compute the state at time t1 = 0.5, then, one must write:","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"t1 = 0.5\nx1, p1 = f(t0, x0, p0, t1, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"note: Free times\nIn the particular cases: the initial time t0 is the only variable, the final time tf is the only variable, or the initial and final times t0 and tf are the only variables and are in order v=(t0, tf), the times do not need to be repeated in the call of the flow:xf, pf = f(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Since the variable is the final time, we can make the time-reparameterisation t = s t_f to normalise the time s in 0 1.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"ocp = @def begin\n\n    tf ‚àà R, variable\n    s ‚àà [0, 1], time\n    x ‚àà R, state\n    u ‚àà R, control\n\n    x(0) == 0\n    x(1) == 1\n    \n    ·∫ã(s) == tf^2 * u(s)\n\n    tf + (0.5*tf)*‚à´(u(s)^2) ‚Üí min\n\nend\n\nf = Flow(ocp, u)\nxf, pf = f(0, x0, p0, 1, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Another possibility is to add a new state variable t_f(s). The problem has no variable anymore.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"ocp = @def begin\n\n    s ‚àà [0, 1], time\n    y = (x, tf) ‚àà R¬≤, state\n    u ‚àà R, control\n\n    x(0) == 0\n    x(1) == 1\n\n    dx = tf(s)^2 * u(s)\n    dtf = 0 * u(s) # 0\n    ·∫è(s) == [dx, dtf]\n\n    tf(1) + 0.5‚à´(tf(s) * u(s)^2) ‚Üí min\n\nend\n\nu(y, q) = y[2] * q[1]\n\nf = Flow(ocp, u)\nyf, pf = f(0, [x0, tf], [p0, 0], 1)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"danger: Bug\nNote that in the previous optimal control problem, we have dtf = 0 * u(s) instead of dtf = 0. The latter does not work.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"note: Goddard problem\nIn the Goddard problem, you may find other constructions of flows, especially for singular and boundary arcs.","category":"page"},{"location":"tutorial-flow.html#Concatenation-of-arcs","page":"Compute flows","title":"Concatenation of arcs","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"In this part, we present how to concatenate several flows. Let us consider the following problem.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"t0 =  0\ntf =  1\nx0 = -1\nxf =  0\n\n@def ocp begin\n\n    t ‚àà [ t0, tf ], time\n    x ‚àà R, state\n    u ‚àà R, control\n\n    x(t0) == x0\n    x(tf) == xf\n\n    -1 ‚â§ u(t) ‚â§ 1\n\n    xÃá(t) == -x(t) + u(t)\n\n    ‚à´( abs(u(t)) ) ‚Üí min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"From the Pontryagin maximum principle, the optimal control is a concatenation of an off arc (u=0) followed by a  positive bang arc (u=1). The initial costate is ","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"p_0 = frac1x_0 - (x_f-1) e^t_f","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"and the switching time is t_1 = -ln(p_0).","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"p0 = 1/( x0 - (xf-1) * exp(tf) )\nt1 = -log(p0)\nnothing  # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Let us define the two flows and the concatenation. Note that the concatenation of two flows is a flow.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"f0 = Flow(ocp, (x, p) -> 0)     # off arc: u = 0\nf1 = Flow(ocp, (x, p) -> 1)     # positive bang arc: u = 1\n\nf = f0 * (t1, f1)               # f0 followed by f1 whenever t ‚â• t1\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Now, we can check that the state reach the target.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"sol = f((t0, tf), x0, p0)\nplot(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"note: Goddard problem\nIn the Goddard problem, you may find more complex concatenations.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"For the moment, this concatenation is not equivalent to an exact concatenation.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"f = Flow(x ->  x)\ng = Flow(x -> -x)\n\nx0 = 1\nœÜ(t) = (f * (t/2, g))(0, x0, t)\nœà(t) = g(t/2, f(0, x0, t/2), t)\n\nprintln(\"œÜ(t) = \", abs(œÜ(1)-x0))\nprintln(\"œà(t) = \", abs(œà(1)-x0))\n\nt = range(1, 5e2, 201)\n\nplt = plot(yaxis=:log, legend=:bottomright, title=\"Comparison of concatenations\", xlabel=\"t\")\nplot!(plt, t, t->abs(œÜ(t)-x0), label=\"OptimalControl\")\nplot!(plt, t, t->abs(œà(t)-x0), label=\"Classical\")","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"","category":"page"},{"location":"tutorial-double-integrator-time.html#double-integrator-time","page":"Time mininimisation","title":"Double integrator: time minimisation","text":"","category":"section"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"The problem consists in minimising the final time t_f for the double integrator system","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) quad u(t) in -11","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"and the limit conditions","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"    x(0) = (12) quad x(t_f) = (00)","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"This problem can be interpretated as a simple model for a wagon with constant mass moving along a line without fricton.","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-double-integrator-time.html#Optimal-control-problem","page":"Time mininimisation","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"Let us define the problem","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"ocp = @def begin\n\n    tf ‚àà R,          variable\n    t ‚àà [0, tf],   time\n    x = (q, v) ‚àà R¬≤, state\n    u ‚àà R,           control\n\n    tf ‚â• 0\n    -1 ‚â§ u(t) ‚â§ 1\n\n    q(0)  == 1\n    v(0)  == 2\n    q(tf) == 0\n    v(tf) == 0\n\n    -5 ‚â§ q(t) ‚â§ 5,          (1)\n    -3 ‚â§ v(t) ‚â§ 3,          (2)\n\n    xÃá(t) == [v(t), u(t)]\n\n    tf ‚Üí min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"tip: Convergence\nIn order to ensure convergence of the direct solver, we have added the state constraints labelled (1) and (2):-5 leq q(t) leq 5quad -3 leq v(t) leq 3quad t in 0 t_f","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"note: Nota bene\nFor a comprehensive introduction to the syntax used above to define the optimal control problem, check this abstract syntax tutorial. In particular, there are non-unicode alternatives for derivatives, integrals, etc.","category":"page"},{"location":"tutorial-double-integrator-time.html#Solve-and-plot","page":"Time mininimisation","title":"Solve and plot","text":"","category":"section"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"Solve it","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"sol = solve(ocp; print_level=4)\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"and plot the solution","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"plot(sol)","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"note: Nota bene\nThe solve function has options, see the solve tutorial. You can customise the plot, see the plot tutorial.","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<img width=\"800\" alt=\"juliaopt2024\" src=\"./assets/zhejiang-2025.jpg\">","category":"page"},{"location":"zhejiang-2025.html#Solving-optimal-control-problems-in-Julia:-the-OptimalControl.jl-package","page":"Zhejiang 2025","title":"Solving optimal control problems in Julia: the OptimalControl.jl package","text":"","category":"section"},{"location":"zhejiang-2025.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://github.com/joseph-gergaud),-[Pierre-Martinon](https://github.com/PierreMartinon),-[Sophia-Sed](https://sed-sam-blog.gitlabpages.inria.fr)","page":"Zhejiang 2025","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"page"},{"location":"zhejiang-2025.html#What-it's-about","page":"Zhejiang 2025","title":"What it's about","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"subject to","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"plus boundary, control and state constraints","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"zhejiang-2025.html#OptimalControl.jl-for-trajectory-optimisation","page":"Zhejiang 2025","title":"OptimalControl.jl for trajectory optimisation","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Basic example\nGoddard problem\nOrbit transfer","category":"page"},{"location":"zhejiang-2025.html#Wrap-up","page":"Zhejiang 2025","title":"Wrap up","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"High level modelling of optimal control problems\nEfficient numerical resolution coupling direct and indirect methods\nCollection of examples","category":"page"},{"location":"zhejiang-2025.html#Future","page":"Zhejiang 2025","title":"Future","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"New applications (pace mechanics, biology, quantum mechanics and more)\nAdditional solvers: optimisation on GPU, direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions! If you like the package, please give us a star ‚≠êÔ∏è","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<a href=\"https://github.com/control-toolbox/OptimalControl.jl\"><img width=\"800\" alt=\"OptimalControl.jl\" src=\"./assets/star.jpg\"></a>","category":"page"},{"location":"zhejiang-2025.html#control-toolbox.org","page":"Zhejiang 2025","title":"control-toolbox.org","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"zhejiang-2025.html#Credits-(not-exhaustive!)","page":"Zhejiang 2025","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nIpopt.jl\nMadNLP.jl\nMLStyle.jl","category":"page"},{"location":"zhejiang-2025.html#Stand-up-for-science-2025","page":"Zhejiang 2025","title":"Stand up for science 2025","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<a href=\"https://standupforscience2025.org\"><img width=\"200\" alt=\"stand up for science 2025\" src=\"./assets/standup.jpg\"></a>","category":"page"},{"location":"zhejiang-2025.html#Acknowledgements","page":"Zhejiang 2025","title":"Acknowledgements","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Jean-Baptiste Caillau is partially funded by a France 2030 support managed by the Agence Nationale de la Recherche, under the reference ANR-23-PEIA-0004 (PDE-AI project).","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<img width=\"150\" alt=\"affiliations\" src=\"./assets/france-2030.png\">","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"","category":"page"},{"location":"dev-ctflows.html#CTFlows.jl","page":"CTFlows.jl","title":"CTFlows.jl","text":"","category":"section"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"The CTFlows.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"flowchart TD\nB(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctbase.html'>CTBase</a>)\nM(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctmodels.html'>CTModels</a>)\nP(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctparser.html'>CTParser</a>)\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-optimalcontrol.html'>OptimalControl</a>)\nD(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctdirect.html'>CTDirect</a>)\nF(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> M\nP --> B\nM --> B\nstyle F fill:#FBF275","category":"page"},{"location":"dev-ctflows.html#Index","page":"CTFlows.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Pages   = [\"dev-ctflows.md\"]\nModules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctflows.html#Documentation","page":"CTFlows.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctflows.html#Public","page":"CTFlows.jl","title":"Public","text":"","category":"section"},{"location":"dev-ctflows.html#Private","page":"CTFlows.jl","title":"Private","text":"","category":"section"},{"location":"dev-ctflows.html#CTFlows.:‚Öã-Union{Tuple{V}, Tuple{VectorField{<:Function, CTFlows.Autonomous, V}, VectorField{<:Function, CTFlows.Autonomous, V}}} where V<:CTFlows.VariableDependence","page":"CTFlows.jl","title":"CTFlows.:‚Öã","text":"‚Öã(\n    X::VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence},\n    Y::VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\n\"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, autonomous case\n\nExample\n\njulia> X = VectorField(x -> [x[2], -x[1]])\njulia> Y = VectorField(x -> [x[1], x[2]])\njulia> CTBase.:(‚Öã)(X, Y)([1, 2])\n[2, -1]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.:‚Öã-Union{Tuple{V}, Tuple{VectorField{<:Function, CTFlows.NonAutonomous, V}, VectorField{<:Function, CTFlows.NonAutonomous, V}}} where V<:CTFlows.VariableDependence","page":"CTFlows.jl","title":"CTFlows.:‚Öã","text":"‚Öã(\n    X::VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence},\n    Y::VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\n\"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, nonautonomous case\n\nExample\n\njulia> X = VectorField((t, x, v) -> [t + v[1] + v[2] + x[2], -x[1]], NonFixed, NonAutonomous)\njulia> Y = VectorField((t, x, v) ->  [v[1] + v[2] + x[1], x[2]], NonFixed, NonAutonomous)\njulia> CTBase.:(‚Öã)(X, Y)(1, [1, 2], [2, 3])\n[8, -1]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.:‚ãÖ-Tuple{Function, Function}","page":"CTFlows.jl","title":"CTFlows.:‚ãÖ","text":"‚ãÖ(\n    X::Function,\n    f::Function\n) -> CTFlows.var\"#27#29\"{VectorField{var\"#s182\", CTFlows.Autonomous, CTFlows.Fixed}, <:Function} where var\"#s182\"<:Function\n\n\nLie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable.\n\nExample\n\njulia> œÜ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (œÜ‚ãÖf)([1, 2])\n0\njulia> œÜ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (œÜ‚ãÖf)(1, [1, 2], [2, 1])\nMethodError\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.:‚ãÖ-Tuple{VectorField{<:Function, CTFlows.Autonomous}, Function}","page":"CTFlows.jl","title":"CTFlows.:‚ãÖ","text":"‚ãÖ(\n    X::VectorField{<:Function, CTFlows.Autonomous},\n    f::Function\n) -> CTFlows.var\"#27#29\"{VectorField{var\"#s2\", CTFlows.Autonomous, var\"#s1\"}, <:Function} where {var\"#s2\"<:Function, var\"#s1\"<:CTFlows.VariableDependence}\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X‚ãÖf, in autonomous case\n\nExample\n\njulia> œÜ = x -> [x[2], -x[1]]\njulia> X = VectorField(œÜ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X‚ãÖf)([1, 2])\n0\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.:‚ãÖ-Tuple{VectorField{<:Function, CTFlows.NonAutonomous}, Function}","page":"CTFlows.jl","title":"CTFlows.:‚ãÖ","text":"‚ãÖ(\n    X::VectorField{<:Function, CTFlows.NonAutonomous},\n    f::Function\n) -> CTFlows.var\"#31#33\"{VectorField{var\"#s26\", CTFlows.NonAutonomous, var\"#s2\"}, <:Function} where {var\"#s26\"<:Function, var\"#s2\"<:CTFlows.VariableDependence}\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X‚ãÖf, in nonautonomous case\n\nExample\n\njulia> œÜ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(œÜ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X‚ãÖf)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Lie-Tuple{Function, Function}","page":"CTFlows.jl","title":"CTFlows.Lie","text":"Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Union{CTFlows.var\"#27#29\"{VectorField{var\"#s2\", CTFlows.Autonomous, var\"#s1\"}, <:Function} where {var\"#s2\"<:Function, var\"#s1\"<:CTFlows.VariableDependence}, CTFlows.var\"#31#33\"{VectorField{var\"#s26\", CTFlows.NonAutonomous, var\"#s2\"}, <:Function} where {var\"#s26\"<:Function, var\"#s2\"<:CTFlows.VariableDependence}}\n\n\nLie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> œÜ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(œÜ,f)([1, 2])\n0\njulia> œÜ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(œÜ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Lie-Tuple{VectorField, Function}","page":"CTFlows.jl","title":"CTFlows.Lie","text":"Lie(\n    X::VectorField,\n    f::Function\n) -> Union{CTFlows.var\"#27#29\"{VectorField{var\"#s2\", CTFlows.Autonomous, var\"#s1\"}, <:Function} where {var\"#s2\"<:Function, var\"#s1\"<:CTFlows.VariableDependence}, CTFlows.var\"#31#33\"{VectorField{var\"#s26\", CTFlows.NonAutonomous, var\"#s2\"}, <:Function} where {var\"#s26\"<:Function, var\"#s2\"<:CTFlows.VariableDependence}}\n\n\nLie derivative of a scalar function along a vector field.\n\nExample\n\njulia> œÜ = x -> [x[2], -x[1]]\njulia> X = VectorField(œÜ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> œÜ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(œÜ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Lie-Union{Tuple{V}, Tuple{VectorField{<:Function, CTFlows.Autonomous, V}, VectorField{<:Function, CTFlows.Autonomous, V}}} where V<:CTFlows.VariableDependence","page":"CTFlows.jl","title":"CTFlows.Lie","text":"Lie(\n    X::VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence},\n    Y::VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case\n\nExample\n\njulia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Lie-Union{Tuple{V}, Tuple{VectorField{<:Function, CTFlows.NonAutonomous, V}, VectorField{<:Function, CTFlows.NonAutonomous, V}}} where V<:CTFlows.VariableDependence","page":"CTFlows.jl","title":"CTFlows.Lie","text":"Lie(\n    X::VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence},\n    Y::VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case\n\nExample\n\njulia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Lift-Tuple{Function}","page":"CTFlows.jl","title":"CTFlows.Lift","text":"Lift(\n    X::Function;\n    autonomous,\n    variable\n) -> CTFlows.var\"#19#23\"{<:Function}\n\n\nReturn the Lift of a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Lift-Tuple{VectorField}","page":"CTFlows.jl","title":"CTFlows.Lift","text":"Lift(\n    X::VectorField\n) -> HamiltonianLift{VectorField{TF, TD, VD}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\n\nReturn the HamiltonianLift of a VectorField.\n\nExample\n\njulia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Poisson-Tuple{Function, Function}","page":"CTFlows.jl","title":"CTFlows.Poisson","text":"Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Poisson-Union{Tuple{VD}, Tuple{TD}, Tuple{CTFlows.AbstractHamiltonian{TD, VD}, Function}} where {TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}","page":"CTFlows.jl","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence},\n    g::Function\n) -> Hamiltonian\n\n\nPoisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Poisson-Union{Tuple{VD}, Tuple{TD}, Tuple{Function, CTFlows.AbstractHamiltonian{TD, VD}}} where {TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}","page":"CTFlows.jl","title":"CTFlows.Poisson","text":"Poisson(\n    f::Function,\n    g::CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n) -> Hamiltonian\n\n\nPoisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Poisson-Union{Tuple{V}, Tuple{CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V}, CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V}}} where V<:CTFlows.VariableDependence","page":"CTFlows.jl","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V<:CTFlows.VariableDependence},\n    g::CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Poisson-Union{Tuple{V}, Tuple{CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V}, CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V}}} where V<:CTFlows.VariableDependence","page":"CTFlows.jl","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V<:CTFlows.VariableDependence},\n    g::CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case\n\nExample\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence}","page":"CTFlows.jl","title":"CTFlows.Poisson","text":"Poisson(\n    f::HamiltonianLift{T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence},\n    g::HamiltonianLift{T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence}\n)\n\n\nPoisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw, CTFlows.Lagrange, Real, Real, CTFlows.MixedConstraint, CTFlows.Multiplier}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw,\n    f‚Å∞::CTFlows.Lagrange,\n    p‚Å∞::Real,\n    s::Real,\n    g::CTFlows.MixedConstraint,\n    Œº::CTFlows.Multiplier\n) -> CTFlows.var\"#H#102\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}, CTFlows.Lagrange{TF2, TD2, VD2}, var\"#s182\", var\"#s1821\", CTFlows.MixedConstraint{TF3, TD3, VD3}, CTFlows.Multiplier{TF4, TD4, VD4}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence, TF2<:Function, TD2<:CTFlows.TimeDependence, VD2<:CTFlows.VariableDependence, var\"#s182\"<:Real, var\"#s1821\"<:Real, TF3<:Function, TD3<:CTFlows.TimeDependence, VD3<:CTFlows.VariableDependence, TF4<:Function, TD4<:CTFlows.TimeDependence, VD4<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ‚ãÖ f(t, x, u(t, x, p)) + s p‚Å∞ f‚Å∞(t, x, u(t, x, p)) + Œº(t, x, p) ‚ãÖ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw, CTFlows.Lagrange, Real, Real}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw,\n    f‚Å∞::CTFlows.Lagrange,\n    p‚Å∞::Real,\n    s::Real\n) -> CTFlows.var\"#H#100\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}, CTFlows.Lagrange{TF2, TD2, VD2}, <:Real, <:Real} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence, TF2<:Function, TD2<:CTFlows.TimeDependence, VD2<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ‚ãÖ f(t, x, u(t, x, p)) + s p‚Å∞ f‚Å∞(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw, CTFlows.MixedConstraint, CTFlows.Multiplier}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw,\n    g::CTFlows.MixedConstraint,\n    Œº::CTFlows.Multiplier\n) -> CTFlows.var\"#H#101\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}, CTFlows.MixedConstraint{TF2, TD2, VD2}, CTFlows.Multiplier{TF3, TD3, VD3}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence, TF2<:Function, TD2<:CTFlows.TimeDependence, VD2<:CTFlows.VariableDependence, TF3<:Function, TD3<:CTFlows.TimeDependence, VD3<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ‚ãÖ f(t, x, u(t, x, p)) + Œº(t, x, p) ‚ãÖ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw\n) -> CTFlows.var\"#98#99\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p f(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.‚àÇ‚Çú-Tuple{Any}","page":"CTFlows.jl","title":"CTFlows.‚àÇ‚Çú","text":"‚àÇ‚Çú(f) -> CTFlows.var\"#36#38\"\n\n\nPartial derivative wrt time of a function.\n\nExample\n\njulia> ‚àÇ‚Çú((t,x) -> t*x)(0,8)\n8\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.@Lie-Tuple{Expr, Any, Any}","page":"CTFlows.jl","title":"CTFlows.@Lie","text":"Macros for Poisson brackets\n\nExample\n\njulia> H0 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7]) autonomous=true variable=false\n#\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false variable=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) autonomous=true variable=true\n#\njulia> H0 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2) autonomous=false variable=true\n\n\n\n\n\n","category":"macro"},{"location":"dev-ctflows.html#CTFlows.@Lie-Tuple{Expr, Any}","page":"CTFlows.jl","title":"CTFlows.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) variable=true\n#\n\n\n\n\n\n","category":"macro"},{"location":"dev-ctflows.html#CTFlows.@Lie-Tuple{Expr}","page":"CTFlows.jl","title":"CTFlows.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\n#\njulia> F0 = VectorField((t, x) -> [t+x[1], x[2], (1-x[3])], autonomous=false)\njulia> F1 = VectorField((t, x) -> [t, -x[3], x[2]], autonomous=false)\njulia> @Lie [F0, F1](1, [1, 2, 3])\n#\njulia> F0 = VectorField((x, v) -> [x[1]+v, x[2], (1-x[3])], variable=true)\njulia> F1 = VectorField((x, v) -> [0, -x[3]-v, x[2]], variable=true)\njulia> @Lie [F0, F1]([1, 2, 3], 2)\n#\njulia> F0 = VectorField((t, x, v) -> [t+x[1]+v, x[2], (1-x[3])], autonomous=false, variable=true)\njulia> F1 = VectorField((t, x, v) -> [t, -x[3]-v, x[2]], autonomous=false, variable=true)\njulia> @Lie [F0, F1](1, [1, 2, 3], 2)\n#\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7])\n3.0\n#\njulia> H0 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2), autonomous=false)\njulia> H1 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2), autonomous=false)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7])\n#\njulia> H0 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), variable=true)\njulia> H1 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), variable=true)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2)\n#\njulia> H0 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), autonomous=false, variable=true)\njulia> H1 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), autonomous=false, variable=true)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2)\n#\n\n\n\n\n\n","category":"macro"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"","category":"page"},{"location":"tutorial-initial-guess.html#tutorial-initial-guess","page":"Set an initial guess","title":"Initial guess (or iterate) for the resolution","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"We present in this tutorial the different possibilities to provide an initial guess to solve an  optimal control problem with the OptimalControl.jl package. ","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"For the illustrations, we define the following optimal control problem.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"t0 = 0\ntf = 10\nŒ±  = 5\n\nocp = @def begin\n    t ‚àà [t0, tf], time\n    v ‚àà R, variable\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n    x(t0) == [ -1, 0 ]\n    x‚ÇÅ(tf) == 0\n    xÃá(t) == [ x‚ÇÇ(t), x‚ÇÅ(t) + Œ±*x‚ÇÅ(t)^2 + u(t) ]\n    x‚ÇÇ(tf)^2 + ‚à´( 0.5u(t)^2 ) ‚Üí min\nend\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Default-initial-guess","page":"Set an initial guess","title":"Default initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"We first solve the problem without giving an initial guess. This will default to initialize all variables to 0.1.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# solve the optimal control problem without initial guess\nsol = solve(ocp; display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Let us plot the solution of the optimal control problem.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"plot(sol; size=(600, 450))","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Note that the following formulations are equivalent to not giving an initial guess.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"sol = solve(ocp; init=nothing, display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\nsol = solve(ocp; init=(), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"tip: Interactions with an optimal control solution\nTo get the number of iterations of the solver, check the iterations function.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"To reduce the number of iterations and improve the convergence, we can give an initial guess to the solver.  This initial guess can be built from constant values, interpolated vectors, functions, or existing solutions. Except when initializing from a solution, the arguments are to be passed as a named tuple init=(state=..., control=..., variable=...) whose fields are optional. Missing fields will revert to default initialization (ie constant 0.1).","category":"page"},{"location":"tutorial-initial-guess.html#Constant-initial-guess","page":"Set an initial guess","title":"Constant initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"We first illustrate the constant initial guess, using vectors or scalars according to the dimension.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# solve the optimal control problem with initial guess with constant values\nsol = solve(ocp; init=(state=[-0.2, 0.1], control=-0.2, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Partial initializations are also valid, as shown below. Note the ending comma when a single argument is passed, since it must be a tuple.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# initialisation only on the state\nsol = solve(ocp; init=(state=[-0.2, 0.1],), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\n# initialisation only on the control\nsol = solve(ocp; init=(control=-0.2,), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\n# initialisation only on the state and the variable\nsol = solve(ocp; init=(state=[-0.2, 0.1], variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Functional-initial-guess","page":"Set an initial guess","title":"Functional initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"For the state and control, we can also provide functions of time as initial guess.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# initial guess as functions of time\nx(t) = [ -0.2t, 0.1t ]\nu(t) = -0.2t\n\nsol = solve(ocp; init=(state=x, control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Vector-initial-guess-(interpolated)","page":"Set an initial guess","title":"Vector initial guess (interpolated)","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Initialization can also be provided with vectors / matrices to be interpolated along a given time grid.  In this case the time steps must be given through an additional argument time, which can be a vector or line/column matrix. For the values to be interpolated both matrices and vectors of vectors are allowed, but the shape should be number of time steps x variable dimension. Simple vectors are also allowed for variables of dimension 1.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# initial guess as vector of points\nt_vec = LinRange(t0,tf,4)\nx_vec = [[0, 0], [-0.1, 0.3], [-0.15,0.4], [-0.3, 0.5]]\nu_vec = [0, -0.8,  -0.3, 0]\n\nsol = solve(ocp; init=(time=t_vec, state=x_vec, control=u_vec, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Note: in the free final time case, the given time grid should be consistent with the initial guess provided for the final time (in the optimization variables).","category":"page"},{"location":"tutorial-initial-guess.html#Mixed-initial-guess","page":"Set an initial guess","title":"Mixed initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"The constant, functional and vector initializations can be mixed, for instance as","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# we can mix constant values with functions of time\nsol = solve(ocp; init=(state=[-0.2, 0.1], control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\n# wa can mix every possibility\nsol = solve(ocp; init=(time=t_vec, state=x_vec, control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Solution-as-initial-guess-(warm-start)","page":"Set an initial guess","title":"Solution as initial guess (warm start)","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Finally, we can use an existing solution to provide the initial guess.  The dimensions of the state, control and optimization variable must coincide. This particular feature allows an easy implementation of discrete continuations.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# generate the initial solution\nsol_init = solve(ocp; display=false)\n\n# solve the problem using solution as initial guess\nsol = solve(ocp; init=sol_init, display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Note that you can also manually pick and choose which data to reuse from a solution, by recovering the  functions state(sol), control(sol) and the values variable(sol). For instance the following formulation is equivalent to the init=sol one.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# use a previous solution to initialise picking data\nsol = solve(ocp; \n    init = (\n        state    = state(sol), \n        control  = control(sol), \n        variable = variable(sol)\n    ), \n    display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"tip: Interactions with an optimal control solution\nPlease check state, costate, control and variable to get data from the solution. The functions state, costate and control return functions of time and variable returns a vector.","category":"page"},{"location":"tutorial-initial-guess.html#Costate-/-multipliers","page":"Set an initial guess","title":"Costate / multipliers","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"For the moment there is no option to provide an initial guess for the costate / multipliers.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"","category":"page"},{"location":"index.html#OptimalControl.jl","page":"Getting Started","title":"OptimalControl.jl","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"The OptimalControl.jl package is the root package of the control-toolbox ecosystem. The control-toolbox ecosystem gathers Julia packages for mathematical control and applications. It aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods.","category":"page"},{"location":"index.html#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"To install OptimalControl.jl, please open Julia's interactive session (known as REPL) and use the Julia package manager:","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"OptimalControl\")","category":"page"},{"location":"index.html#Basic-usage","page":"Getting Started","title":"Basic usage","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"Let us model, solve and plot a simple optimal control problem.","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots\n\nocp = @def begin\n    t ‚àà [0, 1], time\n    x ‚àà R¬≤, state\n    u ‚àà R, control\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n    xÃá(t) == [ x‚ÇÇ(t), u(t) ]\n    ‚à´( 0.5u(t)^2 ) ‚Üí min\nend\n\nsol = solve(ocp)\n\nplot(sol)","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"For more details about this problem, please check the basic example tutorial. \nFor a comprehensive introduction to the syntax used above to describe the optimal control problem, check the abstract syntax tutorial. \nThe solve function has options, see the solve tutorial.\nYou can customise the plot, see the plot tutorial.","category":"page"},{"location":"index.html#Citing-us","page":"Getting Started","title":"Citing us","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"If you use OptimalControl.jl in your work, please cite us:","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"Caillau, J.-B., Cots, O., Gergaud, J., Martinon, P., & Sed, S. OptimalControl.jl: a Julia package to model and solve optimal control problems with ODE's. doi.org/10.5281/zenodo.13336563","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"or in bibtex format:","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"@software{Caillau_OptimalControl_jl_a_Julia,\nauthor = {Caillau, Jean-Baptiste and Cots, Olivier and Gergaud, Joseph and Martinon, Pierre and Sed, Sophia},\ndoi = {10.5281/zenodo.13336563},\nlicense = {[\"MIT\"]},\ntitle = {{OptimalControl.jl: a Julia package to model and solve optimal control problems with ODE's}},\nurl = {https://control-toolbox.org/OptimalControl.jl}\n}","category":"page"},{"location":"index.html#Contributing","page":"Getting Started","title":"Contributing","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"If you think you found a bug or if you have a feature request / suggestion, feel free to open an issue. Before opening a pull request, please start an issue or a discussion on the topic. ","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"Contributions are welcomed, check out how to contribute to a Github project. If it is your first contribution, you can also check this first contribution tutorial. You can find first good issues (if any üôÇ) here. You may find other packages to contribute to at the control-toolbox organization.","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"If you want to ask a question, feel free to start a discussion here. This forum is for general discussion about this repository and the control-toolbox organization.","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"note: Note\nIf you want to add an application or a package to the control-toolbox ecosystem, please follow this set up tutorial.","category":"page"},{"location":"index.html#Reproducibility","page":"Getting Started","title":"Reproducibility","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"<details><summary>The documentation of this package was built using these direct dependencies,</summary>","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"</details>","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"</details>","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"</details>","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/control-toolbox/\" *\n                name *\n                \".jl/tree/gh-pages/v\" *\n                version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/control-toolbox/\" *\n               name *\n               \".jl/tree/gh-pages/v\" *\n               version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"","category":"page"}]
}
