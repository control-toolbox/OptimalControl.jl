var documenterSearchIndex = {"docs":
[{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<img width=\"800\" alt=\"juliaopt2024\" src=\"./assets/juliacon2024.jpg\">","category":"page"},{"location":"juliacon2024.html#Trajectory-optimisation-in-space-mechanics-with-Julia","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"","category":"section"},{"location":"juliacon2024.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Alesia-Herasimenka](https://www.uni.lu/snt-en/people/alesia-herasimenka)","page":"Trajectory optimisation in space mechanics with Julia","title":"Jean-Baptiste Caillau, Olivier Cots, Alesia Herasimenka","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil-lux.jpg\">","category":"page"},{"location":"juliacon2024.html#What-it's-about","page":"Trajectory optimisation in space mechanics with Julia","title":"What it's about","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"subject to","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"plus boundary conditions, control and state constraints","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"juliacon2024.html#OptimalControl.jl-for-trajectory-optimisation","page":"Trajectory optimisation in space mechanics with Julia","title":"OptimalControl.jl for trajectory optimisation","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Basic example\nGoddard problem\nOrbit transfer","category":"page"},{"location":"juliacon2024.html#Wrap-up","page":"Trajectory optimisation in space mechanics with Julia","title":"Wrap up","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"High level modelling of optimal control problems\nEfficient numerical resolution coupling direct and indirect methods\nCollection of examples","category":"page"},{"location":"juliacon2024.html#Future","page":"Trajectory optimisation in space mechanics with Julia","title":"Future","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"New applications (biology, space mechanics, quantum mechanics and more)\nAdditional solvers: direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions!","category":"page"},{"location":"juliacon2024.html#control-toolbox.org","page":"Trajectory optimisation in space mechanics with Julia","title":"control-toolbox.org","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"juliacon2024.html#Credits-(not-exhaustive!)","page":"Trajectory optimisation in space mechanics with Julia","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nMLStyle.jl","category":"page"},{"location":"juliacon2024.html#Acknowledgements","page":"Trajectory optimisation in space mechanics with Julia","title":"Acknowledgements","text":"","category":"section"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"Jean-Baptiste Caillau is partially funded by a France 2030 support managed by the Agence Nationale de la Recherche, under the reference ANR-23-PEIA-0004 (PDE-AI project).","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"<img width=\"200\" alt=\"affiliations\" src=\"./assets/france-2030.png\">","category":"page"},{"location":"juliacon2024.html","page":"Trajectory optimisation in space mechanics with Julia","title":"Trajectory optimisation in space mechanics with Julia","text":"","category":"page"},{"location":"tutorial-lqr-basic.html#A-simple-Linear–quadratic-regulator-example","page":"Linear–quadratic regulator","title":"A simple Linear–quadratic regulator example","text":"","category":"section"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"We consider the following Linear Quadratic Regulator (LQR) problem which consists in minimising","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"    frac12 int_0^t_f left( x_1^2(t) + x_2^2(t) + u^2(t) right)  mathrmdt ","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"subject to the constraints","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = -x_1(t) + u(t) quad u(t) in R","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"and the initial condition","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"    x(0) = (01)","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"We aim to solve this optimal control problem for different values of t_f. First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"Then, we can define the problem parameterized by the final time tf.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"x0 = [ 0\n       1 ]\n\nfunction lqr(tf)\n\n    ocp = @def begin\n        t ∈ [0, tf], time\n        x ∈ R², state\n        u ∈ R, control\n        x(0) == x0\n        ẋ(t) == [x₂(t), - x₁(t) + u(t)]\n        ∫( 0.5(x₁(t)^2 + x₂(t)^2 + u(t)^2) ) → min\n    end\n\n    return ocp\nend;\nnothing # hide","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"We solve the problem for t_f in 3 5 30.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"solutions = []   # empty list of solutions\ntfs = [3, 5, 30]\n\nfor tf ∈ tfs\n    solution = solve(lqr(tf), display=false)\n    push!(solutions, solution)\nend\nnothing # hide","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"We plot the state and control variables considering a normalized time s=(t-t_0)(t_f-t_0), thanks to the keyword argument time=:normalize of the plot function.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"plt = plot(solutions[1], time=:normalize)\nfor sol ∈ solutions[2:end]\n    plot!(plt, sol, time=:normalize)\nend\n\n# we plot only the state and control variables and we add the legend\nN = length(tfs)\npx1 = plot(plt[1], legend=false, xlabel=\"s\", ylabel=\"x₁\")\npx2 = plot(plt[2], label=reshape([\"tf = $tf\" for tf ∈ tfs], (1, N)), xlabel=\"s\", ylabel=\"x₂\")\npu  = plot(plt[5], legend=false, xlabel=\"s\", ylabel=\"u\")\n\nusing Plots.PlotMeasures # for leftmargin, bottommargin\nplot(px1, px2, pu, layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"note: Nota bene\nWe can observe that x(t_f) converges to the origin as t_f increases.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"","category":"page"},{"location":"tutorial-iss.html#tutorial-indirect-simple-shooting","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"In this tutorial we present the indirect simple shooting method on a simple example.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us start by importing the necessary packages.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using OptimalControl    # to define the optimal control problem and its flow\nusing OrdinaryDiffEq    # to get the Flow function from OptimalControl\nusing NonlinearSolve    # interface to NLE solvers\nusing MINPACK           # NLE solver: use to solve the shooting equation\nusing Plots             # to plot the solution","category":"page"},{"location":"tutorial-iss.html#Optimal-control-problem","page":"Indirect simple shooting","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us consider the following optimal control problem:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"left \n    beginarrayl\n        min displaystyle frac12 int_t_0^t_f u^2(t)  mathrmd t10em\n        dotx(t)  =  displaystyle -x(t)+alpha x^2(t)+u(t) quad  u(t) in R \n        quad t in t_0 t_f text ae 05em\n        x(t_0) = x_0 quad x(t_f) = x_f\n    endarray\nright","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"with t_0 = 0, t_f = 1, x_0 = -1, x_f = 0, alpha=15 and forall t in t_0 t_f, x(t) in R.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"const t0 = 0\nconst tf = 1\nconst x0 = -1\nconst xf = 0\nconst α  = 1.5\nocp = @def begin\n\n    t ∈ [t0, tf], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == xf\n\n    ẋ(t) == -x(t) + α * x(t)^2 + u(t)\n\n    ∫( 0.5u(t)^2 ) → min\n    \nend\nnothing # hide","category":"page"},{"location":"tutorial-iss.html#Boundary-value-problem","page":"Indirect simple shooting","title":"Boundary value problem","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"The pseudo-Hamiltonian of this problem is","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    H(xpu) = p  (-x+alpha x^2+u) + p^0 u^2 2","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"where p^0 = -1 since we are in the normal case. From the Pontryagin Maximum Principle, the maximising control is given by","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"u(x p) = p","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"since partial^2_uu H = p^0 = - 1  0. Plugging this control in feedback form into the pseudo-Hamiltonian, and considering the limit conditions, we obtain the following two-points boundary value problem (BVP).","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    left \n        beginarrayl\n            dotx(t)  = phantom- nabla_p Ht = -x(t) + alpha x^2(t) + u(x(t) p(t)) \n            = -x(t) + alpha x^2(t) + p(t) 05em\n            dotp(t)  = -           nabla_x Ht = (1 - 2 alpha x(t)) p(t)    05em\n            x(t_0)        = x_0 quad x(t_f) = x_f\n        endarray\n    right","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"where t=  (x(t)p(t)u(x(t) p(t))).","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"note: Our goal\nOur goal is to solve this (BVP). Solving (BVP) consists in solving the Pontryagin Maximum Principle which provides necessary conditions of optimality.","category":"page"},{"location":"tutorial-iss.html#Shooting-function","page":"Indirect simple shooting","title":"Shooting function","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"To achive our goal, let us first introduce the pseudo-Hamiltonian vector field","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    vecH(zu) = left( nabla_p H(zu) -nabla_x H(zu) right) quad z = (xp)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"and then denote by varphi_t_0 x_0 p_0(cdot) the solution of the following Cauchy problem","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"dotz(t) = vecH(z(t) u(z(t))) quad z(t_0) = (x_0 p_0)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Our goal becomes to solve","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"pi( varphi_t_0 x_0 p_0(t_f) ) = x_f","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"where pi(x p) = x. To compute varphi with OptimalControl.jl package, we define the flow of the associated Hamiltonian vector field by:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"u(x, p) = p\nφ = Flow(ocp, u)\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We define also the projection function on the state space.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"π((x, p)) = x\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"note: Nota bene\nActually, varphi_t_0 x_0 p_0(cdot) is also solution of    dotz(t) = vecmathbfH(z(t)) quad z(t_0) = (x_0 p_0)where mathbfH(z) = H(z u(z)) and vecmathbfH = (nabla_p mathbfH -nabla_x mathbfH). This is what is actually computed by Flow.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Now, to solve the (BVP) we introduce the shooting function:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    beginarrayrlll\n        S colon     R     longrightarrow    R \n                     p_0     longmapsto      S(p_0) = pi( varphi_t_0 x_0 p_0(t_f) ) - x_f\n    endarray","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"S(p0) = π( φ(t0, x0, p0, tf) ) - xf    # shooting function\nnothing # hide","category":"page"},{"location":"tutorial-iss.html#Resolution-of-the-shooting-equation","page":"Indirect simple shooting","title":"Resolution of the shooting equation","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"At the end, solving (BVP) is equivalent to solve S(p_0) = 0. This is what we call the indirect simple shooting method. We define an initial guess.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"ξ = [0.1]    # initial guess\nnothing # hide","category":"page"},{"location":"tutorial-iss.html#MINPACK.jl","page":"Indirect simple shooting","title":"MINPACK.jl","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We can use NonlinearSolve.jl package or, instead, MINPACK.jl to solve the shooting equation. To compute the Jacobian of the shooting function we use DifferentiationInterface.jl with ForwardDiff.jl backend.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using MINPACK\nfunction fsolve(f, j, x; kwargs...)\n    try\n        MINPACK.fsolve(f, j, x; kwargs...)\n    catch e\n        println(\"Erreur using MINPACK\")\n        println(e)\n        println(\"hybrj not supported. Replaced by hybrd even if it is not visible on the doc.\")\n        MINPACK.fsolve(f, x; kwargs...)\n    end\nend","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using DifferentiationInterface\nimport ForwardDiff\nbackend = AutoForwardDiff()\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us define the problem to solve.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"nle!  = ( s, ξ) -> s[1] = S(ξ[1])                                 # auxiliary function\njnle! = (js, ξ) -> jacobian!(nle!, similar(ξ), js, backend, ξ)    # Jacobian of nle\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We are now in position to solve the problem with the hybrj solver from MINPACK.jl through the fsolve function, providing the Jacobian. Let us solve the problem and retrieve the initial costate solution.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"indirect_sol = fsolve(nle!, jnle!, ξ; show_trace=true)    # resolution of S(p0) = 0\np0_sol = indirect_sol.x[1]                                # costate solution\nprintln(\"\\ncostate:    p0 = \", p0_sol)\nprintln(\"shoot: |S(p0)| = \", abs(S(p0_sol)), \"\\n\")","category":"page"},{"location":"tutorial-iss.html#Plot-of-the-solution","page":"Indirect simple shooting","title":"Plot of the solution","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"The solution can be plot calling first the flow.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"sol = φ((t0, tf), x0, p0_sol)\nplot(sol)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"In the indirect shooting method, the research of the optimal control is replaced by the computation of its associated extremal. This computation is equivalent to finding the initial covector solution to the shooting function. Let us plot the extremal in the phase space and the shooting function with  the solution.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"<article class=\"docstring\">\n<header>\n    <a class=\"docstring-article-toggle-button fa-solid fa-chevron-right\" href=\"javascript:;\" title=\"Expand docstring\"> </a>\n    <code>pretty_plot</code> — <span class=\"docstring-category\">Function</span>\n</header>\n<section style=\"display: none;\"><div><pre><code class=\"language-julia hljs\">using Plots.PlotMeasures\n\nfunction pretty_plot(S, p0; Np0=20, kwargs...) \n \n    # times for wavefronts\n    times = range(t0, tf, length=3)\n\n    # times for trajectories\n    tspan = range(t0, tf, length=100)\n\n    # interval of initial covector\n    p0_min = -0.5 \n    p0_max = 2 \n\n    # covector solution\n    p0_sol = p0 \n \n    # plot of the flow in phase space\n    plt_flow = plot() \n    p0s = range(p0_min, p0_max, length=Np0) \n    for i ∈ eachindex(p0s) \n        sol = φ((t0, tf), x0, p0s[i])\n        x = state(sol).(tspan)\n        p = costate(sol).(tspan)\n        label = i==1 ? \"extremals\" : false \n        plot!(plt_flow, x, p, color=:blue, label=label) \n    end \n \n    # plot of wavefronts in phase space \n    p0s = range(p0_min, p0_max, length=200) \n    xs  = zeros(length(p0s), length(times)) \n    ps  = zeros(length(p0s), length(times)) \n    for i ∈ eachindex(p0s) \n        sol = φ((t0, tf), x0, p0s[i], saveat=times)\n        xs[i, :] .= state(sol).(times) \n        ps[i, :] .= costate(sol).(times) \n    end \n    for j ∈ eachindex(times) \n        label = j==1 ? \"flow at times\" : false \n        plot!(plt_flow, xs[:, j], ps[:, j], color=:green, linewidth=2, label=label) \n    end \n \n    #  \n    plot!(plt_flow, xlims=(-1.1, 1), ylims=(p0_min, p0_max)) \n    plot!(plt_flow, [0, 0], [p0_min, p0_max], color=:black, xlabel=\"x\", ylabel=\"p\", label=\"x=xf\") \n     \n    # solution \n    sol = φ((t0, tf), x0, p0_sol)\n    x = state(sol).(tspan)\n    p = costate(sol).(tspan)\n    plot!(plt_flow, x, p, color=:red, linewidth=2, label=\"extremal solution\") \n    plot!(plt_flow, [x[end]], [p[end]], seriestype=:scatter, color=:green, label=false) \n \n    # plot of the shooting function  \n    p0s = range(p0_min, p0_max, length=200) \n    plt_shoot = plot(xlims=(p0_min, p0_max), ylims=(-2, 4), xlabel=\"p₀\", ylabel=\"y\") \n    plot!(plt_shoot, p0s, S, linewidth=2, label=\"S(p₀)\", color=:green) \n    plot!(plt_shoot, [p0_min, p0_max], [0, 0], color=:black, label=\"y=0\") \n    plot!(plt_shoot, [p0_sol, p0_sol], [-2, 0], color=:black, label=\"p₀ solution\", linestyle=:dash) \n    plot!(plt_shoot, [p0_sol], [0], seriestype=:scatter, color=:green, label=false) \n \n    # final plot \n    plot(plt_flow, plt_shoot; layout=(1,2), leftmargin=15px, bottommargin=15px, kwargs...) \n \nend</code><button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code ;opblock\" title=\"Copy\"></button></pre></div>\n</section>\n</article>","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using Plots.PlotMeasures # hide\nfunction pretty_plot(S, p0; Np0=20, kwargs...) # hide\n # hide\n    # times for wavefronts# hide\n    times = range(t0, tf, length=3)# hide\n# hide\n    # times for trajectories# hide\n    tspan = range(t0, tf, length=100)# hide\n# hide\n    # interval of initial covector# hide\n    p0_min = -0.5 # hide\n    p0_max = 2 # hide\n# hide\n    # covector solution# hide\n    p0_sol = p0 # hide\n # hide\n    # plot of the flow in phase space# hide\n    plt_flow = plot() # hide\n    p0s = range(p0_min, p0_max, length=Np0) # hide\n    for i ∈ eachindex(p0s) # hide\n        sol = φ((t0, tf), x0, p0s[i])# hide\n        x = state(sol).(tspan)# hide\n        p = costate(sol).(tspan)# hide\n        label = i==1 ? \"extremals\" : false # hide\n        plot!(plt_flow, x, p, color=:blue, label=label) # hide\n    end # hide\n # hide\n    # plot of wavefronts in phase space # hide\n    p0s = range(p0_min, p0_max, length=200) # hide\n    xs  = zeros(length(p0s), length(times)) # hide\n    ps  = zeros(length(p0s), length(times)) # hide\n    for i ∈ eachindex(p0s) # hide\n        sol = φ((t0, tf), x0, p0s[i], saveat=times)# hide\n        xs[i, :] .= state(sol).(times) # hide\n        ps[i, :] .= costate(sol).(times) # hide\n    end # hide\n    for j ∈ eachindex(times) # hide\n        label = j==1 ? \"flow at times\" : false # hide\n        plot!(plt_flow, xs[:, j], ps[:, j], color=:green, linewidth=2, label=label) # hide\n    end # hide\n # hide\n    #  # hide\n    plot!(plt_flow, xlims=(-1.1, 1), ylims=(p0_min, p0_max)) # hide\n    plot!(plt_flow, [0, 0], [p0_min, p0_max], color=:black, xlabel=\"x\", ylabel=\"p\", label=\"x=xf\") # hide\n     # hide\n    # solution # hide\n    sol = φ((t0, tf), x0, p0_sol)# hide\n    x = state(sol).(tspan)# hide\n    p = costate(sol).(tspan)# hide\n    plot!(plt_flow, x, p, color=:red, linewidth=2, label=\"extremal solution\") # hide\n    plot!(plt_flow, [x[end]], [p[end]], seriestype=:scatter, color=:green, label=false) # hide\n # hide\n    # plot of the shooting function  # hide\n    p0s = range(p0_min, p0_max, length=200) # hide\n    plt_shoot = plot(xlims=(p0_min, p0_max), ylims=(-2, 4), xlabel=\"p₀\", ylabel=\"y\") # hide\n    plot!(plt_shoot, p0s, S, linewidth=2, label=\"S(p₀)\", color=:green) # hide\n    plot!(plt_shoot, [p0_min, p0_max], [0, 0], color=:black, label=\"y=0\") # hide\n    plot!(plt_shoot, [p0_sol, p0_sol], [-2, 0], color=:black, label=\"p₀ solution\", linestyle=:dash) # hide\n    plot!(plt_shoot, [p0_sol], [0], seriestype=:scatter, color=:green, label=false) # hide\n # hide\n    # final plot # hide\n    plot(plt_flow, plt_shoot; layout=(1,2), leftmargin=15px, bottommargin=15px, kwargs...) # hide\n # hide\nend# hide\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"pretty_plot(S, p0_sol; size=(800, 450))","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"","category":"page"},{"location":"dev-optimalcontrol.html#OptimalControl.jl","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"CollapsedDocStrings = false","category":"page"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"The OptimalControl.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"flowchart TD\nB(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctbase.html'>CTBase</a>)\nM(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctmodels.html'>CTModels</a>)\nP(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctparser.html'>CTParser</a>)\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-optimalcontrol.html'>OptimalControl</a>)\nD(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctdirect.html'>CTDirect</a>)\nF(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> B\nM --> B\nstyle O fill:#FBF275","category":"page"},{"location":"dev-optimalcontrol.html#Index","page":"OptimalControl.jl","title":"Index","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Pages   = [\"dev-optimalcontrol.md\"]\nModules = [OptimalControl]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-optimalcontrol.html#Available-methods","page":"OptimalControl.jl","title":"Available methods","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"using OptimalControl\navailable_methods()","category":"page"},{"location":"dev-optimalcontrol.html#Documentation","page":"OptimalControl.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-optimalcontrol.html#Public","page":"OptimalControl.jl","title":"Public","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Modules = [OptimalControl]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"dev-optimalcontrol.html#OptimalControl.OptimalControl","page":"OptimalControl.jl","title":"OptimalControl.OptimalControl","text":"OptimalControl module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\n\nList of all the exported names:\n\n*\nFlow\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\n@Lie\nLie\nLift\nModel\nParsingError\nPoisson\nVectorField\navailable_methods\nbuild_OCP_solution\nconstraint\ncontrol\ncontrol_components\ncontrol_dimension\ncontrol_name\ncostate\ncriterion\n@def\ndirect_transcription\ndynamics\nexport_ocp_solution\nfinal_time\nimport_ocp_solution\ninfos\ninitial_time\niterations\nlagrange\nmayer\nmessage\nobjective\nset_initial_guess\nsolve\nstate\nstate_components\nstate_dimension\nstate_name\nstopping\ntime_grid\ntime_name\nvariable\nvariable_components\nvariable_dimension\nvariable_name\n⋅\n\n\n\n\n\n","category":"module"},{"location":"dev-optimalcontrol.html#CommonSolve.solve-Tuple{Model, Vararg{Symbol}}","page":"OptimalControl.jl","title":"CommonSolve.solve","text":"solve(ocp::Model, description::Symbol...; kwargs...)\n\n\nSolve the the optimal control problem ocp by the method given by the (optional) description. The available methods are given by available_methods(). The higher in the list, the higher is the priority. The keyword arguments are specific to the chosen method and represent the options of the solver.\n\nnote: Note\nSee the tutorial on solving optimal control problems for more information.\n\nArguments\n\nocp::OptimalControlModel: the optimal control problem to solve.\ndescription::Symbol...: the description of the method to use to solve the problem.\nkwargs...: the options of the solver.\n\nExamples\n\nThe simplest way to solve the optimal control problem is to call the function without any argument.\n\njulia> sol = solve(ocp)\n\nThe method can be specified by passing the description as a Symbol. You can provide a partial description, the function will  find the best match.\n\njulia> sol = solve(ocp, :direct)\n\nThe method can be specified by passing the full description as a list of Symbols.\n\njulia> sol = solve(ocp, :direct, :adnlp, :ipopt)\n\nThe keyword arguments are specific to the chosen method and represent the options of the solver. For example, the keyword display is used to display the information of the solver. The default value is true.\n\njulia> sol = solve(ocp, :direct, :ipopt, display=false)\n\nThe initial guess can be provided by the keyword init. You can provide the initial guess for the state, control, and variable.\n\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5))\n\ntip: Tip\nFor more information on how to provide the initial guess, see the tutorial on the initial guess.\n\n\n\n\n\n","category":"method"},{"location":"dev-optimalcontrol.html#OptimalControl.available_methods-Tuple{}","page":"OptimalControl.jl","title":"OptimalControl.available_methods","text":"available_methods(\n\n) -> Tuple{Vararg{Tuple{Symbol, Symbol, Symbol}}}\n\n\nReturn the list of available methods that can be used to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-optimalcontrol.html#Private","page":"OptimalControl.jl","title":"Private","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Modules = [OptimalControl]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-optimalcontrol.html#OptimalControl.clean-Tuple{Tuple{Vararg{Symbol}}}","page":"OptimalControl.jl","title":"OptimalControl.clean","text":"clean(d::Tuple{Vararg{Symbol}}) -> Tuple{Vararg{Symbol}}\n\n\nWhen calling the function solve, the user can provide a description of the method to use to solve the optimal control problem. The description can be a partial description or a full description. The function solve will find the best match from the available methods, thanks to the function getFullDescription. Then, the description is cleaned by the function clean to remove the Symbols that are specific to  OptimalControl.jl and so must not be passed to the solver. For instance, the Symbol :direct is specific to OptimalControl.jl and must be removed. It must not be passed to the CTDirect.jl solver.\n\n\n\n\n\n","category":"method"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"","category":"page"},{"location":"tutorial-abstract.html#tutorial-abstract-syntax","page":"Define a problem","title":"The syntax to define an optimal control problem","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The full grammar of OptimalControl.jl small Domain Specific Language is given below. The idea is to use a syntax that is","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"pure Julia (and, as such, effortlessly analysed by the standard Julia parser),\nas close as possible to the mathematical description of an optimal control problem. ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"While the syntax will be transparent to those users familiar with Julia expressions (Expr's), we provide examples for every case that should be widely understandable. We rely heavily on MLStyle.jl and its pattern matching abilities 👍🏽 for the semantic pass. Abstract definitions use the macro @def.","category":"page"},{"location":"tutorial-abstract.html#variable","page":"Define a problem","title":"Variable","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $v ∈ R^$q, variable ) \n:( $v ∈ R   , variable ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"A variable (only one is allowed) is a finite dimensional vector or reals that will be optimised along with state and control values. To define an (almost empty!) optimal control problem, named ocp, having a dimension two variable named v, do the following:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    v ∈ R², variable\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nNote that the full code of the definition above is not provided (hence the ...) The same is true for most examples below (only those without ... are indeed complete). Also note that problem definitions must at least include definitions for time, state, control, and dynamics.","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Aliases v₁, v₂ (and v1, v2) are automatically defined and can be used in subsequent expressions instead of v[1] and v[2]. The user can also define her own aliases for the components (one alias per dimension):","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    v = (a, b) ∈ R², variable\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"A one dimensional variable can be declared according to","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    v ∈ R, variable\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"note: Note\nIt is also possible to use the following syntax@def ocp begin\n    v ∈ R, variable\n    ...\nendthat is equivalent toocp = @def begin\n    v ∈ R, variable\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html#Time","page":"Define a problem","title":"Time","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $t ∈ [$t0, $tf], time ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The independent variable or time is a scalar bound to a given interval. Its name is arbitrary.","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"t0 = 1\ntf = 5\n@def begin\n    t ∈ [t0, tf], time\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"One (or even the two bounds) can be variable, typically for minimum time problems (see Mayer cost section):","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    v = (T, λ) ∈ R², variable\n    t ∈ [0, T], time\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html#state","page":"Define a problem","title":"State","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $x ∈ R^$n, state ) \n:( $x ∈ R   , state ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The state declaration defines the name and the dimension of the state:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    x ∈ R⁴, state\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"As for the variable, there are automatic aliases (x₁ and x1 for x[1], etc.) and the user can define her own aliases (one per scalar component of the state):","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    x = (q₁, q₂, v₁, v₂) ∈ R⁴, state\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html#control","page":"Define a problem","title":"Control","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $u ∈ R^$m, control ) \n:( $u ∈ R   , control ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The control declaration defines the name and the dimension of the control:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    u ∈ R², control\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"As before, there are automatic aliases (u₁ and u1 for u[1], etc.) and the user can define her own aliases (one per scalar component of the state):","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    u = (α, β) ∈ R², control\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html#dynamics","page":"Define a problem","title":"Dynamics","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( ∂($x)($t) == $e1 ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The dynamics is given in the standard vectorial ODE form:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"    dotx(t) = f(t x(t) u(t) v)","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"depending on whether it is autonomous / with a variable or not (the parser will detect time and variable dependences, which entails that time, state and variable must be declared prior to dynamics - an error will be issued otherwise). The symbol ∂, or the dotted state name (ẋ), or the keyword derivative can be used:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    ∂(x)(t) == [x₂(t), u(t)]\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"or","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    ẋ(t) == [x₂(t), u(t)]\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"or","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    derivative(x)(t) == [x₂(t), u(t)]\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Any Julia code can be used, so the following is also OK: ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"ocp = @def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    ẋ(t) == F₀(x(t)) + u(t) * F₁(x(t))\n    ...\nend\n\nF₀(x) = [x[2], 0]\nF₁(x) = [0, 1]","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"note: Note\nThe vector fields F₀ and F₁ can be defined afterwards, as they only need to be available when the dynamics will be evaluated.","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Currently, it is not possible to declare the dynamics component after component, but a simple workaround is to use aliases (check the relevant aliases section below):","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    q̇ = v(t)\n    v̇ = u(t) - c(t)\n    ẋ(t) == [q̇, v̇]\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html#Constraints","page":"Define a problem","title":"Constraints","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $e1 == $e2        ) \n:( $e1 ≤  $e2 ≤  $e3 ) \n:(        $e2 ≤  $e3 ) \n:( $e3 ≥  $e2 ≥  $e1 ) \n:( $e2 ≥  $e1        ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Admissible constraints can be","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"five types: boundary, control, state, mixed, variable,\nlinear (ranges) or nonlinear (not ranges),\nequalities or (one or two-sided) inequalities.","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Boundary conditions are detected when the expression contains evaluations of the state at initial and / or final time bounds (e.g., x(0)), and may not involve the control. Conversely control, state or mixed constraints will involve control, state or both evaluated at the declared time (e.g., x(t) + u(t)).  Other combinations should be detected as incorrect by the parser 🤞🏾. The variable may be involved in any of the four previous constraints. Constraints involving the variable only are variable constraints, either linear or nonlinear. In the example below, there are","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"two linear boundary constraints,\none linear variable constraint,\none linear state constraint,\none (two-sided) nonlinear control constraint.","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(tf) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    tf ≥ 0 \n    x₂(t) ≤ 1\n    u(t)^2 ≤ 1\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"note: Note\nSymbols like <= or >= are also authorised:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(tf) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    tf >= 0 \n    x₂(t) <= 1\n    u(t)^2 <= 1\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nWrite either u(t)^2 or (u^2)(t), not u^2(t) since in Julia the latter means u^(2t). Moreover, in the case of equalities or of one-sided inequalities, the control and / or the state must belong to the left-hand side. The following will error:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"using OptimalControl","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ∈ [0, 2], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(2) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    1 ≤ x₂(t)\n    -1 ≤ u(t) ≤ 1\nend","category":"page"},{"location":"tutorial-abstract.html#mayer","page":"Define a problem","title":"Mayer cost","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $e1 → min ) \n:( $e1 → max ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Mayer costs are defined in a similar way to boundary conditions and follow the same rules. The symbol → is used to denote minimisation or maximisation, the latter being treated by minimising the opposite cost. (The symbol => can also be used.)","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5\n   -2 ≤ v(t) ≤ 3\n    ẋ(t) == [v(t), u(t)]\n    tf → min\nend","category":"page"},{"location":"tutorial-abstract.html#Lagrange-cost","page":"Define a problem","title":"Lagrange cost","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":(       ∫($e1) → min ) \n:(     - ∫($e1) → min ) \n:( $e1 * ∫($e2) → min ) \n:(       ∫($e1) → max ) \n:(     - ∫($e1) → max ) \n:( $e1 * ∫($e2) → max ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Lagrange (integral) costs are defined used the symbol ∫, with parentheses. The keyword integral can also be used:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ∈ [0, 1], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    0.5∫(q(t) + u(t)^2) → min\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"or","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ∈ [0, 1], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    0.5integral(q(t) + u(t)^2) → min\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The integration range is implicitly equal to the time range, so the cost above is to be understood as","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"frac12 int_0^1 left( q(t) + u^2(t) right) mathrmdt to min","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"As for the dynamics, the parser will detect whether the integrand depends or not on time (autonomous / non-autonomous case).","category":"page"},{"location":"tutorial-abstract.html#Bolza-cost","page":"Define a problem","title":"Bolza cost","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $e1 +       ∫($e2)       → min ) \n:( $e1 + $e2 * ∫($e3)       → min ) \n:( $e1 -       ∫($e2)       → min ) \n:( $e1 - $e2 * ∫($e3)       → min ) \n:( $e1 +       ∫($e2)       → max ) \n:( $e1 + $e2 * ∫($e3)       → max ) \n:( $e1 -       ∫($e2)       → max ) \n:( $e1 - $e2 * ∫($e3)       → max ) \n:(             ∫($e2) + $e1 → min ) \n:(       $e2 * ∫($e3) + $e1 → min ) \n:(             ∫($e2) - $e1 → min ) \n:(       $e2 * ∫($e3) - $e1 → min ) \n:(             ∫($e2) + $e1 → max ) \n:(       $e2 * ∫($e3) + $e1 → max ) \n:(             ∫($e2) - $e1 → max ) \n:(       $e2 * ∫($e3) - $e1 → max ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Quite readily, Mayer and Lagrange costs can be combined into general Bolza costs. For instance as follows:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    p = (t0, tf) ∈ R², variable\n    t ∈ [t0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R², control\n    (tf - t0) + 0.5∫(c(t) * u(t)^2) → min\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nThe expression must be the sum of two terms (plus, possibly, a scalar factor before the integral), not more, so mind the parentheses. For instance, the following errors:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    p = (t0, tf) ∈ R², variable\n    t ∈ [t0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R², control\n    (tf - t0) + q(tf) + 0.5∫( c(t) * u(t)^2 ) → min\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The correct syntax is","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    p = (t0, tf) ∈ R², variable\n    t ∈ [t0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R², control\n    ((tf - t0) + q(tf)) + 0.5∫( c(t) * u(t)^2 ) → min\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html#aliases","page":"Define a problem","title":"Aliases","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":":( $a = $e1 )","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"The single = symbol is used to define not a constraint but an alias, that is a purely syntactic replacement. There are some automatic aliases, e.g. x₁ for x[1] if x is the state, and we have also seen that the user can define her own aliases when declaring the variable, state and control. Arbitrary aliases can be further defined, as below (compare with previous examples in the dynamics section):","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    F₀ = [x₂(t), 0]\n    F₁ = [0, 1]\n    ẋ(t) == F₀ + u(t) * F₁\n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nSuch aliases do not define any additional function and are just replaced textually by the parser. In particular, they cannot be used outside the @def begin ... end block.","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"hint: Hint\nYou can rely on a trace mode for the macro @def to look at your code after expansions of the aliases using the @def ocp ... syntax and adding true after your begin ... end block:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    q̇ = v(t)\n    v̇ = u(t) - c(t)\n    ẋ(t) == [q̇, v̇]\nend true;","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"caveat: Caveat\nThe dynamics of an OCP is indeed a particular constraint, be careful to use == and not a single = that would try to define an alias:","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"double_integrator = @def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    q̇ = v\n    v̇ = u\n    ẋ(t) = [q̇, v̇]\nend","category":"page"},{"location":"tutorial-abstract.html#Misc","page":"Define a problem","title":"Misc","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Declarations (of variable - if any -, time, state and control) must be done first. Then, dynamics, constraints and cost can be introduced in an arbitrary order.\nIt is possible to provide numbers / labels (as in math equations) for the constraints to improve readability (this is mostly for future use, typically to retrieve the Lagrange multiplier associated with the discretisation of a given constraint):","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    tf ≥ 0, (1)\n    q(0) == 2, (♡)\n    q̇ = v(t)\n    v̇ = u(t) - c(t)\n    ẋ(t) == [q̇, v̇]\n    x(t).^2  ≤ [1, 2], (state_con) \n    ...\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"Parsing errors should be explicit enough (with line number in the @def begin ... end block indicated) 🤞🏾\nCheck tutorials and applications in the documentation for further use.","category":"page"},{"location":"tutorial-abstract.html","page":"Define a problem","title":"Define a problem","text":"","category":"page"},{"location":"tutorial-double-integrator-energy.html#tutorial-double-integrator-energy","page":"Energy minimisation","title":"Double integrator: energy minimisation","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force u. We denote by x = (x_1 x_2) the state of the wagon, that is its position x_1 and its velocity x_2.","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We assume that the mass is constant and unitary and that there is no friction. The dynamics we consider is given by","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t)quad u(t) in R","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"which is simply the double integrator system. Les us consider a transfer starting at time t_0 = 0 and ending at time t_f = 1, for which we want to minimise the transfer energy","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"    frac12int_0^1 u^2(t)  mathrmdt","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"starting from the condition x(0) = (-1 0) and with the goal to reach the target x(1) = (0 0).","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-double-integrator-energy.html#Optimal-control-problem","page":"Energy minimisation","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"Let us define the problem","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"ocp = @def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n    ẋ(t) == [ x₂(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"note: Nota bene\nFor a comprehensive introduction to the syntax used above to define the optimal control problem, check this abstract syntax tutorial. In particular, there are non-unicode alternatives for derivatives, integrals, etc.","category":"page"},{"location":"tutorial-double-integrator-energy.html#basic-solve-plot","page":"Energy minimisation","title":"Solve and plot","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We can solve it simply with:","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"And plot the solution with:","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"plot(sol)","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"note: Nota bene\nThe solve function has options, see the solve tutorial. You can customise the plot with the plot function, see the plot tutorial.","category":"page"},{"location":"tutorial-double-integrator-energy.html#State-constraint","page":"Energy minimisation","title":"State constraint","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We add the path constraint","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"x_2(t) le 12","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"Let us model, solve and plot the optimal control problem with this constraint.","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"ocp = @def begin\n\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x₂(t) ≤ 1.2\n\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n\n    ẋ(t) == [ x₂(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\n\nsol = solve(ocp)\n\nplot(sol)","category":"page"},{"location":"tutorial-double-integrator-energy.html#Exporting-and-importing-the-solution","page":"Energy minimisation","title":"Exporting and importing the solution","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"We can export (or save) the solution in a Julia .jld2 data file and reload it later, and also export a discretised version of the solution in a more portable JSON format. Note that the optimal control problem is needed when loading a solution.","category":"page"},{"location":"tutorial-double-integrator-energy.html#JLD2","page":"Energy minimisation","title":"JLD2","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"using JLD2\n\nusing Suppressor # hide\n@suppress_err begin # hide\nexport_ocp_solution(sol; filename_prefix=\"my_solution\")\nend # hide\n\nsol_jld = import_ocp_solution(ocp; filename_prefix=\"my_solution\")\n\nprintln(\"Objective from computed solution: \", objective(sol))\nprintln(\"Objective from imported solution: \", objective(sol_jld))","category":"page"},{"location":"tutorial-double-integrator-energy.html#JSON","page":"Energy minimisation","title":"JSON","text":"","category":"section"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"# load additional modules\nusing JSON3\n\nexport_ocp_solution(sol; filename_prefix=\"my_solution\", format=:JSON)\n\nsol_json = import_ocp_solution(ocp; filename_prefix=\"my_solution\", format=:JSON)\n\nprintln(\"Objective from computed solution: \", objective(sol))\nprintln(\"Objective from imported solution: \", objective(sol_json))","category":"page"},{"location":"tutorial-double-integrator-energy.html","page":"Energy minimisation","title":"Energy minimisation","text":"","category":"page"},{"location":"tutorial-solve.html#tutorial-solve","page":"Solve a problem","title":"The solve function","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"In this tutorial, we explain the solve function from OptimalControl.jl package.","category":"page"},{"location":"tutorial-solve.html#Basic-usage","page":"Solve a problem","title":"Basic usage","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Let us define a basic optimal control problem.","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"using OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == [ 0, 0 ]\n\n    ẋ(t)  == [ v(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"We can now solve the problem:","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"using NLPModelsIpopt\n\nsolve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Notice that we need to load the NLPModelsIpopt package before calling solve. This is because the method currently implements a direct approach, where the optimal control problem is transcribed to a nonlinear optimization problem (NLP) of the form","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"textminimizequad F(y) quadtextsubject to the constraintsquad g(y)=0 quad h(y)le 0 ","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Note: calling solve without loading a NLP solver package first will notify the user:","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"julia> solve(ocp)\nERROR: ExtensionError. Please make: julia> using NLPModelsIpopt","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"See below for the NLP solver options.","category":"page"},{"location":"tutorial-solve.html#Resolution-methods-and-algorithms","page":"Solve a problem","title":"Resolution methods and algorithms","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"OptimalControl.jl offers a list of methods to solve your optimal control problem. To get the list of methods, simply call available_methods.","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"available_methods()","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Each line is a method, with priority going from top to bottom. This means that ","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"solve(ocp)","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"is equivalent to ","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"solve(ocp, :direct, :adnlp, :ipopt)","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"The first symbol :direct refers to the general class of method, with only the so-called direct approach currently implemented. Direct methods discretize the original optimal control problem and solve the resulting NLP problem. The second symbol :adnlp is for the choice of NLP modeler.  We currently use ADNLPModels.jl which provides an automatic differentiation (AD)-based model implementations that conform to the NLPModels.jl API. The third symbol corresponds to the NLP solver, with the possible values:","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":":ipopt (default value) for Ipopt (via the NLPModelsIpopt.jl package).\n:madnlp is MadNLP.jl, an open-source nonlinear programming solver purely implemented in Julia, which implements a filter line-search interior-point algorithm, as the one in Ipopt.\n:knitro for the Knitro solver (requires a license).","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"For instance, let us try MadNLP.jl.","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"using MadNLP\n\nsolve(ocp, :madnlp)\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Note that you can provide a partial description.  If several full descriptions contain it, the priority is given to first one in the list.  Hence, these calls are all equivalent:","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"solve(ocp)\nsolve(ocp, :direct                )\nsolve(ocp,          :adnlp        )\nsolve(ocp,                  :ipopt)\nsolve(ocp, :direct, :adnlp        )\nsolve(ocp, :direct,         :ipopt)\nsolve(ocp, :direct, :adnlp, :ipopt)","category":"page"},{"location":"tutorial-solve.html#Direct-method","page":"Solve a problem","title":"Direct method","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"The options for the direct method are listed in the direct_solve keywords. The main options, with their [default values], are:","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"display ([true], false): setting display to false will disable output\ngrid_size ([250]): size of the (uniform) time discretization grid. More precisely, it is the number of time steps, that is if N = grid_size and if the initial and final times are denoted respectively t0 and tf, then we have Δt = (tf - t0) / N\ndisc_method ([:trapeze], :midpoint, :euler, :euler_implicit, :gauss_legendre_2, :gauss_legendre_3): see discretisation methods.\ninit: info for the starting guess, which can be provided as numerical values, functions, or an existing solution. See initial guess tutorial. ","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"For examples of more advanced use, see ","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"discrete continuation\nNLP direct handling","category":"page"},{"location":"tutorial-solve.html#NLP-solver-specific-options","page":"Solve a problem","title":"NLP solver specific options","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"In addition to these options, all remaining keyword arguments passed to solve will be transmitted to the NLP solver used.","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Please check the list of Ipopt options and the NLPModelsIpopt.jl documentation.","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"solve(ocp; max_iter=0)\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"Similarly, please check the MadNLP.jl documentation and the list of MadNLP.jl options.","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"solve(ocp, :madnlp; max_iter=0)\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve a problem","title":"Solve a problem","text":"","category":"page"},{"location":"tutorial-nlp.html#NLP-and-DOCP-manipulations","page":"NLP manipulations","title":"NLP and DOCP manipulations","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"We describe here some more advanced operations related to the discretized optimal control problem. When calling solve(ocp) three steps are performed internally:","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"first, the OCP is discretized into a DOCP (a nonlinear optimization problem) with direct_transcription,\nthen, this DOCP is solved (with the internal function solve_docp),\nfinally, a functional solution of the OCP is rebuilt from the solution of the discretized problem, with OptimalControlSolution.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"These steps can also be done separately, for instance if you want to use your own NLP solver. ","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"Let us load the packages.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"using OptimalControl\nusing Plots","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"We define a test problem","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"ocp = @def begin\n\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n\n    ẋ(t) == [ x₂(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html#Discretization-and-NLP-problem","page":"NLP manipulations","title":"Discretization and NLP problem","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"We discretize the problem.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"docp, nlp = direct_transcription(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"The DOCP contains information related to the transcription, including a copy of the original OCP, and the NLP is the resulting discretized problem, in our case an ADNLPModel.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"We can now use the solver of our choice to solve it.","category":"page"},{"location":"tutorial-nlp.html#Resolution-of-the-NLP-problem","page":"NLP manipulations","title":"Resolution of the NLP problem","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"For a first example we use the ipopt solver from NLPModelsIpopt.jl package to solve the NLP problem.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"using NLPModelsIpopt\n\nnlp_sol = ipopt(nlp; print_level=5, mu_strategy=\"adaptive\", tol=1e-8, sb=\"yes\")\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"Then we can rebuild and plot an optimal control problem solution (note that the multipliers are optional, but the OCP costate will not be retrieved if the multipliers are not provided).","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"sol = build_OCP_solution(docp; primal=nlp_sol.solution, dual=nlp_sol.multipliers)\nplot(sol)","category":"page"},{"location":"tutorial-nlp.html#Change-the-NLP-solver","page":"NLP manipulations","title":"Change the NLP solver","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"Alternatively, we can use MadNLP.jl to solve anew the NLP problem:","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"using MadNLP\n\nnlp_sol = madnlp(nlp)","category":"page"},{"location":"tutorial-nlp.html#Initial-guess","page":"NLP manipulations","title":"Initial guess","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"An initial guess, including warm start, can be passed to direct_transcription the same way as for solve.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"docp, nlp = direct_transcription(ocp; init=sol)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"It can also be changed after the transcription is done, with  set_initial_guess.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"set_initial_guess(docp, nlp, sol)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP manipulations","title":"NLP manipulations","text":"","category":"page"},{"location":"tutorial-plot.html#tutorial-plot","page":"Plot a solution","title":"How to plot a solution","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In this tutorial we explain the different ways to plot a solution of an optimal control problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Let us start by importing the package to define the problem and solve it.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using OptimalControl\nusing NLPModelsIpopt","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Then, we define a simple optimal control problem and solve it.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"ocp = @def begin\n\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x(0) == [-1, 0]\n    x(1) == [0, 0]\n\n    ẋ(t) == [x₂(t), u(t)]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\n\nsol = solve(ocp, display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html#First-ways-to-plot","page":"Plot a solution","title":"First ways to plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The simplest way to plot the solution is to use the plot function with only the solution as argument.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: The plot function\nThe plot function on a solution of an optimal control problem is an extension of the plot function from the package Plots.jl. Hence, we need to import this package to plot a solution.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using Plots\nplot(sol)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"As you can see, it produces a grid of subplots. The left column contains the state trajectories, the right column the costate trajectories, and at the bottom we have the control trajectory.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Attributes from Plots.jl can be passed to the plot function:","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In addition to sol you can pass attributes to the full plot, see the attributes plot documentation from Plots.jl for more details. For instance, you can specify the size of the figure.\nYou can also pass attributes to the subplots, see the attributes subplot documentation from Plots.jl for more details. However, it will affect all the subplots. For instance, you can specify the location of the legend.\nIn the same way, you can pass axis attributes to the subplots, see the attributes axis documentation from Plots.jl for more details. It will also affect all the subplots. For instance, you can remove the grid.\nIn the same way, you can pass series attributes to the all the subplots, see the attributes series documentation from Plots.jl for more details. It will also affect all the subplots. For instance, you can set the width of the curves with linewidth.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, size=(700, 450), legend=:bottomright, grid=false, linewidth=2)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To specify series attributes to a specific subplot, you can use the optional keyword arguments state_style, costate_style and control_style which correspond respectively to the state, costate and control trajectories. See the attribute series documentation from Plots.jl for more details. For instance, you can specify the color of the state trajectories and more.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; \n     state_style   = (color=:blue,), \n     costate_style = (color=:black, linestyle=:dash),\n     control_style = (color=:red, linewidth=2))","category":"page"},{"location":"tutorial-plot.html#From-Flow","page":"Plot a solution","title":"From Flow","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The previous resolution of the optimal control problem was done with the solve function. If you use an indirect shooting method and solve shooting equations, you may want to plot the associated solution. To do so, you need to use the Flow function to  reconstruct the solution. See the Indirect Simple Shooting tutorial for an example. In our example, you must provide the maximising control (x p) mapsto p_2 together with the optimal control problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"tip: Interactions with an optimal control solution\nPlease check state, costate, control and variable to get data from the solution. The functions state, costate and control return functions of time and variable returns a vector.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using OrdinaryDiffEq\nt0 = 0\ntf = 1\nx0 = [ -1, 0 ]\np0 = costate(sol)(t0)\nf  = Flow(ocp, (x, p) -> p[2])\nsol_flow = f( (t0, tf), x0, p0 )\nplot(sol_flow)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can notice that the time grid has very few points. To have a better visualisation (the accuracy won't change), you can give a finer grid.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"sol_flow = f( (t0, tf), x0, p0; saveat=range(t0, tf, 100) )\nplot(sol_flow)","category":"page"},{"location":"tutorial-plot.html#Split-versus-group-layout","page":"Plot a solution","title":"Split versus group layout","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"If you prefer to get a more compact figure, you can use the layout optional keyword argument with :group value. It will group the state, costate and control trajectories in one subplot for each.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; layout=:group, size=(800, 300))","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Default layout value\nThe default layout value is :split which corresponds to the grid of subplots presented above.","category":"page"},{"location":"tutorial-plot.html#Additional-plots","page":"Plot a solution","title":"Additional plots","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can plot the solution of a second optimal control problem on the same figure if it has the same number of states, costates and controls. For instance, consider the same optimal control problem but with a different initial condition.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"ocp = @def begin\n\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x(0) == [-0.5, -0.5]\n    x(1) == [0, 0]\n\n    ẋ(t) == [x₂(t), u(t)]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nsol2 = solve(ocp; display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We first plot the solution of the first optimal control problem, then, we plot the solution of the second optimal control problem on the same figure, but with dashed lines.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"# first plot\nplt = plot(sol; solution_label=\"(sol1)\", size=(700, 500))\n\n# second plot\nplot!(plt, sol2; solution_label=\"(sol2)\", linestyle=:dash)","category":"page"},{"location":"tutorial-plot.html#Plot-the-norm-of-the-control","page":"Plot a solution","title":"Plot the norm of the control","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"For some problem, it is interesting to plot the norm of the control. You can do it by using the control optional keyword argument with :norm value. The default value is :components.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; control=:norm, size=(800, 300), layout=:group)","category":"page"},{"location":"tutorial-plot.html#Custom-plot","page":"Plot a solution","title":"Custom plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can of course create your own plots by getting the state, costate and control from the optimal control solution. For instance, let us plot the norm of the control for the orbital transfer problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"tip: Interactions with an optimal control solution\nAdditionally to state, costate, control and variable, the function time_grid returns the discretized time grid returned by the solver.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using LinearAlgebra\nt = time_grid(sol)\nx = state(sol)\np = costate(sol)\nu = control(sol)\nplot(t, norm∘u; label=\"‖u‖\") ","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Nota bene\nThe norm function is from LinearAlgebra.jl. \nThe ∘ operator is the composition operator. Hence, norm∘u is the function t -> norm(u(t)). ","category":"page"},{"location":"tutorial-plot.html#Normalized-time","page":"Plot a solution","title":"Normalized time","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We consider a LQR example and solve the problem for different values of the final time tf. Then, we plot the solutions on the same figure considering a normalized time s=(t-t_0)(t_f-t_0), thanks to the keyword argument time=:normalize of the plot function.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"\n# parameters\nx0 = [ 0\n       1 ]\n\n# definition\nfunction lqr(tf)\n\n    ocp = @def begin\n        t ∈ [0, tf], time\n        x ∈ R², state\n        u ∈ R, control\n        x(0) == x0\n        ẋ(t) == [x₂(t), - x₁(t) + u(t)]\n        ∫( 0.5(x₁(t)^2 + x₂(t)^2 + u(t)^2) ) → min\n    end\n\n    return ocp\nend;\n\n# solve\nsolutions = []\ntfs = [3, 5, 30]\nfor tf ∈ tfs\n    solution = solve(lqr(tf); display=false)\n    push!(solutions, solution)\nend\n\n# create plots\nplt = plot(solutions[1]; time=:normalize)\nfor sol ∈ solutions[2:end]\n    plot!(plt, sol; time=:normalize)\nend\n\n# make a custom plot from created plots: only state and control are plotted\nN = length(tfs)\npx1 = plot(plt[1]; legend=false, xlabel=\"s\", ylabel=\"x₁\")\npx2 = plot(plt[2]; label=reshape([\"tf = $tf\" for tf ∈ tfs], (1, N)), xlabel=\"s\", ylabel=\"x₂\")\npu  = plot(plt[5]; legend=false, xlabel=\"s\", ylabel=\"u\")\n\nusing Plots.PlotMeasures # for leftmargin, bottommargin\nplot(px1, px2, pu; layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"","category":"page"},{"location":"dev-ctdirect.html#CTDirect.jl","page":"CTDirect.jl","title":"CTDirect.jl","text":"","category":"section"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"CollapsedDocStrings = false","category":"page"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"The CTDirect.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"flowchart TD\nB(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctbase.html'>CTBase</a>)\nM(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctmodels.html'>CTModels</a>)\nP(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctparser.html'>CTParser</a>)\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-optimalcontrol.html'>OptimalControl</a>)\nD(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctdirect.html'>CTDirect</a>)\nF(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> B\nM --> B\nstyle D fill:#FBF275","category":"page"},{"location":"dev-ctdirect.html#Index","page":"CTDirect.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Pages   = [\"dev-ctdirect.md\"]\nModules = [CTDirect]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctdirect.html#Documentation","page":"CTDirect.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctdirect.html#Public","page":"CTDirect.jl","title":"Public","text":"","category":"section"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Modules = [CTDirect]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"dev-ctdirect.html#Private","page":"CTDirect.jl","title":"Private","text":"","category":"section"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Modules = [CTDirect]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-ctdirect.html#CTDirect.DOCP","page":"CTDirect.jl","title":"CTDirect.DOCP","text":"Struct for discretized optimal control problem DOCP\n\nContains:\n\na copy of the original OCP\ndata required to link the OCP with the discretized DOCP\n\n\n\n\n\n","category":"type"},{"location":"dev-ctdirect.html#CTDirect.Gauss_Legendre_1","page":"CTDirect.jl","title":"CTDirect.Gauss_Legendre_1","text":"Implicit Midpoint discretization, formulated as a generic IRK (ie Gauss Legendre 1) For testing purpose only, use :midpoint instead (cf midpoint.jl) !\n\n\n\n\n\n","category":"type"},{"location":"dev-ctdirect.html#CTDirect.Gauss_Legendre_2","page":"CTDirect.jl","title":"CTDirect.Gauss_Legendre_2","text":"Gauss Legendre 2 discretization, formulated as a generic IRK\n\n\n\n\n\n","category":"type"},{"location":"dev-ctdirect.html#CTDirect.Gauss_Legendre_3","page":"CTDirect.jl","title":"CTDirect.Gauss_Legendre_3","text":"Gauss Legendre 3 discretization, formulated as a generic IRK\n\n\n\n\n\n","category":"type"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Midpoint}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Midpoint}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Trapeze}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Trapeze}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Hessian_pattern-Union{Tuple{CTDirect.DOCP{D}}, Tuple{D}} where D<:CTDirect.Discretization","page":"CTDirect.jl","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{D<:CTDirect.Discretization}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Midpoint}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Midpoint}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Trapeze}}","page":"CTDirect.jl","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Trapeze}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_Jacobian_pattern-Union{Tuple{CTDirect.DOCP{D}}, Tuple{D}} where D<:CTDirect.Discretization","page":"CTDirect.jl","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{D<:CTDirect.Discretization}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_constraints!-Tuple{Any, Any, CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.DOCP_constraints!","text":"DOCP_constraints!(c, xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the constraints C for the DOCP problem (modeled as LB <= C(X) <= UB).\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_initial_guess","page":"CTDirect.jl","title":"CTDirect.DOCP_initial_guess","text":"DOCP_initial_guess(docp::CTDirect.DOCP) -> Vector{Float64}\nDOCP_initial_guess(\n    docp::CTDirect.DOCP,\n    init::CTModels.Init\n) -> Vector{Float64}\n\n\nBuild initial guess for discretized problem\n\n\n\n\n\n","category":"function"},{"location":"dev-ctdirect.html#CTDirect.DOCP_objective-Tuple{Any, CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.DOCP_objective","text":"DOCP_objective(xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the objective for the DOCP problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.IRK_dims-NTuple{7, Any}","page":"CTDirect.jl","title":"CTDirect.IRK_dims","text":"IRK_dims(\n    dim_NLP_steps,\n    dim_NLP_x,\n    dim_NLP_u,\n    dim_NLP_v,\n    dim_path_cons,\n    dim_boundary_cons,\n    stage\n) -> NTuple{5, Any}\n\n\nReturn the dimension of the NLP variables and constraints for a generic IRK discretizion, with the control taken constant per step (ie not distinct controls at time stages)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.SolverInfos-Tuple{}","page":"CTDirect.jl","title":"CTDirect.SolverInfos","text":"SolverInfos() -> Tuple{Int64, Float64, String, Symbol, Bool}\n\n\nRetrieve convergence information (Ipopt version)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__adnlp_backend-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__adnlp_backend","text":"__adnlp_backend() -> Symbol\n\n\nUsed to set the default backend for AD in ADNLPModels. The default value is :optimized.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__disc_method-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__disc_method","text":"__disc_method() -> Symbol\n\n\nUsed to set the default discretization method. The default value is trapeze.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__display-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__display","text":"__display() -> Bool\n\n\nUsed to set the default display toggle. The default value is true.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__grid_size-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__grid_size","text":"__grid_size() -> Int64\n\n\nUsed to set the default grid size. The default value is 250.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__ipopt_linear_solver-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__ipopt_linear_solver","text":"__ipopt_linear_solver() -> String\n\n\nUsed to set the default value of the linear solver of Ipopt for the direct method. The default value is mumps.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__ipopt_mu_strategy-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__ipopt_mu_strategy","text":"__ipopt_mu_strategy() -> String\n\n\nUsed to set the default value of the μ strategy of Ipopt for the direct method. The default value is adaptive.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__ipopt_print_level-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__ipopt_print_level","text":"__ipopt_print_level() -> Int64\n\n\nUsed to set the default value of the print level of Ipopt for the direct method. The default value is 5.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__knitro_print_level-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__knitro_print_level","text":"__knitro_print_level() -> Int64\n\n\nUsed to set the default value of the print level of Knitro for the direct method. The default value is 3.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__madnlp_linear_solver-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__madnlp_linear_solver","text":"__madnlp_linear_solver() -> String\n\n\nUsed to set the default value of the linear solver of MadNLP for the direct method. The default value is umfpack.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__max_iterations-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__max_iterations","text":"__max_iterations() -> Int64\n\n\nUsed to set the default maximum of iterations. The default value is 1000.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__ocp_init-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__ocp_init","text":"__ocp_init()\n\n\nUsed to set the default initial guess. The default value is nothing and will correspond to 0.1 for all variables.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__time_grid-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__time_grid","text":"__time_grid()\n\n\nUsed to set the default time grid. The default value is nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__tolerance-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__tolerance","text":"__tolerance() -> Float64\n\n\nUsed to set the default tolerance. The default value is 1e-6.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.add_nonzero_block!-NTuple{5, Any}","page":"CTDirect.jl","title":"CTDirect.add_nonzero_block!","text":"add_nonzero_block!(M, i_start, i_end, j_start, j_end; sym)\n\n\nAdd block of nonzeros elements to a sparsity pattern  Format: boolean matrix (M) or index vectors (Is, Js)  Includes a more compact method for single element case Option to add the symmetric block also (eg for Hessian) Note: independent from discretization scheme\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.available_methods-Tuple{}","page":"CTDirect.jl","title":"CTDirect.available_methods","text":"available_methods(\n\n) -> Tuple{Tuple{Symbol, Symbol}, Tuple{Symbol, Symbol}, Tuple{Symbol, Symbol}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.build_OCP_solution-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTDirect.build_OCP_solution","text":"build_OCP_solution(\n    docp,\n    docp_solution\n) -> CTModels.Solution{TimeGridModelType, TimesModelType, StateModelType, ControlModelType, VariableModelType, CostateModelType, Float64, CTModels.DualModel{CTModels.var\"#70#83\"{Matrix{Float64}}, CTModels.var\"#71#84\"{Matrix{Float64}}, Vector{Float64}, Vector{Float64}, CTModels.var\"#72#85\"{Matrix{Float64}, Int64}, CTModels.var\"#73#86\"{Matrix{Float64}, Int64}, CTModels.var\"#74#87\"{Matrix{Float64}, Int64}, CTModels.var\"#75#88\"{Matrix{Float64}, Int64}, Vector{Float64}, Vector{Float64}}, CTModels.SolverInfos{Dict{Symbol, Any}}} where {TimeGridModelType<:CTModels.TimeGridModel, TimesModelType<:CTModels.TimesModel, StateModelType<:Union{CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#64#77\", CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#65#78\"}, ControlModelType<:Union{CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#66#79\", CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#67#80\"}, VariableModelType<:Union{CTModels.VariableModelSolution{Vector{Float64}}, CTModels.VariableModelSolution{Float64}}, CostateModelType<:Union{CTModels.var\"#68#81\", CTModels.var\"#69#82\"}}\n\n\nBuild OCP functional solution from DOCP discrete solution (given as a SolverCore.GenericExecutionStats)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.build_OCP_solution-Tuple{Any}","page":"CTDirect.jl","title":"CTDirect.build_OCP_solution","text":"build_OCP_solution(docp; primal, dual, mult_LB, mult_UB)\n\n\nBuild OCP functional solution from DOCP discrete solution (given as a SolverCore.GenericExecutionStats)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.build_bounds-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.build_bounds","text":"build_bounds(\n    dim_var,\n    dim_box,\n    box_triplet\n) -> Tuple{Any, Any}\n\n\nBuild full, ordered sets of bounds for state, control or optimization variables\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.constraints_bounds!-Tuple{CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.constraints_bounds!","text":"constraints_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP nonlinear constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.direct_transcription-Tuple{Model, Vararg{Any}}","page":"CTDirect.jl","title":"CTDirect.direct_transcription","text":"direct_transcription(\n    ocp::Model,\n    description...;\n    grid_size,\n    disc_method,\n    time_grid,\n    init,\n    adnlp_backend,\n    solver_backend,\n    show_time,\n    matrix_free\n) -> Tuple{CTDirect.DOCP{_A, Model{TimesModelType, StateModelType, ControlModelType, VariableModelType, DynamicsModelType, ObjectiveModelType, ConstraintsModelType}} where {_A<:CTDirect.Discretization, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:CTModels.AbstractConstraintsModel}, ADNLPModels.ADNLPModel{Float64, Vector{Float64}, Vector{Int64}}}\n\n\nDiscretize an optimal control problem into a nonlinear optimization problem (ie direct transcription)\n\nArguments\n\nocp: optimal control problem as defined in CTModels\n[description]: can specifiy for instance the NLP model and / or solver (:ipopt, :madnlp or :knitro)\n\nKeyword arguments (optional)\n\ngrid_size: number of time steps for the discretized problem ([250])\ndisc_method: discretization method ([:trapeze], :euler, :euler_implicit, :midpoint, gauss_legendre_2, gauss_legendre_3)\ntime_grid: explicit time grid (can be non uniform)\ninit: info for the starting guess (values as named tuple or existing solution)\nadnlp_backend: backend for automatic differentiation in ADNLPModels ([:optimized], :manual, :default)\nshow_time: (:true, [:false]) show timing details from ADNLPModels\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_OCP_control_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"CTDirect.jl","title":"CTDirect.get_OCP_control_at_time_step","text":"get_OCP_control_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve control variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps(+1), with convention u(tf) = U_N Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_OCP_control_at_time_step-Tuple{Any, CTDirect.DOCP{CTDirect.Euler}, Any}","page":"CTDirect.jl","title":"CTDirect.get_OCP_control_at_time_step","text":"get_OCP_control_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    i\n) -> Any\n\n\nRetrieve control variables at given time step from the NLP variables. Convention: see above for acplicit / implicit versions Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_OCP_state_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"CTDirect.jl","title":"CTDirect.get_OCP_state_at_time_step","text":"get_OCP_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve state variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1 Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_OCP_variable-Tuple{Any, CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.get_OCP_variable","text":"get_OCP_variable(xu, docp::CTDirect.DOCP) -> Any\n\n\nRetrieve optimization variables from the NLP variables. Convention: stored at the end, hence not dependent on the discretization method Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_lagrange_state_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"CTDirect.jl","title":"CTDirect.get_lagrange_state_at_time_step","text":"get_lagrange_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve state variable for lagrange cost at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1   (no check for actual lagrange cost presence !)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_stagevars_at_time_step-Tuple{Any, CTDirect.DOCP, Any, Any}","page":"CTDirect.jl","title":"CTDirect.get_stagevars_at_time_step","text":"get_stagevars_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i,\n    j\n) -> Any\n\n\nRetrieve stage variables at given time step/stage from the NLP variables. Convention: 1 <= i <= dimNLPsteps(+1),\t1 <= j <= s Vector output Note that passing correct indices is up to the caller, no checks are made here.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_time_grid-Tuple{Any, CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.get_time_grid","text":"get_time_grid(xu, docp::CTDirect.DOCP) -> Any\n\n\nReturn time grid for variable time problems (times are then dependent on NLP variables)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.is_solvable-Tuple{Any}","page":"CTDirect.jl","title":"CTDirect.is_solvable","text":"is_solvable(ocp) -> Bool\n\n\nCheck if an OCP is solvable by the method solve.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.parse_DOCP_solution_dual-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.parse_DOCP_solution_dual","text":"parse_DOCP_solution_dual(\n    docp,\n    multipliers,\n    constraints\n) -> NTuple{5, Any}\n\n\nRecover OCP costate and constraints multipliers from DOCP multipliers\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.parse_DOCP_solution_primal-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTDirect.parse_DOCP_solution_primal","text":"parse_DOCP_solution_primal(\n    docp,\n    solution;\n    mult_LB,\n    mult_UB\n) -> Tuple{Any, Any, Any, NTuple{6, Any}}\n\n\nRecover OCP primal variables from DOCP solution\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setPointConstraints!-Tuple{CTDirect.DOCP, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setPointConstraints!","text":"setPointConstraints!(docp::CTDirect.DOCP, c, xu, v) -> Any\n\n\nSet the boundary and variable constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Vararg{Any, 6}}","page":"CTDirect.jl","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps (+1)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Euler}, Vararg{Any, 6}}","page":"CTDirect.jl","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Vararg{Any, 6}}","page":"CTDirect.jl","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Vararg{Any, 6}}","page":"CTDirect.jl","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setWorkArray","text":"setWorkArray(docp::CTDirect.DOCP, xu, time_grid, v) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Euler}, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_control_at_time_step!-Tuple{Any, Any, CTDirect.DOCP, Any}","page":"CTDirect.jl","title":"CTDirect.set_control_at_time_step!","text":"set_control_at_time_step!(\n    xu,\n    u_init,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nSet initial guess for control variables at given time step Convention: 1 <= i <= dimNLPsteps(+1)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_initial_guess-Tuple{CTDirect.DOCP, Any, Any}","page":"CTDirect.jl","title":"CTDirect.set_initial_guess","text":"set_initial_guess(docp::CTDirect.DOCP, nlp, init) -> Any\n\n\nSet initial guess in the DOCP\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_optim_variable!-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.set_optim_variable!","text":"set_optim_variable!(xu, v_init, docp) -> Any\n\n\nSet optimization variables in the NLP variables (for initial guess)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_state_at_time_step!-Tuple{Any, Any, CTDirect.DOCP, Any}","page":"CTDirect.jl","title":"CTDirect.set_state_at_time_step!","text":"set_state_at_time_step!(\n    xu,\n    x_init,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nSet initial guess for state variables at given time step Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.solve-Tuple{Model, Vararg{Symbol}}","page":"CTDirect.jl","title":"CTDirect.solve","text":"solve(\n    ocp::Model,\n    description::Symbol...;\n    display,\n    grid_size,\n    disc_method,\n    time_grid,\n    init,\n    adnlp_backend,\n    kwargs...\n)\n\n\nSolve an OCP with a direct method\n\nArguments\n\nocp: optimal control problem as defined in CTBase\n[description]: can specifiy for instance the NLP model and / or solver (:ipopt, :madnlp or :knitro)\n\nKeyword arguments (optional)\n\ndisplay: ([true], false) will disable output if set to false\ngrid_size: number of time steps for the discretized problem ([250])\ndisc_method: discretization method ([:trapeze], :midpoint, gauss_legendre_2)\ntime_grid: explicit time grid (can be non uniform)\ninit: info for the starting guess (values or existing solution)\nadnlp_backend: backend for automatic differentiation in ADNLPModels ([:optimized], :manual, :default)\n\nAll further keywords are passed to the inner call of solve_docp\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.variables_bounds!-Tuple{CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.variables_bounds!","text":"variables_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP variable box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"","category":"page"},{"location":"tutorial-continuation.html#Discrete-continuation","page":"Discrete continuation","title":"Discrete continuation","text":"","category":"section"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Using the warm start option, it is easy to implement a basic discrete continuation method, where a sequence of problems is solved using each solution as initial guess for the next problem. This usually gives better and faster convergence than solving each problem with the same initial guess, and is a way to handle problems that require a good initial guess.","category":"page"},{"location":"tutorial-continuation.html#Continuation-on-parametric-OCP","page":"Discrete continuation","title":"Continuation on parametric OCP","text":"","category":"section"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"The most compact syntax to perform a discrete continuation is to use a function that returns the OCP for a given value of the continuation parameter, and solve a sequence of these problems. We illustrate this on a very basic double integrator with increasing fixed final time.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"First we load the required packages","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Printf\nusing Plots","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"and write a function that returns the OCP for a given final time","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"function ocp_T(T)\n    ocp = @def begin\n        t ∈ [0, T], time\n        x ∈ R², state\n        u ∈ R, control\n        q = x₁\n        v = x₂\n        q(0) == 0\n        v(0) == 0\n        q(T) == 1\n        v(T) == 0\n        ẋ(t) == [ v(t), u(t) ]\n        ∫(u(t)^2) → min\n    end\n    return ocp\nend\nnothing # hide","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Then we perform the continuation with a simple for loop, using each solution to initialize the next problem.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"init1 = ()\nfor T=1:5\n    ocp1 = ocp_T(T) \n    sol1 = solve(ocp1; display=false, init=init1)\n    global init1 = sol1\n    @printf(\"T %.2f objective %9.6f iterations %d\\n\", T, objective(sol1), iterations(sol1))\nend","category":"page"},{"location":"tutorial-continuation.html#Continuation-on-global-variable","page":"Discrete continuation","title":"Continuation on global variable","text":"","category":"section"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"As a second example, we show how to avoid redefining a new OCP each time, and modify the original one instead. More precisely we now solve a Goddard problem for a decreasing maximal thrust. If we store the value for Tmax in a global variable, we can simply modify this variable and keep the same OCP problem during the continuation.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Let us first define the Goddard problem (note that the formulation below illustrates all the possible constraints types, and the problem could be defined in a more compact way).","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Cd = 310\nTmax = 3.5\nβ = 500\nb = 2\nfunction F0(x)\n    r, v, m = x\n    D = Cd * v^2 * exp(-β*(r - 1))\n    return [ v, -D/m - 1/r^2, 0 ]\nend\nfunction F1(x)\n    r, v, m = x\n    return [ 0, Tmax/m, -b*Tmax ]\nend\nr0 = 1\nv0 = 0\nm0 = 1\nmf = 0.6\nx0 = [r0, v0, m0]\nvmax = 0.1\n\n@def ocp begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x ∈ R^3, state\n    u ∈ R, control\n    0.01 ≤ tf ≤ Inf\n    r = x[1]\n    v = x[2]\n    m = x[3]\n    x(0) == x0\n    m(tf) == mf\n    r0 ≤ r(t) ≤ r0 + 0.1\n    v0 ≤ v(t) ≤ vmax\n    mf ≤ m(t) ≤ m0\n    0 ≤ u(t) ≤ 1\n    ẋ(t) == F0(x(t)) + u(t) * F1(x(t))\n    r(tf) → max\nend\n\nsol0 = solve(ocp; display=false)\n@printf(\"Objective for reference solution %.6f\\n\", objective(sol0))","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Then we perform the continuation on the maximal thrust.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"sol       = sol0\nTmax_list = []\nobj_list  = []\nfor Tmax_local=3.5:-0.5:1\n    global Tmax = Tmax_local  \n    global sol = solve(ocp; display=false, init=sol)\n    @printf(\"Tmax %.2f objective %.6f iterations %d\\n\", Tmax, objective(sol), iterations(sol))\n    push!(Tmax_list, Tmax)\n    push!(obj_list, objective(sol))\nend ","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"We plot now the objective w.r.t the maximal thrust, as well as both solutions for Tmax=3.5 and Tmax=1.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"using Plots.PlotMeasures # for leftmargin\n\nplt_obj = plot(Tmax_list, obj_list;\n    seriestype=:scatter,\n    title=\"Goddard problem\",\n    label=\"r(tf)\", \n    xlabel=\"Maximal thrust (Tmax)\",\n    ylabel=\"Maximal altitude r(tf)\")\n\nplt_sol = plot(sol0; solution_label=\"(Tmax = \"*string(Tmax_list[1])*\")\")\nplot!(plt_sol, sol;  solution_label=\"(Tmax = \"*string(Tmax_list[end])*\")\")\n\nlayout = grid(2, 1, heights=[0.2, 0.8])\nplot(plt_obj, plt_sol; layout=layout, size=(800, 1000), leftmargin=5mm)","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"","category":"page"},{"location":"dev-ctmodels.html#CTModels.jl","page":"CTModels.jl","title":"CTModels.jl","text":"","category":"section"},{"location":"dev-ctmodels.html","page":"CTModels.jl","title":"CTModels.jl","text":"CollapsedDocStrings = false","category":"page"},{"location":"dev-ctmodels.html","page":"CTModels.jl","title":"CTModels.jl","text":"The CTModels.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"dev-ctmodels.html","page":"CTModels.jl","title":"CTModels.jl","text":"flowchart TD\nB(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctbase.html'>CTBase</a>)\nM(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctmodels.html'>CTModels</a>)\nP(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctparser.html'>CTParser</a>)\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-optimalcontrol.html'>OptimalControl</a>)\nD(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctdirect.html'>CTDirect</a>)\nF(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> B\nM --> B\nstyle M fill:#FBF275","category":"page"},{"location":"dev-ctmodels.html#Index","page":"CTModels.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctmodels.html","page":"CTModels.jl","title":"CTModels.jl","text":"Pages   = [\"dev-ctmodels.md\"]\nModules = [CTModels]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctmodels.html#Documentation","page":"CTModels.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctmodels.html#Public","page":"CTModels.jl","title":"Public","text":"","category":"section"},{"location":"dev-ctmodels.html","page":"CTModels.jl","title":"CTModels.jl","text":"Modules = [CTModels]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"dev-ctmodels.html#Private","page":"CTModels.jl","title":"Private","text":"","category":"section"},{"location":"dev-ctmodels.html","page":"CTModels.jl","title":"CTModels.jl","text":"Modules = [CTModels]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-ctmodels.html#CTModels.AbstractConstraintsModel","page":"CTModels.jl","title":"CTModels.AbstractConstraintsModel","text":"abstract type AbstractConstraintsModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractControlModel","page":"CTModels.jl","title":"CTModels.AbstractControlModel","text":"abstract type AbstractControlModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractDualModel","page":"CTModels.jl","title":"CTModels.AbstractDualModel","text":"abstract type AbstractDualModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractModel","page":"CTModels.jl","title":"CTModels.AbstractModel","text":"abstract type AbstractModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractObjectiveModel","page":"CTModels.jl","title":"CTModels.AbstractObjectiveModel","text":"abstract type AbstractObjectiveModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractSolution","page":"CTModels.jl","title":"CTModels.AbstractSolution","text":"abstract type AbstractSolution\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractSolverInfos","page":"CTModels.jl","title":"CTModels.AbstractSolverInfos","text":"abstract type AbstractSolverInfos\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractStateModel","page":"CTModels.jl","title":"CTModels.AbstractStateModel","text":"abstract type AbstractStateModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractTimeGridModel","page":"CTModels.jl","title":"CTModels.AbstractTimeGridModel","text":"abstract type AbstractTimeGridModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractTimeModel","page":"CTModels.jl","title":"CTModels.AbstractTimeModel","text":"abstract type AbstractTimeModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractTimesModel","page":"CTModels.jl","title":"CTModels.AbstractTimesModel","text":"abstract type AbstractTimesModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.AbstractVariableModel","page":"CTModels.jl","title":"CTModels.AbstractVariableModel","text":"abstract type AbstractVariableModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.BolzaObjectiveModel","page":"CTModels.jl","title":"CTModels.BolzaObjectiveModel","text":"struct BolzaObjectiveModel{TM<:Function, TL<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nmayer::Function\nlagrange::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.ConstraintsModel","page":"CTModels.jl","title":"CTModels.ConstraintsModel","text":"struct ConstraintsModel{TP<:Tuple, TB<:Tuple, TS<:Tuple, TC<:Tuple, TV<:Tuple, TC_ALL<:Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}} <: CTModels.AbstractConstraintsModel\n\nFields\n\npath_nl::Tuple\nboundary_nl::Tuple\nstate_box::Tuple\ncontrol_box::Tuple\nvariable_box::Tuple\ndict::Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.ControlModel","page":"CTModels.jl","title":"CTModels.ControlModel","text":"struct ControlModel <: CTModels.AbstractControlModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.ControlModelSolution","page":"CTModels.jl","title":"CTModels.ControlModelSolution","text":"struct ControlModelSolution{TS<:Function} <: CTModels.AbstractControlModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Function\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.DualModel","page":"CTModels.jl","title":"CTModels.DualModel","text":"struct DualModel{PC<:Function, PC_Dual<:Function, BC<:(AbstractVector{<:Real}), BC_Dual<:(AbstractVector{<:Real}), SC_LB_Dual<:Function, SC_UB_Dual<:Function, CC_LB_Dual<:Function, CC_UB_Dual<:Function, VC_LB_Dual<:(AbstractVector{<:Real}), VC_UB_Dual<:(AbstractVector{<:Real})} <: CTModels.AbstractDualModel\n\nFields\n\npath_constraints::Function\npath_constraints_dual::Function\nboundary_constraints::AbstractVector{<:Real}\nboundary_constraints_dual::AbstractVector{<:Real}\nstate_constraints_lb_dual::Function\nstate_constraints_ub_dual::Function\ncontrol_constraints_lb_dual::Function\ncontrol_constraints_ub_dual::Function\nvariable_constraints_lb_dual::AbstractVector{<:Real}\nvariable_constraints_ub_dual::AbstractVector{<:Real}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.EmptyTimeGridModel","page":"CTModels.jl","title":"CTModels.EmptyTimeGridModel","text":"struct EmptyTimeGridModel <: CTModels.AbstractTimeGridModel\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.EmptyVariableModel","page":"CTModels.jl","title":"CTModels.EmptyVariableModel","text":"struct EmptyVariableModel <: CTModels.AbstractVariableModel\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.FixedTimeModel","page":"CTModels.jl","title":"CTModels.FixedTimeModel","text":"struct FixedTimeModel{T<:Real} <: CTModels.AbstractTimeModel\n\nFields\n\ntime::Real\nname::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.FreeTimeModel","page":"CTModels.jl","title":"CTModels.FreeTimeModel","text":"struct FreeTimeModel <: CTModels.AbstractTimeModel\n\nFields\n\nindex::Int64\nname::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.Init","page":"CTModels.jl","title":"CTModels.Init","text":"Initial guess for OCP, contains\n\nfunctions of time for the state and control variables\nvector for optimization variables\n\nInitialization data for each field can be left to default or: \n\nvector for optimization variables\nconstant / vector / function for state and control  \nexisting solution ('warm start') for all fields\n\nConstructors:\n\nInit(): default initialization\nInit(state, control, variable, time): constant vector, function handles and / or matrices / vectors interpolated along given time grid\nInit(sol): from existing solution\n\nExamples\n\njulia> init = Init()\njulia> init = Init(state=[0.1, 0.2], control=0.3)\njulia> init = Init(state=[0.1, 0.2], control=0.3, variable=0.5)\njulia> init = Init(state=[0.1, 0.2], controlt=t->sin(t), variable=0.5)\njulia> init = Init(state=[[0, 0], [1, 2], [5, -1]], time=[0, .3, 1.], controlt=t->sin(t))\njulia> init = Init(sol)\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.LagrangeObjectiveModel","page":"CTModels.jl","title":"CTModels.LagrangeObjectiveModel","text":"struct LagrangeObjectiveModel{TL<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nlagrange::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.MayerObjectiveModel","page":"CTModels.jl","title":"CTModels.MayerObjectiveModel","text":"struct MayerObjectiveModel{TM<:Function} <: CTModels.AbstractObjectiveModel\n\nFields\n\nmayer::Function\ncriterion::Symbol\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.Model","page":"CTModels.jl","title":"CTModels.Model","text":"struct Model{TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:CTModels.AbstractConstraintsModel} <: CTModels.AbstractModel\n\nFields\n\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ndynamics::Function\nobjective::CTModels.AbstractObjectiveModel\nconstraints::CTModels.AbstractConstraintsModel\ndefinition::Expr\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.PreModel","page":"CTModels.jl","title":"CTModels.PreModel","text":"mutable struct PreModel <: CTModels.AbstractModel\n\nFields\n\ntimes::Union{Nothing, CTModels.AbstractTimesModel}: Default: nothing\nstate::Union{Nothing, CTModels.AbstractStateModel}: Default: nothing\ncontrol::Union{Nothing, CTModels.AbstractControlModel}: Default: nothing\nvariable::CTModels.AbstractVariableModel: Default: EmptyVariableModel()\ndynamics::Union{Nothing, Function}: Default: nothing\nobjective::Union{Nothing, CTModels.AbstractObjectiveModel}: Default: nothing\nconstraints::Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}: Default: ConstraintsDictType()\ndefinition::Union{Nothing, Expr}: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.Solution","page":"CTModels.jl","title":"CTModels.Solution","text":"struct Solution{TimeGridModelType<:CTModels.AbstractTimeGridModel, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, CostateModelType<:Function, ObjectiveValueType<:Real, DualModelType<:CTModels.AbstractDualModel, SolverInfosType<:CTModels.AbstractSolverInfos} <: CTModels.AbstractSolution\n\nFields\n\ntime_grid::CTModels.AbstractTimeGridModel\ntimes::CTModels.AbstractTimesModel\nstate::CTModels.AbstractStateModel\ncontrol::CTModels.AbstractControlModel\nvariable::CTModels.AbstractVariableModel\ncostate::Function\nobjective::Real\ndual::CTModels.AbstractDualModel\nsolver_infos::CTModels.AbstractSolverInfos\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.SolverInfos","page":"CTModels.jl","title":"CTModels.SolverInfos","text":"struct SolverInfos{TI<:Dict{Symbol, Any}} <: CTModels.AbstractSolverInfos\n\nFields\n\niterations::Int64\nstopping::Symbol\nmessage::String\nsuccess::Bool\nconstraints_violation::Float64\ninfos::Dict{Symbol, Any}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.StateModel","page":"CTModels.jl","title":"CTModels.StateModel","text":"struct StateModel <: CTModels.AbstractStateModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.StateModelSolution","page":"CTModels.jl","title":"CTModels.StateModelSolution","text":"struct StateModelSolution{TS<:Function} <: CTModels.AbstractStateModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Function\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.TimeGridModel","page":"CTModels.jl","title":"CTModels.TimeGridModel","text":"struct TimeGridModel{T<:Union{StepRangeLen, AbstractVector{<:Real}}} <: CTModels.AbstractTimeGridModel\n\nFields\n\nvalue::Union{StepRangeLen, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.TimesModel","page":"CTModels.jl","title":"CTModels.TimesModel","text":"struct TimesModel{TI<:CTModels.AbstractTimeModel, TF<:CTModels.AbstractTimeModel} <: CTModels.AbstractTimesModel\n\nFields\n\ninitial::CTModels.AbstractTimeModel\nfinal::CTModels.AbstractTimeModel\ntime_name::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.VariableModel","page":"CTModels.jl","title":"CTModels.VariableModel","text":"struct VariableModel <: CTModels.AbstractVariableModel\n\nFields\n\nname::String\ncomponents::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#CTModels.VariableModelSolution","page":"CTModels.jl","title":"CTModels.VariableModelSolution","text":"struct VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}} <: CTModels.AbstractVariableModel\n\nFields\n\nname::String\ncomponents::Vector{String}\nvalue::Union{Real, AbstractVector{<:Real}}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctmodels.html#Base.isempty-Tuple{CTModels.ConstraintsModel}","page":"CTModels.jl","title":"Base.isempty","text":"isempty(model::CTModels.ConstraintsModel) -> Bool\n\n\nReturn if the constraints model is not empty.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTModels.PreModel}","page":"CTModels.jl","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::CTModels.PreModel\n)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTModels.Solution}","page":"CTModels.jl","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    sol::CTModels.Solution\n)\n\n\nPrints the solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Model}","page":"CTModels.jl","title":"Base.show","text":"show(io::IO, _::MIME{Symbol(\"text/plain\")}, ocp::Model)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__constraint!-Tuple{Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}, Symbol, Int64, Int64, Int64}","page":"CTModels.jl","title":"CTModels.__constraint!","text":"__constraint!(\n    ocp_constraints::Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}},\n    type::Symbol,\n    n::Int64,\n    m::Int64,\n    q::Int64;\n    rg,\n    f,\n    lb,\n    ub,\n    label\n)\n\n\nAdd a constraint to a dictionary of constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__constraint_label-Tuple{}","page":"CTModels.jl","title":"CTModels.__constraint_label","text":"__constraint_label() -> Symbol\n\n\nUsed to set the default value of the label of a constraint. A unique value is given to each constraint using the gensym function and prefixing by :unamed.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__control_components-Tuple{Int64, String}","page":"CTModels.jl","title":"CTModels.__control_components","text":"__control_components(\n    m::Int64,\n    name::String\n) -> Vector{String}\n\n\nUsed to set the default value of the names of the controls. The default value is [\"u\"] for a one dimensional control, and [\"u₁\", \"u₂\", ...] for a multi dimensional control.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__control_name-Tuple{}","page":"CTModels.jl","title":"CTModels.__control_name","text":"__control_name() -> String\n\n\nUsed to set the default value of the names of the control. The default value is \"u\".\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__criterion_type-Tuple{}","page":"CTModels.jl","title":"CTModels.__criterion_type","text":"__criterion_type() -> Symbol\n\n\nUsed to set the default value of the type of criterion. Either :min or :max. The default value is :min. The other possible criterion type is :max.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_consistent-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_consistent","text":"__is_consistent(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_control_set-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_control_set","text":"__is_control_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_control_set-Tuple{Model}","page":"CTModels.jl","title":"CTModels.__is_control_set","text":"__is_control_set(ocp::Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_definition_set-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_definition_set","text":"__is_definition_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_definition_set-Tuple{Model}","page":"CTModels.jl","title":"CTModels.__is_definition_set","text":"__is_definition_set(ocp::Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_dynamics_set-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_dynamics_set","text":"__is_dynamics_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_dynamics_set-Tuple{Model}","page":"CTModels.jl","title":"CTModels.__is_dynamics_set","text":"__is_dynamics_set(ocp::Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_empty-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_empty","text":"__is_empty(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_objective_set-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_objective_set","text":"__is_objective_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_objective_set-Tuple{Model}","page":"CTModels.jl","title":"CTModels.__is_objective_set","text":"__is_objective_set(ocp::Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_state_set-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_state_set","text":"__is_state_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_state_set-Tuple{Model}","page":"CTModels.jl","title":"CTModels.__is_state_set","text":"__is_state_set(ocp::Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_times_set-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_times_set","text":"__is_times_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_times_set-Tuple{Model}","page":"CTModels.jl","title":"CTModels.__is_times_set","text":"__is_times_set(ocp::Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_variable_set-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.__is_variable_set","text":"__is_variable_set(ocp::CTModels.PreModel) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__is_variable_set-Tuple{Model}","page":"CTModels.jl","title":"CTModels.__is_variable_set","text":"__is_variable_set(ocp::Model) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__state_components-Tuple{Int64, String}","page":"CTModels.jl","title":"CTModels.__state_components","text":"__state_components(n::Int64, name::String) -> Vector{String}\n\n\nUsed to set the default value of the names of the states. The default value is [\"x\"] for a one dimensional state, and [\"x₁\", \"x₂\", ...] for a multi dimensional state.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__state_name-Tuple{}","page":"CTModels.jl","title":"CTModels.__state_name","text":"__state_name() -> String\n\n\nUsed to set the default value of the name of the state. The default value is \"x\".\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__time_name-Tuple{}","page":"CTModels.jl","title":"CTModels.__time_name","text":"__time_name() -> String\n\n\nUsed to set the default value of the name of the time. The default value is t.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__variable_components-Tuple{Int64, String}","page":"CTModels.jl","title":"CTModels.__variable_components","text":"__variable_components(\n    q::Int64,\n    name::String\n) -> Vector{String}\n\n\nUsed to set the default value of the names of the variables. The default value is [\"v\"] for a one dimensional variable, and [\"v₁\", \"v₂\", ...] for a multi dimensional variable.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.__variable_name-Tuple{Int64}","page":"CTModels.jl","title":"CTModels.__variable_name","text":"__variable_name(q::Int64) -> String\n\n\nUsed to set the default value of the names of the variables. The default value is \"v\".\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.boundary_constraints-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.boundary_constraints","text":"boundary_constraints(\n    sol::CTModels.Solution\n) -> AbstractVector{<:Real}\n\n\nReturn the boundary constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.boundary_constraints_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.boundary_constraints_dual","text":"boundary_constraints_dual(\n    sol::CTModels.Solution\n) -> AbstractVector{<:Real}\n\n\nReturn the dual of the boundary constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.boundary_constraints_nl-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, TB}}, Tuple{TB}} where TB","page":"CTModels.jl","title":"CTModels.boundary_constraints_nl","text":"boundary_constraints_nl(\n    model::CTModels.ConstraintsModel{<:Tuple, TB}\n) -> Any\n\n\nGet the nonlinear boundary constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.boundary_constraints_nl-Union{Tuple{Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, TB}}}, Tuple{TB}} where TB<:Tuple","page":"CTModels.jl","title":"CTModels.boundary_constraints_nl","text":"boundary_constraints_nl(\n    ocp::Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, TB<:Tuple}}\n) -> Any\n\n\nGet the nonlinear boundary constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.buildFunctionalInit-Tuple{Any, Any, Any}","page":"CTModels.jl","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(data, time, dim) -> CTModels.var\"#14#15\"\n\n\nBuild functional initialization: general interpolation case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.buildFunctionalInit-Tuple{Function, Any, Any}","page":"CTModels.jl","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Function,\n    time,\n    dim\n) -> CTModels.var\"#16#17\"{<:Function}\n\n\nBuild functional initialization: function case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.buildFunctionalInit-Tuple{Nothing, Any, Any}","page":"CTModels.jl","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Nothing,\n    time,\n    dim\n) -> CTModels.var\"#14#15\"\n\n\nBuild functional initialization: default case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.buildFunctionalInit-Tuple{Union{Real, AbstractVector{<:Real}}, Any, Any}","page":"CTModels.jl","title":"CTModels.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Union{Real, AbstractVector{<:Real}},\n    time,\n    dim\n) -> Union{CTModels.var\"#18#20\", CTModels.var\"#19#21\"}\n\n\nBuild functional initialization: constant / 1D interpolation\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.buildVectorInit-Tuple{Any, Any}","page":"CTModels.jl","title":"CTModels.buildVectorInit","text":"buildVectorInit(data, dim) -> Any\n\n\nBuild vector initialization: default / vector case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.build_constraints-Tuple{Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}}","page":"CTModels.jl","title":"CTModels.build_constraints","text":"build_constraints(\n    constraints::Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}\n) -> CTModels.ConstraintsModel{TP, TB, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}} where {TP<:Tuple{Vector{Real}, Any, Vector{Real}}, TB<:Tuple{Vector{Real}, Any, Vector{Real}}}\n\n\nBuild a concrete type constraints model from a dictionary of constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.build_model-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.build_model","text":"build_model(\n    pre_ocp::CTModels.PreModel\n) -> Model{TimesModelType, StateModelType, ControlModelType, VariableModelType, DynamicsModelType, ObjectiveModelType, ConstraintsModelType} where {TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:(CTModels.ConstraintsModel{TP, TB, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Dict{Symbol, Tuple{Symbol, Union{Function, OrdinalRange{<:Int64}}, AbstractVector{<:Real}, AbstractVector{<:Real}}}} where {TP<:Tuple{Vector{Real}, Any, Vector{Real}}, TB<:Tuple{Vector{Real}, Any, Vector{Real}}})}\n\n\nBuild a concrete type model from a pre-model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.build_solution-Union{Tuple{TP}, Tuple{TU}, Tuple{TX}, Tuple{Model, Vector{Float64}, TX, TU, Vector{Float64}, TP}} where {TX<:Union{Function, Matrix{Float64}}, TU<:Union{Function, Matrix{Float64}}, TP<:Union{Function, Matrix{Float64}}}","page":"CTModels.jl","title":"CTModels.build_solution","text":"build_solution(\n    ocp::Model,\n    T::Vector{Float64},\n    X::Union{Function, Matrix{Float64}},\n    U::Union{Function, Matrix{Float64}},\n    v::Vector{Float64},\n    P::Union{Function, Matrix{Float64}};\n    objective,\n    iterations,\n    constraints_violation,\n    message,\n    stopping,\n    success,\n    path_constraints,\n    path_constraints_dual,\n    boundary_constraints,\n    boundary_constraints_dual,\n    state_constraints_lb_dual,\n    state_constraints_ub_dual,\n    control_constraints_lb_dual,\n    control_constraints_ub_dual,\n    variable_constraints_lb_dual,\n    variable_constraints_ub_dual\n)\n\n\nBuild a solution from the optimal control problem, the time grid, the state, control, variable, and dual variables.\n\nArguments\n\nocp::Model: the optimal control problem.\nT::Vector{Float64}: the time grid.\nX::Matrix{Float64}: the state trajectory.\nU::Matrix{Float64}: the control trajectory.\nv::Vector{Float64}: the variable trajectory.\nP::Matrix{Float64}: the costate trajectory.\nobjective::Float64: the objective value.\niterations::Int: the number of iterations.\nconstraints_violation::Float64: the constraints violation.\nmessage::String: the message associated to the stopping criterion.\nstopping::Symbol: the stopping criterion.\nsuccess::Bool: the success status.\npath_constraints::Matrix{Float64}: the path constraints.\npath_constraints_dual::Matrix{Float64}: the dual of the path constraints.\nboundary_constraints::Vector{Float64}: the boundary constraints.\nboundary_constraints_dual::Vector{Float64}: the dual of the boundary constraints.\nstate_constraints_lb_dual::Matrix{Float64}: the lower bound dual of the state constraints.\nstate_constraints_ub_dual::Matrix{Float64}: the upper bound dual of the state constraints.\ncontrol_constraints_lb_dual::Matrix{Float64}: the lower bound dual of the control constraints.\ncontrol_constraints_ub_dual::Matrix{Float64}: the upper bound dual of the control constraints.\nvariable_constraints_lb_dual::Vector{Float64}: the lower bound dual of the variable constraints.\nvariable_constraints_ub_dual::Vector{Float64}: the upper bound dual of the variable constraints.\n\nReturns\n\nsol::Solution: the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.checkDim-Tuple{Any, Any}","page":"CTModels.jl","title":"CTModels.checkDim","text":"checkDim(actual_dim, target_dim)\n\n\nCheck if actual dimension is equal to target dimension, error otherwise\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.components-Tuple{CTModels.ControlModelSolution}","page":"CTModels.jl","title":"CTModels.components","text":"components(\n    model::CTModels.ControlModelSolution\n) -> Vector{String}\n\n\nGet the components names of the control from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.components-Tuple{CTModels.ControlModel}","page":"CTModels.jl","title":"CTModels.components","text":"components(model::CTModels.ControlModel) -> Vector{String}\n\n\nGet the components names of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.components-Tuple{CTModels.EmptyVariableModel}","page":"CTModels.jl","title":"CTModels.components","text":"components(_::CTModels.EmptyVariableModel) -> Vector{String}\n\n\nGet the components names of the variable from the empty variable model. Return an empty vector.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.components-Tuple{CTModels.StateModelSolution}","page":"CTModels.jl","title":"CTModels.components","text":"components(\n    model::CTModels.StateModelSolution\n) -> Vector{String}\n\n\nGet the components names of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.components-Tuple{CTModels.StateModel}","page":"CTModels.jl","title":"CTModels.components","text":"components(model::CTModels.StateModel) -> Vector{String}\n\n\nGet the components names of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.components-Tuple{CTModels.VariableModelSolution}","page":"CTModels.jl","title":"CTModels.components","text":"components(\n    model::CTModels.VariableModelSolution\n) -> Vector{String}\n\n\nGet the components names of the variable from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.components-Tuple{CTModels.VariableModel}","page":"CTModels.jl","title":"CTModels.components","text":"components(model::CTModels.VariableModel) -> Vector{String}\n\n\nGet the components names of the variable from the variable model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.constraint!-Tuple{CTModels.PreModel, Symbol}","page":"CTModels.jl","title":"CTModels.constraint!","text":"constraint!(\n    ocp::CTModels.PreModel,\n    type::Symbol;\n    rg,\n    f,\n    lb,\n    ub,\n    label\n)\n\n\nAdd a constraint to a pre-model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.constraint-Tuple{Model, Symbol}","page":"CTModels.jl","title":"CTModels.constraint","text":"constraint(ocp::Model, label::Symbol) -> Tuple\n\n\nGet a labelled constraint from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.constraints-Union{Tuple{Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, C}}, Tuple{C}} where C<:CTModels.AbstractConstraintsModel","page":"CTModels.jl","title":"CTModels.constraints","text":"constraints(\n    ocp::Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, C<:CTModels.AbstractConstraintsModel}\n) -> CTModels.AbstractConstraintsModel\n\n\nGet the constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.constraints_violation-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.constraints_violation","text":"constraints_violation(sol::CTModels.Solution) -> Float64\n\n\nReturn the constraints violation of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"CTModels.jl","title":"CTModels.control!","text":"control!(ocp::CTModels.PreModel, m::Int64)\ncontrol!(\n    ocp::CTModels.PreModel,\n    m::Int64,\n    name::Union{String, Symbol}\n)\ncontrol!(\n    ocp::CTModels.PreModel,\n    m::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the control dimension and possibly the names of each coordinate.\n\nnote: Note\nYou must use control! only once to set the control dimension.\n\nExamples\n\njulia> control!(ocp, 1)\njulia> control_dimension(ocp)\n1\njulia> control_components(ocp)\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> control_dimension(ocp)\n1\njulia> control_components(ocp)\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\", [\"a\", \"b\"])\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"a\", \"b\"]\n\njulia> control!(ocp, 2, \"v\", [:a, :b])\njulia> control_dimension(ocp)\n2\njulia> control_components(ocp)\n[\"a\", \"b\"]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.ControlModelSolution{TS}}}, Tuple{TS}} where TS<:Function","page":"CTModels.jl","title":"CTModels.control","text":"control(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.ControlModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the control (function of time) of the optimal control solution.\n\njulia> t0 = time_grid(sol)[1]\njulia> u  = control(sol)\njulia> u0 = u(t0) # control at initial time\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control-Union{Tuple{Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, T}}, Tuple{T}} where T<:CTModels.AbstractControlModel","page":"CTModels.jl","title":"CTModels.control","text":"control(\n    ocp::Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, T<:CTModels.AbstractControlModel}\n) -> CTModels.AbstractControlModel\n\n\nGet the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_components-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.control_components","text":"control_components(sol::CTModels.Solution) -> Vector{String}\n\n\nReturn the names of the components of the control of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_components-Tuple{Model}","page":"CTModels.jl","title":"CTModels.control_components","text":"control_components(ocp::Model) -> Vector{String}\n\n\nGet the components names of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_constraints_box-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}}, Tuple{TC}} where TC","page":"CTModels.jl","title":"CTModels.control_constraints_box","text":"control_constraints_box(\n    model::CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}\n) -> Any\n\n\nGet the control box constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_constraints_box-Union{Tuple{Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC}}}, Tuple{TC}} where TC<:Tuple","page":"CTModels.jl","title":"CTModels.control_constraints_box","text":"control_constraints_box(\n    ocp::Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, TC<:Tuple}}\n) -> Any\n\n\nGet the box constraints on control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_constraints_lb_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.control_constraints_lb_dual","text":"control_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Function\n\n\nReturn the lower bound dual of the control constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_constraints_ub_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.control_constraints_ub_dual","text":"control_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Function\n\n\nReturn the upper bound dual of the control constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_dimension-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.control_dimension","text":"control_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the control of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_dimension-Tuple{Model}","page":"CTModels.jl","title":"CTModels.control_dimension","text":"control_dimension(ocp::Model) -> Int64\n\n\nGet the control dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_discretized-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.control_discretized","text":"control_discretized(sol::CTModels.Solution) -> Any\n\n\nReturn the control values at times time_grid(sol) of the optimal control solution or nothing.\n\njulia> u  = control_discretized(sol)\njulia> u0 = u[1] # control at initial time\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_name-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.control_name","text":"control_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the control of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.control_name-Tuple{Model}","page":"CTModels.jl","title":"CTModels.control_name","text":"control_name(ocp::Model) -> String\n\n\nGet the name of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.costate-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, Co}}, Tuple{Co}} where Co<:Function","page":"CTModels.jl","title":"CTModels.costate","text":"costate(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, Co<:Function}\n) -> Function\n\n\nReturn the costate of the optimal control solution.\n\njulia> t0 = time_grid(sol)[1]\njulia> p  = costate(sol)\njulia> p0 = p(t0)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.costate_discretized-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.costate_discretized","text":"costate_discretized(sol::CTModels.Solution) -> Any\n\n\nReturn the costate values at times time_grid(sol) of the optimal control solution or nothing.\n\njulia> p  = costate_discretized(sol)\njulia> p0 = p[1] # costate at initial time\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.criterion-Tuple{CTModels.BolzaObjectiveModel}","page":"CTModels.jl","title":"CTModels.criterion","text":"criterion(model::CTModels.BolzaObjectiveModel) -> Symbol\n\n\nGet the criterion (:min or :max) of the Bolza objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.criterion-Tuple{CTModels.LagrangeObjectiveModel}","page":"CTModels.jl","title":"CTModels.criterion","text":"criterion(model::CTModels.LagrangeObjectiveModel) -> Symbol\n\n\nGet the criterion (:min or :max) of the Lagrange objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.criterion-Tuple{CTModels.MayerObjectiveModel}","page":"CTModels.jl","title":"CTModels.criterion","text":"criterion(model::CTModels.MayerObjectiveModel) -> Symbol\n\n\nGet the criterion (:min or :max) of the Mayer objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.criterion-Tuple{Model}","page":"CTModels.jl","title":"CTModels.criterion","text":"criterion(ocp::Model) -> Symbol\n\n\nGet the type of criterion (:min or :max) from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.ctinterpolate-Tuple{Any, Any}","page":"CTModels.jl","title":"CTModels.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn the interpolation of f at x.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.definition!-Tuple{CTModels.PreModel, Expr}","page":"CTModels.jl","title":"CTModels.definition!","text":"definition!(ocp::CTModels.PreModel, definition::Expr)\n\n\nSet the model definition of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.definition-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.definition","text":"definition(ocp::CTModels.PreModel) -> Union{Nothing, Expr}\n\n\nReturn the model definition of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.definition-Tuple{Model}","page":"CTModels.jl","title":"CTModels.definition","text":"definition(ocp::Model) -> Expr\n\n\nReturn the model definition of the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_boundary_constraints_nl-Tuple{CTModels.ConstraintsModel}","page":"CTModels.jl","title":"CTModels.dim_boundary_constraints_nl","text":"dim_boundary_constraints_nl(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of nonlinear boundary constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_boundary_constraints_nl-Tuple{Model}","page":"CTModels.jl","title":"CTModels.dim_boundary_constraints_nl","text":"dim_boundary_constraints_nl(ocp::Model) -> Int64\n\n\nReturn the dimension of the boundary constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_control_constraints_box-Tuple{CTModels.ConstraintsModel}","page":"CTModels.jl","title":"CTModels.dim_control_constraints_box","text":"dim_control_constraints_box(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of control box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_control_constraints_box-Tuple{Model}","page":"CTModels.jl","title":"CTModels.dim_control_constraints_box","text":"dim_control_constraints_box(ocp::Model) -> Int64\n\n\nReturn the dimension of box constraints on control.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_path_constraints_nl-Tuple{CTModels.ConstraintsModel}","page":"CTModels.jl","title":"CTModels.dim_path_constraints_nl","text":"dim_path_constraints_nl(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of nonlinear path constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_path_constraints_nl-Tuple{Model}","page":"CTModels.jl","title":"CTModels.dim_path_constraints_nl","text":"dim_path_constraints_nl(ocp::Model) -> Int64\n\n\nReturn the dimension of nonlinear path constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_state_constraints_box-Tuple{CTModels.ConstraintsModel}","page":"CTModels.jl","title":"CTModels.dim_state_constraints_box","text":"dim_state_constraints_box(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of state box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_state_constraints_box-Tuple{Model}","page":"CTModels.jl","title":"CTModels.dim_state_constraints_box","text":"dim_state_constraints_box(ocp::Model) -> Int64\n\n\nReturn the dimension of box constraints on state.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_variable_constraints_box-Tuple{CTModels.ConstraintsModel}","page":"CTModels.jl","title":"CTModels.dim_variable_constraints_box","text":"dim_variable_constraints_box(\n    model::CTModels.ConstraintsModel\n) -> Int64\n\n\nReturn the dimension of variable box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dim_variable_constraints_box-Tuple{Model}","page":"CTModels.jl","title":"CTModels.dim_variable_constraints_box","text":"dim_variable_constraints_box(ocp::Model) -> Int64\n\n\nReturn the dimension of box constraints on variable.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dimension-Tuple{CTModels.ControlModelSolution}","page":"CTModels.jl","title":"CTModels.dimension","text":"dimension(model::CTModels.ControlModelSolution) -> Int64\n\n\nGet the control dimension from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dimension-Tuple{CTModels.ControlModel}","page":"CTModels.jl","title":"CTModels.dimension","text":"dimension(model::CTModels.ControlModel) -> Int64\n\n\nGet the control dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dimension-Tuple{CTModels.EmptyVariableModel}","page":"CTModels.jl","title":"CTModels.dimension","text":"dimension(_::CTModels.EmptyVariableModel) -> Int64\n\n\nGet the variable dimension from the empty variable model. Return 0.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dimension-Tuple{CTModels.StateModelSolution}","page":"CTModels.jl","title":"CTModels.dimension","text":"dimension(model::CTModels.StateModelSolution) -> Int64\n\n\nGet the dimension of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dimension-Tuple{CTModels.StateModel}","page":"CTModels.jl","title":"CTModels.dimension","text":"dimension(model::CTModels.StateModel) -> Int64\n\n\nGet the dimension of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dimension-Tuple{CTModels.VariableModelSolution}","page":"CTModels.jl","title":"CTModels.dimension","text":"dimension(model::CTModels.VariableModelSolution) -> Int64\n\n\nGet the variable dimension from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dimension-Tuple{CTModels.VariableModel}","page":"CTModels.jl","title":"CTModels.dimension","text":"dimension(model::CTModels.VariableModel) -> Int64\n\n\nGet the variable dimension from the variable model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dynamics!-Tuple{CTModels.PreModel, Function}","page":"CTModels.jl","title":"CTModels.dynamics!","text":"dynamics!(ocp::CTModels.PreModel, f::Function)\n\n\nSet the dynamics of the optimal control problem, in a pre-model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.dynamics-Union{Tuple{Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, D}}, Tuple{D}} where D<:Function","page":"CTModels.jl","title":"CTModels.dynamics","text":"dynamics(\n    ocp::Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, D<:Function}\n) -> Function\n\n\nGet the dynamics from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, TF}}, Tuple{TF}} where TF<:CTModels.AbstractTimeModel","page":"CTModels.jl","title":"CTModels.final","text":"final(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, TF<:CTModels.AbstractTimeModel}\n) -> CTModels.AbstractTimeModel\n\n\nGet the final time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"CTModels.jl","title":"CTModels.final_time","text":"final_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the final time from the times model, from a fixed final time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time-Union{Tuple{Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FixedTimeModel{T}}}}, Tuple{T}} where T<:Real","page":"CTModels.jl","title":"CTModels.final_time","text":"final_time(\n    ocp::Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nGet the final time from the model, for a fixed final time.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time-Union{Tuple{T}, Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}, AbstractVector{T}}} where T<:Real","page":"CTModels.jl","title":"CTModels.final_time","text":"final_time(\n    model::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the final time from the times model, from a free final time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time-Union{Tuple{T}, Tuple{Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}}, AbstractVector{T}}} where T<:Real","page":"CTModels.jl","title":"CTModels.final_time","text":"final_time(\n    ocp::Model{<:CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the final time from the model, for a free final time.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time_name-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.final_time_name","text":"final_time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the final time of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time_name-Tuple{CTModels.TimesModel}","page":"CTModels.jl","title":"CTModels.final_time_name","text":"final_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the final time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.final_time_name-Tuple{Model}","page":"CTModels.jl","title":"CTModels.final_time_name","text":"final_time_name(ocp::Model) -> String\n\n\nGet the name of the final time from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.formatData-Tuple{Any}","page":"CTModels.jl","title":"CTModels.formatData","text":"formatData(data) -> Any\n\n\nConvert matrix to vector of vectors (could be expanded)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.formatTimeGrid-Tuple{Any}","page":"CTModels.jl","title":"CTModels.formatTimeGrid","text":"formatTimeGrid(time) -> Any\n\n\nConvert matrix time-grid to vector\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_fixed_final_time-Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}}","page":"CTModels.jl","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the final time is free. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_fixed_final_time-Tuple{Model}","page":"CTModels.jl","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(ocp::Model) -> Bool\n\n\nCheck if the final time is fixed.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_fixed_final_time-Union{Tuple{CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"CTModels.jl","title":"CTModels.has_fixed_final_time","text":"has_fixed_final_time(\n    times::CTModels.TimesModel{<:CTModels.AbstractTimeModel, <:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the final time is fixed. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_fixed_initial_time-Tuple{CTModels.TimesModel{CTModels.FreeTimeModel}}","page":"CTModels.jl","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(\n    times::CTModels.TimesModel{CTModels.FreeTimeModel}\n) -> Bool\n\n\nCheck if the initial time is free. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_fixed_initial_time-Tuple{Model}","page":"CTModels.jl","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(ocp::Model) -> Bool\n\n\nCheck if the initial time is fixed.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_fixed_initial_time-Union{Tuple{CTModels.TimesModel{<:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"CTModels.jl","title":"CTModels.has_fixed_initial_time","text":"has_fixed_initial_time(\n    times::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Bool\n\n\nCheck if the initial time is fixed. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_free_final_time-Tuple{CTModels.TimesModel}","page":"CTModels.jl","title":"CTModels.has_free_final_time","text":"has_free_final_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_free_final_time-Tuple{Model}","page":"CTModels.jl","title":"CTModels.has_free_final_time","text":"has_free_final_time(ocp::Model) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_free_initial_time-Tuple{CTModels.TimesModel}","page":"CTModels.jl","title":"CTModels.has_free_initial_time","text":"has_free_initial_time(times::CTModels.TimesModel) -> Bool\n\n\nCheck if the final time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_free_initial_time-Tuple{Model}","page":"CTModels.jl","title":"CTModels.has_free_initial_time","text":"has_free_initial_time(ocp::Model) -> Bool\n\n\nCheck if the initial time is free.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_lagrange_cost-Tuple{CTModels.BolzaObjectiveModel}","page":"CTModels.jl","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    model::CTModels.BolzaObjectiveModel\n) -> Bool\n\n\nCheck if the Bolza objective model has a Lagrange function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_lagrange_cost-Tuple{CTModels.LagrangeObjectiveModel}","page":"CTModels.jl","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    model::CTModels.LagrangeObjectiveModel\n) -> Bool\n\n\nCheck if the Lagrange objective model has a Lagrange function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_lagrange_cost-Tuple{CTModels.MayerObjectiveModel}","page":"CTModels.jl","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(\n    model::CTModels.MayerObjectiveModel\n) -> Bool\n\n\nCheck if the Mayer objective model has a Lagrange function. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_lagrange_cost-Tuple{Model}","page":"CTModels.jl","title":"CTModels.has_lagrange_cost","text":"has_lagrange_cost(ocp::Model) -> Bool\n\n\nCheck if the model has a Lagrange cost.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_mayer_cost-Tuple{CTModels.BolzaObjectiveModel}","page":"CTModels.jl","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(model::CTModels.BolzaObjectiveModel) -> Bool\n\n\nCheck if the Bolza objective model has a Mayer function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_mayer_cost-Tuple{CTModels.LagrangeObjectiveModel}","page":"CTModels.jl","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(\n    model::CTModels.LagrangeObjectiveModel\n) -> Bool\n\n\nCheck if the Lagrange objective model has a Mayer function. Return false.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_mayer_cost-Tuple{CTModels.MayerObjectiveModel}","page":"CTModels.jl","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(model::CTModels.MayerObjectiveModel) -> Bool\n\n\nCheck if the Mayer objective model has a Mayer function. Return true.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.has_mayer_cost-Tuple{Model}","page":"CTModels.jl","title":"CTModels.has_mayer_cost","text":"has_mayer_cost(ocp::Model) -> Bool\n\n\nCheck if the model has a Mayer cost.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.index-Tuple{CTModels.FreeTimeModel}","page":"CTModels.jl","title":"CTModels.index","text":"index(model::CTModels.FreeTimeModel) -> Int64\n\n\nGet the index of the time variable from the free time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.infos-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.infos","text":"infos(sol::CTModels.Solution) -> Dict{Symbol, Any}\n\n\nReturn a dictionary of additional infos depending on the solver or nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial-Union{Tuple{CTModels.TimesModel{TI}}, Tuple{TI}} where TI<:CTModels.AbstractTimeModel","page":"CTModels.jl","title":"CTModels.initial","text":"initial(\n    model::CTModels.TimesModel{TI<:CTModels.AbstractTimeModel}\n) -> CTModels.AbstractTimeModel\n\n\nGet the initial time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial_time-Union{Tuple{CTModels.TimesModel{<:CTModels.FixedTimeModel{T}}}, Tuple{T}} where T<:Real","page":"CTModels.jl","title":"CTModels.initial_time","text":"initial_time(\n    model::CTModels.TimesModel{<:CTModels.FixedTimeModel{T<:Real}}\n) -> Real\n\n\nGet the initial time from the times model, from a fixed initial time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial_time-Union{Tuple{Model{<:CTModels.TimesModel{CTModels.FixedTimeModel{T}}}}, Tuple{T}} where T<:Real","page":"CTModels.jl","title":"CTModels.initial_time","text":"initial_time(\n    ocp::Model{<:CTModels.TimesModel{CTModels.FixedTimeModel{T<:Real}}}\n) -> Real\n\n\nGet the initial time from the model, for a fixed initial time.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial_time-Union{Tuple{T}, Tuple{CTModels.TimesModel{CTModels.FreeTimeModel}, AbstractVector{T}}} where T<:Real","page":"CTModels.jl","title":"CTModels.initial_time","text":"initial_time(\n    model::CTModels.TimesModel{CTModels.FreeTimeModel},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the initial time from the times model, from a free initial time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial_time-Union{Tuple{T}, Tuple{Model{<:CTModels.TimesModel{CTModels.FreeTimeModel}}, AbstractVector{T}}} where T<:Real","page":"CTModels.jl","title":"CTModels.initial_time","text":"initial_time(\n    ocp::Model{<:CTModels.TimesModel{CTModels.FreeTimeModel}},\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the initial time from the model, for a free initial time.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial_time_name-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.initial_time_name","text":"initial_time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the initial time of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial_time_name-Tuple{CTModels.TimesModel}","page":"CTModels.jl","title":"CTModels.initial_time_name","text":"initial_time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the initial time from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.initial_time_name-Tuple{Model}","page":"CTModels.jl","title":"CTModels.initial_time_name","text":"initial_time_name(ocp::Model) -> String\n\n\nGet the name of the initial time from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.is_empty_time_grid-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.is_empty_time_grid","text":"is_empty_time_grid(sol::CTModels.Solution) -> Bool\n\n\nCheck if the time grid is empty from the solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.isaVectVect-Tuple{Any}","page":"CTModels.jl","title":"CTModels.isaVectVect","text":"isaVectVect(data) -> Bool\n\n\nReturn true if argument is a vector of vectors\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.isempty_constraints-Tuple{Model}","page":"CTModels.jl","title":"CTModels.isempty_constraints","text":"isempty_constraints(ocp::Model) -> Bool\n\n\nReturn if the constraints from the model are not empty.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.iterations-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.iterations","text":"iterations(sol::CTModels.Solution) -> Int64\n\n\nReturn the number of iterations (if solved by an iterative method) of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.lagrange-Union{Tuple{CTModels.BolzaObjectiveModel{<:Function, L}}, Tuple{L}} where L<:Function","page":"CTModels.jl","title":"CTModels.lagrange","text":"lagrange(\n    model::CTModels.BolzaObjectiveModel{<:Function, L<:Function}\n) -> Function\n\n\nGet the Lagrange function of the Bolza objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.lagrange-Union{Tuple{CTModels.LagrangeObjectiveModel{L}}, Tuple{L}} where L<:Function","page":"CTModels.jl","title":"CTModels.lagrange","text":"lagrange(\n    model::CTModels.LagrangeObjectiveModel{L<:Function}\n) -> Function\n\n\nGet the Lagrange function of the Lagrange objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.lagrange-Union{Tuple{Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{<:Function, L}}}, Tuple{L}} where L<:Function","page":"CTModels.jl","title":"CTModels.lagrange","text":"lagrange(\n    ocp::Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{<:Function, L<:Function}}\n) -> Any\n\n\nGet the Lagrange cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.lagrange-Union{Tuple{Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, CTModels.LagrangeObjectiveModel{L}}}, Tuple{L}} where L<:Function","page":"CTModels.jl","title":"CTModels.lagrange","text":"lagrange(\n    ocp::Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, CTModels.LagrangeObjectiveModel{L<:Function}}\n) -> Function\n\n\nGet the Lagrange cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.matrix2vec","page":"CTModels.jl","title":"CTModels.matrix2vec","text":"matrix2vec(x::Matrix{<:Real}) -> Vector{<:Vector{<:Real}}\nmatrix2vec(\n    x::Matrix{<:Real},\n    dim::Int64\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms x to a Vector{<:Vector{<:ctNumber}}.\n\nNote. dim ∈ {1, 2} is the dimension along which the matrix is transformed.\n\n\n\n\n\n","category":"function"},{"location":"dev-ctmodels.html#CTModels.mayer-Union{Tuple{CTModels.BolzaObjectiveModel{M}}, Tuple{M}} where M<:Function","page":"CTModels.jl","title":"CTModels.mayer","text":"mayer(\n    model::CTModels.BolzaObjectiveModel{M<:Function}\n) -> Function\n\n\nGet the Mayer function of the Bolza objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.mayer-Union{Tuple{CTModels.MayerObjectiveModel{M}}, Tuple{M}} where M<:Function","page":"CTModels.jl","title":"CTModels.mayer","text":"mayer(\n    model::CTModels.MayerObjectiveModel{M<:Function}\n) -> Function\n\n\nGet the Mayer function of the Mayer objective model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.mayer-Union{Tuple{Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{M}}}, Tuple{M}} where M<:Function","page":"CTModels.jl","title":"CTModels.mayer","text":"mayer(\n    ocp::Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.BolzaObjectiveModel{M<:Function}}\n) -> Any\n\n\nGet the Mayer cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.mayer-Union{Tuple{Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.MayerObjectiveModel{M}}}, Tuple{M}} where M<:Function","page":"CTModels.jl","title":"CTModels.mayer","text":"mayer(\n    ocp::Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.MayerObjectiveModel{M<:Function}}\n) -> Any\n\n\nGet the Mayer cost from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.message-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.message","text":"message(sol::CTModels.Solution) -> String\n\n\nReturn the message associated to the stopping criterion of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.ControlModelSolution}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.ControlModelSolution) -> String\n\n\nGet the name of the control from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.ControlModel}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.ControlModel) -> String\n\n\nGet the name of the control from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.EmptyVariableModel}","page":"CTModels.jl","title":"CTModels.name","text":"name(_::CTModels.EmptyVariableModel) -> String\n\n\nGet the variable name from the empty variable model. Return an empty string.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.FixedTimeModel}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.FixedTimeModel) -> String\n\n\nGet the name of the time from the fixed time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.FreeTimeModel}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.FreeTimeModel) -> String\n\n\nGet the name of the time from the free time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.StateModelSolution}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.StateModelSolution) -> String\n\n\nGet the name of the state from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.StateModel}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.StateModel) -> String\n\n\nGet the name of the state from the state model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.VariableModelSolution}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.VariableModelSolution) -> String\n\n\nGet the variable name from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.name-Tuple{CTModels.VariableModel}","page":"CTModels.jl","title":"CTModels.name","text":"name(model::CTModels.VariableModel) -> String\n\n\nGet the variable name from the variable model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.objective!","page":"CTModels.jl","title":"CTModels.objective!","text":"objective!(ocp::CTModels.PreModel; ...)\nobjective!(\n    ocp::CTModels.PreModel,\n    criterion::Symbol;\n    mayer,\n    lagrange\n)\n\n\nSet the objective of the optimal control problem.\n\nArguments\n\nocp::PreModel: the optimal control problem.\ncriterion::Symbol: the type of criterion. Either :min or :max. Default is :min.\nmayer::Union{Function, Nothing}: the Mayer function (inplace). Default is nothing.\nlagrange::Union{Function, Nothing}: the Lagrange function (inplace). Default is nothing.\n\nnote: Note\nThe state, control and variable must be set before the objective.\nThe objective must not be set before.\nAt least one of the two functions must be given. Please provide a Mayer or a Lagrange function.\n\nExamples\n\n```@example julia> function mayer(x0, xf, v)            return x0[1] + xf[1] + v[1]        end juila> function lagrange(t, x, u, v)            return x[1] + u[1] + v[1]        end julia> objective!(ocp, :min, mayer=mayer, lagrange=lagrange)\n\n\n\n\n\n","category":"function"},{"location":"dev-ctmodels.html#CTModels.objective-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O}}, Tuple{O}} where O<:Real","page":"CTModels.jl","title":"CTModels.objective","text":"objective(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O<:Real}\n) -> Real\n\n\nReturn the objective value of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.objective-Union{Tuple{Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O}}, Tuple{O}} where O<:CTModels.AbstractObjectiveModel","page":"CTModels.jl","title":"CTModels.objective","text":"objective(\n    ocp::Model{<:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, O<:CTModels.AbstractObjectiveModel}\n) -> CTModels.AbstractObjectiveModel\n\n\nGet the objective from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.path_constraints-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.path_constraints","text":"path_constraints(sol::CTModels.Solution) -> Function\n\n\nReturn the path constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.path_constraints_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.path_constraints_dual","text":"path_constraints_dual(sol::CTModels.Solution) -> Function\n\n\nReturn the dual of the path constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.path_constraints_nl-Union{Tuple{CTModels.ConstraintsModel{TP}}, Tuple{TP}} where TP","page":"CTModels.jl","title":"CTModels.path_constraints_nl","text":"path_constraints_nl(\n    model::CTModels.ConstraintsModel{TP}\n) -> Any\n\n\nGet the nonlinear path constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.path_constraints_nl-Union{Tuple{Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{TP}}}, Tuple{TP}} where TP<:Tuple","page":"CTModels.jl","title":"CTModels.path_constraints_nl","text":"path_constraints_nl(\n    ocp::Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{TP<:Tuple}}\n) -> Any\n\n\nGet the nonlinear path constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"CTModels.jl","title":"CTModels.state!","text":"state!(ocp::CTModels.PreModel, n::Int64)\nstate!(\n    ocp::CTModels.PreModel,\n    n::Int64,\n    name::Union{String, Symbol}\n)\nstate!(\n    ocp::CTModels.PreModel,\n    n::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the state dimension and possibly the names of each component.\n\nnote: Note\nYou must use state! only once to set the state dimension.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> state_dimension(ocp)\n1\njulia> state_components(ocp)\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> state_dimension(ocp)\n1\njulia> state_components(ocp)\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\", [\"u\", \"v\"])\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"u\", \"v\"]\n\njulia> state!(ocp, 2, \"y\", [:u, :v])\njulia> state_dimension(ocp)\n2\njulia> state_components(ocp)\n[\"u\", \"v\"]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.StateModelSolution{TS}}}, Tuple{TS}} where TS<:Function","page":"CTModels.jl","title":"CTModels.state","text":"state(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.StateModelSolution{TS<:Function}}\n) -> Function\n\n\nReturn the state (function of time) of the optimal control solution.\n\njulia> t0 = time_grid(sol)[1]\njulia> x  = state(sol)\njulia> x0 = x(t0)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state-Union{Tuple{Model{<:CTModels.TimesModel, T}}, Tuple{T}} where T<:CTModels.AbstractStateModel","page":"CTModels.jl","title":"CTModels.state","text":"state(\n    ocp::Model{<:CTModels.TimesModel, T<:CTModels.AbstractStateModel}\n) -> CTModels.AbstractStateModel\n\n\nGet the state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_components-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.state_components","text":"state_components(sol::CTModels.Solution) -> Vector{String}\n\n\nReturn the names of the components of the state of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_components-Tuple{Model}","page":"CTModels.jl","title":"CTModels.state_components","text":"state_components(ocp::Model) -> Vector{String}\n\n\nGet the components names of the state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_constraints_box-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}}, Tuple{TS}} where TS","page":"CTModels.jl","title":"CTModels.state_constraints_box","text":"state_constraints_box(\n    model::CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}\n) -> Any\n\n\nGet the state box constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_constraints_box-Union{Tuple{Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS}}}, Tuple{TS}} where TS<:Tuple","page":"CTModels.jl","title":"CTModels.state_constraints_box","text":"state_constraints_box(\n    ocp::Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, TS<:Tuple}}\n) -> Any\n\n\nGet the box constraints on state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_constraints_lb_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.state_constraints_lb_dual","text":"state_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> Function\n\n\nReturn the lower bound dual of the state constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_constraints_ub_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.state_constraints_ub_dual","text":"state_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> Function\n\n\nReturn the upper bound dual of the state constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_dimension-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.state_dimension","text":"state_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the state of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_dimension-Tuple{Model}","page":"CTModels.jl","title":"CTModels.state_dimension","text":"state_dimension(ocp::Model) -> Int64\n\n\nGet the state dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_discretized-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.state_discretized","text":"state_discretized(sol::CTModels.Solution) -> Any\n\n\nReturn the state values at times time_grid(sol) of the optimal control solution or nothing.\n\njulia> x  = state_discretized(sol)\njulia> x0 = x[1] # state at initial time\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_name-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.state_name","text":"state_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the state of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.state_name-Tuple{Model}","page":"CTModels.jl","title":"CTModels.state_name","text":"state_name(ocp::Model) -> String\n\n\nGet the name of the state from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.stopping-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.stopping","text":"stopping(sol::CTModels.Solution) -> Symbol\n\n\nReturn the stopping criterion (a Symbol) of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.success-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.success","text":"success(sol::CTModels.Solution) -> Bool\n\n\nReturn the success status of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.time!-Tuple{CTModels.PreModel}","page":"CTModels.jl","title":"CTModels.time!","text":"time!(ocp::CTModels.PreModel; t0, tf, ind0, indf, time_name)\n\n\nSet the initial and final times. We denote by t0 the initial time and tf the final time. The optimal control problem is denoted ocp. When a time is free, then, one must provide the corresponding index of the ocp variable.\n\nnote: Note\nYou must use time! only once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, t0=0,   tf=1  ) # Fixed t0 and fixed tf\njulia> time!(ocp, t0=0,   indf=2) # Fixed t0 and free  tf\njulia> time!(ocp, ind0=2, tf=1  ) # Free  t0 and fixed tf\njulia> time!(ocp, ind0=2, indf=3) # Free  t0 and free  tf\n\nWhen you plot a solution of an optimal control problem, the name of the time variable appears. By default, the name is \"t\". Consider you want to set the name of the time variable to \"s\".\n\njulia> time!(ocp, t0=0, tf=1, name=\"s\") # name is a String\n# or\njulia> time!(ocp, t0=0, tf=1, name=:s ) # name is a Symbol  \n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.time-Union{Tuple{CTModels.FixedTimeModel{T}}, Tuple{T}} where T<:Real","page":"CTModels.jl","title":"CTModels.time","text":"time(model::CTModels.FixedTimeModel{T<:Real}) -> Real\n\n\nGet the time from the fixed time model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.time-Union{Tuple{T}, Tuple{CTModels.FreeTimeModel, AbstractVector{T}}} where T<:Real","page":"CTModels.jl","title":"CTModels.time","text":"time(\n    model::CTModels.FreeTimeModel,\n    variable::AbstractArray{T<:Real, 1}\n) -> Any\n\n\nGet the time from the free time model.\n\nExceptions\n\nIf the index of the time variable is not in [1, length(variable)], throw an error.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.time_grid-Union{Tuple{CTModels.Solution{<:CTModels.TimeGridModel{T}}}, Tuple{T}} where T<:Union{StepRangeLen, AbstractVector{<:Real}}","page":"CTModels.jl","title":"CTModels.time_grid","text":"time_grid(\n    sol::CTModels.Solution{<:CTModels.TimeGridModel{T<:Union{StepRangeLen, AbstractVector{<:Real}}}}\n) -> Union{StepRangeLen, AbstractVector{<:Real}}\n\n\nReturn the time grid of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.time_name-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.time_name","text":"time_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the time component of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.time_name-Tuple{CTModels.TimesModel}","page":"CTModels.jl","title":"CTModels.time_name","text":"time_name(model::CTModels.TimesModel) -> String\n\n\nGet the name of the time variable from the times model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.time_name-Tuple{Model}","page":"CTModels.jl","title":"CTModels.time_name","text":"time_name(ocp::Model) -> String\n\n\nGet the name of the time from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.times-Union{Tuple{Model{T}}, Tuple{T}} where T<:CTModels.TimesModel","page":"CTModels.jl","title":"CTModels.times","text":"times(\n    ocp::Model{T<:CTModels.TimesModel}\n) -> CTModels.TimesModel\n\n\nGet the times from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.value-Union{Tuple{CTModels.ControlModelSolution{TS}}, Tuple{TS}} where TS<:Function","page":"CTModels.jl","title":"CTModels.value","text":"value(\n    model::CTModels.ControlModelSolution{TS<:Function}\n) -> Function\n\n\nGet the control function value from the model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.value-Union{Tuple{CTModels.StateModelSolution{TS}}, Tuple{TS}} where TS<:Function","page":"CTModels.jl","title":"CTModels.value","text":"value(\n    model::CTModels.StateModelSolution{TS<:Function}\n) -> Function\n\n\nGet the state function from the state model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.value-Union{Tuple{CTModels.VariableModelSolution{TS}}, Tuple{TS}} where TS<:Union{Real, AbstractVector{<:Real}}","page":"CTModels.jl","title":"CTModels.value","text":"value(\n    model::CTModels.VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}}\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nGet the variable from the variable model solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable!-Union{Tuple{T2}, Tuple{T1}, Tuple{CTModels.PreModel, Int64}, Tuple{CTModels.PreModel, Int64, T1}, Tuple{CTModels.PreModel, Int64, T1, Vector{T2}}} where {T1<:Union{String, Symbol}, T2<:Union{String, Symbol}}","page":"CTModels.jl","title":"CTModels.variable!","text":"variable!(ocp::CTModels.PreModel, q::Int64)\nvariable!(\n    ocp::CTModels.PreModel,\n    q::Int64,\n    name::Union{String, Symbol}\n)\nvariable!(\n    ocp::CTModels.PreModel,\n    q::Int64,\n    name::Union{String, Symbol},\n    components_names::Array{T2<:Union{String, Symbol}, 1}\n)\n\n\nDefine the variable dimension and possibly the names of each component.\n\nnote: Note\nYou can use variable! once to set the variable dimension.\n\nExamples\n\njulia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"v₁\", \"v₂\" ])\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable-Union{Tuple{CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.VariableModelSolution{TS}}}, Tuple{TS}} where TS<:Union{Real, AbstractVector{<:Real}}","page":"CTModels.jl","title":"CTModels.variable","text":"variable(\n    sol::CTModels.Solution{<:CTModels.AbstractTimeGridModel, <:CTModels.AbstractTimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.VariableModelSolution{TS<:Union{Real, AbstractVector{<:Real}}}}\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the variable of the optimal control solution or nothing.\n\njulia> v  = variable(sol)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable-Union{Tuple{Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, T}}, Tuple{T}} where T<:CTModels.AbstractVariableModel","page":"CTModels.jl","title":"CTModels.variable","text":"variable(\n    ocp::Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, T<:CTModels.AbstractVariableModel}\n) -> CTModels.AbstractVariableModel\n\n\nGet the variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_components-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.variable_components","text":"variable_components(\n    sol::CTModels.Solution\n) -> Vector{String}\n\n\nReturn the names of the components of the variable of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_components-Tuple{Model}","page":"CTModels.jl","title":"CTModels.variable_components","text":"variable_components(ocp::Model) -> Vector{String}\n\n\nGet the components names of the variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_constraints_box-Union{Tuple{CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}}, Tuple{TV}} where TV","page":"CTModels.jl","title":"CTModels.variable_constraints_box","text":"variable_constraints_box(\n    model::CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}\n) -> Any\n\n\nGet the variable box constraints from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_constraints_box-Union{Tuple{Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV}}}, Tuple{TV}} where TV<:Tuple","page":"CTModels.jl","title":"CTModels.variable_constraints_box","text":"variable_constraints_box(\n    ocp::Model{<:CTModels.TimesModel, <:CTModels.AbstractStateModel, <:CTModels.AbstractControlModel, <:CTModels.AbstractVariableModel, <:Function, <:CTModels.AbstractObjectiveModel, <:CTModels.ConstraintsModel{<:Tuple, <:Tuple, <:Tuple, <:Tuple, TV<:Tuple}}\n) -> Any\n\n\nGet the box constraints on variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_constraints_lb_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.variable_constraints_lb_dual","text":"variable_constraints_lb_dual(\n    sol::CTModels.Solution\n) -> AbstractVector{<:Real}\n\n\nReturn the lower bound dual of the variable constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_constraints_ub_dual-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.variable_constraints_ub_dual","text":"variable_constraints_ub_dual(\n    sol::CTModels.Solution\n) -> AbstractVector{<:Real}\n\n\nReturn the upper bound dual of the variable constraints of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_dimension-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.variable_dimension","text":"variable_dimension(sol::CTModels.Solution) -> Int64\n\n\nReturn the dimension of the variable of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_dimension-Tuple{Model}","page":"CTModels.jl","title":"CTModels.variable_dimension","text":"variable_dimension(ocp::Model) -> Int64\n\n\nGet the variable dimension from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_name-Tuple{CTModels.Solution}","page":"CTModels.jl","title":"CTModels.variable_name","text":"variable_name(sol::CTModels.Solution) -> String\n\n\nReturn the name of the variable of the optimal control solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html#CTModels.variable_name-Tuple{Model}","page":"CTModels.jl","title":"CTModels.variable_name","text":"variable_name(ocp::Model) -> String\n\n\nGet the name of the variable from the model.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctmodels.html","page":"CTModels.jl","title":"CTModels.jl","text":"","category":"page"},{"location":"dev-ctparser.html#CTParser.jl","page":"CTParser.jl","title":"CTParser.jl","text":"","category":"section"},{"location":"dev-ctparser.html","page":"CTParser.jl","title":"CTParser.jl","text":"CollapsedDocStrings = false","category":"page"},{"location":"dev-ctparser.html","page":"CTParser.jl","title":"CTParser.jl","text":"The CTParser.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"dev-ctparser.html","page":"CTParser.jl","title":"CTParser.jl","text":"flowchart TD\nB(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctbase.html'>CTBase</a>)\nM(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctmodels.html'>CTModels</a>)\nP(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctparser.html'>CTParser</a>)\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-optimalcontrol.html'>OptimalControl</a>)\nD(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctdirect.html'>CTDirect</a>)\nF(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> B\nM --> B\nstyle P fill:#FBF275","category":"page"},{"location":"dev-ctparser.html#Index","page":"CTParser.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctparser.html","page":"CTParser.jl","title":"CTParser.jl","text":"Pages   = [\"dev-ctparser.md\"]\nModules = [CTParser]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctparser.html#Documentation","page":"CTParser.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctparser.html#Public","page":"CTParser.jl","title":"Public","text":"","category":"section"},{"location":"dev-ctparser.html","page":"CTParser.jl","title":"CTParser.jl","text":"Modules = [CTParser]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"dev-ctparser.html#CTParser.CTParser","page":"CTParser.jl","title":"CTParser.CTParser","text":"CTParser module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\nMLStyle\nOrderedCollections\nParameters\nUnicode\n\nList of all the exported names:\n\n\n\n\n\n","category":"module"},{"location":"dev-ctparser.html#Private","page":"CTParser.jl","title":"Private","text":"","category":"section"},{"location":"dev-ctparser.html","page":"CTParser.jl","title":"CTParser.jl","text":"Modules = [CTParser]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-ctparser.html#CTParser.ParsingInfo","page":"CTParser.jl","title":"CTParser.ParsingInfo","text":"mutable struct ParsingInfo\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"dev-ctparser.html#CTParser.constraint_type-NTuple{7, Any}","page":"CTParser.jl","title":"CTParser.constraint_type","text":"constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n\n\nReturn the type constraint among :initial, :final, :boundary, :control_range, :control_fun, :state_range, :state_fun, :mixed, :variable_range, :variable_fun (:other otherwise), together with the appropriate value (range, updated expression...) Expressions like u(t0) where u is the control and t0 the initial time return :other.\n\nExample\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, 1)\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, 1)\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, 1)\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, 1)\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, 2)\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n:variable_fun\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n:variable_fun\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.expr_it-Tuple{Any, Any, Any}","page":"CTParser.jl","title":"CTParser.expr_it","text":"expr_it(e, _Expr, f) -> Any\n\n\nExpr iterator: apply _Expr to nodes and f to leaves of the AST.\n\nExample\n\njulia> id(e) = expr_it(e, Expr, x -> x)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.has-Tuple{Any, Any, Any}","page":"CTParser.jl","title":"CTParser.has","text":"has(e, x, t) -> Union{Missing, Bool}\n\n\nReturn true if e contains a (...x...)(t) call.\n\nExample\n\njulia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, :x, :t)\ntrue\n\njulia> has(e, :u, :t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.has-Tuple{Any, Any}","page":"CTParser.jl","title":"CTParser.has","text":"has(e, e1) -> Union{Missing, Bool}\n\n\nReturn true if e contains e1.\n\nExample\n\njulia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, 2)\ntrue\n\njulia> has(e, :x)\ntrue\n\njulia> has(e, :min)\ntrue\n\njulia> has(e, :( x[1](t)^2 ))\ntrue\n\njulia> !has(e, :( x[1](t)^3 ))\ntrue\n\njulia> !has(e, 3)\ntrue\n\njulia> !has(e, :max)\ntrue\n\njulia> has(:x, :x)\ntrue\n\njulia> !has(:x, 2)\ntrue\n\njulia> !has(:x, :y)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.parse!-Tuple{Any, Any, Any}","page":"CTParser.jl","title":"CTParser.parse!","text":"parse!(p, p_ocp, e; log) -> Union{Expr, LineNumberNode}\n\n\nParse the expression e and update the ParsingInfo structure p.\n\nExample\n\nparse!(p, :p_ocp, :(v ∈ R, variable))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.replace_call-Tuple{Any, Symbol, Any, Any}","page":"CTParser.jl","title":"CTParser.replace_call","text":"replace_call(e, x::Symbol, t, y) -> Any\n\n\nReplace calls in e of the form (...x...)(t) by (...y...).\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","page":"CTParser.jl","title":"CTParser.replace_call","text":"replace_call(e, x::Vector{Symbol}, t, y) -> Any\n\n\nReplace calls in e of the form (...x1...x2...)(t) by (...y1...y2...) for all symbols x1, x2... in the vector x.\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.subs-Tuple{Any, Union{Real, Symbol}, Any}","page":"CTParser.jl","title":"CTParser.subs","text":"subs(e, e1::Union{Real, Symbol}, e2) -> Any\n\n\nSubstitute expression e1 by expression e2 in expression e.\n\nExamples\n\njulia> e = :( ∫( r(t)^2 + 2u₁(t)) → min )\n:(∫(r(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> subs(e, :r, :( x[1] ))\n:(∫((x[1])(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> e = :( ∫( u₁(t)^2 + 2u₂(t)) → min )\n:(∫(u₁(t) ^ 2 + 2 * u₂(t)) → min)\n\njulia> for i ∈ 1:2\n       e = subs(e, Symbol(:u, Char(8320+i)), :( u[$i] ))\n       end; e\n:(∫((u[1])(t) ^ 2 + 2 * (u[2])(t)) → min)\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); subs(e, :( $x[1]($(t0)) ), :( $x0[1] ))\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctparser.html#CTParser.@def-Tuple{Any}","page":"CTParser.jl","title":"CTParser.@def","text":"Define an optimal control problem. One pass parsing of the definition. Can be used writing either ocp = @def begin ... end or @def ocp begin ... end. In the second case, setting log to true will display the parsing steps.\n\nExample\n\nocp = @def begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend\n\n@def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend true # final boolean to show parsing log\n\n\n\n\n\n","category":"macro"},{"location":"dev-ctparser.html","page":"CTParser.jl","title":"CTParser.jl","text":"","category":"page"},{"location":"dev-ctbase.html#CTBase.jl","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"section"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"CollapsedDocStrings = false","category":"page"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"The CTBase.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"flowchart TD\nB(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctbase.html'>CTBase</a>)\nM(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctmodels.html'>CTModels</a>)\nP(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctparser.html'>CTParser</a>)\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-optimalcontrol.html'>OptimalControl</a>)\nD(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctdirect.html'>CTDirect</a>)\nF(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> B\nM --> B\nstyle B fill:#FBF275","category":"page"},{"location":"dev-ctbase.html#Index","page":"CTBase.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Pages   = [\"dev-ctbase.md\"]\nModules = [CTBase]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctbase.html#Documentation","page":"CTBase.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctbase.html#Public","page":"CTBase.jl","title":"Public","text":"","category":"section"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"dev-ctbase.html#CTBase.CTBase","page":"CTBase.jl","title":"CTBase.CTBase","text":"CTBase module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\n\nList of all the exported names:\n\n\n\n\n\n","category":"module"},{"location":"dev-ctbase.html#Private","page":"CTBase.jl","title":"Private","text":"","category":"section"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Modules = [CTBase]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-ctbase.html#CTBase.DescVarArg","page":"CTBase.jl","title":"CTBase.DescVarArg","text":"DescVarArg is a Vararg of symbols. DescVarArg is a type alias for a Vararg of symbols.\n\njulia> const DescVarArg = Vararg{Symbol}\n\nSee also: Description.\n\n\n\n\n\n","category":"constant"},{"location":"dev-ctbase.html#CTBase.AmbiguousDescription","page":"CTBase.jl","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTBase.CTException\n\nException thrown when the description is ambiguous / incorrect.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.CTException","page":"CTBase.jl","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract type for exceptions.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.Description","page":"CTBase.jl","title":"CTBase.Description","text":"A description is a tuple of symbols. Description is a type alias for a tuple of symbols.\n\njulia> const Description = Tuple{DescVarArg}\n\nSee also: DescVarArg.\n\nExample\n\nBase.show is overloaded for descriptions, that is tuple of descriptions are printed as follows:\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.ExtensionError","page":"CTBase.jl","title":"CTBase.ExtensionError","text":"struct ExtensionError <: CTBase.CTException\n\nException thrown when an extension is not loaded but the user tries to call a function of it.\n\nFields\n\nweakdeps::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.IncorrectArgument","page":"CTBase.jl","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTBase.CTException\n\nException thrown when an argument is inconsistent.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.IncorrectMethod","page":"CTBase.jl","title":"CTBase.IncorrectMethod","text":"struct IncorrectMethod <: CTBase.CTException\n\nException thrown when a method is incorrect.\n\nFields\n\nvar::Symbol\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.IncorrectOutput","page":"CTBase.jl","title":"CTBase.IncorrectOutput","text":"struct IncorrectOutput <: CTBase.CTException\n\nException thrown when the output is incorrect.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.NotImplemented","page":"CTBase.jl","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTBase.CTException\n\nException thrown when a method is not implemented.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.ParsingError","page":"CTBase.jl","title":"CTBase.ParsingError","text":"struct ParsingError <: CTBase.CTException\n\nException thrown for syntax error during abstract parsing.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.UnauthorizedCall","page":"CTBase.jl","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTBase.CTException\n\nException thrown when a call to a function is not authorized.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.ctNumber","page":"CTBase.jl","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\njulia> const ctNumber = Real\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"CTBase.jl","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    descriptions::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n)\n\n\nPrint a tuple of descriptions.\n\nExample\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, CTBase.AmbiguousDescription}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.AmbiguousDescription)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, CTBase.ExtensionError}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.ExtensionError)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, CTBase.IncorrectArgument}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.IncorrectArgument)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, CTBase.IncorrectMethod}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.IncorrectMethod)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, CTBase.IncorrectOutput}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.IncorrectOutput)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, CTBase.NotImplemented}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.NotImplemented)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, CTBase.UnauthorizedCall}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.UnauthorizedCall)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, ParsingError}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::ParsingError)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__display-Tuple{}","page":"CTBase.jl","title":"CTBase.__display","text":"__display() -> Bool\n\n\nUsed to set the default value of the display argument. The default value is true, which means that the output is printed during resolution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","page":"CTBase.jl","title":"CTBase.add","text":"add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nConcatenate the description y to the tuple of descriptions x if x does not contain y and return the new tuple of descriptions. Throw an error if the description y is already contained in x.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> descriptions = add(descriptions, (:b,))\n(:a,)\n(:b,)\njulia> descriptions = add(descriptions, (:b,))\nERROR: IncorrectArgument: the description (:b,) is already in ((:a,), (:b,))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","page":"CTBase.jl","title":"CTBase.add","text":"add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> print(descriptions)\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.ctindice-Tuple{Int64}","page":"CTBase.jl","title":"CTBase.ctindice","text":"ctindice(i::Int64) -> Char\n\n\nReturn i ∈ [0, 9] as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.ctindices-Tuple{Int64}","page":"CTBase.jl","title":"CTBase.ctindices","text":"ctindices(i::Int64) -> String\n\n\nReturn i > 0 as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.ctupperscript-Tuple{Int64}","page":"CTBase.jl","title":"CTBase.ctupperscript","text":"ctupperscript(i::Int64) -> Char\n\n\nReturn i ∈ [0, 9] as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.ctupperscripts-Tuple{Int64}","page":"CTBase.jl","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Int64) -> String\n\n\nReturn i > 0 as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"CTBase.jl","title":"CTBase.getFullDescription","text":"getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn a complete description from an incomplete description desc and  a list of complete descriptions desc_list. If several complete descriptions are possible,  then the first one is returned.\n\nExample\n\njulia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n(:a, :b)\n(:b, :c)\n(:a, :c)\njulia> getFullDescription((:a,), desc_list)\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.remove-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Symbol}}}","page":"CTBase.jl","title":"CTBase.remove","text":"remove(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn the difference between the description x and the description y.\n\nExample\n\njulia> remove((:a, :b), (:a,))\n(:b,)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"page"},{"location":"tutorial-flow.html#manual-flow","page":"Compute flows","title":"How to compute flows","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"In this tutorial, we explain the Flow function from OptimalControl.jl package.","category":"page"},{"location":"tutorial-flow.html#Basic-usage","page":"Compute flows","title":"Basic usage","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Les us define a basic optimal control problem.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"using OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == [ 0, 0 ]\n\n    ẋ(t)  == [ v(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"The pseudo-Hamiltonian of this problem is","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"    H(x p u) = p_q q + p_v v + p^0 u^2 2","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"where p^0 = -1 since we are in the normal case. From the Pontryagin maximum principle, the maximising control is given in feedback form by","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"u(x p) = p_v","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"since partial^2_uu H = p^0 = - 1  0. ","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"u(x, p) = p[2]\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Actually, if (x u) is a solution of the optimal control problem,  then, the Pontryagin maximum principle tells us that there exists a costate p such that u(t) = u(x(t) p(t)) and such that the pair (x p) satisfies:","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"beginarrayl\n    dotx(t) = displaystylephantom-nabla_p H(x(t) p(t) u(x(t) p(t))) 05em\n    dotp(t) = displaystyle         - nabla_x H(x(t) p(t) u(x(t) p(t)))\nendarray","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"The Flow function aims to compute (x p) from the optimal control problem ocp and the control in  feedback form u(x, p).","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"note: Nota bene\nActually, writing z = (x p), then the pair (x p) is also solution of    dotz(t) = vecmathbfH(z(t))where mathbfH(z) = H(z u(z)) and vecmathbfH = (nabla_p mathbfH -nabla_x mathbfH). This is what is actually computed by Flow.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Let us try to get the associated flow:","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"using OptimalControl\nt0 = 0\ntf = 1\nx0 = [-1, 0]\nocp = @def begin\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    x(t0) == x0\n    x(tf) == [ 0, 0 ]\n    ẋ(t)  == [ v(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend\nu(x, p) = p[2]","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"julia> f = Flow(ocp, u)\nERROR: ExtensionError. Please make: julia> using OrdinaryDiffEq","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"As you can see, an error occured since we need the package OrdinaryDiffEq.jl. This package provides numerical integrators to compute solutions of the ordinary differential equation  dotz(t) = vecmathbfH(z(t)).","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"note: OrdinaryDiffEq.jl\nThe package OrdinaryDiffEq.jl is part of DifferentialEquations.jl. You can either use one or the other.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"using OrdinaryDiffEq\n\nf = Flow(ocp, u)\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Now we have the flow of the associated Hamiltonian vector field, we can use it. Some simple calculations shows that the initial covector p(0) solution of the Pontryagin maximum principle is 12 6. Let us check that integrating the flow from (t_0 x_0) = (0 -1 0) to the final time t_f we reach the target x_f = 0 0.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"p0 = [12, 6]\nxf, pf = f(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"If you prefer to get the state, costate and control trajectories at any time, you can call the flow:","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"sol = f((t0, tf), x0, p0)\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"In this case, you obtain a data that you can plot exactly like when solving the optimal control problem  with the function solve. See for instance the basic example or the  plot tutorial.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"using Plots\n\nplot(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"You can notice from the graph of v that the integrator has made very few steps:","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"time_grid(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"note: Time grid\nThe function time_grid returns the discretized time grid returned by the solver. In this case, the solution has been computed by numerical integration with an adaptive step-length Runge-Kutta scheme.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"To have a better visualisation (the accuracy won't change), you can provide a fine grid.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"sol = f((t0, tf), x0, p0; saveat=range(t0, tf, 100))\nplot(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"The argument saveat is an option from OrdinaryDiffEq.jl. Please check the  list of common options. For instance, one can change the integrator with the keyword argument alg or the absolute tolerance with  abstol. Note that you can set an option when declaring the flow or set an option in a particular call of the flow.  In the following example, the integrator will be BS5() and the absolute tolerance will be abstol=1e-8.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"f = Flow(ocp, u; alg=BS5(), abstol=1)   # alg=BS5(), abstol=1\nxf, pf = f(t0, x0, p0, tf; abstol=1e-8) # alg=BS5(), abstol=1e-8","category":"page"},{"location":"tutorial-flow.html#Extremals-and-trajectories","page":"Compute flows","title":"Extremals and trajectories","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"The pairs (x p) solution of the Hamitonian vector field are called extremals. We can compute some constructing the flow from the optimal control problem and the control in feedback form. Another way to compute extremals is  to define explicitely the Hamiltonian.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"H(x, p, u) = p[1] * x[2] + p[2] * u - 0.5 * u^2     # pseudo-Hamiltonian\nH(x, p) = H(x, p, u(x, p))                          # Hamiltonian\n\nz = Flow(Hamiltonian(H))\nxf, pf = z(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"You can also provide the Hamiltonian vector field.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Hv(x, p) = [x[2], p[2]], [0.0, -p[1]]     # Hamiltonian vector field\n\nz = Flow(HamiltonianVectorField(Hv))\nxf, pf = z(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Note that if you call the flow on tspan=(t0, tf), then you obtain the output solution  from OrdinaryDiffEq.jl.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"sol = z((t0, tf), x0, p0)\nxf, pf = sol(tf)[1:2], sol(tf)[3:4]","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"You can also compute trajectories from the control dynamics (x u) mapsto (v u) and a control law  t mapsto u(t).","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"u(t) = 6-12t\nx = Flow((t, x) -> [x[2], u(t)]; autonomous=false) # the vector field depends on t\nx(t0, x0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Again, giving a tspan you get an output solution from OrdinaryDiffEq.jl.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"sol = x((t0, tf), x0)\nplot(sol)","category":"page"},{"location":"tutorial-flow.html#Variable","page":"Compute flows","title":"Variable","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Let us consider an optimal control problem with a (decision / optimisation) variable.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"t0 = 0\nx0 = 0\n\nocp = @def begin\n\n    tf ∈ R, variable             # the optimisation variable is tf\n    t ∈ [t0, tf], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == 1\n    \n    ẋ(t) == tf * u(t)\n\n    tf + 0.5∫(u(t)^2) → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"As you can see, the variable is the final time tf. Note that the dynamics depends on tf. From the Pontryagin maximum principle, the solution is given by:","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"tf = (3/2)^(1/4)\np0 = 2tf/3\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"The input arguments of the maximising control are now the state x, the costate p and the variable tf.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"u(x, p, tf) = tf * p\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Let us check that the final condition x(tf) = 1 is satisfied.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"f = Flow(ocp, u)\nxf, pf = f(t0, x0, p0, tf, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"The usage of the flow f is the following: f(t0, x0, p0, tf, v) where v is the variable. If one wants to compute the state at time t1 = 0.5, then, one must write:","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"t1 = 0.5\nx1, p1 = f(t0, x0, p0, t1, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"note: Free times\nIn the particular cases: the initial time t0 is the only variable, the final time tf is the only variable, or the initial and final times t0 and tf are the only variables and are in order v=(t0, tf), the times do not need to be repeated in the call of the flow:xf, pf = f(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Since the variable is the final time, we can make the time-reparameterisation t = s t_f to normalise the time s in 0 1.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"ocp = @def begin\n\n    tf ∈ R, variable\n    s ∈ [0, 1], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(0) == 0\n    x(1) == 1\n    \n    ẋ(s) == tf^2 * u(s)\n\n    tf + (0.5*tf)*∫(u(s)^2) → min\n\nend\n\nf = Flow(ocp, u)\nxf, pf = f(0, x0, p0, 1, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Another possibility is to add a new state variable t_f(s). The problem has no variable anymore.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"ocp = @def begin\n\n    s ∈ [0, 1], time\n    y = (x, tf) ∈ R², state\n    u ∈ R, control\n\n    x(0) == 0\n    x(1) == 1\n\n    dx = tf(s)^2 * u(s)\n    dtf = 0 * u(s) # 0\n    ẏ(s) == [dx, dtf]\n\n    tf(1) + 0.5∫(tf(s) * u(s)^2) → min\n\nend\n\nu(y, q) = y[2] * q[1]\n\nf = Flow(ocp, u)\nyf, pf = f(0, [x0, tf], [p0, 0], 1)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"danger: Bug\nNote that in the previous optimal control problem, we have dtf = 0 * u(s) instead of dtf = 0. The latter does not work.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"note: Goddard problem\nIn the Goddard problem, you may find other constructions of flows, especially for singular and boundary arcs.","category":"page"},{"location":"tutorial-flow.html#Concatenation-of-arcs","page":"Compute flows","title":"Concatenation of arcs","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"In this part, we present how to concatenate several flows. Let us consider the following problem.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"t0 =  0\ntf =  1\nx0 = -1\nxf =  0\n\n@def ocp begin\n\n    t ∈ [ t0, tf ], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == xf\n\n    -1 ≤ u(t) ≤ 1\n\n    ẋ(t) == -x(t) + u(t)\n\n    ∫( abs(u(t)) ) → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"From the Pontryagin maximum principle, the optimal control is a concatenation of an off arc (u=0) followed by a  positive bang arc (u=1). The initial costate is ","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"p_0 = frac1x_0 - (x_f-1) e^t_f","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"and the switching time is t_1 = -ln(p_0).","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"p0 = 1/( x0 - (xf-1) * exp(tf) )\nt1 = -log(p0)\nnothing  # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Let us define the two flows and the concatenation. Note that the concatenation of two flows is a flow.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"f0 = Flow(ocp, (x, p) -> 0)     # off arc: u = 0\nf1 = Flow(ocp, (x, p) -> 1)     # positive bang arc: u = 1\n\nf = f0 * (t1, f1)               # f0 followed by f1 whenever t ≥ t1\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"Now, we can check that the state reach the target.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"sol = f((t0, tf), x0, p0)\nplot(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"note: Goddard problem\nIn the Goddard problem, you may find more complex concatenations.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"For the moment, this concatenation is not equivalent to an exact concatenation.","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"f = Flow(x ->  x)\ng = Flow(x -> -x)\n\nx0 = 1\nφ(t) = (f * (t/2, g))(0, x0, t)\nψ(t) = g(t/2, f(0, x0, t/2), t)\n\nprintln(\"φ(t) = \", abs(φ(1)-x0))\nprintln(\"ψ(t) = \", abs(ψ(1)-x0))\n\nt = range(1, 5e2, 201)\n\nplt = plot(yaxis=:log, legend=:bottomright, title=\"Comparison of concatenations\", xlabel=\"t\")\nplot!(plt, t, t->abs(φ(t)-x0), label=\"OptimalControl\")\nplot!(plt, t, t->abs(ψ(t)-x0), label=\"Classical\")","category":"page"},{"location":"tutorial-flow.html","page":"Compute flows","title":"Compute flows","text":"","category":"page"},{"location":"tutorial-double-integrator-time.html#double-integrator-time","page":"Time mininimisation","title":"Double integrator: time minimisation","text":"","category":"section"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"The problem consists in minimising the final time t_f for the double integrator system","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) quad u(t) in -11","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"and the limit conditions","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"    x(0) = (12) quad x(t_f) = (00)","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"This problem can be interpretated as a simple model for a wagon with constant mass moving along a line without fricton.","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-double-integrator-time.html#Optimal-control-problem","page":"Time mininimisation","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"Let us define the problem","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"ocp = @def begin\n\n    tf ∈ R,          variable\n    t ∈ [ 0, tf ],   time\n    x = (q, v) ∈ R², state\n    u ∈ R,           control\n\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n\n    q(0)  == 1\n    v(0)  == 2\n    q(tf) == 0\n    v(tf) == 0\n\n    -5 ≤ q(t) ≤ 5,          (1)\n    -3 ≤ v(t) ≤ 3,          (2)\n\n    ẋ(t) == [ v(t), u(t) ]\n\n    tf → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"tip: Convergence\nIn order to ensure convergence of the direct solver, we have added the state constraints labelled (1) and (2):-5 leq q(t) leq 5quad -3 leq v(t) leq 3quad t in  0 t_f ","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"note: Nota bene\nFor a comprehensive introduction to the syntax used above to define the optimal control problem, check this abstract syntax tutorial. In particular, there are non-unicode alternatives for derivatives, integrals, etc.","category":"page"},{"location":"tutorial-double-integrator-time.html#Solve-and-plot","page":"Time mininimisation","title":"Solve and plot","text":"","category":"section"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"Solve it","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"sol = solve(ocp; print_level=4)\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"and plot the solution","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"plot(sol)","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"note: Nota bene\nThe solve function has options, see the solve tutorial. You can customise the plot with the plot function, see the plot tutorial.","category":"page"},{"location":"tutorial-double-integrator-time.html","page":"Time mininimisation","title":"Time mininimisation","text":"","category":"page"},{"location":"tutorial-goddard.html#Direct-and-indirect-methods-for-the-Goddard-problem","page":"Goddard: direct, indirect","title":"Direct and indirect methods for the Goddard problem","text":"","category":"section"},{"location":"tutorial-goddard.html#Introduction","page":"Goddard: direct, indirect","title":"Introduction","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"<img src=\"./assets/Goddard_and_Rocket.jpg\" style=\"float: left; margin: auto 10px;\" width=\"200px\">","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"For this example, we consider the well-known Goddard problem[1] [2] which models the ascent of a rocket through the atmosphere, and we restrict here ourselves to vertical (one dimensional) trajectories. The state variables are the altitude r, speed v and mass m of the rocket during the flight, for a total dimension of 3. The rocket is subject to gravity g, thrust u and drag force D (function of speed and altitude). The final time t_f is free, and the objective is to reach a maximal altitude with a bounded fuel consumption.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We thus want to solve the optimal control problem in Mayer form","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"    r(t_f) to max","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"subject to the controlled dynamics","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"    dotr = v quad\n    dotv = fracT_maxu - D(rv)m - g quad\n    dotm = -u","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"and subject to the control constraint u(t) in 01 and the state constraint v(t) leq v_max. The initial state is fixed while only the final mass is prescribed.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"note: Nota bene\nThe Hamiltonian is affine with respect to the control, so singular arcs may occur, as well as constrained arcs due to the path constraint on the velocity (see below).","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We import the OptimalControl.jl package to define the optimal control problem and NLPModelsIpopt.jl to solve it.  We import the Plots.jl package to plot the solution.  The OrdinaryDiffEq.jl package is used to  define the shooting function for the indirect method and the  NonlinearSolve.jl and  MINPACK.jl packages permit to solve the shooting  equation.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"using OptimalControl  # to define the optimal control problem and more\nusing NLPModelsIpopt  # to solve the problem via a direct method\nusing OrdinaryDiffEq  # to get the Flow function from OptimalControl\nusing NonlinearSolve  # interface to NLE solvers\nusing MINPACK         # NLE solver: use to solve the shooting equation\nusing Plots           # to plot the solution","category":"page"},{"location":"tutorial-goddard.html#Optimal-control-problem","page":"Goddard: direct, indirect","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We define the problem","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"const t0 = 0      # initial time\nconst r0 = 1      # initial altitude\nconst v0 = 0      # initial speed\nconst m0 = 1      # initial mass\nconst vmax = 0.1  # maximal authorized speed\nconst mf = 0.6    # final mass to target\n\nocp = @def begin # definition of the optimal control problem\n\n    tf ∈ R, variable\n    t ∈ [t0, tf], time\n    x = (r, v, m) ∈ R³, state\n    u ∈ R, control\n\n    x(t0) == [r0, v0, m0]\n    m(tf) == mf,         (1)\n    0 ≤ u(t) ≤ 1\n    r(t) ≥ r0\n    0 ≤ v(t) ≤ vmax\n\n    ẋ(t) == F0(x(t)) + u(t) * F1(x(t))\n\n    r(tf) → max\n\nend\n\n# Dynamics\nconst Cd = 310\nconst Tmax = 3.5\nconst β = 500\nconst b = 2\n\nF0(x) = begin\n    r, v, m = x\n    D = Cd * v^2 * exp(-β*(r - 1)) # Drag force\n    return [v, -D/m - 1/r^2, 0]\nend\n\nF1(x) = begin\n    r, v, m = x\n    return [0, Tmax/m, -b*Tmax]\nend\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html#Direct-method","page":"Goddard: direct, indirect","title":"Direct method","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We then solve it","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"direct_sol = solve(ocp; grid_size=100)\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"and plot the solution","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"plt = plot(direct_sol, solution_label=\"(direct)\", size=(800, 800))","category":"page"},{"location":"tutorial-goddard.html#tutorial-goddard-structure","page":"Goddard: direct, indirect","title":"Structure of the solution","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We first determine visually the structure of the optimal solution which is composed of a bang arc with maximal control, followed by a singular arc, then by a boundary arc and the final arc is with zero control. Note that the switching function vanishes along the singular and boundary arcs.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"tip: Interactions with an optimal control solution\nPlease check state, costate, control and variable to get data from the solution. The functions state, costate and control return functions of time and variable returns a vector. The function time_grid returns the discretized time grid returned by the solver.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"t = time_grid(direct_sol)\nx = state(direct_sol)\nu = control(direct_sol)\np = costate(direct_sol)\n\nH1 = Lift(F1)           # H1(x, p) = p' * F1(x)\nφ(t) = H1(x(t), p(t))   # switching function\ng(x) = vmax - x[2]      # state constraint v ≤ vmax\n\nu_plot  = plot(t, u,     label = \"u(t)\")\nH1_plot = plot(t, φ,     label = \"H₁(x(t), p(t))\")\ng_plot  = plot(t, g ∘ x, label = \"g(x(t))\")\n\nplot(u_plot, H1_plot, g_plot, layout=(3,1), size=(500, 500))","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We are now in position to solve the problem by an indirect shooting method. We first define the four control laws in feedback form and their associated flows. For this we need to compute some Lie derivatives, namely Poisson brackets of Hamiltonians (themselves obtained as lifts to the cotangent bundle of vector fields), or derivatives of functions along a vector field. For instance, the control along the minimal order singular arcs is obtained as the quotient","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"u_s = -fracH_001H_101","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"of length three Poisson brackets:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"H_001 = H_0H_0H_1 quad H_101 = H_1H_0H_1","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"where, for two Hamiltonians H and G,","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"HG = (nabla_p Hnabla_x G) - (nabla_x Hnabla_p G)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"While the Lie derivative of a function f wrt. a vector field X is simply obtained as","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"(X cdot f)(x) = f(x) cdot X(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"and is used to the compute the control along the boundary arc,","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"u_b(x) = -(F_0 cdot g)(x)  (F_1 cdot g)(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"as well as the associated multiplier for the order one state constraint on the velocity:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"mu(x p) = H_01(x p)  (F_1 cdot g)(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"note: Poisson bracket and Lie derivative\nThe Poisson bracket HG is also given by the Lie derivative of G along the Hamiltonian vector field X_H = (nabla_p H -nabla_x H) of H, that is    HG = X_H cdot Gwhich is the reason why we use the @Lie macro to compute Poisson brackets below.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"With the help of the differential geometry primitives from CTBase.jl, these expressions are straightforwardly translated into Julia code:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# Controls\nconst u0 = 0                            # off control\nconst u1 = 1                            # bang control\n\nH0 = Lift(F0)                           # H0(x, p) = p' * F0(x)\nH01  = @Lie {H0, H1}\nH001 = @Lie {H0, H01}\nH101 = @Lie {H1, H01}\nus(x, p) = -H001(x, p) / H101(x, p)     # singular control\n\nub(x) = -(F0⋅g)(x) / (F1⋅g)(x)          # boundary control\nμ(x, p) = H01(x, p) / (F1⋅g)(x)         # multiplier associated to the state constraint g\n\n# Flows\nf0 = Flow(ocp, (x, p, tf) -> u0)\nf1 = Flow(ocp, (x, p, tf) -> u1)\nfs = Flow(ocp, (x, p, tf) -> us(x, p))\nfb = Flow(ocp, (x, p, tf) -> ub(x), (x, u, tf) -> g(x), (x, p, tf) -> μ(x, p))\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html#Shooting-function","page":"Goddard: direct, indirect","title":"Shooting function","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Then, we define the shooting function according to the optimal structure we have determined, that is a concatenation of four arcs.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"x0 = [r0, v0, m0] # initial state\n\nfunction shoot!(s, p0, t1, t2, t3, tf)\n\n    x1, p1 = f1(t0, x0, p0, t1)\n    x2, p2 = fs(t1, x1, p1, t2)\n    x3, p3 = fb(t2, x2, p2, t3)\n    xf, pf = f0(t3, x3, p3, tf)\n\n    s[1] = xf[3] - mf                             # final mass constraint\n    s[2:3] = pf[1:2] - [1, 0]                     # transversality conditions\n    s[4] = H1(x1, p1)                             # H1 = H01 = 0\n    s[5] = H01(x1, p1)                            # at the entrance of the singular arc\n    s[6] = g(x2)                                  # g = 0 when entering the boundary arc\n    s[7] = H0(xf, pf)                             # since tf is free\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html#Initial-guess","page":"Goddard: direct, indirect","title":"Initial guess","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"To solve the problem by an indirect shooting method, we then need a good initial guess, that is a good approximation of the initial costate, the three switching times and the final time.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"η = 1e-3\nt13 = t[ abs.(φ.(t)) .≤ η ]\nt23 = t[ 0 .≤ (g ∘ x).(t) .≤ η ]\np0 = p(t0)\nt1 = min(t13...)\nt2 = min(t23...)\nt3 = max(t23...)\ntf = t[end]\n\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\nusing LinearAlgebra: norm\ns = similar(p0, 7)\nshoot!(s, p0, t1, t2, t3, tf)\nprintln(\"\\nNorm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html#Indirect-shooting","page":"Goddard: direct, indirect","title":"Indirect shooting","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We aggregate the data to define the initial guess vector.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"ξ = [p0..., t1, t2, t3, tf] # initial guess","category":"page"},{"location":"tutorial-goddard.html#MINPACK.jl","page":"Goddard: direct, indirect","title":"MINPACK.jl","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We can use NonlinearSolve.jl package or, instead, the  MINPACK.jl package to solve  the shooting equation. To compute the Jacobian of the shooting function we use the  DifferentiationInterface.jl package with  ForwardDiff.jl backend.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"function fsolve(f, j, x; kwargs...)\n    try\n        MINPACK.fsolve(f, j, x; kwargs...)\n    catch e\n        println(\"Error using MINPACK\")\n        println(e)\n        println(\"hybrj not supported. Replaced by hybrd even if it is not visible on the doc.\")\n        MINPACK.fsolve(f, x; kwargs...)\n    end\nend","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"using DifferentiationInterface\nimport ForwardDiff\nbackend = AutoForwardDiff()\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Let us define the problem to solve.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# auxiliary function with aggregated inputs\nnle!  = ( s, ξ) -> shoot!(s, ξ[1:3], ξ[4], ξ[5], ξ[6], ξ[7])\n\n# Jacobian of the (auxiliary) shooting function\njnle! = (js, ξ) -> jacobian!(nle!, similar(ξ), js, backend, ξ)\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We are now in position to solve the problem with the hybrj solver from MINPACK.jl through the fsolve  function, providing the Jacobian. Let us solve the problem and retrieve the initial costate solution.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# resolution of S(ξ) = 0\nindirect_sol = fsolve(nle!, jnle!, ξ, show_trace=true)\n\n# we retrieve the costate solution together with the times\np0 = indirect_sol.x[1:3]\nt1 = indirect_sol.x[4]\nt2 = indirect_sol.x[5]\nt3 = indirect_sol.x[6]\ntf = indirect_sol.x[7]\n\nprintln(\"\")\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\ns = similar(p0, 7)\nshoot!(s, p0, t1, t2, t3, tf)\nprintln(\"\\nNorm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html#tutorial-goddard-plot","page":"Goddard: direct, indirect","title":"Plot of the solution","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We plot the solution of the indirect solution (in red) over the solution of the direct method  (in blue).","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"f = f1 * (t1, fs) * (t2, fb) * (t3, f0) # concatenation of the flows\nflow_sol = f((t0, tf), x0, p0)          # compute the solution: state, costate, control...\n\nplot!(plt, flow_sol, solution_label=\"(indirect)\")","category":"page"},{"location":"tutorial-goddard.html#References","page":"Goddard: direct, indirect","title":"References","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"[1]: R.H. Goddard. A Method of Reaching Extreme Altitudes, volume 71(2) of Smithsonian Miscellaneous Collections. Smithsonian institution, City of Washington, 1919.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"[2]: H. Seywald and E.M. Cliff. Goddard problem in presence of a dynamic pressure limit. Journal of Guidance, Control, and Dynamics, 16(4):776–781, 1993.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<img width=\"800\" alt=\"juliaopt2024\" src=\"./assets/zhejiang-2025.jpg\">","category":"page"},{"location":"zhejiang-2025.html#Solving-optimal-control-problems-in-Julia:-the-OptimalControl.jl-package","page":"Zhejiang 2025","title":"Solving optimal control problems in Julia: the OptimalControl.jl package","text":"","category":"section"},{"location":"zhejiang-2025.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://github.com/joseph-gergaud),-[Pierre-Martinon](https://github.com/PierreMartinon),-[Sophia-Sed](https://sed-sam-blog.gitlabpages.inria.fr)","page":"Zhejiang 2025","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"page"},{"location":"zhejiang-2025.html#What-it's-about","page":"Zhejiang 2025","title":"What it's about","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"subject to","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"plus boundary, control and state constraints","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"zhejiang-2025.html#OptimalControl.jl-for-trajectory-optimisation","page":"Zhejiang 2025","title":"OptimalControl.jl for trajectory optimisation","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Basic example\nGoddard problem\nOrbit transfer","category":"page"},{"location":"zhejiang-2025.html#Wrap-up","page":"Zhejiang 2025","title":"Wrap up","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"High level modelling of optimal control problems\nEfficient numerical resolution coupling direct and indirect methods\nCollection of examples","category":"page"},{"location":"zhejiang-2025.html#Future","page":"Zhejiang 2025","title":"Future","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"New applications (pace mechanics, biology, quantum mechanics and more)\nAdditional solvers: optimisation on GPU, direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions! If you like the package, please give us a star ⭐️","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<a href=\"https://github.com/control-toolbox/OptimalControl.jl\"><img width=\"800\" alt=\"OptimalControl.jl\" src=\"./assets/star.jpg\"></a>","category":"page"},{"location":"zhejiang-2025.html#control-toolbox.org","page":"Zhejiang 2025","title":"control-toolbox.org","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"zhejiang-2025.html#Credits-(not-exhaustive!)","page":"Zhejiang 2025","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nIpopt.jl\nMadNLP.jl\nMLStyle.jl","category":"page"},{"location":"zhejiang-2025.html#Stand-up-for-science-2025","page":"Zhejiang 2025","title":"Stand up for science 2025","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<a href=\"https://standupforscience2025.org\"><img width=\"200\" alt=\"stand up for science 2025\" src=\"./assets/standup.jpg\"></a>","category":"page"},{"location":"zhejiang-2025.html#Acknowledgements","page":"Zhejiang 2025","title":"Acknowledgements","text":"","category":"section"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"Jean-Baptiste Caillau is partially funded by a France 2030 support managed by the Agence Nationale de la Recherche, under the reference ANR-23-PEIA-0004 (PDE-AI project).","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"<img width=\"150\" alt=\"affiliations\" src=\"./assets/france-2030.png\">","category":"page"},{"location":"zhejiang-2025.html","page":"Zhejiang 2025","title":"Zhejiang 2025","text":"","category":"page"},{"location":"tutorial-discretisation.html#tutorial-discretisation-methods","page":"Discretisation methods","title":"Discretisation methods","text":"","category":"section"},{"location":"tutorial-discretisation.html#Discretisation-formulas","page":"Discretisation methods","title":"Discretisation formulas","text":"","category":"section"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"When calling solve, the option disc_method=... can be used to set the discretisation scheme. In addition to the default implicit :trapeze method (aka Crank-Nicolson), other choices are available, namely implicit :midpoint and the Gauss-Legendre collocations with 2 and  stages, :gauss_legendre_2 and :gauss_legendre_3, of order 4 and 6 respectively.  Note that higher order methods will typically lead to larger NLP problems for the same number of time steps, and that accuracy will also depend on the smoothness of the problem.","category":"page"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"As an example we will use the Goddard problem","category":"page"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"using OptimalControl  # to define the optimal control problem and more\nusing NLPModelsIpopt  # to solve the problem via a direct method\nusing Plots           # to plot the solution\n\nt0 = 0      # initial time\nr0 = 1      # initial altitude\nv0 = 0      # initial speed\nm0 = 1      # initial mass\nvmax = 0.1  # maximal authorized speed\nmf = 0.6    # final mass to target\n\nocp = @def begin # definition of the optimal control problem\n\n    tf ∈ R, variable\n    t ∈ [t0, tf], time\n    x = (r, v, m) ∈ R³, state\n    u ∈ R, control\n\n    x(t0) == [ r0, v0, m0 ]\n    m(tf) == mf,         (1)\n    0 ≤ u(t) ≤ 1\n    r(t) ≥ r0\n    0 ≤ v(t) ≤ vmax\n\n    ẋ(t) == F0(x(t)) + u(t) * F1(x(t))\n\n    r(tf) → max\n\nend;\n\n# Dynamics\nconst Cd = 310\nconst Tmax = 3.5\nconst β = 500\nconst b = 2\n\nF0(x) = begin\n    r, v, m = x\n    D = Cd * v^2 * exp(-β*(r - 1)) # Drag force\n    return [ v, -D/m - 1/r^2, 0 ]\nend\n\nF1(x) = begin\n    r, v, m = x\n    return [ 0, Tmax/m, -b*Tmax ]\nend\nnothing # hide","category":"page"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"Now let us compare different discretisations","category":"page"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"sol_trapeze = solve(ocp; tol=1e-8)\nplot(sol_trapeze)\n\nsol_midpoint = solve(ocp, disc_method=:midpoint; tol=1e-8)\nplot!(sol_midpoint)\n\nsol_euler = solve(ocp, disc_method=:euler; tol=1e-8)\nplot!(sol_euler)\n\nsol_euler_imp = solve(ocp, disc_method=:euler_implicit; tol=1e-8)\nplot!(sol_euler_imp)\n\nsol_gl2 = solve(ocp, disc_method=:gauss_legendre_2; tol=1e-8)\nplot!(sol_gl2)\n\nsol_gl3 = solve(ocp, disc_method=:gauss_legendre_3; tol=1e-8)\nplot!(sol_gl3)","category":"page"},{"location":"tutorial-discretisation.html#Large-problems-and-AD-backend","page":"Discretisation methods","title":"Large problems and AD backend","text":"","category":"section"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"For some large problems, you may notice that solving spends a long time before the iterations actually begin. This is due to the computing of the sparse derivatives, namely the Jacobian of the constraints and the Hessian of the Lagrangian, that can become quite costly. A possible alternative is to set the option adnlp_backend=:manual, which will use more basic sparsity patterns. The resulting matrices are faster to compute but are also less sparse, so this is a trade-off bewteen the AD preparation and the optimization itself.","category":"page"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"solve(ocp, disc_method=:gauss_legendre_3, grid_size=1000, adnlp_backend=:manual)\nnothing # hide","category":"page"},{"location":"tutorial-discretisation.html#Explicit-time-grid","page":"Discretisation methods","title":"Explicit time grid","text":"","category":"section"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"The option time_grid=... allows to pass the complete time grid vector t0, t1, ..., tf, which is typically useful if one wants a non uniform grid.  In the case of a free initial and/or final time, provide a normalised grid between 0 and 1.  Note that time_grid will override grid_size if both are present.","category":"page"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"sol = solve(ocp, time_grid=[0, 0.1, 0.5, 0.9, 1], display=false)\nprintln(time_grid(sol))","category":"page"},{"location":"tutorial-discretisation.html","page":"Discretisation methods","title":"Discretisation methods","text":"","category":"page"},{"location":"dev-ctflows.html#CTFlows.jl","page":"CTFlows.jl","title":"CTFlows.jl","text":"","category":"section"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"CollapsedDocStrings = false","category":"page"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"The CTFlows.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"flowchart TD\nB(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctbase.html'>CTBase</a>)\nM(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctmodels.html'>CTModels</a>)\nP(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctparser.html'>CTParser</a>)\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-optimalcontrol.html'>OptimalControl</a>)\nD(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctdirect.html'>CTDirect</a>)\nF(<a href='https://control-toolbox.org/OptimalControl.jl/stable/dev-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> B\nM --> B\nstyle F fill:#FBF275","category":"page"},{"location":"dev-ctflows.html#Index","page":"CTFlows.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Pages   = [\"dev-ctflows.md\"]\nModules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctflows.html#Documentation","page":"CTFlows.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctflows.html#Public","page":"CTFlows.jl","title":"Public","text":"","category":"section"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Modules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"dev-ctflows.html#Private","page":"CTFlows.jl","title":"Private","text":"","category":"section"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Modules = [CTFlows]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-ctflows.html#CTFlows.:⅋-Union{Tuple{V}, Tuple{VectorField{<:Function, CTFlows.Autonomous, V}, VectorField{<:Function, CTFlows.Autonomous, V}}} where V<:CTFlows.VariableDependence","page":"CTFlows.jl","title":"CTFlows.:⅋","text":"⅋(\n    X::VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence},\n    Y::VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\n\"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, autonomous case\n\nExample\n\njulia> X = VectorField(x -> [x[2], -x[1]])\njulia> Y = VectorField(x -> [x[1], x[2]])\njulia> CTBase.:(⅋)(X, Y)([1, 2])\n[2, -1]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.:⅋-Union{Tuple{V}, Tuple{VectorField{<:Function, CTFlows.NonAutonomous, V}, VectorField{<:Function, CTFlows.NonAutonomous, V}}} where V<:CTFlows.VariableDependence","page":"CTFlows.jl","title":"CTFlows.:⅋","text":"⅋(\n    X::VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence},\n    Y::VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\n\"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, nonautonomous case\n\nExample\n\njulia> X = VectorField((t, x, v) -> [t + v[1] + v[2] + x[2], -x[1]], NonFixed, NonAutonomous)\njulia> Y = VectorField((t, x, v) ->  [v[1] + v[2] + x[1], x[2]], NonFixed, NonAutonomous)\njulia> CTBase.:(⅋)(X, Y)(1, [1, 2], [2, 3])\n[8, -1]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.:⋅-Tuple{Function, Function}","page":"CTFlows.jl","title":"CTFlows.:⋅","text":"⋅(\n    X::Function,\n    f::Function\n) -> CTFlows.var\"#27#29\"{VectorField{var\"#s182\", CTFlows.Autonomous, CTFlows.Fixed}, <:Function} where var\"#s182\"<:Function\n\n\nLie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.:⋅-Tuple{VectorField{<:Function, CTFlows.Autonomous}, Function}","page":"CTFlows.jl","title":"CTFlows.:⋅","text":"⋅(\n    X::VectorField{<:Function, CTFlows.Autonomous},\n    f::Function\n) -> CTFlows.var\"#27#29\"{VectorField{var\"#s2\", CTFlows.Autonomous, var\"#s1\"}, <:Function} where {var\"#s2\"<:Function, var\"#s1\"<:CTFlows.VariableDependence}\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in autonomous case\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.:⋅-Tuple{VectorField{<:Function, CTFlows.NonAutonomous}, Function}","page":"CTFlows.jl","title":"CTFlows.:⋅","text":"⋅(\n    X::VectorField{<:Function, CTFlows.NonAutonomous},\n    f::Function\n) -> CTFlows.var\"#31#33\"{VectorField{var\"#s26\", CTFlows.NonAutonomous, var\"#s2\"}, <:Function} where {var\"#s26\"<:Function, var\"#s2\"<:CTFlows.VariableDependence}\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in nonautonomous case\n\nExample\n\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Lie-Tuple{Function, Function}","page":"CTFlows.jl","title":"CTFlows.Lie","text":"Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Union{CTFlows.var\"#27#29\"{VectorField{var\"#s2\", CTFlows.Autonomous, var\"#s1\"}, <:Function} where {var\"#s2\"<:Function, var\"#s1\"<:CTFlows.VariableDependence}, CTFlows.var\"#31#33\"{VectorField{var\"#s26\", CTFlows.NonAutonomous, var\"#s2\"}, <:Function} where {var\"#s26\"<:Function, var\"#s2\"<:CTFlows.VariableDependence}}\n\n\nLie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Lie-Tuple{VectorField, Function}","page":"CTFlows.jl","title":"CTFlows.Lie","text":"Lie(\n    X::VectorField,\n    f::Function\n) -> Union{CTFlows.var\"#27#29\"{VectorField{var\"#s2\", CTFlows.Autonomous, var\"#s1\"}, <:Function} where {var\"#s2\"<:Function, var\"#s1\"<:CTFlows.VariableDependence}, CTFlows.var\"#31#33\"{VectorField{var\"#s26\", CTFlows.NonAutonomous, var\"#s2\"}, <:Function} where {var\"#s26\"<:Function, var\"#s2\"<:CTFlows.VariableDependence}}\n\n\nLie derivative of a scalar function along a vector field.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Lie-Union{Tuple{V}, Tuple{VectorField{<:Function, CTFlows.Autonomous, V}, VectorField{<:Function, CTFlows.Autonomous, V}}} where V<:CTFlows.VariableDependence","page":"CTFlows.jl","title":"CTFlows.Lie","text":"Lie(\n    X::VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence},\n    Y::VectorField{<:Function, CTFlows.Autonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case\n\nExample\n\njulia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Lie-Union{Tuple{V}, Tuple{VectorField{<:Function, CTFlows.NonAutonomous, V}, VectorField{<:Function, CTFlows.NonAutonomous, V}}} where V<:CTFlows.VariableDependence","page":"CTFlows.jl","title":"CTFlows.Lie","text":"Lie(\n    X::VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence},\n    Y::VectorField{<:Function, CTFlows.NonAutonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case\n\nExample\n\njulia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Lift-Tuple{Function}","page":"CTFlows.jl","title":"CTFlows.Lift","text":"Lift(\n    X::Function;\n    autonomous,\n    variable\n) -> CTFlows.var\"#19#23\"{<:Function}\n\n\nReturn the Lift of a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Lift-Tuple{VectorField}","page":"CTFlows.jl","title":"CTFlows.Lift","text":"Lift(\n    X::VectorField\n) -> HamiltonianLift{VectorField{TF, TD, VD}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n\n\nReturn the HamiltonianLift of a VectorField.\n\nExample\n\njulia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Poisson-Tuple{Function, Function}","page":"CTFlows.jl","title":"CTFlows.Poisson","text":"Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Poisson-Union{Tuple{VD}, Tuple{TD}, Tuple{CTFlows.AbstractHamiltonian{TD, VD}, Function}} where {TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}","page":"CTFlows.jl","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence},\n    g::Function\n) -> Hamiltonian\n\n\nPoisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Poisson-Union{Tuple{VD}, Tuple{TD}, Tuple{Function, CTFlows.AbstractHamiltonian{TD, VD}}} where {TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}","page":"CTFlows.jl","title":"CTFlows.Poisson","text":"Poisson(\n    f::Function,\n    g::CTFlows.AbstractHamiltonian{TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence}\n) -> Hamiltonian\n\n\nPoisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Poisson-Union{Tuple{V}, Tuple{CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V}, CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V}}} where V<:CTFlows.VariableDependence","page":"CTFlows.jl","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V<:CTFlows.VariableDependence},\n    g::CTFlows.AbstractHamiltonian{CTFlows.Autonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Poisson-Union{Tuple{V}, Tuple{CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V}, CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V}}} where V<:CTFlows.VariableDependence","page":"CTFlows.jl","title":"CTFlows.Poisson","text":"Poisson(\n    f::CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V<:CTFlows.VariableDependence},\n    g::CTFlows.AbstractHamiltonian{CTFlows.NonAutonomous, V<:CTFlows.VariableDependence}\n) -> Any\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case\n\nExample\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence}","page":"CTFlows.jl","title":"CTFlows.Poisson","text":"Poisson(\n    f::HamiltonianLift{T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence},\n    g::HamiltonianLift{T<:CTFlows.TimeDependence, V<:CTFlows.VariableDependence}\n)\n\n\nPoisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw, CTFlows.Lagrange, Real, Real, CTFlows.MixedConstraint, CTFlows.Multiplier}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw,\n    f⁰::CTFlows.Lagrange,\n    p⁰::Real,\n    s::Real,\n    g::CTFlows.MixedConstraint,\n    μ::CTFlows.Multiplier\n) -> CTFlows.var\"#H#102\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}, CTFlows.Lagrange{TF2, TD2, VD2}, var\"#s182\", var\"#s1821\", CTFlows.MixedConstraint{TF3, TD3, VD3}, CTFlows.Multiplier{TF4, TD4, VD4}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence, TF2<:Function, TD2<:CTFlows.TimeDependence, VD2<:CTFlows.VariableDependence, var\"#s182\"<:Real, var\"#s1821\"<:Real, TF3<:Function, TD3<:CTFlows.TimeDependence, VD3<:CTFlows.VariableDependence, TF4<:Function, TD4<:CTFlows.TimeDependence, VD4<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw, CTFlows.Lagrange, Real, Real}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw,\n    f⁰::CTFlows.Lagrange,\n    p⁰::Real,\n    s::Real\n) -> CTFlows.var\"#H#100\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}, CTFlows.Lagrange{TF2, TD2, VD2}, <:Real, <:Real} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence, TF2<:Function, TD2<:CTFlows.TimeDependence, VD2<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw, CTFlows.MixedConstraint, CTFlows.Multiplier}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw,\n    g::CTFlows.MixedConstraint,\n    μ::CTFlows.Multiplier\n) -> CTFlows.var\"#H#101\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}, CTFlows.MixedConstraint{TF2, TD2, VD2}, CTFlows.Multiplier{TF3, TD3, VD3}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence, TF2<:Function, TD2<:CTFlows.TimeDependence, VD2<:CTFlows.VariableDependence, TF3<:Function, TD3<:CTFlows.TimeDependence, VD3<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{CTFlows.Dynamics, CTFlows.ControlLaw}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::CTFlows.Dynamics,\n    u::CTFlows.ControlLaw\n) -> CTFlows.var\"#98#99\"{CTFlows.Dynamics{TF, TD, VD}, CTFlows.ControlLaw{TF1, TD1, VD1}} where {TF<:Function, TD<:CTFlows.TimeDependence, VD<:CTFlows.VariableDependence, TF1<:Function, TD1<:CTFlows.TimeDependence, VD1<:CTFlows.VariableDependence}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p f(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.∂ₜ-Tuple{Any}","page":"CTFlows.jl","title":"CTFlows.∂ₜ","text":"∂ₜ(f) -> CTFlows.var\"#36#38\"\n\n\nPartial derivative wrt time of a function.\n\nExample\n\njulia> ∂ₜ((t,x) -> t*x)(0,8)\n8\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.@Lie-Tuple{Expr, Any, Any}","page":"CTFlows.jl","title":"CTFlows.@Lie","text":"Macros for Poisson brackets\n\nExample\n\njulia> H0 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7]) autonomous=true variable=false\n#\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false variable=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) autonomous=true variable=true\n#\njulia> H0 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2) autonomous=false variable=true\n\n\n\n\n\n","category":"macro"},{"location":"dev-ctflows.html#CTFlows.@Lie-Tuple{Expr, Any}","page":"CTFlows.jl","title":"CTFlows.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) variable=true\n#\n\n\n\n\n\n","category":"macro"},{"location":"dev-ctflows.html#CTFlows.@Lie-Tuple{Expr}","page":"CTFlows.jl","title":"CTFlows.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\n#\njulia> F0 = VectorField((t, x) -> [t+x[1], x[2], (1-x[3])], autonomous=false)\njulia> F1 = VectorField((t, x) -> [t, -x[3], x[2]], autonomous=false)\njulia> @Lie [F0, F1](1, [1, 2, 3])\n#\njulia> F0 = VectorField((x, v) -> [x[1]+v, x[2], (1-x[3])], variable=true)\njulia> F1 = VectorField((x, v) -> [0, -x[3]-v, x[2]], variable=true)\njulia> @Lie [F0, F1]([1, 2, 3], 2)\n#\njulia> F0 = VectorField((t, x, v) -> [t+x[1]+v, x[2], (1-x[3])], autonomous=false, variable=true)\njulia> F1 = VectorField((t, x, v) -> [t, -x[3]-v, x[2]], autonomous=false, variable=true)\njulia> @Lie [F0, F1](1, [1, 2, 3], 2)\n#\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7])\n3.0\n#\njulia> H0 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2), autonomous=false)\njulia> H1 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2), autonomous=false)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7])\n#\njulia> H0 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), variable=true)\njulia> H1 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), variable=true)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2)\n#\njulia> H0 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), autonomous=false, variable=true)\njulia> H1 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), autonomous=false, variable=true)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2)\n#\n\n\n\n\n\n","category":"macro"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"","category":"page"},{"location":"tutorial-mam.html#Minimal-Action-Method-using-Optimal-Control","page":"Minimal action","title":"Minimal Action Method using Optimal Control","text":"","category":"section"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"The Minimal Action Method (MAM) is used to find the maximum likelihood transition paths between stable states in dynamical systems.  The Minimal Action Method is a numerical technique for finding the most probable transition pathway between stable states in stochastic dynamical systems. It achieves this by minimizing an action functional that represents the path's deviation from the deterministic dynamics, effectively identifying the path of least resistance through the system's landscape. This tutorial demonstrates how to implement MAM as an optimal control problem.","category":"page"},{"location":"tutorial-mam.html#Required-Packages","page":"Minimal action","title":"Required Packages","text":"","category":"section"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots, Printf","category":"page"},{"location":"tutorial-mam.html#Problem-Setup","page":"Minimal action","title":"Problem Setup","text":"","category":"section"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"We'll consider a 2D system with a double-well flow, called the Maier-Stein model. It is a famous benchmark problem as it exhibits non-gradient dynamics with two stable equilibrium points at (-1,0) and (1,0), connected by a non-trivial transition path. The system's deterministic dynamics are given by:","category":"page"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"# Define the vector field\nf(u, v) = [u - u^3 - 10*u*v^2,  -(1 - u^2)*v]\nf(x) = f(x...)\nnothing # hide","category":"page"},{"location":"tutorial-mam.html#Optimal-Control-Formulation","page":"Minimal action","title":"Optimal Control Formulation","text":"","category":"section"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"The minimal action path minimizes the deviation from the deterministic dynamics:","category":"page"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"function ocp(T)\n    action = @def begin\n        t ∈ [0, T], time\n        x ∈ R², state\n        u ∈ R², control\n        x(0) == [-1, 0]    # Starting point (left well)\n        x(T) == [1, 0]     # End point (right well)\n        ẋ(t) == u(t)       # Path dynamics\n        ∫( sum((u(t) - f(x(t))).^2) ) → min  # Minimize deviation from deterministic flow\n    end\n    return action\nend\nnothing # hide","category":"page"},{"location":"tutorial-mam.html#Initial-Guess","page":"Minimal action","title":"Initial Guess","text":"","category":"section"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"We provide an initial guess for the path using a simple interpolation:","category":"page"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"# Time horizon\nT = 50\n\n# Linear interpolation for x₁\nx1(t) = -(1 - t/T) + t/T\n\n# Parabolic guess for x₂\nx2(t) = 0.3(-x1(t)^2 + 1)\nx(t) = [x1(t), x2(t)]\nu(t) = f(x(t))\n\n# Initial guess\ninit = (state=x, control=u)\nnothing # hide","category":"page"},{"location":"tutorial-mam.html#Solving-the-Problem","page":"Minimal action","title":"Solving the Problem","text":"","category":"section"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"We solve the problem in two steps for better accuracy:","category":"page"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"# First solve with coarse grid\nsol = solve(ocp(T); init=init, grid_size=50)\n\n# Refine solution with finer grid\nsol = solve(ocp(T); init=sol, grid_size=1000)\n\n# Objective value\nobjective(sol)","category":"page"},{"location":"tutorial-mam.html#Visualizing-Results","page":"Minimal action","title":"Visualizing Results","text":"","category":"section"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"Let's plot the solution trajectory and phase space:","category":"page"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"plot(sol)","category":"page"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"# Phase space plot\nMLP = state(sol).(time_grid(sol))\nscatter(first.(MLP), last.(MLP), \n        title=\"Minimal Action Path\",\n        xlabel=\"u\",\n        ylabel=\"v\",\n        label=\"Transition path\")","category":"page"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"The resulting path shows the most likely transition between the two stable states given a transient time T=50, minimizing the action functional while respecting the system's dynamics.","category":"page"},{"location":"tutorial-mam.html#Minimize-with-respect-to-T","page":"Minimal action","title":"Minimize with respect to T","text":"","category":"section"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"To find the maximum likelihood path, we also need to minimize the transient time T. Hence, we perform a discrete continuation over the parameter T by solving the optimal control problem over a continuous range of final times T, using each solution to initialize the next problem.","category":"page"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"objectives = []\nTs = range(1,100,100)\nsol = solve(ocp(Ts[1]); display=false, init=init, grid_size=50)\nprintln(\" Time   Objective     Iterations\")\nfor T=Ts\n    global sol = solve(ocp(T); display=false, init=sol, grid_size=1000, tol=1e-8)\n    @printf(\"%6.2f  %9.6e  %d\\n\", T, objective(sol), iterations(sol))\n    push!(objectives, objective(sol))\nend","category":"page"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"T_min = Ts[argmin(objectives)]\nplt1 = scatter(Ts, log10.(objectives), xlabel=\"Time\", label=\"Objective (log10)\")\nvline!(plt1, [T_min], label=\"Minimum\", z_order=:back)\nplt2 = scatter(Ts[20:100], log10.(objectives[20:100]), xlabel=\"Time\", label=\"Objective (log10)\")\nvline!(plt2, [T_min], label=\"Minimum\", z_order=:back)\nplot(plt1, plt2, layout=(2,1), size=(800,800))","category":"page"},{"location":"tutorial-mam.html","page":"Minimal action","title":"Minimal action","text":"","category":"page"},{"location":"tutorial-initial-guess.html#tutorial-initial-guess","page":"Set an initial guess","title":"Initial guess (or iterate) for the resolution","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"We present in this tutorial the different possibilities to provide an initial guess to solve an  optimal control problem with the OptimalControl.jl package. ","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"For the illustrations, we define the following optimal control problem.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"t0 = 0\ntf = 10\nα  = 5\n\nocp = @def begin\n    t ∈ [t0, tf], time\n    v ∈ R, variable\n    x ∈ R², state\n    u ∈ R, control\n    x(t0) == [ -1, 0 ]\n    x₁(tf) == 0\n    ẋ(t) == [ x₂(t), x₁(t) + α*x₁(t)^2 + u(t) ]\n    x₂(tf)^2 + ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Default-initial-guess","page":"Set an initial guess","title":"Default initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"We first solve the problem without giving an initial guess. This will default to initialize all variables to 0.1.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# solve the optimal control problem without initial guess\nsol = solve(ocp; display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Let us plot the solution of the optimal control problem.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"plot(sol; size=(600, 450))","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Note that the following formulations are equivalent to not giving an initial guess.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"sol = solve(ocp; init=nothing, display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\nsol = solve(ocp; init=(), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"tip: Interactions with an optimal control solution\nTo get the number of iterations of the solver, check the iterations function.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"To reduce the number of iterations and improve the convergence, we can give an initial guess to the solver.  This initial guess can be built from constant values, interpolated vectors, functions, or existing solutions. Except when initializing from a solution, the arguments are to be passed as a named tuple init=(state=..., control=..., variable=...) whose fields are optional. Missing fields will revert to default initialization (ie constant 0.1).","category":"page"},{"location":"tutorial-initial-guess.html#Constant-initial-guess","page":"Set an initial guess","title":"Constant initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"We first illustrate the constant initial guess, using vectors or scalars according to the dimension.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# solve the optimal control problem with initial guess with constant values\nsol = solve(ocp; init=(state=[-0.2, 0.1], control=-0.2, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Partial initializations are also valid, as shown below. Note the ending comma when a single argument is passed, since it must be a tuple.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# initialisation only on the state\nsol = solve(ocp; init=(state=[-0.2, 0.1],), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\n# initialisation only on the control\nsol = solve(ocp; init=(control=-0.2,), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\n# initialisation only on the state and the variable\nsol = solve(ocp; init=(state=[-0.2, 0.1], variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Functional-initial-guess","page":"Set an initial guess","title":"Functional initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"For the state and control, we can also provide functions of time as initial guess.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# initial guess as functions of time\nx(t) = [ -0.2t, 0.1t ]\nu(t) = -0.2t\n\nsol = solve(ocp; init=(state=x, control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Vector-initial-guess-(interpolated)","page":"Set an initial guess","title":"Vector initial guess (interpolated)","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Initialization can also be provided with vectors / matrices to be interpolated along a given time grid.  In this case the time steps must be given through an additional argument time, which can be a vector or line/column matrix. For the values to be interpolated both matrices and vectors of vectors are allowed, but the shape should be number of time steps x variable dimension. Simple vectors are also allowed for variables of dimension 1.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# initial guess as vector of points\nt_vec = LinRange(t0,tf,4)\nx_vec = [[0, 0], [-0.1, 0.3], [-0.15,0.4], [-0.3, 0.5]]\nu_vec = [0, -0.8,  -0.3, 0]\n\nsol = solve(ocp; init=(time=t_vec, state=x_vec, control=u_vec, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Note: in the free final time case, the given time grid should be consistent with the initial guess provided for the final time (in the optimization variables).","category":"page"},{"location":"tutorial-initial-guess.html#Mixed-initial-guess","page":"Set an initial guess","title":"Mixed initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"The constant, functional and vector initializations can be mixed, for instance as","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# we can mix constant values with functions of time\nsol = solve(ocp; init=(state=[-0.2, 0.1], control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\n\n# wa can mix every possibility\nsol = solve(ocp; init=(time=t_vec, state=x_vec, control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Solution-as-initial-guess-(warm-start)","page":"Set an initial guess","title":"Solution as initial guess (warm start)","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Finally, we can use an existing solution to provide the initial guess.  The dimensions of the state, control and optimization variable must coincide. This particular feature allows an easy implementation of discrete continuations.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# generate the initial solution\nsol_init = solve(ocp; display=false)\n\n# solve the problem using solution as initial guess\nsol = solve(ocp; init=sol_init, display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"Note that you can also manually pick and choose which data to reuse from a solution, by recovering the  functions state(sol), control(sol) and the values variable(sol). For instance the following formulation is equivalent to the init=sol one.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"# use a previous solution to initialise picking data\nsol = solve(ocp; \n    init = (\n        state    = state(sol), \n        control  = control(sol), \n        variable = variable(sol)\n    ), \n    display=false)\nprintln(\"Number of iterations: \", iterations(sol))\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"tip: Interactions with an optimal control solution\nPlease check state, costate, control and variable to get data from the solution. The functions state, costate and control return functions of time and variable returns a vector.","category":"page"},{"location":"tutorial-initial-guess.html#Costate-/-multipliers","page":"Set an initial guess","title":"Costate / multipliers","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"For the moment there is no option to provide an initial guess for the costate / multipliers.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Set an initial guess","title":"Set an initial guess","text":"","category":"page"},{"location":"index.html#OptimalControl.jl","page":"Getting Started","title":"OptimalControl.jl","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"The OptimalControl.jl package is the root package of the control-toolbox ecosystem. The control-toolbox ecosystem gathers Julia packages for mathematical control and applications. It aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods.","category":"page"},{"location":"index.html#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"To install OptimalControl.jl, please open Julia's interactive session (known as REPL) and use the Julia package manager:","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"OptimalControl\")","category":"page"},{"location":"index.html#Basic-usage","page":"Getting Started","title":"Basic usage","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"Let us model, solve and plot a simple optimal control problem.","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots\n\nocp = @def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n    ẋ(t) == [ x₂(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend\n\nsol = solve(ocp)\n\nplot(sol)","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"For more details about this problem, please check the basic example tutorial. \nFor a comprehensive introduction to the syntax used above to describe the optimal control problem, check the abstract syntax tutorial. \nThe solve function has options, see the solve tutorial.\nYou can customise the plot with the plot function, see the plot tutorial.","category":"page"},{"location":"index.html#Citing-us","page":"Getting Started","title":"Citing us","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"If you use OptimalControl.jl in your work, please cite us:","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"Caillau, J.-B., Cots, O., Gergaud, J., Martinon, P., & Sed, S. OptimalControl.jl: a Julia package to model and solve optimal control problems with ODE's. doi.org/10.5281/zenodo.13336563","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"or in bibtex format:","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"@software{Caillau_OptimalControl_jl_a_Julia,\nauthor = {Caillau, Jean-Baptiste and Cots, Olivier and Gergaud, Joseph and Martinon, Pierre and Sed, Sophia},\ndoi = {10.5281/zenodo.13336563},\nlicense = {[\"MIT\"]},\ntitle = {{OptimalControl.jl: a Julia package to model and solve optimal control problems with ODE's}},\nurl = {https://control-toolbox.org/OptimalControl.jl}\n}","category":"page"},{"location":"index.html#Contributing","page":"Getting Started","title":"Contributing","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"If you think you found a bug or if you have a feature request / suggestion, feel free to open an issue. Before opening a pull request, please start an issue or a discussion on the topic. ","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"Contributions are welcomed, check out how to contribute to a Github project. If it is your first contribution, you can also check this first contribution tutorial. You can find first good issues (if any 🙂) here. You may find other packages to contribute to at the control-toolbox organization.","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"If you want to ask a question, feel free to start a discussion here. This forum is for general discussion about this repository and the control-toolbox organization.","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"note: Note\nIf you want to add an application or a package to the control-toolbox ecosystem, please follow this set up tutorial.","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"","category":"page"}]
}
