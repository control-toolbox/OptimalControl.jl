var documenterSearchIndex = {"docs":
[{"location":"application-surface-revolution.html#The-surface-of-revolution-of-minimum-area","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"","category":"section"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"We consider the well-known surface of revolution of minimum area problem which dates  back to Euler[1] [2]. This is a problem from  calculus of variations but we consider  its optimal control version. We minimise the cost integral","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"    int_0^1 x(t)sqrt1+u^2(t)mathrmd t","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"under the dynamical constraint","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"    dotx(t) = u(t) quad u(t)inR","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"and the limit conditions","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"    x(0) = 1 quad x(1) = 25","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"To define this problem with OptimalControl.jl we have write:","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"using OptimalControl\n\nt0 = 0\ntf = 1\nx0 = 1\nxf = 2.5\n\n@def ocp begin\n\n    t ∈ [ t0, tf ], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == xf\n\n    ẋ(t) ==  u(t)\n\n    ∫( x(t) * √(1 + u(t)^2) ) → min\n\nend\nnothing # hide","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"[1]: H. Schättler & U. Ledzewicz, Geometric optimal control: theory, methods and examples, vol~38 of Interdisciplinary applied mathematics, Springer Science & Business Media, New York (2012), xiv+640.","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"[2]: D. Liberzon, Calculus ov Variations and Optimal Control Theory, Princeton University Press (2012).","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"using Suppressor # to suppress warnings","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"The maximization of the pseudo-Hamiltonian provides the control with respect to  the state and the costate:","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"    u(xp) = mathrmsign(x) fracpsqrtx^2-p^2","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"From this control law, we could define the Hamiltonian  mathbfH(xp)=H(x p u(xp)) and its associated Hamiltonian flow. The OptimalControl.jl package does this for us simply passing to the function Flow, the optimal control problem with the control law.","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"using OrdinaryDiffEq\n\nu(x, p) = sign(x) * p / √(x^2-p^2)\n\nocp_flow = Flow(ocp, u, reltol=1e-10, abstol=1e-10)\nnothing # hide","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"Let us plot some extremals, solutions of this flow. The initial condition x_0 is fixed while we compute some extremals for different values of initial  covector p_0. We compute some specific initial covectors for a nice plot.","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"<article class=\"docstring\">\n<header>\n    <a class=\"docstring-article-toggle-button fa-solid fa-chevron-right\" href=\"javascript:;\" title=\"Expand docstring\"> </a>\n    <span class=\"docstring-category\">Computation of the initial covectors</span>\n</header>\n<section style=\"display: none;\">\n    <div>\n    <pre>\n    <code class=\"language-julia hljs\">using Roots\n\n# parameters\ntmax = 2\nxmax = 4\n\n# the extremal which has a conjugate time equal to 2: \np0_tau_2 = -0.6420147569351132\nxf_tau_2, _ = ocp_flow(t0, x0, p0_tau_2, tmax)\n\n#\nNp0x = 4\nΔx = xmax - xf_tau_2\nδx = Δx / (Np0x-1)\nδt = δx * (tmax - t0) / (xmax - 0) # depends on the xlims and ylims of the plots\n\n#\nxs_target = range(xf_tau_2, xmax, length=Np0x)\nts_target = collect(tmax:-δt:t0)\nNp0t = length(ts_target)\nNp0 = Np0x + Np0t\n\n#\ncondition(z,t,integrator) = z[1] - (xmax+1)\naffect!(integrator) = terminate!(integrator)\ncbt  = ContinuousCallback(condition,affect!)\n\n#\nπ((x, p)) = x\n\n# we seek the p0 which gives the xs_target at tf = 2\nF(p0) = (π ∘ ocp_flow)(t0, x0, p0, tmax, callback=cbt)\np0s = []\nfor i ∈ 1:Np0x\n    if i == 1\n        push!(p0s, p0_tau_2)\n    else\n        push!(p0s, Roots.find_zero(p0 -> F(p0) - xs_target[i], (p0_tau_2,  0.999)))\n    end\n    if i < Np0x\n        push!(p0s, Roots.find_zero(p0 -> F(p0) - (xs_target[i]+δx/2), (p0_tau_2, -0.999)))\n    end\nend\n\n# we seek the p0 which gives the ts_target at xf = xmax\nfor i ∈ 1:Np0t\n    F(p0) = (π ∘ ocp_flow)(t0, x0, p0, ts_target[i], callback=cbt) - xmax\n    push!(p0s, Roots.find_zero(p0 -> F(p0), (p0_tau_2,  0.999)))\n    try \n        F(p0) = (π ∘ ocp_flow)(t0, x0, p0, ts_target[i] - (δt/2), callback=cbt) - xmax\n        push!(p0s, Roots.find_zero(p0 -> F(p0), (p0_tau_2, -0.999)))\n    catch e \n        nothing\n    end\nend\n\nNp0 = length(p0s)</code><button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code ;opblock\" title=\"Copy\"></button></pre></div>\n</section>\n</article>","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"using Roots # hide\n\n# parameters # hide\ntmax = 2 # hide\nxmax = 4 # hide\n\n# the extremal which has a conjugate time equal to 2:  # hide\np0_tau_2 = -0.6420147569351132 # hide\nxf_tau_2, _ = ocp_flow(t0, x0, p0_tau_2, tmax) # hide\n\n# # hide\nNp0x = 4 # hide\nΔx = xmax - xf_tau_2 # hide\nδx = Δx / (Np0x-1) # hide\nδt = δx * (tmax - t0) / (xmax - 0) # depends on the xlims and ylims of the plots # hide\n\n# # hide\nxs_target = range(xf_tau_2, xmax, length=Np0x) # hide\nts_target = collect(tmax:-δt:t0) # hide\nNp0t = length(ts_target) # hide\nNp0 = Np0x + Np0t # hide\n\n# # hide\ncondition(z,t,integrator) = z[1] - (xmax+1) # hide\naffect!(integrator) = terminate!(integrator) # hide\ncbt  = ContinuousCallback(condition,affect!) # hide\n\n# # hide\nπ((x, p)) = x # hide\n\n# we seek the p0 which gives the xs_target at tf = 2 # hide\nF(p0) = (π ∘ ocp_flow)(t0, x0, p0, tmax, callback=cbt) # hide\np0s = [] # hide\nfor i ∈ 1:Np0x # hide\n    if i == 1 # hide\n        push!(p0s, p0_tau_2) # hide\n    else # hide\n        push!(p0s, Roots.find_zero(p0 -> F(p0) - xs_target[i], (p0_tau_2,  0.999))) # hide\n    end # hide\n    if i < Np0x # hide\n        push!(p0s, Roots.find_zero(p0 -> F(p0) - (xs_target[i]+δx/2), (p0_tau_2, -0.999))) # hide\n    end # hide\nend # hide\n\n# we seek the p0 which gives the ts_target at xf = xmax # hide\nfor i ∈ 1:Np0t # hide\n    F(p0) = (π ∘ ocp_flow)(t0, x0, p0, ts_target[i], callback=cbt) - xmax # hide\n    push!(p0s, Roots.find_zero(p0 -> F(p0), (p0_tau_2,  0.999))) # hide\n    try  # hide\n        F(p0) = (π ∘ ocp_flow)(t0, x0, p0, ts_target[i] - (δt/2), callback=cbt) - xmax # hide\n        push!(p0s, Roots.find_zero(p0 -> F(p0), (p0_tau_2, -0.999))) # hide\n    catch e  # hide\n        nothing # hide\n    end # hide\nend # hide\n\nNp0 = length(p0s) # hide\nnothing # hide","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"using Plots\n\nN  = 200\ntf_ = 2\ntspan = range(t0, tf_, N)   # time interval\nplt_x = plot()              # plot of the state x(t)\nplt_p = plot()              # plot of the costate p(t)\nplt_u = plot()              # plot of the control u(t)\nplt_phase = plot()          # plot (x, p)\n\n# callback: termination\n# Without this, the numerical integration stop before tf for p₀ = 0.99\ncondition(z,t,integrator) = z[1] - (xmax+1)\naffect!(integrator) = terminate!(integrator)\ncbt  = ContinuousCallback(condition,affect!)\n\nfor p0 ∈ p0s # plot for each p₀ in p0s\n\n    flow_p0 = ocp_flow((t0, tf_), x0, p0, saveat=tspan, callback=cbt)\n\n    T = flow_p0.ode_sol.t\n    Z = flow_p0.(T)\n    X = [Z[i][1] for i in 1:length(T)]\n    P = [Z[i][2] for i in 1:length(T)]\n\n    plot!(plt_x, T, X;          color=:blue)\n    plot!(plt_p, T, P;          color=:blue)\n    plot!(plt_u, T, u.(X, P);   color=:blue)  \n    plot!(plt_phase, X, P;      color=:blue)\n\nend\n\n# Plots\nplot!(plt_x, xlabel=\"t\", ylabel=\"x(t,p₀)\", legend=false, ylims=(0, xmax))\nplot!(plt_p, xlabel=\"t\", ylabel=\"p(t,p₀)\", legend=false)\nplot!(plt_u, xlabel=\"t\", ylabel=\"u(t,p₀)\", legend=false, ylims=(-2.5, 5))\nplot!(plt_phase, xlabel=\"x(t,p₀)\", ylabel=\"p(t,p₀)\", legend=false, xlims=(0, 2), ylims=(-1, 2))\n\nplot(plt_x, plt_p, plt_u, plt_phase, layout=(2,2), size=(800,600))","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"Here, the shooting equation given by ","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"    S(p₀) = pi(z(t_fx_0p₀)) - x_f = 0","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"with pi(x p) = x, has two solutions: p₀ = -09851 and p₀ = 05126.","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"π((x, p)) = x\n\n# Shooting function\nS(p0) = (π ∘ ocp_flow)(t0, x0, p0, tf) - xf\n\n# Solve the shooting equation: first extremal\nglobal sol1_p0 = # hide\n@suppress_err begin # hide\nRoots.find_zero(S, (-0.99, -0.97)) # hide\nsol1_p0 = Roots.find_zero(S, (-0.99, -0.97))\nend # hide\n\n# Solve the shooting equation: second extremal\nglobal sol2_p0 = # hide\n@suppress_err begin # hide\nRoots.find_zero(S, (0.5, 0.6)) # hide\nsol2_p0 = Roots.find_zero(S, (0.5, 0.6))\nend # hide\n\n@suppress_err begin # hide\nprintln(\"sol1_p0 = \",  sol1_p0, \", S(sol1_p0) = \", S(sol1_p0))\nprintln(\"sol2_p0 =  \", sol2_p0, \", S(sol2_p0) = \", S(sol2_p0))\nend # hide","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"Let us plot the two solutions. One can notice that they intersect as shown by  the top-left subplot.","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"p0s = (sol1_p0, sol2_p0)     # the different p₀\n\nN  = 100\ntspan = range(t0, tf, N)     # time interval\nplt2_x = plot()              # plot of the state x(t)\nplt2_p = plot()              # plot of the costate p(t)\nplt2_u = plot()              # plot of the control u(t)\nplt2_phase = plot()          # plot (x, p)\n\nlabels = [\"p₀=-0.9851\" , \"p₀=0.51265\"]\n\nfor (p0, label) ∈ zip(p0s, labels) # plot for each p₀ in p0s \n    \n    flow_p0 = ocp_flow((t0, tf), x0, p0, saveat=tspan)\n\n    T = tspan\n    Z = flow_p0.(tspan)\n    X = [Z[i][1] for i in 1:N]\n    P = [Z[i][2] for i in 1:N]\n    \n    plot!(plt2_x, T, X,         label=label)\n    plot!(plt2_p, T, P,         label=label)\n    plot!(plt2_u, T, u.(X, P),  label=label)  \n    plot!(plt2_phase, X, P,     label=label)\n\nend\n\nplot!(plt2_x, [tf], [xf], xlabel=\"t\", ylabel=\"x(t,p₀)\", seriestype=:scatter,label=\"\")\nplot!(plt2_p, xlabel=\"t\", ylabel=\"p(t,p₀)\", legend=false, ylims=(-1.5,5.))\nplot!(plt2_u, xlabel=\"t\", ylabel=\"u(t,p₀)\", legend=false, ylims=(-6.,5.))\nplot!(plt2_phase, xlabel=\"x(t,p₀)\", ylabel=\"p(t,p₀)\", legend=false, xlims=(0.,2.5), ylims=(-1.,5.))\n\nplot(plt2_x, plt2_p, plt2_u, plt2_phase, layout=(2,2), size=(800, 600))","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"Now, we can compute the conjugate points along the two extremals. We have to compute the flow delta z(t p₀) of the Jacobi equation  with the initial condition delta z(0) = (0 1). This is given solving","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"    delta z(t p₀) = dfracpartialpartial p₀z(t p₀)","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"Note that to compute the conjugate points, we only need the first component:","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"    delta z(t p₀)_1","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"using ForwardDiff\n\nfunction jacobi_flow(t, p0)\n    x(t, p0) = (π ∘ ocp_flow)(t0, x0, p0, t)\n    return ForwardDiff.derivative(p0 -> x(t, p0), p0)\nend\nnothing # hide","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"The first conjugate time is then the first time tau such that","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"    delta x(tau p₀)= delta z(tau p₀)_1 = 0","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"with p₀ fixed. On the following figure, one can see that the first extremal has  a conjugate time smaller than t_f=1 while for the second extremal, there is  no conjugate time. Thus, the first extremal cannot be optimal.","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"using Plots.PlotMeasures\n\nN = 100\n\n# Jacobi field for the first extremal\ntspan = range(t0, tf, N) # time interval\n\nδx = jacobi_flow.(tspan, sol1_p0)\n\nplt_conj1 = plot()\nplot!(plt_conj1, tspan, δx)  # as n=1, det(δx) = δx\nplot!(plt_conj1, xlabel=\"t\", ylabel=\"δx(t,p₀)\", legend=false, ylims=(-10.,10.), size=(400,300))\n\n# Jacobi field for the second extremal\ntspan = range(t0, 1.5, N) # time interval\n\nδx = jacobi_flow.(tspan, sol2_p0)\n\nplt_conj2= plot()\nplot!(plt_conj2, tspan, δx)  # as n=1 the det(δx) = δx\nplot!(plt_conj2, xlabel=\"t\", ylabel=\"δx(t,p₀)\", legend=false, ylims=(-10.,10.), size=(400,300))\n\n#\nplt_conj = plot(plt_conj1, plt_conj2, layout=(1, 2), size=(800, 300), leftmargin=25px)","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"We compute the first conjugate point along the first extremal and add it to the plot.","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"tau0 = Roots.find_zero(tau -> jacobi_flow(tau, sol1_p0), (0.4, 0.6))\n\nprintln(\"For p0 = \", sol1_p0, \" tau_0 = \", tau0)\n\nplot!(plt_conj[1], [tau0], [jacobi_flow(tau0, sol1_p0)], seriestype=:scatter)","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"To conclude on this example, we compute the conjugate locus by using a path following algorithm. Define F(taup₀) = delta x(taup₀) and suppose that the partial  derivative partial_tau F(taup₀) is invertible, then, by the implicit function  theorem the conjugate time is a function of p₀. So, since here p₀inR, we can  compute them by solving the initial value problem for  p₀ in alpha beta:","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"    dottau(p₀) = -dfracpartial Fpartial tau(tau(p₀)p₀)^-1 \n    dfracpartial Fpartial p₀(tau(p₀)p₀) quad\n    tau(alpha) = tau_0","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"For the numerical experiment, we set alpha = -09995, beta = -05.","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"function conjugate_times_rhs_path(tau, p0)\n    dF = ForwardDiff.gradient(y -> jacobi_flow(y...), [tau, p0])\n    return -dF[2]/dF[1]\nend\n\nfunction conjugate_times(p0span, tau0)\n    ode = OrdinaryDiffEq.ODEProblem((tau, par, p0) -> conjugate_times_rhs_path(tau, p0), tau0, p0span)\n    sol = OrdinaryDiffEq.solve(ode, reltol=1e-8, abstol=1e-8)\n    return sol.u, sol.t # taus, p0s\nend\nnothing # hide","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"Now we have defined the algorithm, let us compute the conjugate locus and plot it.","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"# conjugate locus\np0 = sol1_p0\ntaus1, p0s1 = conjugate_times((p0, -0.5), tau0)\ntaus2, p0s2 = conjugate_times((p0, -0.999), tau0)\ntaus = append!(taus2[end:-1:1],taus1)\np0s = append!(p0s2[end:-1:1],p0s1)\n\n# plot tau(p0)\nplt_conj_times = plot(p0s, taus, xlabel=\"p₀\", ylabel=\"τ\", color=:blue, xlims = (-1,-0.5))\n\n# get conjugate points\nX = []\nfor (tau, p0) ∈ zip(taus, p0s)\n    # compute x(tau, p0)\n    x = (π ∘ ocp_flow)(t0, x0, p0, tau)\n    push!(X, x)\nend\n\n# plot conjugate points on plt_x\nplot!(plt_x, taus, X, linewidth=3, color=:red, legend=false, xlims=(0.,2.0), ylims=(0., xmax))\n\n# \nplot(plt_x, plt_conj_times, layout=(1,2), legend=false, size=(800,300), leftmargin=25px)","category":"page"},{"location":"application-surface-revolution.html","page":"The surface of revolution of minimum area","title":"The surface of revolution of minimum area","text":"","category":"page"},{"location":"tutorial-basic-example.html#basic","page":"Basic example","title":"Basic example","text":"","category":"section"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force u. We denote by x = (x_1 x_2) the state of the wagon, that is its position x_1 and its velocity x_2.","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"We assume that the mass is constant and unitary and that there is no friction. The dynamics we consider is given by","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t)quad u(t) in R","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"which is simply the double integrator system. Les us consider a transfer starting at time t_0 = 0 and ending at time t_f = 1, for which we want to minimise the transfer energy","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"    frac12int_0^1 u^2(t)  mathrmdt","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"starting from the condition x(0) = (-1 0) and with the goal to reach the target x(1) = (0 0).","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"note: Solution and details\nSee the page  Double integrator: energy minimisation  for the analytical solution and details about this problem.","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"First, we need to import the OptimalControl.jl package to define and solve the optimal control problem. We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"Then, we can define the problem","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"@def ocp begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n    ẋ(t) == [ x₂(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"Solve it","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"and plot the solution","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"plot(sol)","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"We can save the solution in a julia .jld2 data file and reload it later, and also export a discretised version of the solution in a more portable JSON format.","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"# load additional modules\nusing JLD2, JSON3\n\n# JLD save / load\nsave(sol, filename_prefix=\"my_solution\")\nsol_reloaded = load(\"my_solution\")\nprintln(\"Objective from loaded solution: \", sol_reloaded.objective)\n\n# JSON export / read\nexport_ocp_solution(sol, filename_prefix=\"my_solution\")\nsol_json = import_ocp_solution(\"my_solution\")\nprintln(\"Objective from JSON discrete solution: \", sol_json.objective)","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"","category":"page"},{"location":"tutorial-lqr-basic.html#LQR-example","page":"LQR example","title":"LQR example","text":"","category":"section"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"We consider the following Linear Quadratic Regulator (LQR) problem which consists in minimising","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"    frac12 int_0^t_f left( x_1^2(t) + x_2^2(t) + u^2(t) right)  mathrmdt ","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"subject to the constraints","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = -x_1(t) + u(t) quad u(t) in R","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"and the initial condition","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"    x(0) = (01)","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"We define A and B as","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"    A = beginpmatrix 0  1  -1  0  endpmatrix quad\n    B = beginpmatrix 0  1  endpmatrix","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"in order to get dotx = Ax + Bu and we aim to solve this optimal control problem for different values of t_f. First, we need to import the OptimalControl.jl and Plots.jl packages.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"Then, we can define the problem parameterized by the final time tf.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"x0 = [ 0\n       1 ]\n\nA  = [ 0 1\n      -1 0 ]\n\nB  = [ 0\n       1 ]\n\nfunction lqr(tf)\n\n    @def ocp begin\n        t ∈ [ 0, tf ], time\n        x ∈ R², state\n        u ∈ R, control\n        x(0) == x0\n        ẋ(t) == A * x(t) + B * u(t)\n        ∫( 0.5(x₁(t)^2 + x₂(t)^2 + u(t)^2) ) → min\n    end\n\n    return ocp\nend;\nnothing # hide","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"We solve the problem for t_f in 3 5 30.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"solutions = []   # empty list of solutions\ntfs = [3, 5, 30]\n\nfor tf ∈ tfs\n    solution = solve(lqr(tf), display=false)\n    push!(solutions, solution)\nend\nnothing # hide","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"We plot the state and control variables considering a normalized time s=(t-t_0)(t_f-t_0), thanks to the keyword argument time=:normalized of the plot function.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"plt = plot(solutions[1], time=:normalized)\nfor sol ∈ solutions[2:end]\n    plot!(plt, sol, time=:normalized)\nend\n\n# we plot only the state and control variables and we add the legend\nN = length(tfs)\npx1 = plot(plt[1], legend=false, xlabel=\"s\", ylabel=\"x₁\")\npx2 = plot(plt[2], label=reshape([\"tf = $tf\" for tf ∈ tfs], (1, N)), xlabel=\"s\", ylabel=\"x₂\")\npu  = plot(plt[5], legend=false, xlabel=\"s\", ylabel=\"u\")\n\nusing Plots.PlotMeasures # for leftmargin, bottommargin\nplot(px1, px2, pu, layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"note: Nota bene\nWe can observe that x(t_f) converges to the origin as t_f increases.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"","category":"page"},{"location":"tutorial-iss.html#Indirect-simple-shooting","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"In this tutorial we present the indirect simple shooting method on a simple example.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using Suppressor # to suppress warnings","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us start by importing the necessary packages.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using OptimalControl\nusing OrdinaryDiffEq        # to get the Flow function from OptimalControl\nusing NonlinearSolve        # NLE solver: we get the fsolve function\nusing Plots","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us consider the following optimal control problem:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"left \n    beginarrayl\n        min displaystyle frac12 int_t_0^t_f u^2(t)  mathrmd t10em\n        dotx(t)  =  displaystyle -x(t)+alpha x^2(t)+u(t) quad  u(t) in R \n        quad t in t_0 t_f text ae 05em\n        x(t_0) = x_0 quad x(t_f) = x_f\n    endarray\nright","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"with t_0 = 0, t_f = 1, x_0 = -1, x_f = 0, alpha=15 and forall t in t_0 t_f, x(t) in R.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"t0 = 0\ntf = 1\nx0 = -1\nxf = 0\nα  = 1.5\n@def ocp begin\n\n    t ∈ [ t0, tf ], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == xf\n\n    ẋ(t) == -x(t) + α * x(t)^2 + u(t)\n\n    ∫( 0.5u(t)^2 ) → min\n    \nend;\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"The pseudo-Hamiltonian of this problem is","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    H(xpu) = p  (-x+alpha x^2+u) + p^0 u^2 2","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"where p^0 = -1 since we are in the normal case. From the Pontryagin Maximum Principle, the maximising control is given by","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"u(x p) = p","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"since partial^2_uu H = p^0 = - 1  0. Plugging this control in feedback form into the pseudo-Hamiltonian, and considering the limit conditions, we obtain the following two-points boundary value problem (BVP).","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    left \n        beginarrayl\n            dotx(t)  = phantom- nabla_p Ht = -x(t) + alpha x^2(t) + u(x(t) p(t)) \n            = -x(t) + alpha x^2(t) + p(t) 05em\n            dotp(t)  = -           nabla_x Ht = (1 - 2 alpha x(t)) p(t)    05em\n            x(t_0)        = x_0 quad x(t_f) = x_f\n        endarray\n    right","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"where t=  (x(t)p(t)u(x(t) p(t))).","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"note: Our goal\nOur goal is to solve this (BVP). Solving (BVP) consists in solving the Pontryagin Maximum Principle which provides necessary conditions of optimality.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"To achive our goal, let us first introduce the pseudo-Hamiltonian vector field","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    vecH(zu) = left( nabla_p H(zu) -nabla_x H(zu) right) quad z = (xp)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"and then denote by varphi_t_0 x_0 p_0(cdot) the solution of the following Cauchy problem","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"dotz(t) = vecH(z(t) u(z(t))) quad z(t_0) = (x_0 p_0)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Our goal becomes to solve","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"pi( varphi_t_0 x_0 p_0(t_f) ) = x_f quad pi(x p) = x","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"To compute varphi with the OptimalControl package, we define the flow of the associated Hamiltonian vector field by:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"u(x, p) = p\nφ = Flow(ocp, u)\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We define also the projection function on the state space.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"π(x, p) = x\nπ(z::Tuple{Number, Number}) = π(z...) # z = (x, p)\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"note: Nota bene\nActually, varphi_t_0 x_0 p_0(cdot) is also solution of    dotz(t) = vecmathbfH(z(t)) quad z(t_0) = (x_0 p_0)where mathbfH(z) = H(z u(z)) and vecmathbfH = (nabla_p mathbfH -nabla_x mathbfH). This is what is actually computed by Flow.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Now, to solve the (BVP) we introduce the shooting function.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    beginarrayrlll\n        S colon     R     longrightarrow    R \n                     p_0     longmapsto      S(p_0) = pi( varphi_t_0 x_0 p_0(t_f) ) - x_f\n    endarray","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"At the end, solving (BVP) is equivalent to solve S(p_0) = 0.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"This is what we call the indirect simple shooting method.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"S(p0) = π( φ(t0, x0, p0, tf) ) - xf;                # shooting function\n\nnle = (s, ξ, λ) -> s[1] = S(ξ[1])                   # auxiliary function\nξ = [ 0.0 ]                                         # initial guess\n\nprob = NonlinearProblem(nle, ξ)\nglobal indirect_sol =      # hide\n@suppress_err begin # hide\nNonlinearSolve.solve(prob)      # hide\nindirect_sol = NonlinearSolve.solve(prob)           # resolution of S(p0) = 0\nend                 # hide\n\np0_sol = indirect_sol.u[1]                          # costate solution\nprintln(\"costate:    p0 = \", p0_sol)\n@suppress_err begin # hide\nprintln(\"shoot: |S(p0)| = \", abs(S(p0_sol)), \"\\n\")\nend # hide\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We get:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"exp(p0; saveat=[]) = φ((t0, tf), x0, p0, saveat=saveat).ode_sol # hide\ntimes = range(t0, tf, length=2) # hide\np0min = -0.5 # hide\np0max = 2 # hide\nplt_flow = plot() # hide\np0s = range(p0min, p0max, length=20) # hide\nfor i ∈ 1:length(p0s) # hide\n    sol = exp(p0s[i]) # hide\n    x = [sol(t)[1] for t ∈ sol.t] # hide\n    p = [sol(t)[2] for t ∈ sol.t] # hide\n    label = i==1 ? \"extremals\" : false # hide\n    plot!(plt_flow, x, p, color=:blue, label=label) # hide\nend # hide\np0s = range(p0min, p0max, length=200) # hide\nxs  = zeros(length(p0s), length(times)) # hide\nps  = zeros(length(p0s), length(times)) # hide\nfor i ∈ 1:length(p0s) # hide\n    sol = exp(p0s[i], saveat=times) # hide\n    xs[i, :] = [z[1] for z ∈ sol.(times)] # hide\n    ps[i, :] = [z[2] for z ∈ sol.(times)] # hide\nend # hide\nfor j ∈ 1:length(times) # hide\n    label = j==1 ? \"flow at times\" : false # hide\n    plot!(plt_flow, xs[:, j], ps[:, j], color=:green, linewidth=2, label=label) # hide\nend # hide\nplot!(plt_flow, xlims = (-1.1, 1), ylims =  (p0min, p0max)) # hide\nplot!(plt_flow, [0, 0], [p0min, p0max], color=:black, xlabel=\"x\", ylabel=\"p\", label=\"x=xf\") # hide\nsol = exp(p0_sol) # hide\nx = [sol(t)[1] for t ∈ sol.t] # hide\np = [sol(t)[2] for t ∈ sol.t] # hide\nplot!(plt_flow, x, p, color=:red, linewidth=2, label=\"extremal solution\") # hide\nplot!(plt_flow, [x[end]], [p[end]], seriestype=:scatter, color=:green, label=false) # hide\nplt_shoot = plot(xlims=(p0min, p0max), ylims=(-2, 4), xlabel=\"p₀\", ylabel=\"y\") # hide\nplot!(plt_shoot, p0s, S, linewidth=2, label=\"S(p₀)\", color=:green) # hide\nplot!(plt_shoot, [p0min, p0max], [0, 0], color=:black, label=\"y=0\") # hide\nplot!(plt_shoot, [p0_sol, p0_sol], [-2, 0], color=:black, label=\"p₀ solution\", linestyle=:dash) # hide\nplot!(plt_shoot, [p0_sol], [0], seriestype=:scatter, color=:green, label=false) # hide\nplot(plt_flow, plt_shoot, layout=(1,2), size=(800, 450)) # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"","category":"page"},{"location":"tutorial-batch.html#batch","page":"Batch processing","title":"Batch processing","text":"","category":"section"},{"location":"tutorial-batch.html#Introduction","page":"Batch processing","title":"Introduction","text":"","category":"section"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"Let us consider a self-replicator model [1] describing the dynamics of a microbial population growing inside a closed bioreactor. The bacterial culture has a constant volume. At the beginning of the experience, there is an initial mass of substrate S inside the bioreactor, that is gradually consumed by the bacterial population, and transformed into precursor metabolites P. These precursors are intermediate metabolites used to produce proteins—such as ribosomes and enzymes—responsible for specific cellular functions; and metabolites of interest X which are excreted from the cell. The proteins forming bacterial cells are divided into three classes M, R and Q, associated with the following cellular functions:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"class M proteins of the metabolic machinery, responsible for the uptake of nutrients,\nclass S from the medium (substrate),\nthe production of precursor metabolites P,\nand the synthesis of metabolites of interest X.","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"Class R proteins of the gene expression machinery (such as ribosomes) actively involved in protein biosynthesis (i.e. in the production of proteins of classes M, Q and R). Class Q Growth are rate-independent proteins, such as housekeeping proteins responsible for cell maintenance, and ribosomes not involved in protein synthesis. There is an internal control, alpha, accounting for the behaviour of each individual cell that has to decide between two pathways (transforming precursors P into metabolites M or into ribosomes R), and one external control leveraging the production of the product X (for instance using a light induced control of bioengineered cells).","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"<img src=\"./assets/batch.jpg\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"400px\">","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"After some normalisations, a simplified version of the system (not describing the production of metabolite as we will focus on volume maximisation on this example) can be written in terms of the concentrations of the substrate s, precursors p, ribosomes r, and the of the volume V of the bacterial population.[2] Accordingly, the state varphi=(sprV) is four-dimensional, and there is only one control, alpha:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"beginalign*\n  dots = -w_M(s)(1-r)V\n  dotp = w_M(s)(1-r) - w_R(p)r(p+1)\n  dotr = (alpha-r)w_R(p)r\n  dotV = w_R(p)rV\nendalign*","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"where velocities are taken linear in the concentrations, and where Michaelis-Menten kinetics are assumed:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"v_R = V_RV = w_R(p) rquad v_M = V_MV = w_M(s) m","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"with","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"w_R(p) = frack_RpK_r + p quad w_M(s) = frack_m sK_m + scdot","category":"page"},{"location":"tutorial-batch.html#Biomass-maximisation","page":"Batch processing","title":"Biomass maximisation","text":"","category":"section"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"We first import the needed packages.","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"We are interested in maximising the biomass production [3] (final volume of the bacterial population) over a finite time horizon 0t_f. To solve the problem, we first set up the boundary values,","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"t0 = 0      \ntf = 90     \ns0 = 0.1\np0 = 0.001\nr0 = 0.1\nV0 = 0.003\nnothing # hide","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"together with parameters and auxiliary functions definnig the synthesis rates:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"kᵣ = 1.1\nkₘ = 1.2\nKᵣ = 1.3\nKₘ = 1.4\n\nwᵣ(p) = kᵣ * p / (Kᵣ + p)\nwₘ(s) = kₘ * s / (Kₘ + s)\nnothing # hide","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"Then we define the optimal control problem setting time, state, control, boundary conditions, state and control constraints, dynamics and Mayer cost:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"@def batch begin\n\n    t ∈ [ t0, tf ], time\n    φ = (s, p, r, V) ∈ R⁴, state \n    α ∈ R, control\n\n    s(t0) == s0\n    p(t0) == p0\n    r(t0) == r0\n    V(t0) == V0\n    \n    s(t) ≥ 0\n    p(t) ≥ 0\n    0 ≤ r(t) ≤ 1\n    V(t) ≥ 0\n    0 ≤ α(t) ≤ 1\n\n    φ̇(t) == F0(s(t), p(t), r(t), V(t)) + α(t) * F1(s(t), p(t), r(t), V(t))\n\n    V(tf) → max\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"The dynamics is indeed affine in the control, dotvarphi = F_0(varphi) + alpha F_1(varphi), with vector fields","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"F0(s, p, r, V) =\n    [ -wₘ(s) * (1 - r) * V\n       wₘ(s) * (1 - r) - wᵣ(p) * r * (p + 1)\n      -wᵣ(p) * r^2\n       wᵣ(p) * r * V ]\n\nF1(s, p, r, V) = [ 0, 0, wᵣ(p) * r, 0 ]\nnothing # hide","category":"page"},{"location":"tutorial-batch.html#Direct-solve","page":"Batch processing","title":"Direct solve","text":"","category":"section"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"Since the following result holds,[4]","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"Proposition. The Lie bracket F_101 belongs to the span of F_1 and F_01, so singular controls are at least of local order two.","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"one expects singular arcs connected with bang arcs through Fuller phenomenon (accumulation of switching times).","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"We first solve the problem using a uniform discretisation:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"sol0  = solve(batch; grid_size=1000, print_level=0)\nprintln(\"Objective \", sol0.objective, \" after \", sol0.iterations, \" iterations\")","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"Although convergence is obtained, it is actually more efficient to first solve on a raw grid, then use a warm start to solve again on a finer (still uniform) grid:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"sol1 = solve(batch; grid_size=20, print_level=0)\nprintln(\"Objective \", sol1.objective, \" after \", sol1.iterations, \" iterations\")","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"sol2 = solve(batch; grid_size=1000, print_level=0, init=sol1)\nprintln(\"Objective \", sol2.objective, \" after \", sol2.iterations, \" iterations\")","category":"page"},{"location":"tutorial-batch.html#Plotting","page":"Batch processing","title":"Plotting","text":"","category":"section"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"We eventually plot the solutions (raw grid + finer grid) and observe that the control exhibits the expected structure with a Fuller-in arc followed by a singular one, then a Fuller-out arc:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"plot(sol1; solution_label=\"(N=20)\", size=(800, 1000))     # N is the grid size\nplot!(sol2; solution_label=\"(N=1000)\")","category":"page"},{"location":"tutorial-batch.html#References","page":"Batch processing","title":"References","text":"","category":"section"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"[1]: Giordano, N.; Mairet, F.; Gouzé, J.-L.; Geiselmann, J.; De Jong, H. Dynamical allocation of cellular resources as an optimal control problem: novel insights into microbial growth strategies. PLoS comp. biol. 12 (2016), e1004802. ","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"[2]: Yabo, A. G.; Caillau, J.-B.; Gouzé, J.-L.; de Jong, H.; Mairet, F. Dynamical analysis and optimization of a generalized resource allocation model of microbial growth. SIAM J. Appl. Dyn. Syst. 21 (2022), no. 1, 137-165.","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"[3]: Yabo, A. G.; Caillau, J.-B.; Gouzé, J.-L. Optimal bacterial resource allocation strategies in batch processing. SIAM J. Appl. Dyn. Syst., to appear.","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"[4]: Astruc, L.; Edery, N. Optimal allocation of bacterial resources in a bioreactor. Project report, Polytech Nice Sophia, Université Côte d'Azur (2023).","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"","category":"page"},{"location":"api-ctbase.html#CTBase-API","page":"CTBase API","title":"CTBase API","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"This is just a dump of CTBase API documentation. For more details about CTBase.jl package, see the documentation.","category":"page"},{"location":"api-ctbase.html#Index","page":"CTBase API","title":"Index","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"Pages   = [\"api-ctbase.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-ctbase.html#Documentation","page":"CTBase API","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctbase.html#CTBase.CTBase","page":"CTBase API","title":"CTBase.CTBase","text":"CTBase module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDataStructures\nDocStringExtensions\nLinearAlgebra\nMLStyle\nParameters\nPrettyTables\nPrintf\nReplMaker\nUnicode\n\nList of all the exported names:\n\nAbstractHamiltonian\nAmbiguousDescription\nAutonomous\nBoundaryConstraint\nCTCallback\nCTCallbacks\nCTException\nControl\nControlConstraint\nControlLaw\nControls\nCostate\nCostates\nDCostate\nDState\nDescription\nDimension\nDynamics\nFeedbackControl\nFixed\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\nIncorrectArgument\nIncorrectMethod\nIncorrectOutput\nIndex\nLagrange\n@Lie\nLie\nLift\nMayer\nMixedConstraint\nModel\nMultiplier\nNonAutonomous\nNonFixed\nNotImplemented\nOptimalControlInit\nOptimalControlModel\nOptimalControlSolution\nParsingError\nPoisson\nPrintCallback\nState\nStateConstraint\nStates\nStopCallback\nTime\nTimeDependence\nTimes\nTimesDisc\nUnauthorizedCall\nVariable\nVariableConstraint\nVariableDependence\nVectorField\n__OCPModel\nadd\nconstraint\nconstraint!\nconstraint_type\nconstraints_labels\ncontrol!\nctNumber\nctVector\nct_repl\nct_repl_update_model\nctgradient\nctindices\nctinterpolate\nctjacobian\nctupperscripts\n@def\ndim_boundary_constraints\ndim_control_constraints\ndim_control_range\ndim_mixed_constraints\ndim_path_constraints\ndim_state_constraints\ndim_state_range\ndim_variable_constraints\ndim_variable_range\ndynamics!\ngetFullDescription\nget_priority_print_callbacks\nget_priority_stop_callbacks\nhas_free_final_time\nhas_free_initial_time\nhas_lagrange_cost\nhas_mayer_cost\nis_autonomous\nis_fixed\nis_max\nis_min\nis_time_dependent\nis_time_independent\nis_variable_dependent\nis_variable_independent\nnlp_constraints!\nobjective!\nremove_constraint!\nreplace_call\nset_AD_backend\nstate!\ntime!\nvariable!\n∂ₜ\n⋅\n\n\n\n\n\n","category":"module"},{"location":"api-ctbase.html#CTBase.Control","page":"CTBase API","title":"CTBase.Control","text":"Type alias for a control in Rᵐ.\n\njulia> const Control = ctVector\n\nSee also: ctVector, State, Costate, Variable.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Costate","page":"CTBase API","title":"CTBase.Costate","text":"Type alias for a costate in Rⁿ.\n\njulia> const Costate = ctVector\n\nSee also: ctVector, State, Control, Variable.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.DCostate","page":"CTBase API","title":"CTBase.DCostate","text":"Type alias for a tangent vector to the costate space.\n\njulia> const DCostate = ctVector\n\nSee also: ctVector, DState.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.DState","page":"CTBase API","title":"CTBase.DState","text":"Type alias for a tangent vector to the state space.\n\njulia> const DState = ctVector\n\nSee also: ctVector, DCostate.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.State","page":"CTBase API","title":"CTBase.State","text":"Type alias for a state in Rⁿ.\n\njulia> const State = ctVector\n\nSee also: ctVector, Costate, Control, Variable.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.TimesDisc","page":"CTBase API","title":"CTBase.TimesDisc","text":"Type alias for a grid of times. This is used to define a discretization of time interval given to solvers.\n\njulia> const TimesDisc = Union{Times, StepRangeLen}\n\nSee also: Time, Times.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Variable","page":"CTBase API","title":"CTBase.Variable","text":"Type alias for a variable in Rᵏ.\n\njulia> const Variable = ctVector\n\nSee also: ctVector, State, Costate, Control.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ctVector","page":"CTBase API","title":"CTBase.ctVector","text":"Type alias for a vector of real numbers.\n\njulia> const ctVector = Union{ctNumber, AbstractVector{<:ctNumber}}\n\nSee also: ctNumber, State, Costate, Control, Variable.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.AbstractHamiltonian","page":"CTBase API","title":"CTBase.AbstractHamiltonian","text":"abstract type AbstractHamiltonian{time_dependence, variable_dependence}\n\nAbstract type for hamiltonians.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.AmbiguousDescription","page":"CTBase API","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTException\n\nException thrown when the description is ambiguous / incorrect.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Autonomous","page":"CTBase API","title":"CTBase.Autonomous","text":"abstract type Autonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"struct BoundaryConstraint{variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor BoundaryConstraint returns a BoundaryConstraint of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar. When the constraint is dimension 1, return a scalar.\n\nCall\n\nThe call returns the evaluation of the BoundaryConstraint for given values. If a variable is given for a non variable dependent boundary constraint, it will be ignored.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"BoundaryConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> BoundaryConstraint{Fixed}\n\n\nReturn a BoundaryConstraint of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"BoundaryConstraint(\n    f::Function;\n    variable\n) -> BoundaryConstraint{Fixed}\n\n\nReturn a BoundaryConstraint of a function. Dependencies are specified with a boolean, variable, false by default.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"Return the evaluation of the BoundaryConstraint.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.CTCallback","page":"CTBase API","title":"CTBase.CTCallback","text":"abstract type CTCallback\n\nAbstract type for callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.CTCallbacks","page":"CTBase API","title":"CTBase.CTCallbacks","text":"Tuple of callbacks\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.CTException","page":"CTBase API","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract type for exceptions.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ControlConstraint","page":"CTBase API","title":"CTBase.ControlConstraint","text":"struct ControlConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlConstraint returns a ControlConstraint of a function. The function must take 1 to 3 arguments, u to (t, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the control is of dimension 1, consider u as a scalar.\n\nCall\n\nThe call returns the evaluation of the ControlConstraint for given values.\n\nExamples\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ControlConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> ControlConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlConstraint{Autonomous, Fixed}\n\n\nReturn the ControlConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.ControlConstraint","text":"Return the value of the ControlConstraint function.\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlLaw","page":"CTBase API","title":"CTBase.ControlLaw","text":"struct ControlLaw{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to Hamiltonian in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlLaw returns a ControlLaw of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the ControlLaw for given values.\n\nExamples\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ControlLaw-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.ControlLaw","text":"ControlLaw(\n    f::Function,\n    dependencies::DataType...\n) -> ControlLaw{Autonomous, Fixed}\n\n\nReturn the ControlLaw of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlLaw-Tuple{Function}","page":"CTBase API","title":"CTBase.ControlLaw","text":"ControlLaw(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlLaw{Autonomous, Fixed}\n\n\nReturn the ControlLaw of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlLaw-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.ControlLaw","text":"Return the value of the ControlLaw function.\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Controls","page":"CTBase API","title":"CTBase.Controls","text":"Type alias for a vector of controls.\n\njulia> const Controls = AbstractVector{<:Control}\n\nSee also: Control, States, Costates.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Costates","page":"CTBase API","title":"CTBase.Costates","text":"Type alias for a vector of costates.\n\njulia> const Costates = AbstractVector{<:Costate}\n\nSee also: Costate, States, Controls.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Description","page":"CTBase API","title":"CTBase.Description","text":"A description is a tuple of symbols. Description is a type alias for a tuple of symbols.\n\njulia> const Description = Tuple{DescVarArg}\n\nSee also: DescVarArg.\n\nExample\n\nBase.show is overloaded for descriptions, that is tuple of descriptions are printed as follows:\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dimension","page":"CTBase API","title":"CTBase.Dimension","text":"Type alias for a dimension. This is used to define the dimension of the state space,  the costate space, the control space, etc.\n\njulia> const Dimension = Integer\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dynamics","page":"CTBase API","title":"CTBase.Dynamics","text":"struct Dynamics{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Dynamics returns a Dynamics of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Dynamics for given values.\n\nExamples\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dynamics-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Dynamics","text":"Dynamics(\n    f::Function,\n    dependencies::DataType...\n) -> Dynamics{Autonomous, Fixed}\n\n\nReturn the Dynamics of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Dynamics-Tuple{Function}","page":"CTBase API","title":"CTBase.Dynamics","text":"Dynamics(\n    f::Function;\n    autonomous,\n    variable\n) -> Dynamics{Autonomous, Fixed}\n\n\nReturn the Dynamics of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Dynamics-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Dynamics","text":"Return the value of the Dynamics function.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.FeedbackControl","page":"CTBase API","title":"CTBase.FeedbackControl","text":"struct FeedbackControl{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor FeedbackControl returns a FeedbackControl of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the FeedbackControl for given values.\n\nExamples\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.FeedbackControl-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function,\n    dependencies::DataType...\n) -> FeedbackControl{Autonomous, Fixed}\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.FeedbackControl-Tuple{Function}","page":"CTBase API","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function;\n    autonomous,\n    variable\n) -> FeedbackControl{Autonomous, Fixed}\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.FeedbackControl-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.FeedbackControl","text":"Return the value of the FeedbackControl function.\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Fixed","page":"CTBase API","title":"CTBase.Fixed","text":"abstract type Fixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Hamiltonian","page":"CTBase API","title":"CTBase.Hamiltonian","text":"struct Hamiltonian{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Hamiltonian returns a Hamiltonian of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Hamiltonian for given values.\n\nExamples\n\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Hamiltonian-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function,\n    dependencies::DataType...\n) -> Hamiltonian{Autonomous, Fixed}\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Hamiltonian-Tuple{Function}","page":"CTBase API","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function;\n    autonomous,\n    variable\n) -> Hamiltonian{Autonomous, Fixed}\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Hamiltonian-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Hamiltonian","text":"Return the value of the Hamiltonian.\n\njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianLift","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"struct HamiltonianLift{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence}\n\nLifts\n\nX::VectorField\n\nThe values for time_dependence and variable_dependence are deternimed by the values of those for the VectorField.\n\nConstructor\n\nThe constructor HamiltonianLift returns a HamiltonianLift of a VectorField.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed))\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianLift for given values.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\nAlternatively, it is possible to construct the HamiltonianLift from a Function being the VectorField.\n\njulia> HL1 = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL2 = HamiltonianLift(VectorField((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true))\njulia> HL1([1, 0], [0, 1], 1) == HL2([1, 0], [0, 1], 1)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.HamiltonianLift-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], Autonomous, Fixed)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], Autonomous, NonFixed)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], NonAutonomous, Fixed)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianLift-Tuple{Function}","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianLift\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], autonomous=false, variable=false)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianLift-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"Return the value of the HamiltonianLift.\n\nExamples\n\njulia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"struct HamiltonianVectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor HamiltonianVectorField returns a HamiltonianVectorField of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianVectorField for given values.\n\nExamples\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function,\n    dependencies::DataType...\n) -> HamiltonianVectorField{Autonomous, Fixed}\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Function}","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianVectorField{Autonomous, Fixed}\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"Return the value of the HamiltonianVectorField.\n\nExamples\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.IncorrectArgument","page":"CTBase API","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTException\n\nException thrown when an argument is inconsistent.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.IncorrectMethod","page":"CTBase API","title":"CTBase.IncorrectMethod","text":"struct IncorrectMethod <: CTException\n\nException thrown when a method is incorrect.\n\nFields\n\nvar::Symbol\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.IncorrectOutput","page":"CTBase API","title":"CTBase.IncorrectOutput","text":"struct IncorrectOutput <: CTException\n\nException thrown when the output is incorrect.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Index","page":"CTBase API","title":"CTBase.Index","text":"mutable struct Index\n\nFields\n\nval::Integer\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Lagrange","page":"CTBase API","title":"CTBase.Lagrange","text":"struct Lagrange{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Lagrange returns a Lagrange cost of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], Autonomous, Fixed)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, Autonomous, Fixed)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], Autonomous, NonFixed)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, Fixed)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Lagrange cost for given values.\n\nExamples\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Lagrange-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Lagrange","text":"Lagrange(\n    f::Function,\n    dependencies::DataType...\n) -> Lagrange{Autonomous, Fixed}\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lagrange-Tuple{Function}","page":"CTBase API","title":"CTBase.Lagrange","text":"Lagrange(\n    f::Function;\n    autonomous,\n    variable\n) -> Lagrange{Autonomous, Fixed}\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lagrange-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Lagrange","text":"Return the value of the Lagrange function.\n\nExamples\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Mayer","page":"CTBase API","title":"CTBase.Mayer","text":"struct Mayer{variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor Mayer returns a Mayer cost of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar.\n\nCall\n\nThe call returns the evaluation of the Mayer cost for given values. If a variable is given for a non variable dependent Mayer cost, it will be ignored.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1],Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Mayer-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Mayer","text":"Mayer(\n    f::Function,\n    dependencies::DataType...\n) -> Mayer{Fixed}\n\n\nReturn a Mayer cost of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Mayer-Tuple{Function}","page":"CTBase API","title":"CTBase.Mayer","text":"Mayer(f::Function; variable) -> Mayer{Fixed}\n\n\nReturn a Mayer cost of a function. Dependencies are specified with a boolean, variable, false by default.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Mayer-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Mayer","text":"Return the evaluation of the Mayer cost.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1], Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.MixedConstraint","page":"CTBase API","title":"CTBase.MixedConstraint","text":"struct MixedConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to Lagrange in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor MixedConstraint returns a MixedConstraint of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the MixedConstraint for given values.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.MixedConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> MixedConstraint{Autonomous, Fixed}\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.MixedConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> MixedConstraint{Autonomous, Fixed}\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.MixedConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.MixedConstraint","text":"Return the value of the MixedConstraint function.\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Multiplier","page":"CTBase API","title":"CTBase.Multiplier","text":"struct Multiplier{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to ControlLaw in the usage.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Multiplier returns a Multiplier of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Multiplier for given values.\n\nExamples\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Multiplier-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Multiplier","text":"Multiplier(\n    f::Function,\n    dependencies::DataType...\n) -> Multiplier{Autonomous, Fixed}\n\n\nReturn the Multiplier of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Multiplier-Tuple{Function}","page":"CTBase API","title":"CTBase.Multiplier","text":"Multiplier(\n    f::Function;\n    autonomous,\n    variable\n) -> Multiplier{Autonomous, Fixed}\n\n\nReturn the Multiplier of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Multiplier-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Multiplier","text":"Return the value of the Multiplier function.\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.NonAutonomous","page":"CTBase API","title":"CTBase.NonAutonomous","text":"abstract type NonAutonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.NonFixed","page":"CTBase API","title":"CTBase.NonFixed","text":"abstract type NonFixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.NotImplemented","page":"CTBase API","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTException\n\nException thrown when a method is not implemented.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.OptimalControlInit","page":"CTBase API","title":"CTBase.OptimalControlInit","text":"Initial guess for OCP, contains\n\nfunctions of time for the state and control variables\nvector for optimization variables\n\nInitialization data for each field can be left to default or: \n\nvector for optimization variables\nconstant / vector / function for state and control  \nexisting solution ('warm start') for all fields\n\nConstructors:\n\nOptimalControlInit(): default initialization\nOptimalControlInit(state, control, variable, time): constant vector, function handles and / or matrices / vectors interpolated along given time grid\nOptimalControlInit(sol): from existing solution\n\nExamples\n\njulia> init = OptimalControlInit()\njulia> init = OptimalControlInit(state=[0.1, 0.2], control=0.3)\njulia> init = OptimalControlInit(state=[0.1, 0.2], control=0.3, variable=0.5)\njulia> init = OptimalControlInit(state=[0.1, 0.2], controlt=t->sin(t), variable=0.5)\njulia> init = OptimalControlInit(state=[[0, 0], [1, 2], [5, -1]], time=[0, .3, 1.], controlt=t->sin(t))\njulia> init = OptimalControlInit(sol)\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.OptimalControlModel","page":"CTBase API","title":"CTBase.OptimalControlModel","text":"mutable struct OptimalControlModel{time_dependence<:TimeDependence, variable_dependence<:VariableDependence} <: CTBase.AbstractOptimalControlModel\n\nFields\n\nmodel_expression::Union{Nothing, Expr}: Default: nothing\ninitial_time::Union{Nothing, Index, Real}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time::Union{Nothing, Index, Real}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nvariable_dimension::Union{Nothing, Integer}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nlagrange::Union{Nothing, Lagrange}: Default: nothing\nmayer::Union{Nothing, Mayer}: Default: nothing\ncriterion::Union{Nothing, Symbol}: Default: nothing\ndynamics::Union{Nothing, Dynamics}: Default: nothing\nconstraints::Dict{Symbol, Tuple}: Default: Dict{Symbol, Tuple{Vararg{Any}}}()\ndim_control_constraints::Union{Nothing, Integer}: Default: nothing\ndim_state_constraints::Union{Nothing, Integer}: Default: nothing\ndim_mixed_constraints::Union{Nothing, Integer}: Default: nothing\ndim_boundary_constraints::Union{Nothing, Integer}: Default: nothing\ndim_variable_constraints::Union{Nothing, Integer}: Default: nothing\ndim_control_range::Union{Nothing, Integer}: Default: nothing\ndim_state_range::Union{Nothing, Integer}: Default: nothing\ndim_variable_range::Union{Nothing, Integer}: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.OptimalControlSolution","page":"CTBase API","title":"CTBase.OptimalControlSolution","text":"mutable struct OptimalControlSolution <: CTBase.AbstractOptimalControlSolution\n\nType of an optimal control solution.\n\nFields\n\ntimes::Union{Nothing, StepRangeLen, AbstractVector{<:Real}}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\ncontrol::Union{Nothing, Function}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nstate::Union{Nothing, Function}: Default: nothing\nvariable_dimension::Union{Nothing, Integer}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nvariable::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\ncostate::Union{Nothing, Function}: Default: nothing\nobjective::Union{Nothing, Real}: Default: nothing\niterations::Union{Nothing, Integer}: Default: nothing\nstopping::Union{Nothing, Symbol}: Default: nothing\nmessage::Union{Nothing, String}: Default: nothing\nsuccess::Union{Nothing, Bool}: Default: nothing\ninfos::Dict{Symbol, Any}: Default: Dict{Symbol, Any}()\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ParsingError","page":"CTBase API","title":"CTBase.ParsingError","text":"struct ParsingError <: CTException\n\nException thrown for syntax error during abstract parsing.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.PrintCallback","page":"CTBase API","title":"CTBase.PrintCallback","text":"mutable struct PrintCallback <: CTCallback\n\nCallback for printing.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.PrintCallback-Tuple","page":"CTBase API","title":"CTBase.PrintCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.StateConstraint","page":"CTBase API","title":"CTBase.StateConstraint","text":"struct StateConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor StateConstraint returns a StateConstraint of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the StateConstraint for given values.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.StateConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> StateConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.StateConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> StateConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.StateConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.StateConstraint","text":"Return the value of the StateConstraint function.\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.States","page":"CTBase API","title":"CTBase.States","text":"Type alias for a vector of states.\n\njulia> const States = AbstractVector{<:State}\n\nSee also: State, Costates, Controls.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.StopCallback","page":"CTBase API","title":"CTBase.StopCallback","text":"Stopping callback.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.StopCallback-Tuple","page":"CTBase API","title":"CTBase.StopCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Time","page":"CTBase API","title":"CTBase.Time","text":"Type alias for a time.\n\njulia> const Time = ctNumber\n\nSee also: ctNumber, Times, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.TimeDependence","page":"CTBase API","title":"CTBase.TimeDependence","text":"abstract type TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Times","page":"CTBase API","title":"CTBase.Times","text":"Type alias for a vector of times.\n\njulia> const Times = AbstractVector{<:Time}\n\nSee also: Time, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.UnauthorizedCall","page":"CTBase API","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTException\n\nException thrown when a call to a function is not authorized.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VariableConstraint","page":"CTBase API","title":"CTBase.VariableConstraint","text":"struct VariableConstraint\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VariableConstraint returns a VariableConstraint of a function. The function must take 1 argument, v.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\n\nwarning: Warning\nWhen the variable is of dimension 1, consider v as a scalar.\n\nCall\n\nThe call returns the evaluation of the VariableConstraint for given values.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VariableConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.VariableConstraint","text":"Return the value of the VariableConstraint function.\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.VariableDependence","page":"CTBase API","title":"CTBase.VariableDependence","text":"abstract type VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VectorField","page":"CTBase API","title":"CTBase.VectorField","text":"struct VectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VectorField returns a VectorField of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the VectorField for given values.\n\nExamples\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VectorField-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.VectorField","text":"VectorField(\n    f::Function,\n    dependencies::DataType...\n) -> VectorField{Autonomous, Fixed}\n\n\nReturn a VectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.VectorField-Tuple{Function}","page":"CTBase API","title":"CTBase.VectorField","text":"VectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> VectorField{Autonomous, Fixed}\n\n\nReturn a VectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.VectorField-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.VectorField","text":"Return the value of the VectorField.\n\nExamples\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctNumber","page":"CTBase API","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\njulia> const ctNumber = Real\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.:⋅-Tuple{Function, Function}","page":"CTBase API","title":"CTBase.:⋅","text":"⋅(X::Function, f::Function) -> Function\n\n\nLie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.:⋅-Tuple{VectorField{Autonomous, <:VariableDependence}, Function}","page":"CTBase API","title":"CTBase.:⋅","text":"⋅(\n    X::VectorField{Autonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#97#99\"{VectorField{Autonomous, var\"#s98\"}, <:Function} where var\"#s98\"<:VariableDependence\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in autonomous case\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.:⋅-Tuple{VectorField{NonAutonomous, <:VariableDependence}, Function}","page":"CTBase API","title":"CTBase.:⋅","text":"⋅(\n    X::VectorField{NonAutonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#101#103\"{VectorField{NonAutonomous, var\"#s98\"}, <:Function} where var\"#s98\"<:VariableDependence\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in nonautonomous case\n\nExample\n\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Tuple{Function, Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::Function,\n    f::Function,\n    dependences::DataType...\n) -> Function\n\n\nLie derivative of a scalar function along a vector field or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, NonAutonomous, NonFixed)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Tuple{Function, Function}","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Function\n\n\nLie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Tuple{VectorField, Function}","page":"CTBase API","title":"CTBase.Lie","text":"Lie(X::VectorField, f::Function) -> Function\n\n\nLie derivative of a scalar function along a vector field.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{Autonomous, V<:VariableDependence},\n    Y::VectorField{Autonomous, V<:VariableDependence}\n) -> VectorField\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case\n\nExample\n\njulia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{NonAutonomous, V<:VariableDependence},\n    Y::VectorField{NonAutonomous, V<:VariableDependence}\n) -> VectorField{NonAutonomous}\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case\n\nExample\n\njulia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lift-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Lift","text":"Lift(\n    X::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a VectorField or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lift-Tuple{Function}","page":"CTBase API","title":"CTBase.Lift","text":"Lift(X::Function; autonomous, variable) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lift-Tuple{VectorField}","page":"CTBase API","title":"CTBase.Lift","text":"Lift(X::VectorField) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a VectorField.\n\nExample\n\njulia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Model-Tuple{Vararg{DataType}}","page":"CTBase API","title":"CTBase.Model","text":"Model(\n    dependencies::DataType...\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following argument:\n\ndependencies: either Autonomous or NonAutonomous. Default is Autonomous. And either NonFixed or Fixed. Default is Fixed.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(NonAutonomous)\njulia> ocp = Model(Autonomous, NonFixed)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Model-Tuple{}","page":"CTBase API","title":"CTBase.Model","text":"Model(\n;\n    autonomous,\n    variable\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following optional keyword argument:\n\nautonomous: either true or false. Default is true.\nvariable: either true or false. Default is false.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(autonomous=false)\njulia> ocp = Model(autonomous=false, variable=true)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Tuple{Function, Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::Function,\n    dependences::DataType...\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Tuple{Function, Function}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{Autonomous, V}, AbstractHamiltonian{Autonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{Autonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{Autonomous, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{NonAutonomous, V}, AbstractHamiltonian{NonAutonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{NonAutonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{NonAutonomous, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case\n\nExample\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{AbstractHamiltonian{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence},\n    g::Function\n) -> Hamiltonian\n\n\nPoisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{Function, AbstractHamiltonian{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence}\n) -> Hamiltonian\n\n\nPoisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::HamiltonianLift{T<:TimeDependence, V<:VariableDependence},\n    g::HamiltonianLift{T<:TimeDependence, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.__OCPModel-Tuple","page":"CTBase API","title":"CTBase.__OCPModel","text":"__OCPModel(args...; kwargs...) -> OptimalControlModel\n\n\nRedirection to Model to avoid confusion with other functions Model from other packages if imported. This function is used by @def.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","page":"CTBase API","title":"CTBase.add","text":"add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nConcatenate the description y to the tuple of descriptions x if x does not contain y and return the new tuple of descriptions. Throw an error if the description y is already contained in x.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> descriptions = add(descriptions, (:b,))\n(:a,)\n(:b,)\njulia> descriptions = add(descriptions, (:b,))\nERROR: IncorrectArgument: the description (:b,) is already in ((:a,), (:b,))\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","page":"CTBase API","title":"CTBase.add","text":"add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> print(descriptions)\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol;\n    rg,\n    f,\n    lb,\n    ub,\n    label\n)\n\n\nAdd a constraint to an optimal control problem, denoted ocp.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe initial and final times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nYou can add an :initial, :final, :control, :state or :variable box constraint (whole range). \n\nRange constraint on the state, control or variable\n\nYou can add an :initial, :final, :control, :state or :variable box constraint on a range of it, that is only on some components. If not range is specified, then the constraint is on the whole range. We denote by x, u and v respectively the state, control and variable. We denote by n, m and q respectively the dimension of the state, control and variable. The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable.\n\nExamples\n\njulia> constraint!(ocp, :initial; rg=1:2:5, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :initial; rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :final; rg=1, lb=0, ub=2)\njulia> constraint!(ocp, :control; rg=1, lb=0, ub=2)\njulia> constraint!(ocp, :state; rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :variable; rg=1:2, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :initial; lb=[ 0, 0, 0 ])                 # [ 0, 0, 0 ] ≤ x(t0),                          dim(x) = 3\njulia> constraint!(ocp, :initial; lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ]) # [ 0, 0, 0 ] ≤ x(t0) ≤ [ 1, 2, 1 ],            dim(x) = 3\njulia> constraint!(ocp, :final; lb=-1, ub=1)                      #          -1 ≤ x(tf) ≤ 1,                      dim(x) = 1\njulia> constraint!(ocp, :control; lb=0, ub=2)                     #           0 ≤ u(t)  ≤ 2,        t ∈ [t0, tf], dim(u) = 1\njulia> constraint!(ocp, :state; lb=[ 0, 0 ], ub=[ 1, 2 ])         #    [ 0, 0 ] ≤ x(t)  ≤ [ 1, 2 ], t ∈ [t0, tf], dim(x) = 2\njulia> constraint!(ocp, :variable; lb=[ 0, 0 ], ub=[ 1, 2 ])      #    [ 0, 0 ] ≤    v  ≤ [ 1, 2 ],               dim(v) = 2\n\nFunctional constraint\n\nYou can add a :boundary, :control, :state, :mixed or :variable box functional constraint.\n\nExamples\n\n# variable independent ocp\njulia> constraint!(ocp, :boundary; f = (x0, xf) -> x0[3]+xf[2], lb=0, ub=1)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary; f = (x0, xf, v) -> x0[3]+xf[2]*v[1], lb=0, ub=1)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control; f = u -> 2u, lb=0, ub=1)\njulia> constraint!(ocp, :state; f = x -> x-1, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (x, u) -> x[1]-u, lb=0, ub=1)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control; f = (t, u) -> 2u, lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (t, x) -> t * x, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (t, x, u) -> x[1]-u, lb=0, ub=1)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control; f = (u, v) -> 2u * v[1], lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (x, v) -> x * v[1], lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (x, u, v) -> x[1]-v[2]*u, lb=0, ub=1)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control; f = (t, u, v) -> 2u+v[2], lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (t, x, v) -> x-t*v[1], lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (t, x, u, v) -> x[1]*v[2]-u, lb=0, ub=1)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.constraint","text":"constraint(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    label::Symbol\n) -> Any\n\n\nRetrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds).\n\nExample\n\njulia> constraint!(ocp, :initial, 0, :c0)\njulia> c = constraint(ocp, :c0)\njulia> c(1)\n1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint_type-NTuple{7, Any}","page":"CTBase API","title":"CTBase.constraint_type","text":"constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n\n\nReturn the type constraint among :initial, :final, :boundary, :control_range, :control_fun, :state_range, :state_fun, :mixed, :variable_range, :variable_fun (:other otherwise), together with the appropriate value (range, updated expression...) Expressions like u(t0) where u is the control and t0 the initial time return :other.\n\nExample\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, 1)\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, 1)\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, 1)\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, 1)\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, 2)\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n:variable_fun\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n:variable_fun\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraints_labels-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.constraints_labels","text":"constraints_labels(\n    ocp::OptimalControlModel\n) -> Base.KeySet{Symbol, Dict{Symbol, Tuple}}\n\n\nReturn the labels of the constraints as a Base.keys.\n\nExample\n\njulia> constraints_labels(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.control!","page":"CTBase API","title":"CTBase.control!","text":"control!(ocp::OptimalControlModel, m::Integer)\ncontrol!(ocp::OptimalControlModel, m::Integer, name::String)\ncontrol!(\n    ocp::OptimalControlModel,\n    m::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the control dimension and possibly the names of each coordinate.\n\nnote: Note\nYou must use control! only once to set the control dimension.\n\nExamples\n\njulia> control!(ocp, 1)\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.ct_repl-Tuple{}","page":"CTBase API","title":"CTBase.ct_repl","text":"ct_repl(; debug, verbose)\n\n\nCreate a ct REPL.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ct_repl_update_model-Tuple{Expr}","page":"CTBase API","title":"CTBase.ct_repl_update_model","text":"ct_repl_update_model(e::Expr)\n\n\nUpdate the model adding the expression e. It must be public since in the ct repl, this function  is quoted each time an expression is parsed and is valid. \n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctgradient-Tuple{Function, Any}","page":"CTBase API","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x; backend) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctgradient-Tuple{Function, Real}","page":"CTBase API","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x::Real; backend) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctgradient-Tuple{VectorField, Any}","page":"CTBase API","title":"CTBase.ctgradient","text":"ctgradient(X::VectorField, x) -> Any\n\n\nReturn the gradient of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctindices-Tuple{Integer}","page":"CTBase API","title":"CTBase.ctindices","text":"ctindices(i::Integer) -> String\n\n\nReturn i > 0 as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctinterpolate-Tuple{Any, Any}","page":"CTBase API","title":"CTBase.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn the interpolation of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctjacobian-Tuple{Function, Any}","page":"CTBase API","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x; backend) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctjacobian-Tuple{Function, Real}","page":"CTBase API","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x::Real; backend) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctjacobian-Tuple{VectorField, Any}","page":"CTBase API","title":"CTBase.ctjacobian","text":"ctjacobian(X::VectorField, x) -> Any\n\n\nReturn the Jacobian of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctupperscripts-Tuple{Integer}","page":"CTBase API","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Integer) -> String\n\n\nReturn i > 0 as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_boundary_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_boundary_constraints","text":"dim_boundary_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of the boundary constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_control_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_control_constraints","text":"dim_control_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear control constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_control_range-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_control_range","text":"dim_control_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of range constraints on control (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_mixed_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_mixed_constraints","text":"dim_mixed_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear mixed constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_path_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_path_constraints","text":"dim_path_constraints(ocp::OptimalControlModel) -> Any\n\n\nReturn the dimension of nonlinear path (state + control + mixed) constraints (nothing if one of them is not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_state_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_state_constraints","text":"dim_state_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear state constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_state_range-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_state_range","text":"dim_state_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of range constraints on state (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_variable_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_variable_constraints","text":"dim_variable_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear variable constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_variable_range-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_variable_range","text":"dim_variable_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of range constraints on variable (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.dynamics!","text":"dynamics!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    f::Function\n)\n\n\nSet the dynamics.\n\nnote: Note\nYou can use dynamics! only once to define the dynamics.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> dynamics!(ocp, f)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"CTBase API","title":"CTBase.getFullDescription","text":"getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn a complete description from an incomplete description desc and  a list of complete descriptions desc_list. If several complete descriptions are possible,  then the first one is returned.\n\nExample\n\njulia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n(:a, :b)\n(:b, :c)\n(:a, :c)\njulia> getFullDescription((:a,), desc_list)\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.get_priority_print_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","page":"CTBase API","title":"CTBase.get_priority_print_callbacks","text":"get_priority_print_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n\n\nGet the highest priority print callbacks.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.get_priority_stop_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","page":"CTBase API","title":"CTBase.get_priority_stop_callbacks","text":"get_priority_stop_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n\n\nGet the highest priority stop callbacks.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.has_free_final_time-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.has_free_final_time","text":"has_free_final_time(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with free final time.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.has_free_initial_time-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.has_free_initial_time","text":"has_free_initial_time(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with free initial time.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.has_lagrange_cost-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.has_lagrange_cost","text":"has_lagrange_cost(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with lagrange cost.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.has_mayer_cost-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.has_mayer_cost","text":"has_mayer_cost(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with mayer cost.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_autonomous-Tuple{OptimalControlModel{Autonomous}}","page":"CTBase API","title":"CTBase.is_autonomous","text":"is_autonomous(ocp::OptimalControlModel{Autonomous}) -> Bool\n\n\nReturn true if the model is autonomous.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_fixed-Tuple{OptimalControlModel{<:TimeDependence, Fixed}}","page":"CTBase API","title":"CTBase.is_fixed","text":"is_fixed(\n    ocp::OptimalControlModel{<:TimeDependence, Fixed}\n) -> Bool\n\n\nReturn true if the model is fixed (= has no variable).\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_max-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_max","text":"is_max(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :max.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_min-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_min","text":"is_min(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :min.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_time_dependent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_time_dependent","text":"is_time_dependent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_time_independent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_time_independent","text":"is_time_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as time independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_variable_dependent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_variable_dependent","text":"is_variable_dependent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_variable_independent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_variable_independent","text":"is_variable_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as variable independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.nlp_constraints!-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.nlp_constraints!","text":"nlp_constraints!(\n    ocp::OptimalControlModel\n) -> Tuple{Tuple{Any, CTBase.var\"#ξ#91\", Vector{Real}}, Tuple{Any, CTBase.var\"#η#92\", Vector{Real}}, Tuple{Any, CTBase.var\"#ψ#93\", Vector{Real}}, Tuple{Any, CTBase.var\"#ϕ#94\", Vector{Real}}, Tuple{Any, CTBase.var\"#θ#95\", Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}\n\n\nReturn a 6-tuple of tuples:\n\n(ξl, ξ, ξu) are control constraints\n(ηl, η, ηu) are state constraints\n(ψl, ψ, ψu) are mixed constraints\n(ϕl, ϕ, ϕu) are boundary constraints\n(θl, θ, θu) are variable constraints\n(ul, uind, uu) are control linear constraints of a subset of indices\n(xl, xind, xu) are state linear constraints of a subset of indices\n(vl, vind, vu) are variable linear constraints of a subset of indices\n\nand update information about constraints dimensions of  ocp.\n\nnote: Note\nThe dimensions of the state and control must be set before calling nlp_constraints!.\nFor a Fixed problem, dimensions associated with constraints on the variable are set to zero.\n\nExample\n\njulia> (ξl, ξ, ξu), (ηl, η, ηu), (ψl, ψ, ψu), (ϕl, ϕ, ϕu), (θl, θ, θu),\n    (ul, uind, uu), (xl, xind, xu), (vl, vind, vu) = nlp_constraints!(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function g and f⁰. Type can be :bolza. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> objective!(ocp, :bolza, (x0, xf) -> x0[1] + xf[2], (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function f. Type can be :mayer or :lagrange. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\njulia> objective!(ocp, :mayer, (x0, xf) -> x0[1] + xf[2])\njulia> objective!(ocp, :lagrange, (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\nwarning: Warning\nIf you set twice the objective, only the last one will be taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}","page":"CTBase API","title":"CTBase.remove_constraint!","text":"remove_constraint!(ocp::OptimalControlModel, label::Symbol)\n\n\nRemove a labeled constraint.\n\nExample\n\njulia> remove_constraint!(ocp, :con)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}","page":"CTBase API","title":"CTBase.replace_call","text":"replace_call(e, x::Symbol, t, y) -> Any\n\n\nReplace calls in e of the form (...x...)(t) by (...y...).\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","page":"CTBase API","title":"CTBase.replace_call","text":"replace_call(e, x::Vector{Symbol}, t, y) -> Any\n\n\nReplace calls in e of the form (...x1...x2...)(t) by (...y1...y2...) for all symbols x1, x2... in the vector x.\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.state!","page":"CTBase API","title":"CTBase.state!","text":"state!(ocp::OptimalControlModel, n::Integer)\nstate!(ocp::OptimalControlModel, n::Integer, name::String)\nstate!(\n    ocp::OptimalControlModel,\n    n::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the state dimension and possibly the names of each component.\n\nnote: Note\nYou must use state! only once to set the state dimension.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.time!-Union{Tuple{OptimalControlModel{<:TimeDependence, VT}}, Tuple{VT}} where VT","page":"CTBase API","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel{<:TimeDependence, VT};\n    t0,\n    tf,\n    ind0,\n    indf,\n    name\n)\n\n\nSet the initial and final times. We denote by t0 the initial time and tf the final time. The optimal control problem is denoted ocp. When a time is free, then one must provide the corresponding index of the ocp variable.\n\nnote: Note\nYou must use time! only once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, t0=0,   tf=1  ) # Fixed t0 and fixed tf\njulia> time!(ocp, t0=0,   indf=2) # Fixed t0 and free  tf\njulia> time!(ocp, ind0=2, tf=1  ) # Free  t0 and fixed tf\njulia> time!(ocp, ind0=2, indf=3) # Free  t0 and free  tf\n\nWhen you plot a solution of an optimal control problem, the name of the time variable appears. By default, the name is \"t\". Consider you want to set the name of the time variable to \"s\".\n\njulia> time!(ocp, t0=0, tf=1, name=\"s\") # name is a String\n# or\njulia> time!(ocp, t0=0, tf=1, name=:s ) # name is a Symbol  \n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.variable!","page":"CTBase API","title":"CTBase.variable!","text":"variable!(ocp::OptimalControlModel, q::Integer)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String\n)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the variable dimension and possibly the names of each component.\n\nnote: Note\nYou can use variable! once to set the variable dimension when the model is NonFixed.\n\nExamples\n\njulia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"v₁\", \"v₂\" ])\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.∂ₜ-Tuple{Any}","page":"CTBase API","title":"CTBase.∂ₜ","text":"∂ₜ(f) -> CTBase.var\"#106#108\"\n\n\nPartial derivative wrt time of a function.\n\nExample\n\njulia> ∂ₜ((t,x) -> t*x)(0,8)\n8\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.@Lie-Tuple{Expr, Any, Any}","page":"CTBase API","title":"CTBase.@Lie","text":"Macros for Poisson brackets\n\nExample\n\njulia> H0 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7]) autonomous=true variable=false\n#\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false variable=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) autonomous=true variable=true\n#\njulia> H0 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2) autonomous=false variable=true\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase.html#CTBase.@Lie-Tuple{Expr, Any}","page":"CTBase API","title":"CTBase.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) variable=true\n#\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase.html#CTBase.@Lie-Tuple{Expr}","page":"CTBase API","title":"CTBase.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\n#\njulia> F0 = VectorField((t, x) -> [t+x[1], x[2], (1-x[3])], autonomous=false)\njulia> F1 = VectorField((t, x) -> [t, -x[3], x[2]], autonomous=false)\njulia> @Lie [F0, F1](1, [1, 2, 3])\n#\njulia> F0 = VectorField((x, v) -> [x[1]+v, x[2], (1-x[3])], variable=true)\njulia> F1 = VectorField((x, v) -> [0, -x[3]-v, x[2]], variable=true)\njulia> @Lie [F0, F1]([1, 2, 3], 2)\n#\njulia> F0 = VectorField((t, x, v) -> [t+x[1]+v, x[2], (1-x[3])], autonomous=false, variable=true)\njulia> F1 = VectorField((t, x, v) -> [t, -x[3]-v, x[2]], autonomous=false, variable=true)\njulia> @Lie [F0, F1](1, [1, 2, 3], 2)\n#\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7])\n3.0\n#\njulia> H0 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2), autonomous=false)\njulia> H1 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2), autonomous=false)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7])\n#\njulia> H0 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), variable=true)\njulia> H1 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), variable=true)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2)\n#\njulia> H0 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), autonomous=false, variable=true)\njulia> H1 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), autonomous=false, variable=true)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2)\n#\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase.html#CTBase.@def","page":"CTBase API","title":"CTBase.@def","text":"Define an optimal control problem. One pass parsing of the definition.\n\nExample\n\n@def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"","category":"page"},{"location":"api-ctdirect.html#CTDirect-API","page":"CTDirect API","title":"CTDirect API","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect API","title":"CTDirect API","text":"This is just a dump of CTDirect API documentation. For more details about CTDirect.jl package, see the documentation.","category":"page"},{"location":"api-ctdirect.html#Index","page":"CTDirect API","title":"Index","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect API","title":"CTDirect API","text":"Pages   = [\"api-ctdirect.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-ctdirect.html#Documentation","page":"CTDirect API","title":"Documentation","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect API","title":"CTDirect API","text":"Modules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctdirect.html#CTDirect.DOCP","page":"CTDirect API","title":"CTDirect.DOCP","text":"Struct for discretized optimal control problem DOCP\n\nContains:\n\na copy of the original OCP\na NLP formulation of the DOCP\ndata required to link the two problems\n\n\n\n\n\n","category":"type"},{"location":"api-ctdirect.html#CTDirect.available_methods-Tuple{}","page":"CTDirect API","title":"CTDirect.available_methods","text":"available_methods() -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.build_solution-Tuple{Any, Any}","page":"CTDirect API","title":"CTDirect.build_solution","text":"build_solution(\n    docp,\n    docp_solution_ipopt\n) -> OptimalControlSolution\n\n\nBuild OCP functional solution from DOCP discrete solution (given as a GenericExecutionStats)\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.build_solution-Tuple{Any}","page":"CTDirect API","title":"CTDirect.build_solution","text":"build_solution(docp; primal, dual)\n\n\nBuild OCP functional solution from the DOCP discrete solution, given as a vector. Costate will be retrieved from dual variables (multipliers) if available.\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.direct_transcription-Tuple{OptimalControlModel, Vararg{Any}}","page":"CTDirect API","title":"CTDirect.direct_transcription","text":"direct_transcription(\n    ocp::OptimalControlModel,\n    description...;\n    init,\n    grid_size,\n    time_grid\n) -> DOCP\n\n\nDiscretize an optimal control problem into a nonlinear optimization problem (ie direct transcription)\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.get_nlp-Tuple{DOCP}","page":"CTDirect API","title":"CTDirect.get_nlp","text":"get_nlp(docp::DOCP) -> Any\n\n\nExtract the NLP problem from the DOCP\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.is_solvable-Tuple{Any}","page":"CTDirect API","title":"CTDirect.is_solvable","text":"is_solvable(ocp) -> Bool\n\n\nCheck if an OCP is solvable by the method solve.\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.set_initial_guess-Tuple{DOCP, Any}","page":"CTDirect API","title":"CTDirect.set_initial_guess","text":"set_initial_guess(docp::DOCP, init) -> Any\n\n\nSet initial guess in the DOCP\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html","page":"CTDirect API","title":"CTDirect API","text":"","category":"page"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"<img width=\"800\" alt=\"juliacon\" src=\"./assets/juliacon.jpg\">","category":"page"},{"location":"juliacon2023.html#Solving-optimal-control-problems-with-Julia","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"","category":"section"},{"location":"juliacon2023.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://scholar.google.com/citations?userpkH4An4AAAAJ-and-hlfr),-[Pierre-Martinon](https://www.linkedin.com/in/pierre-martinon-b4603a17),-[Sophia-Sed](https://iww.inria.fr/sed-sophia)","page":"Solving optimal control problems with Julia","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"page"},{"location":"juliacon2023.html#What-it's-about","page":"Solving optimal control problems with Julia","title":"What it's about","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"subject to","category":"page"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"plus boundary, control and state constraints","category":"page"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"juliacon2023.html#Where-it-comes-from","page":"Solving optimal control problems with Julia","title":"Where it comes from","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"BOCOP: the optimal control solver\nHamPath: indirect and Hamiltonian pathfollowing\nCoupling direct and indirect solvers, examples","category":"page"},{"location":"juliacon2023.html#OptimalControl.jl","page":"Solving optimal control problems with Julia","title":"OptimalControl.jl","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Basic example: double integrator\nBasic example: double integrator (cont'ed)\nAdvanced example: Goddard problem","category":"page"},{"location":"juliacon2023.html#Wrap-up","page":"Solving optimal control problems with Julia","title":"Wrap up","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"[X] High level modelling of optimal control problems\n[X] Efficient numerical resolution coupling direct and indirect methods\n[X] Collection of examples ","category":"page"},{"location":"juliacon2023.html#Future","page":"Solving optimal control problems with Julia","title":"Future","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"ct_repl\nAdditional solvers: direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions!\nCTProblems.jl","category":"page"},{"location":"juliacon2023.html#control-toolbox.org","page":"Solving optimal control problems with Julia","title":"control-toolbox.org","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"juliacon2023.html#Credits-(not-exhaustive!)","page":"Solving optimal control problems with Julia","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"DifferentialEquations.jl\nJuMP, InfiniteOpt.jl, ADNLPModels.jl\nIpopt\nJuliaDiff (FowardDiff.jl, Zygote.jl)\nMLStyle.jl\nREPLMaker.jl","category":"page"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"","category":"page"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"<img width=\"800\" alt=\"juliaopt2023\" src=\"./assets/juliaopt2023.jpg\">","category":"page"},{"location":"juliaopt2023.html#Solving-optimal-control-problems-with-Julia","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"","category":"section"},{"location":"juliaopt2023.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://scholar.google.com/citations?userpkH4An4AAAAJ-and-hlfr),-[Pierre-Martinon](https://www.linkedin.com/in/pierre-martinon-b4603a17),-[Sophia-Sed](https://iww.inria.fr/sed-sophia)","page":"Solving optimal control problems with Julia","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"page"},{"location":"juliaopt2023.html#What-it's-about","page":"Solving optimal control problems with Julia","title":"What it's about","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"subject to","category":"page"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"plus boundary, control and state constraints","category":"page"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"juliaopt2023.html#Where-it-comes-from","page":"Solving optimal control problems with Julia","title":"Where it comes from","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"BOCOP: the optimal control solver\nHamPath: indirect and Hamiltonian pathfollowing\nCoupling direct and indirect solvers, examples","category":"page"},{"location":"juliaopt2023.html#OptimalControl.jl","page":"Solving optimal control problems with Julia","title":"OptimalControl.jl","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Basic example: double integrator (1/3)\nBasic example: double integrator (2/3)\nBasic example: double integrator (3/3)\nIndirect simple shooting\nAdvanced example: Goddard problem","category":"page"},{"location":"juliaopt2023.html#Wrap-up","page":"Solving optimal control problems with Julia","title":"Wrap up","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"[X] High level modelling of optimal control problems\n[X] Efficient numerical resolution coupling direct and indirect methods\n[X] Collection of examples","category":"page"},{"location":"juliaopt2023.html#Future","page":"Solving optimal control problems with Julia","title":"Future","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"ct_repl\nAdditional solvers: direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions!\nCTProblems.jl","category":"page"},{"location":"juliaopt2023.html#control-toolbox.org","page":"Solving optimal control problems with Julia","title":"control-toolbox.org","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"juliaopt2023.html#Credits-(not-exhaustive!)","page":"Solving optimal control problems with Julia","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"DifferentialEquations.jl\nJuMP, InfiniteOpt.jl, ADNLPModels.jl\nIpopt\nJuliaDiff (FowardDiff.jl, Zygote.jl)\nMLStyle.jl\nREPLMaker.jl","category":"page"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"","category":"page"},{"location":"tutorial-nlp.html#NLP-and-DOCP-manipulations","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"We describe here some more advanced operations related to the discretized optimal control problem. When calling solve(ocp) three steps are performed internally:","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"first, the OCP is discretized into a DOCP (a nonlinear optimization problem) with direct_transcription\nthen, this DOCP is solved, also with the method solve\nfinally, a functional solution of the OCP is rebuilt from the solution of the discretized problem, with build_solution","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"These steps can also be done separately, for instance if you want to use your own NLP solver. Let us load the modules","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"and define a test problem","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"@def ocp begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n    ẋ(t) == [ x₂(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"First let us discretize the problem","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"docp = direct_transcription(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"The DOCP contains a copy of the original OCP, and the resulting discretized problem, in our case an ADNLPModel. You can extract this raw NLP problem  with the get_nlp function","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"nlp = get_nlp(docp)","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"You could then use a custom solver that would return the solution for the NLP problem, such as","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"nlp_sol = MySolver(get_nlp(docp))","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"For illustrative purpose we can mimick this by using the solve from CTDirect on the DOCP, and extract the NLP solution and multipliers","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"using CTDirect\nnlp_sol = CTDirect.solve(docp, display=false)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"Then we can rebuild and plot an OCP solution (note that the multipliers are optional, but the OCP costate will not be retrieved if the multipliers are not provided)","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"sol = build_solution(docp, primal=nlp_sol.solution, dual=nlp_sol.multipliers)\nplot(sol)","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"An initial guess, including warm start, can be passed to direct_transcription the same way as for solve","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"docp = direct_transcription(ocp, init=sol)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"and it can also be changed after the transcription is done, with setinitialguess","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"set_initial_guess(docp, sol)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"Back to the function solve, passing an explicit initial guess to","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"solve(ocp) will transmit it to direct_transcription, therefore the resulting DOCP will have the initial guess embedded in it.\nsolve(docp) will override the initial guess in the DOCP and used the given one instead, without modifying the DOCP. ","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"","category":"page"},{"location":"tutorial-plot.html#Plot-a-solution","page":"Plot a solution","title":"Plot a solution","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In this tutorial we explain the different ways to plot a solution of an optimal control problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Let us start by importing the package to define the problem and solve it.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using OptimalControl\nusing NLPModelsIpopt","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Then, we define a simple optimal control problem and solve it.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"@def ocp begin\n\n    t ∈ [ 0, 1 ], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n\n    ẋ(t) == [ x₂(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\n\nsol = solve(ocp, display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html#First-ways-to-plot","page":"Plot a solution","title":"First ways to plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The simplest way to plot the solution is to use the plot function with only the solution as argument.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: The plot function\nThe plot function on a solution of an optimal control problem is an extension of the plot function from the package Plots.jl. Hence, we need to import this package to plot a solution.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using Plots\nplot(sol)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"As you can see, it produces a grid of subplots. The left column contains the state trajectories, the right column the costate trajectories, and at the bottom we have the control trajectory.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Attributes from Plots.jl can be passed to the plot function:","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In addition to sol you can pass attributes to the full Plot, see the attributes plot documentation from Plots.jl for more details. For instance, you can specify the size of the figure.\nYou can also pass attributes to the subplots, see the attributes subplot documentation from Plots.jl for more details. However, it will affect all the subplots. For instance, you can specify the location of the legend.\nIn the same way, you can pass axis attributes to the subplots, see the attributes axis documentation from Plots.jl for more details. It will also affect all the subplots. For instance, you can remove the grid.\nIn the same way, you can pass series attributes to the all the subplots, see the attributes series documentation from Plots.jl for more details. It will also affect all the subplots. For instance, you can set the width of the curves with linewidth.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, size=(700, 450), legend=:bottomright, grid=false, linewidth=2)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To specify series attributes to a specific subplot, you can use the optional keyword arguments state_style, costate_style and control_style which correspond respectively to the state, costate and control trajectories. See the attribute series documentation from Plots.jl for more details. For instance, you can specify the color of the state trajectories and more.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, \n     state_style   = (color=:blue,), \n     costate_style = (color=:black, linestyle=:dash),\n     control_style = (color=:red, linewidth=2))","category":"page"},{"location":"tutorial-plot.html#Split-versus-group-layout","page":"Plot a solution","title":"Split versus group layout","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"If you prefer to get a more compact figure, you can use the layout optional keyword argument with :group value. It will group the state, costate and control trajectories in one subplot for each.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, layout=:group, size=(800, 300))","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Default layout value\nThe default layout value is :split which corresponds to the grid of subplots presented above.","category":"page"},{"location":"tutorial-plot.html#Additional-plots","page":"Plot a solution","title":"Additional plots","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can plot the solution of a second optimal control problem on the same figure if it has the same number of states, costates and controls. For instance, consider the same optimal control problem but with a different initial condition.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"@def ocp begin\n\n    t ∈ [ 0, 1 ], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x(0) == [ -0.5, -0.5 ]\n    x(1) == [ 0, 0 ]\n\n    ẋ(t) == [ x₂(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nsol2 = solve(ocp, display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We first plot the solution of the first optimal control problem, then, we plot the solution of the second optimal control problem on the same figure, but with dashed lines.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"# first plot\nplt = plot(sol, solution_label=\"(sol1)\", size=(700, 500))\n\n# second plot\nplot!(plt, sol2, solution_label=\"(sol2)\", linestyle=:dash)","category":"page"},{"location":"tutorial-plot.html#Plot-the-norm-of-the-control","page":"Plot a solution","title":"Plot the norm of the control","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"For some problem, it is interesting to plot the norm of the control. You can do it by using the control optional keyword argument with :norm value. The default value is :components. Let us illustrate this on the consumption minimisation orbital transfer problem from CTProlbems.jl.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using CTProblems\nprob = Problem(:orbital_transfert, :consumption)\nplot(prob.solution, control=:norm, size=(800, 300), layout=:group)","category":"page"},{"location":"tutorial-plot.html#Custom-plot","page":"Plot a solution","title":"Custom plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can of course create your own plots by getting the state, costate and control from the optimal control solution. For instance, let us plot the norm of the control for the orbital transfer problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using LinearAlgebra\nt = sol.times\nx = sol.state\np = sol.costate\nu = sol.control\nplot(t, norm∘u, label=\"‖u‖\") ","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Nota bene\nThe norm function is from LinearAlgebra.jl. \nThe ∘ operator is the composition operator. Hence, norm∘u is the function t -> norm(u(t)). \nThe sol.state, sol.costate and sol.control are functions that return the state, costate and control trajectories at a given time.","category":"page"},{"location":"tutorial-plot.html#Normalized-time","page":"Plot a solution","title":"Normalized time","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We consider a LQR example and solve the problem for different values of the final time tf. Then, we plot the solutions on the same figure considering a normalized time s=(t-t_0)(t_f-t_0), thanks to the keyword argument time=:normalized of the plot function.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"\n# parameters\nx0 = [ 0\n       1 ]\n\nA  = [ 0 1\n      -1 0 ]\n\nB  = [ 0\n       1 ]\n\n# definition\nfunction lqr(tf)\n\n    @def ocp begin\n        t ∈ [ 0, tf ], time\n        x ∈ R², state\n        u ∈ R, control\n        x(0) == x0\n        ẋ(t) == A * x(t) + B * u(t)\n        ∫( 0.5(x₁(t)^2 + x₂(t)^2 + u(t)^2) ) → min\n    end\n\n    return ocp\nend;\n\n# solve\nsolutions = []\ntfs = [3, 5, 30]\nfor tf ∈ tfs\n    solution = solve(lqr(tf), display=false)\n    push!(solutions, solution)\nend\n\n# create plots\nplt = plot(solutions[1], time=:normalized)\nfor sol ∈ solutions[2:end]\n    plot!(plt, sol, time=:normalized)\nend\n\n# make a custom plot from created plots: only state and control are plotted\nN = length(tfs)\npx1 = plot(plt[1], legend=false, xlabel=\"s\", ylabel=\"x₁\")\npx2 = plot(plt[2], label=reshape([\"tf = $tf\" for tf ∈ tfs], (1, N)), xlabel=\"s\", ylabel=\"x₂\")\npu  = plot(plt[5], legend=false, xlabel=\"s\", ylabel=\"u\")\n\nusing Plots.PlotMeasures # for leftmargin, bottommargin\nplot(px1, px2, pu, layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"","category":"page"},{"location":"api-ctproblems.html#CTProblems-API","page":"CTProblems API","title":"CTProblems API","text":"","category":"section"},{"location":"api-ctproblems.html","page":"CTProblems API","title":"CTProblems API","text":"This is just a dump of CTProblems API documentation. For more details about CTProblems.jl package, see the documentation.","category":"page"},{"location":"api-ctproblems.html#Index","page":"CTProblems API","title":"Index","text":"","category":"section"},{"location":"api-ctproblems.html","page":"CTProblems API","title":"CTProblems API","text":"Pages   = [\"api-ctproblems.md\"]\nModules = [CTProblems]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-ctproblems.html#Documentation","page":"CTProblems API","title":"Documentation","text":"","category":"section"},{"location":"api-ctproblems.html","page":"CTProblems API","title":"CTProblems API","text":"Modules = [CTProblems]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctproblems.html#CTProblems.CTProblems","page":"CTProblems API","title":"CTProblems.CTProblems","text":"CTProblems module.\n\nLists all the imported modules and packages:\n\nBase\nCTBase\nCTFlows\nCore\nDocStringExtensions\nLinearAlgebra\n\nList of all the exported names:\n\nProblem\n@Problems\nProblems\n@ProblemsDescriptions\nProblemsDescriptions\n\n\n\n\n\n","category":"module"},{"location":"api-ctproblems.html#CTProblems.Problem-Tuple{Vararg{Symbol}}","page":"CTProblems API","title":"CTProblems.Problem","text":"Problem(\n    description::Symbol...\n) -> CTProblems.OptimalControlProblem\n\n\nReturn the optimal control problem described by description.\n\nIf you give a partial description, then, if several complete descriptions contains the partial one, then,  only the problem with the highest priority is returned. The higher in the list, the higher is the priority.\n\nExample\n\njulia> Problem(:integrator, :energy)\n\n\n\n\n\n","category":"method"},{"location":"api-ctproblems.html#CTProblems.Problems-Tuple{Vararg{Symbol}}","page":"CTProblems API","title":"CTProblems.Problems","text":"Problems(\n    description::Symbol...\n) -> Tuple{Vararg{CTProblems.OptimalControlProblem}}\n\n\nReturn the list of optimal control problems consistent with the description.\n\nIf you give a partial description, then, if several complete descriptions contains the partial one, then,  only the problem with the highest priority is returned. The higher in the list, the higher is the priority.\n\nExample\n\njulia> Problems(:integrator, :energy)\n\n\n\n\n\n","category":"method"},{"location":"api-ctproblems.html#CTProblems.ProblemsDescriptions-Tuple{Vararg{Symbol}}","page":"CTProblems API","title":"CTProblems.ProblemsDescriptions","text":"ProblemsDescriptions(\n    description::Symbol...\n) -> Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n\n\nReturn the list of problems descriptions consistent with the description, as a Tuple of Description. \n\nExample\n\njulia> ProblemsDescriptions(:integrator, :energy)\n\n\n\n\n\n","category":"method"},{"location":"api-ctproblems.html#CTProblems.@Problems","page":"CTProblems API","title":"CTProblems.@Problems","text":"Return the list of problems consistent with the description.\n\nExample\n\njulia> @Problems :integrator & :energy\n\nnote: Note\nYou have to define a logical condition with the combination of symbols and the three  operators: !, | and &, respectively for the negation, the disjunction and the conjunction.\n\n\n\n\n\n","category":"macro"},{"location":"api-ctproblems.html#CTProblems.@ProblemsDescriptions","page":"CTProblems API","title":"CTProblems.@ProblemsDescriptions","text":"Return the list of problems descriptions consistent with the expression.\n\nExample\n\njulia> @ProblemsDescriptions :integrator & :energy\n\nnote: Note\nYou have to define a logical condition with the combination of symbols and the three  operators: !, | and &, respectively for the negation, the disjunction and the conjunction.\n\n\n\n\n\n","category":"macro"},{"location":"api-ctproblems.html","page":"CTProblems API","title":"CTProblems API","text":"","category":"page"},{"location":"tutorial-continuation.html#Discrete-continuation","page":"Discrete continuation","title":"Discrete continuation","text":"","category":"section"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Using the warm start option, it is easy to implement a basic discrete continuation method, where a sequence of problems is solved using each solution as initial guess for the next problem. This usually gives better and faster convergence than solving each problem with the same initial guess, and is a way to handle problems that require a good initial guess.","category":"page"},{"location":"tutorial-continuation.html#Continuation-on-parametric-OCP","page":"Discrete continuation","title":"Continuation on parametric OCP","text":"","category":"section"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"The most compact syntax to perform a discrete continuation is to use a function that returns the OCP for a given value of the continuation parameter, and solve a sequence of these problems. We illustrate this on a very basic double integrator with increasing fixed final time.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"First we load the required packages","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Printf\nusing Plots","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"and write a function that returns the OCP for a given final time","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"function ocp_T(T)\n    @def ocp begin\n        t ∈ [ 0, T ], time\n        x ∈ R², state\n        u ∈ R, control\n        q = x₁\n        v = x₂\n        q(0) == 0\n        v(0) == 0\n        q(T) == 1\n        v(T) == 0\n        ẋ(t) == [ v(t), u(t) ]\n        ∫(u(t)^2) → min\n    end\n    return ocp\nend\nnothing # hide","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Then we perform the continuation with a simple for loop, using each solution to initialize the next problem.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"init1 = ()\nfor T=1:5\n    ocp1 = ocp_T(T) \n    sol1 = solve(ocp1, display=false, init=init1)\n    global init1 = sol1\n    @printf(\"T %.2f objective %9.6f iterations %d\\n\", T, sol1.objective, sol1.iterations)\nend","category":"page"},{"location":"tutorial-continuation.html#Continuation-on-global-variable","page":"Discrete continuation","title":"Continuation on global variable","text":"","category":"section"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"As a second example, we show how to avoid redefining a new OCP each time, and modify the original one instead. More precisely we now solve a Goddard problem for a decreasing maximal thrust. If we store the value for Tmax in a global variable, we can simply modify this variable and keep the same OCP problem during the continuation.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Let us first define the Goddard problem (note that the formulation below illustrates all the possible constraints types, and the problem could be defined in a more compact way).","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Cd = 310\nTmax = 3.5\nβ = 500\nb = 2\nfunction F0(x)\n    r, v, m = x\n    D = Cd * v^2 * exp(-β*(r - 1))\n    return [ v, -D/m - 1/r^2, 0 ]\nend\nfunction F1(x)\n    r, v, m = x\n    return [ 0, Tmax/m, -b*Tmax ]\nend\n\nocp = Model(variable=true)\nr0 = 1\nv0 = 0\nm0 = 1\nmf = 0.6\nx0=[r0,v0,m0]\nvmax = 0.1\nstate!(ocp, 3)\ncontrol!(ocp, 1)\nvariable!(ocp, 1)\ntime!(ocp, t0=0, indf=1)\nconstraint!(ocp, :initial, lb=x0, ub=x0)\nconstraint!(ocp, :final, rg=3, lb=mf, ub=Inf)\nconstraint!(ocp, :state, lb=[r0,v0,mf], ub=[r0+0.2,vmax,m0])\nconstraint!(ocp, :control, lb=0, ub=1)\nconstraint!(ocp, :variable, lb=0.01, ub=Inf)\nobjective!(ocp, :mayer, (x0, xf, v) -> xf[1], :max)\ndynamics!(ocp, (x, u, v) -> F0(x) + u*F1(x) )\n\nsol0 = solve(ocp, display=false)\nsol = sol0\n@printf(\"Objective for reference solution %.6f\\n\", sol0.objective)","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Then we perform the continuation on the maximal thrust.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Tmax_list = []\nobj_list = []\nfor Tmax_local=3.5:-0.5:1\n    global Tmax = Tmax_local  \n    global sol = solve(ocp, display=false, init=sol)\n    @printf(\"Tmax %.2f objective %.6f iterations %d\\n\", Tmax, sol.objective, sol.iterations)\n    push!(Tmax_list, Tmax)\n    push!(obj_list, sol.objective)\nend ","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"We plot now the objective w.r.t the maximal thrust, as well as both solutions for Tmax=3.5 and Tmax=1.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"pobj = plot(Tmax_list, obj_list, label=\"r(tf)\",seriestype=:scatter)\nxlabel!(\"Maximal thrust (Tmax)\")\nylabel!(\"Maximal altitude r(tf)\")\nplot(sol0)\np = plot!(sol)\nplot(pobj, p, layout=2, size=(1000, 500))","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"","category":"page"},{"location":"tutorial-double-integrator.html#double-int","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"","category":"section"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"The problem consists in minimising the final time t_f for the double integrator system","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) quad u(t) in -11","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"and the limit conditions","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"    x(0) = (12) quad x(t_f) = (00)","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"This problem can be interpretated as a simple model for a wagon with constant mass moving along a line without fricton.","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"First, we need to import the OptimalControl.jl package to define and solve the optimal control problem. We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"Then, we can define the problem","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"@def ocp begin\n\n    tf ∈ R,          variable\n    t ∈ [ 0, tf ],   time\n    x = (q, v) ∈ R², state\n    u ∈ R,           control\n\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n\n    q(0)  == 1\n    v(0)  == 2\n    q(tf) == 0\n    v(tf) == 0\n\n     0 ≤ q(t) ≤ 5,          (1)\n    -2 ≤ v(t) ≤ 3,          (2)\n\n    ẋ(t) == [ v(t), u(t) ]\n\n    tf → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"note: Nota bene\nIn order to ensure convergence of the direct solver, we have added the state constraints labelled (1) and (2):0 leq q(t) leq 5quad -2 leq v(t) leq 3quad t in  0 t_f ","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"Solve it","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"and plot the solution","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"plot(sol)","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"","category":"page"},{"location":"application-mri-saturation.html#mri-saturation","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"","category":"section"},{"location":"application-mri-saturation.html#Background-overview","page":"The saturation problem in Magnetic Resonance Imaging","title":"Background overview","text":"","category":"section"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"From the 2010 survey[1], one of the earliest examples of coherent control of quantum dynamics  is manipulation of nuclear spin ensembles using radiofrequency (RF) fields[2].  This manipulation is possible due to the Nuclear Magnetic Resonance (NMR) phenomenon[3] [4] which has become a very powerful tool to study matter in a variety of domains from biology  and chemistry to solid physics and quantum mechanics. Two of the main applications of NMR  control techniques are maybe high-resolution spectroscopy and Magnetic Resonance Imaging (MRI).","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"MRI is a medical imaging technique used to produce pictures of the anatomy and investigate  physiological processes of the body. The general principles involve the interaction of matter  with electromagnetic fields and are the following. When a sample of matter, in liquid phase,  is inside a strong and uniform longitudinal magnetic field (B_0), the magnetic moments of the spin-12 particles align with the direction of this field. When a transverse radio-frequency magnetic pulse (B_1) is then applied, the sample alter its magnetization  alignment relative to the field and its characteristics (the relaxation times T_1 and T_2). These changes in magnetization alignment produce a changing magnetic flux, which  yields to the emission of an electric signal which is detected and amplified. Then, the image  is obtained by the analysis of the Fourier transform of this signal. One key point of this  process is the control of the magnetization vector via the magnetic pulse. To do that, many different control strategies already exists[4], but the majority are based  upon heuristic reasoning[5] [6].","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"(Image: MRI)","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Optimal control algorithms were introduced in NMR to improve control field sequences  recently[7] and at the end of the nineties, new methods appeared in optimal control of NMR  systems both from the analytical and numerical points of view[8] [9]. More recently, the  combination of geometric optimal control based on the Maximum Principle[10] and related  numerical algorithms (gradient methods[11], shooting and continuation methods[12]) leads  to sophisticated results about the time-minimal saturation problem (which consists in bringing  the magnetization vector to zero, ie. the state to the origin) of a single spin[13] with applications to the contrast problem in MRI, see[14] [15]. They are the basis to  numerical computations of robust optimal controls which take into account inhomogeneities  contained in the B_0 and B_1 magnetic fields and which have been validated very recently  by in vitro and in vivo experiments, see[16] [17].","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"note: Recent survey\nThis background overview is not up-to-date. We refer to [18] for more details.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[1]: C. Brif, R. Chakrabarti & H. Rabitz, Control of Quantum Phenomena: Past, Present and Future, New Journal for Physics, 12 (2010), pp.1–68.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[2]: A. Abragam, The Principles of Nucelar Magnetism, Oxford University Press, London (1961).","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[3]: R. R. Ernst, Principles of Nuclear Magnetic Resonance in one and two dimensions International Series of Monographs on Chemistry, Oxford University Press, Oxford (1990).","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[4]: M. H. Levitt, Spin dynamics: Basics of Nuclear Magnetic Resonance, John Wiley & Sons, New York-London-Sydney (2008).","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[5]: M. A. Berstein, K. F. King & X. J. Zhou, Handbook of MRI pulse sequences, Elsevier, Amsterdam (2004).","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[6]: J. N. Rydberg, S. J. Riederer, C. H. Rydberg & C. R. Jack, Contrast optimization of fluid-attenuated inversion recovery (flair) imaging, Magn. Reson. Med., 34 (1995), no. 6, 868–877.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[7]: S. Conolly, D. Nishimura & A. Macovski, Optimal control solutions to the magnetic resonance selective excitation problem, IEEE Trans. Med. Imaging, 5 (1986), no. 2, 106–115.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[8]: N. Khaneja, S. J. Glaser & R. Brockett, Sub-Riemannian geometry and time optimal control of three spin systems: quantum gates and coherence transfer, Phys. Rev. A, 65 (2002), no. 3, 032301, pp.11. Errata Phys. Rev. A 68 (2003), 049903; Phys. Rev. A 71 (2005), 039906.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[9]: T. E. Skinner, T. O. Reiss, B. Luy, N. Khaneja & S. J. Glaser, Application of optimal control theory to the design of broadband excitation pulses for high-resolution NMR, J. Magn. Reson., 163 (2003), no. 1, 8–15.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[10]: L. S. Pontryagin, V. G. Boltyanskii, R. V. Gamkrelidze & E. F. Mishchenko, The Mathematical Theory of Optimal Processes, Translated from the Russian by K. N. Trirogoff, edited by L. W. Neustadt, Interscience Publishers John Wiley & Sons, Inc., New York-London, 1962.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[11]: N. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbriiggen & S. J. Glaser, Optimal control of coupled spin dynamics: design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson., 172 (2005), no. 2, 296–305.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[12]: O. Cots, Contrôle optimal géométrique : méthodes homotopiques et applications, Phd thesis, Institut Mathématiques de Bourgogne, Dijon, France, 2012.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[13]: M. Lapert, Y. Zhang, M. Braun, S. J. Glaser & D. Sugny, Singular extremals for the time-optimal control of dissipative spin 1/2 particles, Phys. Rev. Lett., 104 (2010), 083001.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[14]: B. Bonnard, M. Chyba & J. Marriott, Singular Trajectories and the Contrast Imaging Problem in Nuclear Magnetic resonance, SIAM J. Control Optim., 51 (2013), no. 2, 1325–1349.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[15]: M. Lapert, Y. Zhang, M. A. Janich, S. J. Glaser & D. Sugny, Exploring the physical limits of saturation contrast in magnetic resonance imaging, Sci. Rep., 589 (2012), no. 2.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[16]: B. Bonnard, O. Cots, S. Glaser, M. Lapert, D. Sugny & Y. Zhang, *Geometric optimal control of the contrast imaging problem in nuclear magnetic resonance, IEEE Trans. Automat. Control, 57 (2012), no. 8, 1957–1969.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[17]: E. Van Reeth, H. Ratiney, M. Tesch, D. Grenier, O. Beuf, S. J. Glaser &  D. Sugny, Optimal control design of preparation pulses for contrast optimization in MRI, J. Magn. Reson., 279 (2017), 39–50.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[18]: C. P. Koch, U. Boscain, T. Calarco, G. Dirr, S. Filipp, S. J. Glaser, R. Kosloff, S. Montangero, T. Schulte-Herbrüggen, D. Sugny & F. K. Wilhelm, Quantum optimal control in quantum technologies. strategic report on current status, visions and goals for research in europe, EPJ Quantum Technology, 9 (2022), p. 60.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"[19]: Bonnard, B.; Cots, O.; Rouot, J.; Verron, T. Time minimal saturation of a pair of spins and application in magnetic resonance imaging. Mathematical Control and Related Fields, 2020, 10 (1), pp.47-88. https://inria.hal.science/hal-01779377","category":"page"},{"location":"application-mri-saturation.html#The-Bloch-equation","page":"The saturation problem in Magnetic Resonance Imaging","title":"The Bloch equation","text":"","category":"section"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"<img src=\"./mri-resources/bloch.jpeg\" style=\"float: left; margin: auto 10px;\" width=\"200px\">","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"The mathematical model which is suitable for analyzing such problems is to consider an  ensemble of spins, each spin being described by a magnetization vector M = (M_X M_Y M_Z)  in the laboratory frame 0XYZ whose evolution satisfies the so-called Bloch equation","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    dotM(tau) = bargamma M(tau) wedge B(tau) + R(M(tau))","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"where tau is the time, bargamma is the gyromagnetic ratio of the considered nucleus,  B(tau) = (B_X(tau) B_Y(tau) B_Z(tau)) is the total magnetic field applied to the  system which decomposes into","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    B(tau) = B_0 + B_1(tau)","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"where B_0 = B_Z e_Z is a constant and strong polarizing field in the Z-direction, while the control RF-field B_1(tau) = B_X(tau) e_X + B_Y(tau) e_Y is in the  transverse plane (XY). The vectors e_X, e_Y and e_Z form the standard basis of  R^3. The R(M) term represents the dissipation and is of the form:","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    R(M) = left( -fracM_XT_2 -fracM_YT_2 -frac(M_Z-M_0)T_1 right)","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"where M_0 is the equilibrium magnetization, and T_1, T_2 are the relaxation times  which are the chemical signatures of the observed species and satisfy the physical constraints  0  T_2 le 2 T_1. The control is denoted omega(tau) = (omega_X(tau)omega_Y(tau)) coloneqq (-bargamma  B_X(tau) -bargamma B_Y(tau)), and is bounded by  omega_mathrmmax, ie. Vertomega(tau)Vertle omega_mathrmmax, where omega_mathrmmax is the maximal experimental intensity of the experiments and  VertcdotVert is the Euclidean norm.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"The Bloch equation can be written in a rotating frame 0xyz where the equilibrium is  normalized introducing the state q=(xyz), the matrices","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    Omega_z =\n    beginbmatrix\n        0  -1  0 \n        1  0  0 \n        0  0  0\n    endbmatrix","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"and S(tau) = exp(tau  baromega  Omega_z), and writting  M(tau) = M_0 S(tau) q(tau). In the rotating frame the Bloch equation becomes:","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    dotq(tau) = \n    beginbmatrix\n        -1T_2    -Deltaomega      omega_y \n        Deltaomega     -1T_2    -omega_x \n        -omega_y         omega_x          -1T_1 \n    endbmatrix q(tau) + \n    beginbmatrix\n        0  0  1T_1\n    endbmatrix","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"where Delta omega = omega_0 - baromega is the resonance offset,  omega_0 = -bargamma B_Z is the resonance frequency and the new control is","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    beginaligned\n        omega_x(tau) coloneqq omega_X(tau) cos(baromega tau) + \n        omega_Y(tau) sin(baromega tau) \n        omega_y(tau) coloneqq omega_Y(tau) cos(baromega tau) - \n        omega_X(tau) sin(baromega tau)\n    endaligned","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"which preserves the control bound omega_x^2(tau) + omega_y^2(tau) le omega_mathrmmax.  Finally, we introduce the normalized control and time:","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    u coloneqq fracu_mathrmmaxomega_mathrmmax omega \n    quad t coloneqq fracomega_mathrmmaxu_mathrmmax tau","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"such that the normalized control satisfies Vertu(t)Vertle u_mathrmmax.  In the sequel, we fix baromega = omega_0 which gives Delta omega = 0 (it is called the resonant case) and which leads to the final normalized Bloch equation:","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    left \n        beginaligned\n            dotx(t)  = displaystyle -Gamma x(t) + u_2(t) z(t) 02em\n            doty(t)  = displaystyle -Gamma y(t) - u_1(t) z(t) 02em\n            dotz(t)  = displaystyle gamma(1-z(t)) + u_1(t) y(t) - u_2(t) x(t)\n        endaligned\n    right","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"where","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    gamma coloneqq fracu_mathrmmaxw_mathrmmax T_1 quad \n    Gamma coloneqq fracu_mathrmmaxw_mathrmmax T_2\n    quad 0  gamma le 2Gamma","category":"page"},{"location":"application-mri-saturation.html#Time-parameterization","page":"The saturation problem in Magnetic Resonance Imaging","title":"Time parameterization","text":"","category":"section"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"In this setting, the normalized Bloch equation has 3 positive parameters: gamma, Gamma and  u_mathrmmax. However, one may choose one parameter to fix since for any lambda  0 and  any triplet (gamma Gamma u_mathrmmax), both systems in coordinates (x y z) with parameters (gamma Gamma u_mathrmmax) or  (lambdagamma lambdaGamma lambda u_mathrmmax) are equivalent, up to a time  reparameterization.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Note that for the constant control u(cdot) =(u_mathrmmax0), starting from x=0 and  denoting q = (yz), the Bloch equation becomes to","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    dotx(t) = -Gamma x(t) quad\n    dotq(t) = u_mathrmmax \n    beginpmatrix\n        0  -1 \n        1  0\n    endpmatrix\n    q(t)","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"and the solution is given by x(t) = 0, q(t) = R(u_mathrmmax t)  q(0) where  R(theta) is the rotation matrix of angle theta. Thus, this trajectory is periodic of  period T given by:","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    T = frac2 piu_mathrmmax","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Classically, one may fix the period to T=1 and so u_mathrmmax = 2 pi, or on the contrary  one may fix u_mathrmmax = 1 and choose T = 2 pi. From now, we choose to fix  u_mathrmmax = 1.","category":"page"},{"location":"application-mri-saturation.html#Spherical-coordinates","page":"The saturation problem in Magnetic Resonance Imaging","title":"Spherical coordinates","text":"","category":"section"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"The Bloch equation in the spherical coordinates","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    beginaligned\n        x = rho sinphi costheta quad 01em\n        y = rho sinphi sintheta quad 01em\n        z = rho cosphi\n    endaligned","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"with the feedback u = R(theta)^-1 v becomes:","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    left \n        beginaligned\n            dotrho(t)   = gamma cos phi(t) (1 - rho(t) cos phi(t)) - Gamma rho(t) sin^2 phi(t) 00em\n            dotphi(t)   = delta sin phi(t) cos phi(t) - fracgammarho(t) sin phi(t) + v_2(t) 00em\n            dottheta(t) = - cot phi(t) v_1(t)\n        endaligned\n    right","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"where delta coloneqq gamma - Gamma and with the control constraint  v_1^2 + v_2^2 = u_1^2 + u_2^2 le 1.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"<article class=\"docstring\">\n<header>\n    <a class=\"docstring-article-toggle-button fa-solid fa-chevron-right\" href=\"javascript:;\" title=\"Expand docstring\"> </a>\n    <span class=\"docstring-category\">Details.</span>\n</header>\n<section style=\"display: none;\">\n    <div><p>Inverting the spherical change of coordinates, we get</p>\n\n<p class=\"math-container\"><span><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>ρ</mi><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup><mo separator=\"true\">,</mo><mspace width=\"1em\"></mspace><mi>θ</mi><mo>=</mo><mi>arctan</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>y</mi><mi mathvariant=\"normal\">/</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mspace width=\"1em\"></mspace><mi>ϕ</mi><mo>=</mo><mi>arccos</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>z</mi><mi mathvariant=\"normal\">/</mi><mi>ρ</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">    \\rho^2  = x^2 + y^2 + z^2,  \\quad %\\\\[0.1em]\n    \\theta  = \\arctan(y/x),     \\quad %\\\\[0.1em]\n    \\phi    = \\arccos(z/\\rho).</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0585em; vertical-align: -0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">ρ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8641em;\"><span class=\"\" style=\"top: -3.113em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.9474em; vertical-align: -0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8641em;\"><span class=\"\" style=\"top: -3.113em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0585em; vertical-align: -0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8641em;\"><span class=\"\" style=\"top: -3.113em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0585em; vertical-align: -0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.044em;\">z</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8641em;\"><span class=\"\" style=\"top: -3.113em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 1em;\"></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">θ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mop\">arctan</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">y</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 1em;\"></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mop\">arccos</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.044em;\">z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">ρ</span><span class=\"mclose\">)</span><span class=\"mord\">.</span></span></span></span></span></span></p>\n\n<p>To get the dynamics with the new coordinates, we use the following procedure: let us assume  that we have a multi-inputs affine control system of the form  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>q</mi><mo>˙</mo></mover><mo>=</mo><mi>X</mi><mo stretchy=\"false\">(</mo><mi>q</mi><mo stretchy=\"false\">)</mo><mo>+</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><msub><mi>u</mi><mi>i</mi></msub><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>q</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\dot{q} = X(q) + \\sum_{i=1}^{m} u_i Y_i(q)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8623em; vertical-align: -0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6679em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.0556em;\"><span class=\"mord\">˙</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1944em;\"><span class=\"\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.104em; vertical-align: -0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position: relative; top: 0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8043em;\"><span class=\"\" style=\"top: -2.4003em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span class=\"\" style=\"top: -3.2029em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.2997em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3117em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.2222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3117em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.2222em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"mclose\">)</span></span></span></span></span></span>, where <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span></span></span></span></span></span>, <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>Y</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">Y_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8333em; vertical-align: -0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.2222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.2222em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span></span></span></span></span></span>, ..., <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>Y</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">Y_m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8333em; vertical-align: -0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.2222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1514em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.2222em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span></span></span></span></span></span> are vector fields. Considering that we are working in local coordinates, we can define the matrix  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi><mo stretchy=\"false\">(</mo><mi>q</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">[</mo><msub><mi>Y</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mi>q</mi><mo stretchy=\"false\">)</mo><mo>⋯</mo><msub><mi>Y</mi><mi>m</mi></msub><mo stretchy=\"false\">(</mo><mi>q</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo><mo>∈</mo><msup><mi mathvariant=\"double-struck\">R</mi><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">Y(q) = [Y_1(q) \\cdots Y_m(q)] \\in \\R^{n\\times m}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.2222em;\">Y</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.2222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.2222em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.2222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1514em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.2222em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"mclose\">)]</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7713em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">×</span><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, where <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span></span> is the dimension of the state  space and <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span></span> the dimension of the control space. Let <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi><mspace></mspace><mspace width=\"0.1111em\"></mspace><mo lspace=\"0em\" rspace=\"0.17em\"></mo> ⁣<mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333em\"></mspace><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup><mo>→</mo><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\varphi\\colon \\R^n \\to \\R^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8833em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right: 0.1111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right: -0.1667em;\"></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right: 0.3333em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span></span> be a  diffeomorphism and <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>q</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">q'</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.9463em; vertical-align: -0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span> the new coordinates given by <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>q</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>=</mo><mi>φ</mi><mo stretchy=\"false\">(</mo><mi>q</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">q' = \\varphi(q)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.9463em; vertical-align: -0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"mclose\">)</span></span></span></span></span></span>. The dynamics in the new  coordinates with the affine feedback <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo>=</mo><mi>A</mi><mo stretchy=\"false\">(</mo><mi>q</mi><mo stretchy=\"false\">)</mo> <mi>v</mi><mo>+</mo><mi>b</mi><mo stretchy=\"false\">(</mo><mi>q</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u = A(q)\\, v + b(q)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"mclose\">)</span></span></span></span></span></span>, <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">(</mo><mi>q</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><msup><mi mathvariant=\"double-struck\">R</mi><mrow><mi>m</mi><mtext>&nbsp;</mtext><mo>×</mo><mi>m</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">A(q) \\in \\R^{m&nbsp;\\times m}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7713em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mord mtight\">&nbsp;</span><span class=\"mbin mtight\">×</span><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span></span></span></span></span></span></span>  invertible, <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo stretchy=\"false\">(</mo><mi>q</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><mtext>&nbsp;</mtext><msup><mi mathvariant=\"double-struck\">R</mi><mi>m</mi></msup></mrow><annotation encoding=\"application/x-tex\">b(q) \\in&nbsp;\\R^m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6889em;\"></span><span class=\"mord\">&nbsp;</span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span></span></span></span></span></span>, is given by the new vector fields</p>\n\n<p class=\"math-container\"><span><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.25em\" columnalign=\"right left\" columnspacing=\"0em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><msup><mi>X</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><msub><mi>φ</mi><mo>∗</mo></msub><mi>X</mi><mo>+</mo><mo stretchy=\"false\">(</mo><msub><mi>φ</mi><mo>∗</mo></msub><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>⋅</mo><mo stretchy=\"false\">(</mo><mi>b</mi><mo>∘</mo><msup><mi>φ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><msup><mi>Y</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mi>φ</mi><mo>∗</mo></msub><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>⋅</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo>∘</mo><msup><mi>φ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding=\"application/x-tex\">    \\left\\{\n    \\begin{aligned}\n        X' &amp;= \\varphi_* X + (\\varphi_* Y) \\cdot (b \\circ \\varphi^{-1}), \\\\[0.2em]\n        Y' &amp;= (\\varphi_* Y)\\cdot (A\\circ \\varphi^{-1}),\n    \\end{aligned}\n    \\right.</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 3.2482em; vertical-align: -1.3741em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top: 0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 1.8741em;\"><span class=\"\" style=\"top: -4.01em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8019em;\"><span class=\"\" style=\"top: -3.113em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span><span class=\"\" style=\"top: -2.2859em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.2222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8019em;\"><span class=\"\" style=\"top: -3.113em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 1.3741em;\"><span class=\"\"></span></span></span></span></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 1.8741em;\"><span class=\"\" style=\"top: -4.01em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">φ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1757em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">φ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1757em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right: 0.2222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">φ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8641em;\"><span class=\"\" style=\"top: -3.113em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span></span></span><span class=\"\" style=\"top: -2.2859em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">φ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1757em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right: 0.2222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">φ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8641em;\"><span class=\"\" style=\"top: -3.113em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 1.3741em;\"><span class=\"\"></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></span></p>\n\n    <p>where <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>φ</mi><mo>∗</mo></msub><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">\\varphi_* X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8778em; vertical-align: -0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">φ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1757em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span></span></span></span></span></span> is the image (or push-forward) of <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span></span></span></span></span></span> by <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">\\varphi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.625em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span></span></span> defined by <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>φ</mi><mo>∗</mo></msub><mi>X</mi><mo stretchy=\"false\">(</mo><msup><mi>q</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo><mo>=</mo><mi mathvariant=\"normal\">d</mi><mi>φ</mi><mo stretchy=\"false\">(</mo><msup><mi>φ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><msup><mi>q</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>⋅</mo><mi>X</mi><mo stretchy=\"false\">(</mo><msup><mi>φ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><msup><mi>q</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\varphi_* X (q') = \\mathrm{d} \\varphi (\\varphi^{-1}(q')) \\cdot X(\\varphi^{-1}(q'))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0019em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">φ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1757em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathrm\">d</span><span class=\"mord mathnormal\">φ</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">φ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">φ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">))</span></span></span></span></span></span> and  we define in a similar way  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>φ</mi><mo>∗</mo></msub><mi>Y</mi><mo stretchy=\"false\">(</mo><msup><mi>q</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">[</mo><msub><mi>φ</mi><mo>∗</mo></msub><msub><mi>Y</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><msup><mi>q</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo><mo>⋯</mo><msub><mi>φ</mi><mo>∗</mo></msub><msub><mi>Y</mi><mi>m</mi></msub><mo stretchy=\"false\">(</mo><msup><mi>q</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo><mo>∈</mo><msup><mi mathvariant=\"double-struck\">R</mi><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\varphi_* Y (q') = [\\varphi_* Y_1(q') \\cdots \\varphi_* Y_m(q') ] \\in \\R^{n\\times m}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0019em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">φ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1757em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right: 0.2222em;\">Y</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0019em; vertical-align: -0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\">φ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1757em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.2222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.2222em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">φ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1757em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.2222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1514em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.2222em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)]</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7713em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">×</span><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span></span></span></span></span></span></span>. </p>\n    </div>\n</section>\n</article>","category":"page"},{"location":"application-mri-saturation.html#The-Bloch-ball","page":"The saturation problem in Magnetic Resonance Imaging","title":"The Bloch ball","text":"","category":"section"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Definition. The closed unit ball is called the Bloch Ball.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Proposition. The Bloch ball is invariant under the Bloch equations if and  only if 0 le gamma le 2 Gamma and it is the smallest invariant closed ball centered at  the origin if and only if 0  gamma le 2 Gamma.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"<article class=\"docstring\">\n<header>\n    <a class=\"docstring-article-toggle-button fa-solid fa-chevron-right\" href=\"javascript:;\" title=\"Expand docstring\"> </a>\n    <span class=\"docstring-category\">Proof.</span>\n</header>\n<section style=\"display: none;\">\n    <div>\n<p>Consider the Bloch equations in spherical coordinates. We want to prove first that  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>ρ</mi><mo>˙</mo></mover><mo>≤</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\dot{\\rho} \\le 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8623em; vertical-align: -0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6679em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\">ρ</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.0556em;\"><span class=\"mord\">˙</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1944em;\"><span class=\"\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span> for every point on the sphere, ie. such that <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\rho = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.625em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">ρ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></span>. On such points  we have:</p>\n\n<p class=\"math-container\"><span><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mover accent=\"true\"><mi>ρ</mi><mo>˙</mo></mover><mo>=</mo><mo>−</mo><mi>δ</mi><msup><mrow><mi>cos</mi><mo>⁡</mo></mrow><mn>2</mn></msup><mi>ϕ</mi><mo>+</mo><mi>γ</mi><mi>cos</mi><mo>⁡</mo><mi>ϕ</mi><mo>−</mo><mi mathvariant=\"normal\">Γ</mi><mo>=</mo><mo>−</mo><mi>δ</mi><msup><mi>X</mi><mn>2</mn></msup><mo>+</mo><mi>γ</mi><mi>X</mi><mo>−</mo><mi mathvariant=\"normal\">Γ</mi><mo>=</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mspace width=\"1em\"></mspace><mi>X</mi><mo>=</mo><mi>cos</mi><mo>⁡</mo><mi>ϕ</mi><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">    \\dot{\\rho} = -\\delta \\cos^2 \\phi + \\gamma \\cos \\phi - \\Gamma = \n    -\\delta X^2 + \\gamma X - \\Gamma = P(X), \\quad X = \\cos \\phi.</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8623em; vertical-align: -0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6679em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\">ρ</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.0556em;\"><span class=\"mord\">˙</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1944em;\"><span class=\"\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0585em; vertical-align: -0.1944em;\"></span><span class=\"mord\">−</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0379em;\">δ</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mop\"><span class=\"mop\">cos</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8641em;\"><span class=\"\" style=\"top: -3.113em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0556em;\">γ</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mop\">cos</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.9474em; vertical-align: -0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0379em;\">δ</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8641em;\"><span class=\"\" style=\"top: -3.113em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.8778em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0556em;\">γ</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.1389em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 1em;\"></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"mop\">cos</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mord\">.</span></span></span></span></span></span></p>\n\n<p>This is a degree 2 polynomial vanishing at <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">X=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></span>, and its discriminant is <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi mathvariant=\"normal\">Γ</mi><mo>−</mo><mi>γ</mi><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mo>≥</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">(2\\Gamma - \\gamma)^2 \\ge 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2Γ</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0556em;\">γ</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span>, so <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.1389em;\">P</span></span></span></span></span></span> has at most another root <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>2</mn></msub><mo>=</mo><mi mathvariant=\"normal\">Γ</mi><mi mathvariant=\"normal\">/</mi><mi>δ</mi></mrow><annotation encoding=\"application/x-tex\">X_2 = {\\Gamma}/{\\delta}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8333em; vertical-align: -0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0785em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0379em;\">δ</span></span></span></span></span></span></span>. If <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>δ</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\delta &lt; 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7335em; vertical-align: -0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0379em;\">δ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span>, the polynomial function is negative between its roots, so <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.1389em;\">P</span></span></span></span></span></span> is  non-positive over <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[-1, 1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></span></span> if and only if <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>2</mn></msub><mo>≤</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">X_2 \\le -1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8333em; vertical-align: -0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0785em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7278em; vertical-align: -0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span></span></span>, that is: <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mi mathvariant=\"normal\">/</mi><mi>δ</mi><mo>≤</mo><mo>−</mo><mn>1</mn><mo>⇔</mo><mi>γ</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">{\\Gamma}/{\\delta} \\le -1 \\Leftrightarrow \\gamma \\ge 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0379em;\">δ</span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7278em; vertical-align: -0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">⇔</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.8304em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0556em;\">γ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span>. If <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>δ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\delta &gt; 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7335em; vertical-align: -0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0379em;\">δ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span>, we need to have <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>2</mn></msub><mo>≥</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">X_2 \\ge 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8333em; vertical-align: -0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0785em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0785em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></span>, that is <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mi mathvariant=\"normal\">/</mi><mi>δ</mi><mo>≥</mo><mn>1</mn><mo>⇔</mo><mi>γ</mi><mo>≤</mo><mn>2</mn><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">{\\Gamma}/{\\delta} \\ge 1 \\Leftrightarrow \\gamma \\le 2\\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0379em;\">δ</span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">⇔</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.8304em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0556em;\">γ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord\">2Γ</span></span></span></span></span></span>. If <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>δ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\delta = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0379em;\">δ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span> then <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.1389em;\">P</span></span></span></span></span></span> is non-positive over <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[-1, 1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></span></span> if and only if  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>γ</mi><mo>=</mo><mi mathvariant=\"normal\">Γ</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\gamma = \\Gamma \\ge 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.625em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0556em;\">γ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.8193em; vertical-align: -0.136em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span>.</p>\n\n<p>Hence, the Bloch ball is invariant under the Bloch equations if and only if  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>γ</mi><mo>≤</mo><mn>2</mn><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">0 \\le \\gamma \\le 2 \\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7804em; vertical-align: -0.136em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.8304em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0556em;\">γ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord\">2Γ</span></span></span></span></span></span> but it is the smallest invariant ball if and only if we also  have <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>γ</mi><mo mathvariant=\"normal\">≠</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\gamma \\ne 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0556em;\">γ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span> since if <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>γ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\gamma = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.625em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0556em;\">γ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span> then every ball centered at the origin is  invariant under the Bloch equations and finally if <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>γ</mi><mo>≤</mo><mn>2</mn><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">0 &lt; \\gamma \\le 2 \\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6835em; vertical-align: -0.0391em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.8304em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0556em;\">γ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord\">2Γ</span></span></span></span></span></span>, then the  dynamics given by the normalized Bloch equation with a zero control (ie. the free dynamics)  is linear, its equilibrium point is the North pole <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">N=(0,0,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.109em;\">N</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></span> and this equilibrium is  globally asymptotically stable so any trajectory solution of the free dynamics would leave  any ball centered at the origin strictly smaller than the unit ball. The result is proved.</p>\n    </div>\n</section>\n</article>","category":"page"},{"location":"application-mri-saturation.html#Symmetry-of-revolution-and-restriction-to-the-2D-case","page":"The saturation problem in Magnetic Resonance Imaging","title":"Symmetry of revolution and restriction to the 2D case","text":"","category":"section"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Considering the Bloch equations in spherical coordinates, one can see that theta does  not appear in the dynamics (it is a cyclic variable) so there exists a one dimensional  symmetry group of translations on theta. Hence, one may fix the initial value theta(0)  to pi2 for instance (it implies x(0) = 0). Finally, imposing theta(0) = pi2 and  u_2 = 0, then, one can reduce (since x(t)=0 for any time t) the Bloch equations to the following two dimensional single-input control system:","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    left \n        beginaligned\n            doty(t)  = displaystyle -Gamma y(t) - u(t) z(t)  02em\n            dotz(t)  = displaystyle gamma(1-z(t)) + u(t) y(t)\n        endaligned\n    right","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"where u coloneqq u_1 satisfies u(t) le 1.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"This control system is affine in the control and may be written in the form ","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    dotq(t) = F_0(q(t)) + u(t) F_1(q(t))","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"where q coloneqq (yz) is the state and where the vector fields F_0 and F_1 are given  by:","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    F_0(q)  = -Gamma y fracpartialpartial y + \n    gamma (1 - z) fracpartialpartial z quad\n    F_1(q)  = -z fracpartialpartial y + y fracpartialpartial z","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"The admissible control set mathcalU is then defined as","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    left\n        u(cdot) colon 0 infty) to -1 1  u(cdot) text measurable\n    right","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"<article class=\"docstring\">\n<header>\n    <a class=\"docstring-article-toggle-button fa-solid fa-chevron-right\" href=\"javascript:;\" title=\"Expand docstring\"> </a>\n    <span class=\"docstring-category\">Restriction to the 2D case for the time-optimal saturation problem</span>\n</header>\n<section style=\"display: none;\">\n    <div>\n<p>Let us consider the Bloch equations in spherical coordinates and take an initial point  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>ρ</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>ϕ</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>θ</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\rho_0, \\phi_0, \\theta_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">ρ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">ϕ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">θ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></span> in the Bloch ball. Let <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\bar{v}(\\cdot) = (\\bar{v}_1(\\cdot), \\bar{v}_2(\\cdot))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">))</span></span></span></span></span></span> denotes an optimal control which steers  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>ρ</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>ϕ</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>θ</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\rho_0, \\phi_0, \\theta_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">ρ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">ϕ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">θ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></span> to the target <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\rho = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.625em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">ρ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span> in time <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mover accent=\"true\"><mi>t</mi><mo>ˉ</mo></mover><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\bar{t}_f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.038em; vertical-align: -0.2861em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\">t</span></span><span class=\"\" style=\"top: -3.1841em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3361em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right: 0.1076em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.2861em;\"><span class=\"\"></span></span></span></span></span></span></span></span></span></span></span>. The control law satisfies <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mn>1</mn><mn>2</mn></msubsup><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo><mo>+</mo><msubsup><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mn>2</mn><mn>2</mn></msubsup><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo><mo>≤</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\bar{v}_1^2(t) + \\bar{v}_2^2(t) \\le 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span class=\"\" style=\"top: -2.4519em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.2481em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span class=\"\" style=\"top: -2.4519em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.2481em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></span> for all  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>∈</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><msub><mover accent=\"true\"><mi>t</mi><mo>ˉ</mo></mover><mi>f</mi></msub><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">t \\in [0, \\bar{t}_f]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6542em; vertical-align: -0.0391em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.038em; vertical-align: -0.2861em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\">t</span></span><span class=\"\" style=\"top: -3.1841em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3361em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right: 0.1076em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.2861em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span></span></span>. Since <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>θ</mi></mrow><annotation encoding=\"application/x-tex\">\\theta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">θ</span></span></span></span></span></span> is a cyclic variable and since the component <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.5806em; vertical-align: -0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span></span></span></span></span></span>  appears only in the <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>θ</mi></mrow><annotation encoding=\"application/x-tex\">\\theta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">θ</span></span></span></span></span></span> dynamics, then, one can define the control law  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>v</mi><mo>∗</mo></msup><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><msub><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v^*(\\cdot) = (0, \\bar{v}_2(\\cdot))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6887em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">))</span></span></span></span></span></span> which satisfies the constraint and also steers the system  from the initial point <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>ρ</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>ϕ</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>θ</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\rho_0, \\phi_0, \\theta_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">ρ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">ϕ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">θ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></span> to the target <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\rho = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.625em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">ρ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span> in the same time <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mover accent=\"true\"><mi>t</mi><mo>ˉ</mo></mover><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\bar{t}_f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.038em; vertical-align: -0.2861em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\">t</span></span><span class=\"\" style=\"top: -3.1841em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3361em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right: 0.1076em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.2861em;\"><span class=\"\"></span></span></span></span></span></span></span></span></span></span></span>, and thus, the control <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>v</mi><mo>∗</mo></msup><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v^*(\\cdot)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6887em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span></span></span></span></span></span> is also optimal.</p>\n\n<p>On the contrary, let us consider an optimal control of the form <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><msub><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\bar{v}(\\cdot) = (0, \\bar{v}_2(\\cdot))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">))</span></span></span></span></span></span> with <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mover accent=\"true\"><mi>t</mi><mo>ˉ</mo></mover><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\bar{t}_f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.038em; vertical-align: -0.2861em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\">t</span></span><span class=\"\" style=\"top: -3.1841em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3361em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right: 0.1076em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.2861em;\"><span class=\"\"></span></span></span></span></span></span></span></span></span></span></span> the optimal time. If there exists times  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>t</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>t</mi><mn>2</mn></msub><mo>≤</mo><msub><mover accent=\"true\"><mi>t</mi><mo>ˉ</mo></mover><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">0 \\le t_1 &lt; t_2 \\le \\bar{t}_f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7804em; vertical-align: -0.136em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7651em; vertical-align: -0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.786em; vertical-align: -0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.038em; vertical-align: -0.2861em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\">t</span></span><span class=\"\" style=\"top: -3.1841em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3361em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right: 0.1076em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.2861em;\"><span class=\"\"></span></span></span></span></span></span></span></span></span></span></span> such that <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>t</mi><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\bar{v}_2(t)^2 &lt; 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></span> on <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[t_1, t_2]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span></span></span>, then clearly,  one can define a new control <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>v</mi><mo>∗</mo></msup><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><msubsup><mi>v</mi><mn>1</mn><mo>∗</mo></msubsup><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v^*(\\cdot) = (v_1^*(\\cdot), \\bar{v}_2(\\cdot))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6887em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6887em;\"><span class=\"\" style=\"top: -2.4519em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.2481em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">))</span></span></span></span></span></span> such that <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>v</mi><mn>1</mn><mo>∗</mo></msubsup><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo mathvariant=\"normal\">≠</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">v_1^*(\\cdot) \\ne 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6887em;\"><span class=\"\" style=\"top: -2.4519em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.2481em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span> on <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[t_1, t_2]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span></span></span>, which satisfies the control constraint over  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><msub><mover accent=\"true\"><mi>t</mi><mo>ˉ</mo></mover><mi>f</mi></msub><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0, \\bar{t}_f]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.038em; vertical-align: -0.2861em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\">t</span></span><span class=\"\" style=\"top: -3.1841em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3361em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right: 0.1076em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.2861em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span></span></span>, and again this control <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>v</mi><mo>∗</mo></msup><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v^*(\\cdot)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6887em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span></span></span></span></span></span> steers the system to <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\rho=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.625em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">ρ</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span> in time  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mover accent=\"true\"><mi>t</mi><mo>ˉ</mo></mover><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\bar{t}_f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.038em; vertical-align: -0.2861em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\">t</span></span><span class=\"\" style=\"top: -3.1841em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3361em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right: 0.1076em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.2861em;\"><span class=\"\"></span></span></span></span></span></span></span></span></span></span></span> and thus is optimal.</p>\n\n<p>As a conclusion, if there exists an optimal control  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\bar{v}(\\cdot) = (\\bar{v}_1(\\cdot), \\bar{v}_2(\\cdot))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">))</span></span></span></span></span></span>, then there exists one of the form <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>v</mi><mo>∗</mo></msup><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><msub><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v^*(\\cdot) = (0, \\bar{v}_2(\\cdot))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6887em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">))</span></span></span></span></span></span>. Besides, if there exists an optimal control of the form  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><msub><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\bar{v}(\\cdot) = (0, \\bar{v}_2(\\cdot))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">))</span></span></span></span></span></span> such that <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mo>⋅</mo><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mo mathvariant=\"normal\">≠</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\bar{v}_2(\\cdot)^2 \\ne 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></span>, then there exist  optimal controls of the form <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>v</mi><mo>∗</mo></msup><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><msubsup><mi>v</mi><mn>1</mn><mo>∗</mo></msubsup><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v^*(\\cdot) = (v_1^*(\\cdot), \\bar{v}_2(\\cdot))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6887em;\"><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6887em;\"><span class=\"\" style=\"top: -2.4519em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.2481em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">))</span></span></span></span></span></span> with  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>v</mi><mn>1</mn><mo>∗</mo></msubsup><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo mathvariant=\"normal\">≠</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">v_1^*(\\cdot) \\ne 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6887em;\"><span class=\"\" style=\"top: -2.4519em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span class=\"\" style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.2481em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span>. In any case, it is reasonable to consider only the optimal controls of  the form <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><msub><mover accent=\"true\"><mi>v</mi><mo>ˉ</mo></mover><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\bar{v}(\\cdot) = (0, \\bar{v}_2(\\cdot))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5678em;\"><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span></span><span class=\"\" style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"accent-body\" style=\"left: -0.2222em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">))</span></span></span></span></span></span>.</p>\n\n<p>Besides, since <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>θ</mi></mrow><annotation encoding=\"application/x-tex\">\\theta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">θ</span></span></span></span></span></span> is a cyclic variable, one can fix <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub><mo>=</mo><mi>π</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\theta_0 = \\pi/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8444em; vertical-align: -0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">θ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0278em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">π</span><span class=\"mord\">/2</span></span></span></span></span></span> and in the case  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">v_1(\\cdot) = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span> and <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>θ</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mi>π</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\theta(0) = \\pi/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">θ</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">π</span><span class=\"mord\">/2</span></span></span></span></span></span>, we have <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>θ</mi><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\theta(\\cdot) = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0278em;\">θ</span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span> and  <span><span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>u</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mo>⋅</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">v_1(\\cdot) =  u_2(\\cdot) = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.3011em;\"><span class=\"\" style=\"top: -2.55em; margin-left: 0em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.15em;\"><span class=\"\"></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">⋅</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></span>.</p>\n    </div>\n</section>\n</article>","category":"page"},{"location":"application-mri-saturation.html#The-time-optimal-saturation-problem","page":"The saturation problem in Magnetic Resonance Imaging","title":"The time-optimal saturation problem","text":"","category":"section"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"The time-optimal saturation problem is the following: starting from a given point in the  Bloch ball, the goal is to reach in minimum time the center of the Bloch ball, which  corresponds at the final time to zero magnetization of the spin.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"note: Time-optimal saturation problem\nWe define the time-optimal saturation problem as the following optimal control  problem:    inf t_f \n    quad textst quad u(cdot) in mathcalU quad \n    t_f ge 0 quad textand quad q(t_f N u(cdot)) = Owhere N = (0 1) is the North pole, where O = (00) is the origin of the Bloch  ball and where t mapsto q(t q_0 u(cdot))  is the unique maximal solution of the 2D control system dotq = F_0(q) + u F_1(q)  associated to the control u(cdot) and starting from the given initial condition q_0.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"The inversion sequence sigma_+ sigma_s^v, that is a positive bang arc followed by a singular vertical arc with zero control, is the simplest way to go from N to O.  Is it optimal?","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"<img src=\"./mri-resources/inversion_sequence.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"500px\">\n<br>","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"We have the following symmetry.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Proposition. Let (y(cdot) z(cdot)), with associated control u(cdot), be a  trajectory solution of dotq = F_0(q) + u F_1(q). Then, (-y(cdot) z(cdot)) with control -u(cdot) is also solution of this system.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"This discrete symmetry allows us to consider only trajectories inside the domain  y le 0 of the Bloch ball.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"In order to solve numerically the problem, we need to set the parameters.  We introduce the practical cases in the following table. We give the relaxation times with  the associated (gamma Gamma) parameters for omega_mathrmmax = 2 pitimes 323 Hz.  Note that in the experiments, omega_mathrmmax may be chosen up to 15 000 Hz but we  consider the same value as in [16].","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Name T_1 T_2 gamma Gamma delta=gamma-Gamma\nWater 2.5 2.5 19710e^-03 19710e^-03 00\nCerebrospinal Fluid 2.0 0.3 24637e^-03 16425e^-02 -13961^-02\nDeoxygenated blood 1.35 0.05 36499e^-03 98548e^-02 -94898^-02\nOxygenated blood 1.35 0.2 36499e^-03 24637e^-02 -20987^-02\nGray cerebral matter 0.92 0.1 53559e^-03 49274e^-02 -43918^-02\nWhite cerebral matter 0.78 0.09 63172e^-03 54749e^-02 -48432^-02\nFat 0.2 0.1 24637e^-02 49274e^-02 -24637^-02\nBrain 1.062 0.052 46397e^-03 94758e^-02 -90118^-02\nParietal muscle 1.2 0.029 41062e^-03 16991e^-01 -16580^-02","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Table: Matter name with associated relaxation times in seconds and relative (gamma Gamma) parameters with omega_mathrmmax = 2 pitimes 323 Hz and u_mathrmmax = 1.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"note: Deoxygenated blood case\nWe consider the Deoxygenated blood case.  According to Theorem 3.6 from [19] the optimal solution is of the form  Bang-Singular-Bang-Singular (BSBS). The two bang arcs are with control u=1.  The first singular arc is contained in the horizontal line z=gamma2delta while the second singular arc is contained in the vertical line y=0.  We propose in the following to retrieve this result numerically.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"using Suppressor # to suppress warnings","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Let us first define the parameters with the two vector fields F_0 and F_1.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"import OptimalControl: ⋅\n⋅(a::Number, b::Number) = a*b\n\n# Blood case\nT1 = 1.35 # s\nT2 = 0.05\n\nω = 2π⋅32.3 # Hz\nγ = 1/(ω⋅T1)\nΓ = 1/(ω⋅T2)\n\nδ = γ - Γ\nzs = γ / 2δ # singular ordinate of the horizontal singular line\n\nF0(y, z) = [ -Γ⋅y, γ⋅(1-z) ]\nF1(y, z) = [ -z, y ]\n\nq0 = [ 0, 1 ] # initial state\nnothing # hide","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Then, we can define the problem with the OptimalControl.jl package.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"using OptimalControl\n\n@def ocp begin\n\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    q = [ y, z ] ∈ R², state\n    u ∈ R, control\n\n    q(0)  == q0\n    q(tf) == [ 0, 0 ]\n\n    -1 ≤ u(t) ≤ 1\n\n    q̇(t) == F0(q(t)...) + u(t) * F1(q(t)...)\n\n    tf → min\n\n    tf ≥ 0\n\nend\nnothing # hide","category":"page"},{"location":"application-mri-saturation.html#Direct-method","page":"The saturation problem in Magnetic Resonance Imaging","title":"Direct method","text":"","category":"section"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"We start to solve the problem with a direct method. The problem is transcribed into a NLP  optimization problem thanks to the package OptimalControl.jl. The NLP problem is then solved by the well-known solver ipopt thanks to the package NLPModelsIpopt.jl.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"We first start with a coarse grid, with only 50 points. We provide an init to get a solution  in the domain y le 0.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"using NLPModelsIpopt\n\nN = 50\nsol = solve(ocp; grid_size=N, init=(state=[-0.5, 0.0], ), print_level=4)\nnothing # hide","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Then, we plot the solution thanks to Plots.jl.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"using Plots\n\nplt = plot(sol; size=(700, 500), solution_label=\"(N = \"*string(N)*\")\")","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"This rough approximation is then refine on a finer grid of 500 points. This two steps resolution increases the speed of convergence. Note that we provide the previous solution as initialisation.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"N = 500\ndirect_sol = solve(ocp; grid_size=N, init=sol, print_level=4, tol=1e-12)\nnothing # hide","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"We can compare both solutions. The BSBS is revelead even if second bang arc is not clearly  demonstrated.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"plot!(plt, direct_sol; solution_label=\"(N = \"*string(N)*\")\")","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"We define a custom plot function to plot the solution inside the Bloch ball.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"<article class=\"docstring\">\n<header>\n    <a class=\"docstring-article-toggle-button fa-solid fa-chevron-right\" href=\"javascript:;\" title=\"Expand docstring\"> </a>\n    <code>spin_plot</code> — <span class=\"docstring-category\">Function</span>\n</header>\n<section style=\"display: none;\">\n    <div>\n    <pre>\n    <code class=\"language-julia hljs\">using Plots.PlotMeasures\nusing CTFlows\nfunction spin_plot(sol; kwargs...)\n\n    if sol isa CTFlows.OptimalControlFlowSolution\n        sol = CTFlows.OptimalControlSolution(sol)\n    end\n\n    y2 = cos(asin(zs))\n    y1 = -y2\n\n    t = sol.times\n    y = t -> sol.state(t)[1]\n    z = t -> sol.state(t)[2]\n    u = sol.control\n\n    # styles\n    Bloch_ball_style = (seriestype=[:shape, ], color=:grey, linecolor=:black, \n        legend=false, fillalpha=0.1, aspect_ratio=1)\n    axis_style = (color=:black, linewidth=0.5)\n    state_style = (label=:none, linewidth=2, color=1)\n    initial_point_style = (seriestype=:scatter, color=:1, linewidth=0)\n    control_style = (label=:none, linewidth=2, color=1)\n\n    # state trajectory in the Bloch ball\n    θ = LinRange(0, 2π, 100)\n    state_plt = plot(cos.(θ), sin.(θ); Bloch_ball_style...) # Bloch ball\n    plot!(state_plt, [-1, 1], [ 0,  0]; axis_style...)      # horizontal axis \n    plot!(state_plt, [ 0, 0], [-1,  1]; axis_style...)      # vertical axis\n    plot!(state_plt, [y1, y2], [zs, zs]; linestyle=:dash, axis_style...) # singular line\n    plot!(state_plt, y.(t), z.(t); state_style...)\n    plot!(state_plt, [0], [1]; initial_point_style...)\n    plot!(state_plt; xlims=(-1.1, 0.1), ylims=(-0.1, 1.1), xlabel=\"y\", ylabel=\"z\")\n\n    # control\n    control_plt = plot(legend=false)\n    plot!(control_plt, [ 0, t[end]], [1,  1]; linestyle=:dash, axis_style...) # ub\n    plot!(control_plt, [ 0, t[end]], [0,  0]; linestyle=:dash, axis_style...)\n    plot!(control_plt, [ 0, 0], [-0.1,  1.1]; axis_style...)\n    plot!(control_plt, [ t[end], t[end]], [-0.1,  1.1]; axis_style...)\n    plot!(control_plt, t, u.(t); control_style...)\n    plot!(control_plt; ylims=(-0.1, 1.1), xlabel=\"t\", ylabel=\"u\")\n\n    return plot(state_plt, control_plt; layout=(1, 2), bottommargin=15px, kwargs...)\n\nend</code>\n    <button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code ;opblock\" title=\"Copy\"></button>\n    </pre>\n    </div>\n</section>\n</article>","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"using Plots.PlotMeasures # hide\nusing CTFlows # hide\nfunction spin_plot(sol; kwargs...) # hide\n\n    if sol isa CTFlows.OptimalControlFlowSolution # hide\n        sol = CTFlows.OptimalControlSolution(sol) # hide\n    end # hide\n\n    y2 = cos(asin(zs)) # hide\n    y1 = -y2 # hide\n\n    t = sol.times # hide\n    y = t -> sol.state(t)[1] # hide\n    z = t -> sol.state(t)[2] # hide\n    u = sol.control # hide\n\n    # styles # hide\n    Bloch_ball_style = (seriestype=[:shape, ], color=:grey, linecolor=:black,  # hide\n        legend=false, fillalpha=0.1, aspect_ratio=1) # hide\n    state_style = (label=:none, linewidth=2, color=1) # hide\n    initial_point_style = (seriestype=:scatter, color=:1, linewidth=0) # hide\n    axis_style = (color=:black, linewidth=0.5) # hide\n    control_style = (label=:none, linewidth=2, color=1) # hide\n\n    # state trajectory in the Bloch ball # hide\n    θ = LinRange(0, 2π, 100) # hide\n    state_plt = plot(cos.(θ), sin.(θ); Bloch_ball_style...) # Bloch ball # hide\n    plot!(state_plt, [-1, 1], [ 0,  0]; axis_style...)      # horizontal axis  # hide\n    plot!(state_plt, [ 0, 0], [-1,  1]; axis_style...)      # vertical axis # hide\n    plot!(state_plt, [y1, y2], [zs, zs]; linestyle=:dash, axis_style...) # singular line # hide\n    plot!(state_plt, y.(t), z.(t); state_style...) # hide\n    plot!(state_plt, [0], [1]; initial_point_style...) # hide\n    plot!(state_plt; xlims=(-1.1, 0.1), ylims=(-0.1, 1.1), xlabel=\"y\", ylabel=\"z\") # hide\n\n    # control # hide\n    control_plt = plot(legend=false) # hide\n    plot!(control_plt, [ 0, t[end]], [1,  1]; linestyle=:dash, axis_style...) # upper bound # hide\n    plot!(control_plt, [ 0, t[end]], [0,  0]; linestyle=:dash, axis_style...) # hide\n    plot!(control_plt, [ 0, 0], [-0.1,  1.1]; axis_style...) # hide\n    plot!(control_plt, [ t[end], t[end]], [-0.1,  1.1]; axis_style...) # hide\n    plot!(control_plt, t, u.(t); control_style...) # hide\n    plot!(control_plt; ylims=(-0.1, 1.1), xlabel=\"t\", ylabel=\"u\") # hide\n\n    return plot(state_plt, control_plt; layout=(1, 2), leftmargin=15px, bottommargin=15px, kwargs...) # hide\n\nend # hide\nnothing # hide","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"And then plot again the solution. We can see that the first bang arc permits to reach the  horizontal singular line z=gamma2delta which is depicted with a dashed line. The second  bang arc is very short which explains why it is not well captured. We should refine the  grid around this bang arc to capture it well.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"spin_plot(direct_sol; size=(700, 350))","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"We extract now the useful information from the direct solution to provide an initial guess for the indirect method in the following part. For instance, we need the initial costate  together with the switching times between bang and sinular arcs and the final time.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"t  = direct_sol.times\nq  = direct_sol.state\np  = direct_sol.costate\nu  = direct_sol.control\ntf = direct_sol.variable\n\nt0 = 0\npz0 = p(t0)[2]\n\nt_bang_1 = t[ (abs.(u.(t)) .≥ 0.25) .& (t .≤  5)]\nt_bang_2 = t[ (abs.(u.(t)) .≥ 0.25) .& (t .≥ 35)]\nt1 = max(t_bang_1...)\nt2 = min(t_bang_2...)\nt3 = max(t_bang_2...)\n\nq1, p1 = q(t1), p(t1)\nq2, p2 = q(t2), p(t2)\nq3, p3 = q(t3), p(t3)\n\nprintln(\"pz0 = \", pz0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)","category":"page"},{"location":"application-mri-saturation.html#Indirect-method","page":"The saturation problem in Magnetic Resonance Imaging","title":"Indirect method","text":"","category":"section"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"We introduce the pseudo-Hamiltonian","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"H(q p u) = H_0(q p) + u H_1(q p)","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"where H_0(q p) = p cdot F_0(q) and H_1(q p) = p cdot F_1(q) are both Hamiltonian lifts. According to the maximisation condition  from the Pontryagin Maximum Principle (PMP), a bang arc occurs when  H_1 is nonzero and of constant sign along the arc. On the contrary the singular arcs are contained in H_1 = 0. If  t mapsto H_1(q(t) p(t)) = 0 along an arc then its derivative is  also zero. Thus, along a singular arc we have also","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"fracmathrmdmathrmdt H_1(q(t) p(t)) = \nH_0 H_1(q(t) p(t)) = 0","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"where H_0 H_1 is the Poisson bracket of H_0 and H_1.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"note: Lie and Poisson brackets\nLet F_0, F_1 be two smooth vector fields on a smooth manifold M and f a  smooth function pn M. Let x be local coordinates. The Lie bracket of F_0  and F_1 is given by     F_0F_1 coloneqq  F_0 cdot F_1 - F_1 cdot F_0with (F_0 cdot F_1)(x) = mathrmd F_1(x) cdot F_0(x). The Lie derivative mathcalL_F_0 f of f along F_0 is simply written  F_0cdot f. Denoting H_0, H_1 the Hamiltonian lifts of F_0, F_1, then the  Poisson bracket of H_0 and H_1 is    H_0H_1  coloneqq  vecH_0 cdot H_1We also use the notation H_01 (resp. F_01) to write the bracket  H_0H_1 (resp. F_0F_1) and so forth. Besides, since H_0, H_1  are Hamiltonian lifts, we have H_0H_1= p cdot F_0F_1.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"We define next a function to plot the switching function t mapsto H_1(q(t) p(t))  and its derivative along the solution computed by the direct method.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"<article class=\"docstring\">\n<header>\n    <a class=\"docstring-article-toggle-button fa-solid fa-chevron-right\" href=\"javascript:;\" title=\"Expand docstring\"> </a>\n    <code>switching_plot</code> — <span class=\"docstring-category\">Function</span>\n</header>\n<section style=\"display: none;\">\n    <div>\n    <pre>\n    <code class=\"language-julia hljs\">function switching_plot(sol, H1, H01; kwargs...)\n\n    if sol isa CTFlows.OptimalControlFlowSolution\n        sol = CTFlows.OptimalControlSolution(sol)\n    end\n\n    t  = sol.times\n    u  = sol.control\n    q  = sol.state\n    p  = sol.costate\n    tf = t[end]\n    φ(t) = H1(q(t), p(t))       # switching function\n    dφ(t) = H01(q(t), p(t))     # derivative of the switching function\n\n    # styles\n    axis_style = (color=:black, linewidth=0.5, label=false)\n    control_style = (label=:none, linewidth=2, color=1)\n\n    # switching function\n    switching_plt = plot()\n    plot!(switching_plt, [0, tf], [0, 0]; axis_style...)\n    plot!(switching_plt, t, φ, label=\"H1(q(t), p(t))\", xlabel=\"t\", linewidth=2)\n    plot!(switching_plt; xlims=(0, tf))\n\n    # derivative of the switching function\n    dswitching_plt = plot()\n    plot!(dswitching_plt, [0, tf], [0, 0]; axis_style...)\n    plot!(dswitching_plt, t, dφ, label=\"H01(q(t), p(t))\", xlabel=\"t\", linewidth=2)\n    plot!(dswitching_plt; xlims=(0, tf))\n\n    # control\n    control_plt = plot(legend=false)\n    plot!(control_plt, [ 0, t[end]], [1,  1]; linestyle=:dash, axis_style...) # upper bound \n    plot!(control_plt, [ 0, t[end]], [0,  0]; linestyle=:dash, axis_style...)\n    plot!(control_plt, [ 0, 0], [-0.1,  1.1]; axis_style...)\n    plot!(control_plt, [ t[end], t[end]], [-0.1,  1.1]; axis_style...)\n    plot!(control_plt, t, u.(t); control_style...)\n    plot!(control_plt; ylims=(-0.1, 1.1), xlabel=\"t\", ylabel=\"u\")\n\n    return plot(switching_plt, dswitching_plt, control_plt; layout=(3, 1), kwargs...)\nend</code>\n    <button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code ;opblock\" title=\"Copy\"></button>\n    </pre>\n    </div>\n</section>\n</article>","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"We can notice on the plots below that maximisation condition from the PMP is not  satisfied. We can see that the switching function becomes negative along the first  bang arc but there is no switching from the control plot. Besides, we can see that along the first singular arc, the switching function is not always zero.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"function switching_plot(sol, H1, H01; kwargs...) # hide\n\n    if sol isa CTFlows.OptimalControlFlowSolution # hide\n        sol = CTFlows.OptimalControlSolution(sol) # hide\n    end # hide\n\n    t  = sol.times  # hide\n    u  = sol.control # hide\n    q  = sol.state # hide\n    p  = sol.costate # hide\n    tf = t[end] # hide\n    φ(t) = H1(q(t), p(t))       # switching function # hide\n    dφ(t) = H01(q(t), p(t))     # derivative of the switching function # hide\n\n    # styles  # hide\n    axis_style = (color=:black, linewidth=0.5, label=false) # hide\n    control_style = (label=:none, linewidth=2, color=1) # hide\n\n    # switching function  # hide\n    switching_plt = plot() # hide\n    plot!(switching_plt, [0, tf], [0, 0]; axis_style...) # hide\n    plot!(switching_plt, t, φ, label=\"H1(q(t), p(t))\", xlabel=\"t\", linewidth=2) # hide\n    plot!(switching_plt; xlims=(0, tf)) # hide\n\n    # derivative of the switching function  # hide\n    dswitching_plt = plot() # hide\n    plot!(dswitching_plt, [0, tf], [0, 0]; axis_style...) # hide\n    plot!(dswitching_plt, t, dφ, label=\"H01(q(t), p(t))\", xlabel=\"t\", linewidth=2) # hide\n    plot!(dswitching_plt; xlims=(0, tf)) # hide\n\n    # control  # hide\n    control_plt = plot(legend=false) # hide\n    plot!(control_plt, [ 0, t[end]], [1,  1]; linestyle=:dash, axis_style...) # upper bound  # hide\n    plot!(control_plt, [ 0, t[end]], [0,  0]; linestyle=:dash, axis_style...) # hide\n    plot!(control_plt, [ 0, 0], [-0.1,  1.1]; axis_style...) # hide\n    plot!(control_plt, [ t[end], t[end]], [-0.1,  1.1]; axis_style...) # hide\n    plot!(control_plt, t, u.(t); control_style...) # hide\n    plot!(control_plt; ylims=(-0.1, 1.1), xlabel=\"t\", ylabel=\"u\") # hide\n\n    return plot(switching_plt, dswitching_plt, control_plt; layout=(3, 1), kwargs...) # hide\nend # hide\nnothing # hide","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"H0 = Lift(q -> F0(q...))\nH1 = Lift(q -> F1(q...))\nH01  = @Lie { H0, H1 }\n\nswitching_plot(direct_sol, H1, H01; size=(700, 900))","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"We aim to compute a better approximation of the solution thanks to indirect shooting. To do so, we need to define the three different flows associated to the three different  control laws in feedback form: bang control, singular control along the horizontal line and singular control along the vertical line. ","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"note: Note\nLet us recall that delta = gamma - Gamma. Then, for any q = (yz) we have:    beginaligned\n        F_01(q) = \n        -(gamma - delta z) fracpartialpartial y + \n        delta y fracpartialpartial z 05em\n        F_001(q) = \n        left( gamma (gamma - 2Gamma) - \n        delta^2 zright)fracpartial partial y + \n        delta^2 y fracpartialpartial z 05em\n        F_101(q) = \n        2 delta y fracpartialpartial y + \n        (gamma - 2 delta z) fracpartialpartial z\n    endalignedAlong a singular arc, we have H_1 = H_01 = 0, that is  p cdot F_1 = p cdot F_01 = 0. Since, p is of dimension 2 and is nonzero, then we have det(F_1 F_01) = y ( gamma - 2 delta z) = 0. This gives us the two singular lines. ALong the horizontal singular line, the control is given by     u_s(y) coloneqq gamma (2Gamma - gamma)  (2 delta y)while along the vertical line it is given by u_0 coloneqq 0. We refer to [19] for details about how to compute the  singular controls in feedback form. ","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"@suppress_err begin # hide\nusing OrdinaryDiffEq\nend # hide\n\n# Controls\nu0 = 0                   # off control: vertical singular line\nu1 = 1                   # bang control\nus(y) = γ⋅(2Γ−γ)/(2δ⋅y)  # singular control: horizontal line\n\n# Flows\nf0 = Flow(ocp, (q, p, tf) -> u0, abstol=1e-14, reltol=1e-10)\nf1 = Flow(ocp, (q, p, tf) -> u1, abstol=1e-14, reltol=1e-10)\nfs = Flow(ocp, (q, p, tf) -> us(q[1]), abstol=1e-14, reltol=1e-10)\nnothing # hide","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"With the previous flows, we can define the shooting function considering the sequence Bang-Singular-Bang-Singular. There are 3 switching times t_1, t_2 and t_3. The final time t_f is unknown such as the initial costate. To reduce the sensitivy of the shooting function we also consider the states and costates at the switching times as unknowns and we add some matching conditions.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Note that the final time is free, hence, in the normal case, H = -p^0 = 1 along the solution of the PMP. Considering this condition at the initial time, we obtain  p_y(0) = -1. At the entrance of the singular arcs, we must satisfy H_1 = H_01 = 0 For the first singular arc, this leads to the conditions ","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    - p_y(t_1) z_s + p_z(t_1) y(t_1) = z(t_1) - z_s = 0","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"At the entrance of the second singular arc, we have","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    p_y(t_3) = y(t_3) = 0","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Finally, the solution has to satisfy the final condition q(t_f) = (0 0). Since, the last singular arc is contained in y=0, this condition is redundant and so we only  need to check that z(t_f) = 0.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Altogether, this leads to the following shooting function.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"function shoot!(s, pz0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)\n\n    p0 = [-1, pz0]\n\n    q1_, p1_ = f1(t0, q0, p0, t1)\n    q2_, p2_ = fs(t1, q1, p1, t2)\n    q3_, p3_ = f1(t2, q2, p2, t3)\n    qf , pf  = f0(t3, q3, p3, tf)\n\n    s[1] = - p1[1] ⋅ zs + p1[2] ⋅ q1[1]   # H1 = H01 = 0 on the horizontal\n    s[2] = q1[2] - zs                     # singular line, z=zs\n    s[3] = p3[1]                          # H1 = H01 = 0 on the vertical\n    s[4] = q3[1]                          # singular line, y=0\n    s[5] = qf[2]                          # z(tf) = 0\n    s[ 6: 7] .= q1 - q1_\n    s[ 8: 9] .= p1 - p1_\n    s[10:11] .= q2 - q2_\n    s[12:13] .= p2 - p2_\n    s[14:15] .= q3 - q3_\n    s[16:17] .= p3 - p3_\n\nend\nnothing # hide","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"We are now in position to solve the shooting equations. Due to the sensitivity of the  first singular arc, we need to improve the initial guess obtained from the direct method to make the Newton solver converge. To do so we set for the initial guess:","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    z(t_1) = z_s","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"and ","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"    p_z(t_1) = p_y(t_1) z_s / y(t_1).","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"One can see below from the norm of the shooting function at the initial guess that  it is not very accurate.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"\n# we refine the initial guess to make the Newton solver converge\nq1[2] = zs\np1[2] = p1[1] ⋅ zs / q1[1]\n\n# Norm of the shooting function at initial guess\nusing LinearAlgebra: norm\n\ns = similar([pz0], 17)\n@suppress_err begin # hide\nshoot!(s, pz0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)\nend # hide\n\nprintln(\"Norm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Finally, we can solve the shooting equations thanks to the NonlinearSolve.jl and improve our solution.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"using NonlinearSolve\n# auxiliary function with aggregated inputs\nnle = (s, ξ, λ) -> shoot!(s, ξ[1], ξ[2:5]..., ξ[6:7], ξ[8:9], ξ[10:11], ξ[12:13], ξ[14:15], ξ[16:17])   \nξ = [ pz0 ; t1 ; t2 ; t3 ; tf ; q1 ; p1 ; q2 ; p2 ; q3 ; p3] # initial guess\n\nprob = NonlinearProblem(nle, ξ)\nglobal indirect_sol =      # hide\n@suppress_err begin # hide\nNonlinearSolve.solve(prob)      # hide\nindirect_sol = NonlinearSolve.solve(prob; abstol=1e-8, reltol=1e-8, show_trace=Val(true)) # resolution of S = 0\nend                 # hide\n\n# we retrieve the costate solution together with the times\npz0 = indirect_sol.u[1]\nt1 = indirect_sol.u[2]\nt2 = indirect_sol.u[3]\nt3 = indirect_sol.u[4]\ntf = indirect_sol.u[5]\nq1 = indirect_sol.u[6:7]\np1 = indirect_sol.u[8:9]\nq2 = indirect_sol.u[10:11]\np2 = indirect_sol.u[12:13]\nq3 = indirect_sol.u[14:15]\np3 = indirect_sol.u[16:17]\n\nprintln(\"pz0 = \", pz0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\ns = similar([pz0], 17)\n@suppress_err begin # hide\nshoot!(s, pz0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)\nend # hide\nprintln(\"Norm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"Let us plot the indirect solution. One can note that the second bang arc is well captured.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"f = f1 * (t1, fs) * (t2, f1) * (t3, f0) # concatenation of the flows\nindirect_sol = f((t0, tf), q0, [-1, pz0]) # compute the solution: state, costate, control...\n\nspin_plot(indirect_sol; size=(700, 350))","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"From the following plot, one can see that the maximisation condition from the PMP is  now well satisfied compared to the solution obtained from the direct method.","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"switching_plot(indirect_sol, H1, H01; size=(700, 900))","category":"page"},{"location":"application-mri-saturation.html","page":"The saturation problem in Magnetic Resonance Imaging","title":"The saturation problem in Magnetic Resonance Imaging","text":"","category":"page"},{"location":"api.html#OptimalControl-API","page":"API","title":"OptimalControl API","text":"","category":"section"},{"location":"api.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Pages   = [\"api.md\"]\nModules = [OptimalControl]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api.html#Available-methods","page":"API","title":"Available methods","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"using OptimalControl\navailable_methods()","category":"page"},{"location":"api.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [OptimalControl]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api.html#OptimalControl.OptimalControl","page":"API","title":"OptimalControl.OptimalControl","text":"OptimalControl module.\n\nLists all the imported modules and packages:\n\nBase\nCTBase\nCTDirect\nCTFlows\nCore\nDocStringExtensions\n\nList of all the exported names:\n\n*\nAutonomous\nControlConstraint\nControlLaw\nFeedbackControl\nFixed\nFlow\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\nIndex\n@Lie\nLie\nLift\nMixedConstraint\nModel\nMultiplier\nNonAutonomous\nNonFixed\nParsingError\nPoisson\nStateConstraint\nVectorField\n__OCPModel\navailable_methods\nbuild_solution\nconstraint\nconstraint!\ncontrol!\nct_repl\n@def\ndirect_transcription\ndynamics!\nexport_ocp_solution\nget_nlp\nimport_ocp_solution\nis_max\nis_min\nis_time_dependent\nis_time_independent\nis_variable_dependent\nis_variable_independent\nload\nobjective!\nplot\nplot!\nremove_constraint!\nsave\nset_initial_guess\nsolve\nstate!\ntime!\nvariable!\n∂ₜ\n⋅\n\n\n\n\n\n","category":"module"},{"location":"api.html#OptimalControl.available_methods-Tuple{}","page":"API","title":"OptimalControl.available_methods","text":"available_methods() -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api.html#OptimalControl.solve-Tuple{OptimalControlModel, Vararg{Symbol}}","page":"API","title":"OptimalControl.solve","text":"solve(\n    ocp::OptimalControlModel,\n    description::Symbol...;\n    display,\n    init,\n    kwargs...\n)\n\n\nSolve the the optimal control problem ocp by the method given by the (optional) description.\n\nThe (optional) description\n\nYou can pass a partial description. If you give a partial description, then, if several complete descriptions contains the partial one,  then, the method with the highest priority is chosen. The higher in the list,  the higher is the priority.\n\nKeyword arguments:\n\ndisplay: print or not information during the resolution\ninit: an initial condition for the solver\n\nwarning: Warning\nThere is only one available method for the moment: a direct method which transforms the optimal control problem into a nonlinear programming problem (NLP) solved by Ipopt, thanks to the package  ADNLPModels. The direct method comes from the  CTDirect package.\n\ntip: Tip\nTo see the list of available methods, simply call available_methods().\nYou can pass any other option by a pair keyword=value according to the chosen method.\n\nExamples\n\njulia> sol = solve(ocp)\njulia> sol = solve(ocp, :direct)\njulia> sol = solve(ocp, :direct, :ipopt)\njulia> sol = solve(ocp, :direct, :ipopt, display=false)\njulia> sol = solve(ocp, :direct, :ipopt, display=false, init=sol)\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2],))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5, variable=[1, 2]))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=t->6-12*t))\njulia> sol = solve(ocp, init=(state=t->[-1+t, t*(t-1)], control=0.5))\njulia> sol = solve(ocp, init=(state=t->[-1+t, t*(t-1)], control=t->6-12*t))\n\n\n\n\n\n","category":"method"},{"location":"api.html","page":"API","title":"API","text":"","category":"page"},{"location":"api-ctflows.html#CTFlows-API","page":"CTFlows API","title":"CTFlows API","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows API","title":"CTFlows API","text":"This is just a dump of CTFlows API documentation. For more details about CTFlows.jl package, see the documentation.","category":"page"},{"location":"api-ctflows.html#Index","page":"CTFlows API","title":"Index","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows API","title":"CTFlows API","text":"Pages   = [\"api-ctflows.md\"]\nModules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-ctflows.html#Documentation","page":"CTFlows API","title":"Documentation","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows API","title":"CTFlows API","text":"Modules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctflows.html","page":"CTFlows API","title":"CTFlows API","text":"","category":"page"},{"location":"tutorial-goddard.html#goddard","page":"Goddard problem","title":"Goddard problem","text":"","category":"section"},{"location":"tutorial-goddard.html#Introduction","page":"Goddard problem","title":"Introduction","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"<img src=\"./assets/Goddard_and_Rocket.jpg\" style=\"float: left; margin: auto 10px;\" width=\"200px\">","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"For this advanced example, we consider the well-known Goddard problem[1] [2] which models the ascent of a rocket through the atmosphere, and we restrict here ourselves to vertical (one dimensional) trajectories. The state variables are the altitude r, speed v and mass m of the rocket during the flight, for a total dimension of 3. The rocket is subject to gravity g, thrust u and drag force D (function of speed and altitude). The final time t_f is free, and the objective is to reach a maximal altitude with a bounded fuel consumption.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"We thus want to solve the optimal control problem in Mayer form","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"    r(t_f) to max","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"subject to the controlled dynamics","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"    dotr = v quad\n    dotv = fracT_maxu - D(rv)m - g quad\n    dotm = -u","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"and subject to the control constraint u(t) in 01 and the state constraint v(t) leq v_max. The initial state is fixed while only the final mass is prescribed.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"note: Nota bene\nThe Hamiltonian is affine with respect to the control, so singular arcs may occur, as well as constrained arcs due to the path constraint on the velocity (see below).","category":"page"},{"location":"tutorial-goddard.html#Direct-method","page":"Goddard problem","title":"Direct method","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"using Suppressor # to suppress warnings","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"We import the OptimalControl.jl package to define and solve the optimal control problem. We import the Plots.jl package to plot the solution. The OrdinaryDiffEq.jl package is used to define the shooting function for the indirect method and the NonlinearSolve.jl package permits solve the shooting equation.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"using OptimalControl\nusing NLPModelsIpopt\nusing OrdinaryDiffEq # to get the Flow function\nusing NonlinearSolve # NLE solver\nusing Plots","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"We define the problem","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"t0 = 0      # initial time\nr0 = 1      # initial altitude\nv0 = 0      # initial speed\nm0 = 1      # initial mass\nvmax = 0.1  # maximal authorized speed\nmf = 0.6    # final mass to target\n\n@def ocp begin # definition of the optimal control problem\n\n    tf ∈ R, variable\n    t ∈ [ t0, tf ], time\n    x = (r, v, m) ∈ R³, state\n    u ∈ R, control\n\n    x(t0) == [ r0, v0, m0 ]\n    m(tf) == mf,         (1)\n    0 ≤ u(t) ≤ 1\n    r(t) ≥ r0\n    0 ≤ v(t) ≤ vmax\n\n    ẋ(t) == F0(x(t)) + u(t) * F1(x(t))\n\n    r(tf) → max\n\nend;\n\n# Dynamics\nconst Cd = 310\nconst Tmax = 3.5\nconst β = 500\nconst b = 2\n\nF0(x) = begin\n    r, v, m = x\n    D = Cd * v^2 * exp(-β*(r - 1)) # Drag force\n    return [ v, -D/m - 1/r^2, 0 ]\nend\n\nF1(x) = begin\n    r, v, m = x\n    return [ 0, Tmax/m, -b*Tmax ]\nend\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"We then solve it","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"direct_sol = OptimalControl.solve(ocp; grid_size=100)\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"and plot the solution","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"plt = plot(direct_sol, solution_label=\"(direct)\", size=(800, 800))","category":"page"},{"location":"tutorial-goddard.html#Indirect-method","page":"Goddard problem","title":"Indirect method","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"We first determine visually the structure of the optimal solution which is composed of a bang arc with maximal control, followed by a singular arc, then by a boundary arc and the final arc is with zero control. Note that the switching function vanishes along the singular and boundary arcs.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"t = direct_sol.times\nx = direct_sol.state\nu = direct_sol.control\np = direct_sol.costate\n\nH1 = Lift(F1)           # H1(x, p) = p' * F1(x)\nφ(t) = H1(x(t), p(t))   # switching function\ng(x) = vmax - x[2]      # state constraint v ≤ vmax\n\nu_plot  = plot(t, u,     label = \"u(t)\")\nH1_plot = plot(t, φ,     label = \"H₁(x(t), p(t))\")\ng_plot  = plot(t, g ∘ x, label = \"g(x(t))\")\n\nplot(u_plot, H1_plot, g_plot, layout=(3,1), size=(500, 500))","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"We are now in position to solve the problem by an indirect shooting method. We first define the four control laws in feedback form and their associated flows. For this we need to compute some Lie derivatives, namely Poisson brackets of Hamiltonians (themselves obtained as lifts to the cotangent bundle of vector fields), or derivatives of functions along a vector field. For instance, the control along the minimal order singular arcs is obtained as the quotient","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"u_s = -fracH_001H_101","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"of length three Poisson brackets:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"H_001 = H_0H_0H_1 quad H_101 = H_1H_0H_1","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"where, for two Hamiltonians H and G,","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"HG = (nabla_p Hnabla_x G) - (nabla_x Hnabla_p G)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"While the Lie derivative of a function f wrt. a vector field X is simply obtained as","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"(X cdot f)(x) = f(x) cdot X(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"and is used to the compute the control along the boundary arc,","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"u_b(x) = -(F_0 cdot g)(x)  (F_1 cdot g)(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"as well as the associated multiplier for the order one state constraint on the velocity:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"mu(x p) = H_01(x p)  (F_1 cdot g)(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"note: Poisson bracket and Lie derivative\nThe Poisson bracket HG is also given by the Lie derivative of G along the Hamiltonian vector field X_H = (nabla_p H -nabla_x H) of H, that is    HG = X_H cdot Gwhich is the reason why we use the @Lie macro to compute Poisson brackets below.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"With the help of the differential geometry primitives from CTBase.jl, these expressions are straightforwardly translated into Julia code:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"# Controls\nu0 = 0                                  # off control\nu1 = 1                                  # bang control\n\nH0 = Lift(F0)                           # H0(x, p) = p' * F0(x)\nH01  = @Lie { H0, H1 }\nH001 = @Lie { H0, H01 }\nH101 = @Lie { H1, H01 }\nus(x, p) = -H001(x, p) / H101(x, p)     # singular control\n\nub(x) = -(F0⋅g)(x) / (F1⋅g)(x)          # boundary control\nμ(x, p) = H01(x, p) / (F1⋅g)(x)         # multiplier associated to the state constraint g\n\n# Flows\nf0 = Flow(ocp, (x, p, tf) -> u0)\nf1 = Flow(ocp, (x, p, tf) -> u1)\nfs = Flow(ocp, (x, p, tf) -> us(x, p))\nfb = Flow(ocp, (x, p, tf) -> ub(x), (x, u, tf) -> g(x), (x, p, tf) -> μ(x, p))\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"Then, we define the shooting function according to the optimal structure we have determined, that is a concatenation of four arcs.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"x0 = [ r0, v0, m0 ] # initial state\n\nfunction shoot!(s, p0, t1, t2, t3, tf)\n\n    x1, p1 = f1(t0, x0, p0, t1)\n    x2, p2 = fs(t1, x1, p1, t2)\n    x3, p3 = fb(t2, x2, p2, t3)\n    xf, pf = f0(t3, x3, p3, tf)\n\n    s[1] = constraint(ocp, :eq1)(x0, xf, tf) - mf # final mass constraint (1)\n    s[2:3] = pf[1:2] - [ 1, 0 ]                   # transversality conditions\n    s[4] = H1(x1, p1)                             # H1 = H01 = 0\n    s[5] = H01(x1, p1)                            # at the entrance of the singular arc\n    s[6] = g(x2)                                  # g = 0 when entering the boundary arc\n    s[7] = H0(xf, pf)                             # since tf is free\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"To solve the problem by an indirect shooting method, we then need a good initial guess, that is a good approximation of the initial costate, the three switching times and the final time.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"η = 1e-3\nt13 = t[ abs.(φ.(t)) .≤ η ]\nt23 = t[ 0 .≤ (g ∘ x).(t) .≤ η ]\np0 = p(t0)\nt1 = min(t13...)\nt2 = min(t23...)\nt3 = max(t23...)\ntf = t[end]\n\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\nusing LinearAlgebra: norm\ns = similar(p0, 7)\n@suppress_err begin # hide\nshoot!(s, p0, t1, t2, t3, tf)\nend # hide\nprintln(\"Norm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"Finally, we can solve the shooting equations thanks to the NonlinearSolve.jl.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"nle = (s, ξ, λ) -> shoot!(s, ξ[1:3], ξ[4], ξ[5], ξ[6], ξ[7])   # auxiliary function\n                                                               # with aggregated inputs\nξ = [ p0 ; t1 ; t2 ; t3 ; tf ]                                 # initial guess\n\nprob = NonlinearProblem(nle, ξ)\nglobal indirect_sol =      # hide\n@suppress_err begin # hide\nNonlinearSolve.solve(prob)      # hide\n# resolution of S(p0) = 0\nindirect_sol = NonlinearSolve.solve(prob; abstol=1e-8, reltol=1e-8, show_trace=Val(true))\nend                 # hide\n\n# we retrieve the costate solution together with the times\np0 = indirect_sol.u[1:3]\nt1 = indirect_sol.u[4]\nt2 = indirect_sol.u[5]\nt3 = indirect_sol.u[6]\ntf = indirect_sol.u[7]\n\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\ns = similar(p0, 7)\n@suppress_err begin # hide\nshoot!(s, p0, t1, t2, t3, tf)\nend # hide\nprintln(\"Norm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"We plot the solution of the indirect solution (in red) over the solution of the direct method (in blue).","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"f = f1 * (t1, fs) * (t2, fb) * (t3, f0) # concatenation of the flows\nflow_sol = f((t0, tf), x0, p0)          # compute the solution: state, costate, control...\n\nplot!(plt, flow_sol, solution_label=\"(indirect)\")","category":"page"},{"location":"tutorial-goddard.html#References","page":"Goddard problem","title":"References","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"[1]: R.H. Goddard. A Method of Reaching Extreme Altitudes, volume 71(2) of Smithsonian Miscellaneous Collections. Smithsonian institution, City of Washington, 1919.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"[2]: H. Seywald and E.M. Cliff. Goddard problem in presence of a dynamic pressure limit. Journal of Guidance, Control, and Dynamics, 16(4):776–781, 1993.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"","category":"page"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"<img width=\"800\" alt=\"juliaopt2023\" src=\"./assets/fgs-2024.jpg\">","category":"page"},{"location":"fgs-2024.html#control-toolbox:-solving-optimal-control-problems-within-Julia","page":"FGS 2024","title":"control-toolbox: solving optimal control problems within Julia","text":"","category":"section"},{"location":"fgs-2024.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://scholar.google.com/citations?userpkH4An4AAAAJ-and-hlfr),-[Pierre-Martinon](https://www.linkedin.com/in/pierre-martinon-b4603a17),-[Sophia-Sed](https://iww.inria.fr/sed-sophia)","page":"FGS 2024","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"page"},{"location":"fgs-2024.html#What-it's-about","page":"FGS 2024","title":"What it's about","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"subject to","category":"page"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"plus boundary, control and state constraints","category":"page"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"fgs-2024.html#Where-it-comes-from","page":"FGS 2024","title":"Where it comes from","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"BOCOP: the optimal control solver\nHamPath: indirect and Hamiltonian pathfollowing\nCoupling direct and indirect solvers, examples","category":"page"},{"location":"fgs-2024.html#OptimalControl.jl","page":"FGS 2024","title":"OptimalControl.jl","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"Double integrator\nBatch processing\nGoddard problem","category":"page"},{"location":"fgs-2024.html#Wrap-up","page":"FGS 2024","title":"Wrap up","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"High level modelling of optimal control problems\nEfficient numerical resolution coupling direct and indirect methods\nCollection of examples","category":"page"},{"location":"fgs-2024.html#Future","page":"FGS 2024","title":"Future","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"New applications (biology, space mechanics, quantum mechanics and more)\nAdditional solvers: direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions!\nCTProblems.jl","category":"page"},{"location":"fgs-2024.html#control-toolbox.org","page":"FGS 2024","title":"control-toolbox.org","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"fgs-2024.html#Credits-(not-exhaustive!)","page":"FGS 2024","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nMLStyle.jl","category":"page"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"","category":"page"},{"location":"tutorial-initial-guess.html#Initial-guess-options","page":"Initial guess options","title":"Initial guess options","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"We present in this tutorial the different possibilities to provide an initial guess to solve an optimal control problem using the solve command. For the illustrations, we define the following optimal control problem.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"t0 = 0\ntf = 10\nα  = 5\n\n@def ocp begin\n    t ∈ [ t0, tf ], time\n    v ∈ R, variable\n    x ∈ R², state\n    u ∈ R, control\n    x(t0) == [ -1, 0 ]\n    x(tf) - [ 0, v ] == [0, 0]\n    ẋ(t) == [ x₂(t), x₁(t) + α*x₁(t)^2 + u(t) ]\n    v^2 + ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Default-initial-guess","page":"Initial guess options","title":"Default initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"We first solve the problem without giving an initial guess. This will default to initialize all variables to 0.1.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"# solve the optimal control problem without initial guess\nsol = solve(ocp, display=false)\n\n# print the number of iterations \nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"Let us plot the solution of the optimal control problem.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"plot(sol, size=(600, 450))","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"Note that the following formulations are equivalent","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"sol = solve(ocp, display=false, init=nothing)\nprintln(\"Number of iterations: \", sol.iterations)\nsol = solve(ocp, display=false, init=())\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"To reduce the number of iterations and improve the convergence, we can give an initial guess to the solver.  This initial guess can be built from constant values, interpolated vectors, functions, or existing solutions. Except when initializing from a solution, the arguments are to be passed as a named tuple init=(state=..., control=..., variable=...) whose fields are optional. Missing fields will revert to default initialization (ie constant 0.1).","category":"page"},{"location":"tutorial-initial-guess.html#Constant-initial-guess","page":"Initial guess options","title":"Constant initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"We first illustrate the constant initial guess, using vectors or scalars according to the dimension.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"# solve the optimal control problem with initial guess\nsol = solve(ocp, display=false, init=(state=[-0.2, 0.1], control=-0.2, variable=0.05))\n\n# print the number of iterations\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"Partial initializations are also valid, as shown below. Note the ending comma when a single argument is passed (tuple).","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"sol = solve(ocp, display=false, init=(state=[-0.2, 0.1],))\nprintln(\"Number of iterations: \", sol.iterations)\nsol = solve(ocp, display=false, init=(control=-0.2,))\nprintln(\"Number of iterations: \", sol.iterations)\nsol = solve(ocp, display=false, init=(state=[-0.2, 0.1], variable=0.05))\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Functional-initial-guess","page":"Initial guess options","title":"Functional initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"For the state and control, we can also provide functions of time as initial guess.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"# initial guess as functions of time\nx(t) = [ -0.2t, 0.1t ]\nu(t) = -0.2t\n\n# solve the optimal control problem with initial guess\nsol = solve(ocp, display=false, init=(state=x, control=u, variable=0.05))\n\n# print the number of iterations\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Vector-initial-guess-(interpolated)","page":"Initial guess options","title":"Vector initial guess (interpolated)","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"Initialization can also be provided with vectors / matrices to be interpolated along a given time grid.  In this case the time steps must be given through an additional argument time, which can be a vector or line/column matrix. For the values to be interpolated both matrices and vectors of vectors are allowed, but the shape should be number of time steps x variable dimension. Simple vectors are also allowed for variables of dimension 1.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"time_vec = LinRange(t0,tf,4)\nx_vec = [[0, 0], [-0.1, 0.3], [-0.15,0.4], [-0.3, 0.5]]\nu_vec = [0, -0.8,  -0.3, 0]\n\nsol = solve(ocp, display=false, init=(time=time_vec, state=x_vec, control=u_vec, variable=0.05))\n\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"Note: in the free final time case, the given time grid should be consistent with the initial guess provided for the final time (in the optimization variables).","category":"page"},{"location":"tutorial-initial-guess.html#Mixed-initial-guess","page":"Initial guess options","title":"Mixed initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"The constant, functional and vector initializations can be mixed, for instance as","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"sol = solve(ocp, display=false, init=(state=[-0.2, 0.1], control=u, variable=0.05))\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide\n\nsol = solve(ocp, display=false, init=(time=time_vec, state=x_vec, control=u, variable=0.05))\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Solution-as-initial-guess-(warm-start)","page":"Initial guess options","title":"Solution as initial guess (warm start)","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"Finally, we can use an existing solution to provide the initial guess.  The dimensions of the state, control and optimization variable must coincide. This particular feature allows an easy implementation of discrete continuations.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"# generate the initial solution\nsol_init = solve(ocp, display=false)\n\n# solve the problem using solution as initial guess\nsol = solve(ocp, init=sol_init, display=false)\n\n# print the number of iterations\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"Note that you can also manually pick and choose which data to reuse from a solution, by recovering the functions sol.state, sol.control and the values sol.variable. For instance the following formulation is equivalent to the init=sol one.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"sol = solve(ocp, display=false, init=(state=sol.state, control=sol.control, variable=sol.variable))\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Costate-/-multipliers","page":"Initial guess options","title":"Costate / multipliers","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"For the moment we can not provide an initial guess for the costate / multipliers.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess options","title":"Initial guess options","text":"","category":"page"},{"location":"tutorial-basic-example-f.html#basic-f","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"","category":"section"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force u. We denote by x = (x_1 x_2) the state of the wagon, that is its position x_1 and its velocity x_2.","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"We assume that the mass is constant and unitary and that there is no friction. The dynamics we consider is given by","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) quad u(t) in R","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"which is simply the double integrator system. Les us consider a transfer starting at time t_0 = 0 and ending at time t_f = 1, for which we want to minimise the transfer energy","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"    frac12int_0^1 u^2(t)  mathrmdt","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"starting from the condition x(0) = (-1 0) and with the goal to reach the target x(1) = (0 0).","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"note: Solution and details\nSee the page  Double integrator: energy minimisation  for the analytical solution and details about this problem.","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"First, we need to import the OptimalControl.jl package to define and solve the optimal control problem. We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"Then, we can define the problem","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"ocp = Model()                                   # empty optimal control problem\n\ntime!(ocp, t0=0, tf=1)                          # initial and final times\nstate!(ocp, 2)                                  # dimension of the state\ncontrol!(ocp, 1)                                # dimension of the control\n\nconstraint!(ocp, :initial; lb=[ -1, 0 ], ub=[ -1, 0 ]) # initial condition\nconstraint!(ocp, :final;   lb=[  0, 0 ], ub=[  0, 0 ]) # final condition\n\ndynamics!(ocp, (x, u) -> [ x[2], u ])           # dynamics of the double integrator\n\nobjective!(ocp, :lagrange, (x, u) -> 0.5u^2)    # cost in Lagrange form\nnothing # hide","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"note: Nota bene\nThere are two ways to define an optimal control problem:using functions like in this example, see also the Model documentation for more details.\nusing an abstract formulation, see for instance basic example to compare.","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"Solve it","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"and plot the solution","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"plot(sol)","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"","category":"page"},{"location":"index.html#OptimalControl.jl","page":"Introduction","title":"OptimalControl.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The OptimalControl.jl package aims to provide tools to solve optimal control problems by direct and indirect methods. It is part of the control-toolbox ecosystem:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"flowchart TD\nO(<a href='https://control-toolbox.org/docs/optimalcontrol/stable/'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/docs/ctbase/stable/'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/docs/ctdirect/stable/'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/docs/ctflows/stable/'>CTFlows</a>)\nP(<a href='https://control-toolbox.org/docs/ctproblems/stable/'>CTProblems</a>) --> F\nP --> B\nF --> B\nD --> B\nstyle O fill:#FBF275","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Install and documentation\nTo install a package from the control-toolbox ecosystem,  please visit the installation page. The documentation is accessible from the main menu.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"An optimal control problem with fixed initial and final times can be described as minimising the cost functional","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"g(x(t_0) x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and other constraints such as","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"See our tutorials to get started solving optimal control problems.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
