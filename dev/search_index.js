var documenterSearchIndex = {"docs":
[{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"<img width=\"800\" alt=\"juliaopt2024\" src=\"./assets/juliacon2024.jpg\">","category":"page"},{"location":"juliacon2024.html#Trajectory-optimisation-in-space-mechanics-with-Julia","page":"JuliaCon 2024","title":"Trajectory optimisation in space mechanics with Julia","text":"","category":"section"},{"location":"juliacon2024.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Alesia-Herasimenka](https://www.uni.lu/snt-en/people/alesia-herasimenka)","page":"JuliaCon 2024","title":"Jean-Baptiste Caillau, Olivier Cots, Alesia Herasimenka","text":"","category":"section"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil-lux.jpg\">","category":"page"},{"location":"juliacon2024.html#What-it's-about","page":"JuliaCon 2024","title":"What it's about","text":"","category":"section"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"subject to","category":"page"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"plus boundary, control and state constraints","category":"page"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"juliacon2024.html#OptimalControl.jl-for-trajectory-optimisation","page":"JuliaCon 2024","title":"OptimalControl.jl for trajectory optimisation","text":"","category":"section"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"Basic example\nGoddard problem\nOrbit transfer","category":"page"},{"location":"juliacon2024.html#Wrap-up","page":"JuliaCon 2024","title":"Wrap up","text":"","category":"section"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"High level modelling of optimal control problems\nEfficient numerical resolution coupling direct and indirect methods\nCollection of examples","category":"page"},{"location":"juliacon2024.html#Future","page":"JuliaCon 2024","title":"Future","text":"","category":"section"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"New applications (biology, space mechanics, quantum mechanics and more)\nAdditional solvers: direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions!","category":"page"},{"location":"juliacon2024.html#control-toolbox.org","page":"JuliaCon 2024","title":"control-toolbox.org","text":"","category":"section"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"juliacon2024.html#Credits-(not-exhaustive!)","page":"JuliaCon 2024","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nMLStyle.jl","category":"page"},{"location":"juliacon2024.html","page":"JuliaCon 2024","title":"JuliaCon 2024","text":"","category":"page"},{"location":"tutorial-basic-example.html#basic","page":"Energy minimisation","title":"Double integrator: energy min (abstract syntax)","text":"","category":"section"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force u. We denote by x = (x_1 x_2) the state of the wagon, that is its position x_1 and its velocity x_2.","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"We assume that the mass is constant and unitary and that there is no friction. The dynamics we consider is given by","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t)quad u(t) in R","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"which is simply the double integrator system. Les us consider a transfer starting at time t_0 = 0 and ending at time t_f = 1, for which we want to minimise the transfer energy","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"    frac12int_0^1 u^2(t)  mathrmdt","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"starting from the condition x(0) = (-1 0) and with the goal to reach the target x(1) = (0 0).","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-basic-example.html#Optimal-control-problem","page":"Energy minimisation","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"Let us define the problem","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"ocp = @def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n    ẋ(t) == [ x₂(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"note: Nota bene\nFor a comprehensive introduction to the syntax used above to describe the optimal control problem, check this tutorial. In particular, there are non-unicode alternatives for derivatives, integrals, etc. There is also a non-standard but more classical functional syntax, check this tutorial.","category":"page"},{"location":"tutorial-basic-example.html#basic-solve-plot","page":"Energy minimisation","title":"Solve and plot","text":"","category":"section"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"We can solve it simply with:","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"And plot the solution with:","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"plot(sol)","category":"page"},{"location":"tutorial-basic-example.html#State-constraint","page":"Energy minimisation","title":"State constraint","text":"","category":"section"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"We add the path constraint","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"x_2(t) le 12","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"ocp = @def begin\n\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x₂(t) ≤ 1.2\n\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n\n    ẋ(t) == [ x₂(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\n\nsol = solve(ocp)\nplot(sol)","category":"page"},{"location":"tutorial-basic-example.html#Save-and-load","page":"Energy minimisation","title":"Save and load","text":"","category":"section"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"We can save the solution in a Julia .jld2 data file and reload it later, and also export a discretised version of the solution in a more portable JSON format.","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"# load additional modules\nusing JLD2, JSON3\n\n# JLD save / load\nsave(sol, filename_prefix=\"my_solution\")\nsol_reloaded = load(\"my_solution\")\nprintln(\"Objective from loaded solution: \", sol_reloaded.objective)\n\n# JSON export / read\nexport_ocp_solution(sol, filename_prefix=\"my_solution\")\nsol_json = import_ocp_solution(\"my_solution\")\nprintln(\"Objective from JSON discrete solution: \", sol_json.objective)","category":"page"},{"location":"tutorial-basic-example.html","page":"Energy minimisation","title":"Energy minimisation","text":"","category":"page"},{"location":"tutorial-lqr-basic.html#A-simple-Linear–quadratic-regulator-example","page":"Linear–quadratic regulator","title":"A simple Linear–quadratic regulator example","text":"","category":"section"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"We consider the following Linear Quadratic Regulator (LQR) problem which consists in minimising","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"    frac12 int_0^t_f left( x_1^2(t) + x_2^2(t) + u^2(t) right)  mathrmdt ","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"subject to the constraints","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = -x_1(t) + u(t) quad u(t) in R","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"and the initial condition","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"    x(0) = (01)","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"We define A and B as","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"    A = beginpmatrix 0  1  -1  0  endpmatrix quad\n    B = beginpmatrix 0  1  endpmatrix","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"in order to get dotx = Ax + Bu and we aim to solve this optimal control problem for different values of t_f.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"Then, we can define the problem parameterized by the final time tf.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"x0 = [ 0\n       1 ]\n\nA  = [ 0 1\n      -1 0 ]\n\nB  = [ 0\n       1 ]\n\nfunction lqr(tf)\n\n    ocp = @def begin\n        t ∈ [0, tf], time\n        x ∈ R², state\n        u ∈ R, control\n        x(0) == x0\n        ẋ(t) == A * x(t) + B * u(t)\n        ∫( 0.5(x₁(t)^2 + x₂(t)^2 + u(t)^2) ) → min\n    end\n\n    return ocp\nend;\nnothing # hide","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"We solve the problem for t_f in 3 5 30.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"solutions = []   # empty list of solutions\ntfs = [3, 5, 30]\n\nfor tf ∈ tfs\n    solution = solve(lqr(tf), display=false)\n    push!(solutions, solution)\nend\nnothing # hide","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"We plot the state and control variables considering a normalized time s=(t-t_0)(t_f-t_0), thanks to the keyword argument time=:normalized of the plot function.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"plt = plot(solutions[1], time=:normalized)\nfor sol ∈ solutions[2:end]\n    plot!(plt, sol, time=:normalized)\nend\n\n# we plot only the state and control variables and we add the legend\nN = length(tfs)\npx1 = plot(plt[1], legend=false, xlabel=\"s\", ylabel=\"x₁\")\npx2 = plot(plt[2], label=reshape([\"tf = $tf\" for tf ∈ tfs], (1, N)), xlabel=\"s\", ylabel=\"x₂\")\npu  = plot(plt[5], legend=false, xlabel=\"s\", ylabel=\"u\")\n\nusing Plots.PlotMeasures # for leftmargin, bottommargin\nplot(px1, px2, pu, layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"note: Nota bene\nWe can observe that x(t_f) converges to the origin as t_f increases.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"Linear–quadratic regulator","title":"Linear–quadratic regulator","text":"","category":"page"},{"location":"tutorial-iss.html#iss","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"In this tutorial we present the indirect simple shooting method on a simple example.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us start by importing the necessary packages.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using OptimalControl    # to define the optimal control problem and its flow\nusing OrdinaryDiffEq    # to get the Flow function from OptimalControl\nusing NonlinearSolve    # interface to NLE solvers\nusing MINPACK           # NLE solver: use to solve the shooting equation\nusing Plots             # to plot the solution","category":"page"},{"location":"tutorial-iss.html#Optimal-control-problem","page":"Indirect simple shooting","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us consider the following optimal control problem:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"left \n    beginarrayl\n        min displaystyle frac12 int_t_0^t_f u^2(t)  mathrmd t10em\n        dotx(t)  =  displaystyle -x(t)+alpha x^2(t)+u(t) quad  u(t) in R \n        quad t in t_0 t_f text ae 05em\n        x(t_0) = x_0 quad x(t_f) = x_f\n    endarray\nright","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"with t_0 = 0, t_f = 1, x_0 = -1, x_f = 0, alpha=15 and forall t in t_0 t_f, x(t) in R.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"t0 = 0\ntf = 1\nx0 = -1\nxf = 0\nα  = 1.5\nocp = @def begin\n\n    t ∈ [t0, tf], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == xf\n\n    ẋ(t) == -x(t) + α * x(t)^2 + u(t)\n\n    ∫( 0.5u(t)^2 ) → min\n    \nend;\nnothing # hide","category":"page"},{"location":"tutorial-iss.html#Boundary-value-problem","page":"Indirect simple shooting","title":"Boundary value problem","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"The pseudo-Hamiltonian of this problem is","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    H(xpu) = p  (-x+alpha x^2+u) + p^0 u^2 2","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"where p^0 = -1 since we are in the normal case. From the Pontryagin Maximum Principle, the maximising control is given by","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"u(x p) = p","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"since partial^2_uu H = p^0 = - 1  0. Plugging this control in feedback form into the pseudo-Hamiltonian, and considering the limit conditions, we obtain the following two-points boundary value problem (BVP).","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    left \n        beginarrayl\n            dotx(t)  = phantom- nabla_p Ht = -x(t) + alpha x^2(t) + u(x(t) p(t)) \n            = -x(t) + alpha x^2(t) + p(t) 05em\n            dotp(t)  = -           nabla_x Ht = (1 - 2 alpha x(t)) p(t)    05em\n            x(t_0)        = x_0 quad x(t_f) = x_f\n        endarray\n    right","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"where t=  (x(t)p(t)u(x(t) p(t))).","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"note: Our goal\nOur goal is to solve this (BVP). Solving (BVP) consists in solving the Pontryagin Maximum Principle which provides necessary conditions of optimality.","category":"page"},{"location":"tutorial-iss.html#Shooting-function","page":"Indirect simple shooting","title":"Shooting function","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"To achive our goal, let us first introduce the pseudo-Hamiltonian vector field","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    vecH(zu) = left( nabla_p H(zu) -nabla_x H(zu) right) quad z = (xp)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"and then denote by varphi_t_0 x_0 p_0(cdot) the solution of the following Cauchy problem","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"dotz(t) = vecH(z(t) u(z(t))) quad z(t_0) = (x_0 p_0)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Our goal becomes to solve","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"pi( varphi_t_0 x_0 p_0(t_f) ) = x_f","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"where pi(x p) = x. To compute varphi with OptimalControl.jl package, we define the flow of the associated Hamiltonian vector field by:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"u(x, p) = p\nφ = Flow(ocp, u)\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We define also the projection function on the state space.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"π((x, p)) = x\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"note: Nota bene\nActually, varphi_t_0 x_0 p_0(cdot) is also solution of    dotz(t) = vecmathbfH(z(t)) quad z(t_0) = (x_0 p_0)where mathbfH(z) = H(z u(z)) and vecmathbfH = (nabla_p mathbfH -nabla_x mathbfH). This is what is actually computed by Flow.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Now, to solve the (BVP) we introduce the shooting function:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    beginarrayrlll\n        S colon     R     longrightarrow    R \n                     p_0     longmapsto      S(p_0) = pi( varphi_t_0 x_0 p_0(t_f) ) - x_f\n    endarray","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"S(p0) = π( φ(t0, x0, p0, tf) ) - xf    # shooting function\nnothing # hide","category":"page"},{"location":"tutorial-iss.html#Resolution-of-the-shooting-equation","page":"Indirect simple shooting","title":"Resolution of the shooting equation","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"At the end, solving (BVP) is equivalent to solve S(p_0) = 0. This is what we call the  indirect simple shooting method. We define an initial guess.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"ξ = [ 0.1 ]    # initial guess\nnothing # hide","category":"page"},{"location":"tutorial-iss.html#NonlinearSolve.jl","page":"Indirect simple shooting","title":"NonlinearSolve.jl","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We first use the NonlinearSolve.jl package to solve the shooting equation. Let us define the problem.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"nle! = (s, ξ, λ) -> s[1] = S(ξ[1])    # auxiliary function\nprob = NonlinearProblem(nle!, ξ)      # NLE problem with initial guess\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us do some benchmarking.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using BenchmarkTools\n@benchmark solve(prob; show_trace=Val(false))","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"For small nonlinear systems, it could be faster to use the  SimpleNewtonRaphson() descent algorithm.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"@benchmark solve(prob, SimpleNewtonRaphson(); show_trace=Val(false))","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Now, let us solve the problem and retrieve the initial costate solution.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"indirect_sol = solve(prob; show_trace=Val(true))      # resolution of S(p0) = 0  \np0_sol = indirect_sol.u[1]                            # costate solution\nprintln(\"\\ncostate:    p0 = \", p0_sol)\nprintln(\"shoot: |S(p0)| = \", abs(S(p0_sol)), \"\\n\")","category":"page"},{"location":"tutorial-iss.html#MINPACK.jl","page":"Indirect simple shooting","title":"MINPACK.jl","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using MINPACK\nfunction fsolve(f, j, x; kwargs...)\n    try\n        MINPACK.fsolve(f, j, x; kwargs...)\n    catch e\n        println(\"Erreur using MINPACK\")\n        println(e)\n        println(\"hybrj not supported. Replaced by hybrd even if it is not visible on the doc.\")\n        MINPACK.fsolve(f, x; kwargs...)\n    end\nend","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Instead of the NonlinearSolve.jl package we can use the  MINPACK.jl package to solve  the shooting equation. To compute the Jacobian of the shooting function we use the  DifferentiationInterface.jl package with  ForwardDiff.jl backend.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using DifferentiationInterface\nimport ForwardDiff\nbackend = AutoForwardDiff()\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us define the problem to solve.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"nle!  = ( s, ξ) -> s[1] = S(ξ[1])                                 # auxiliary function\njnle! = (js, ξ) -> jacobian!(nle!, similar(ξ), js, backend, ξ)    # Jacobian of nle\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We are now in position to solve the problem with the hybrj solver from MINPACK.jl through the fsolve  function, providing the Jacobian. Let us do some benchmarking.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"@benchmark fsolve(nle!, jnle!, ξ; show_trace=false)    # initial guess given to the solver","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We can also use the preparation step of DifferentiationInterface.jl.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"extras = prepare_jacobian(nle!, similar(ξ), backend, ξ)\njnle_prepared!(js, ξ) = jacobian!(nle!, similar(ξ), js, backend, ξ, extras)\n@benchmark fsolve(nle!, jnle_prepared!, ξ; show_trace=false)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Now, let us solve the problem and retrieve the initial costate solution.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"indirect_sol = fsolve(nle!, jnle!, ξ; show_trace=true)    # resolution of S(p0) = 0\np0_sol = indirect_sol.x[1]                                # costate solution\nprintln(\"\\ncostate:    p0 = \", p0_sol)\nprintln(\"shoot: |S(p0)| = \", abs(S(p0_sol)), \"\\n\")","category":"page"},{"location":"tutorial-iss.html#Plot-of-the-solution","page":"Indirect simple shooting","title":"Plot of the solution","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"The solution can be plot calling first the flow.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"sol = φ((t0, tf), x0, p0_sol)\nplot(sol)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"In the indirect shooting method, the research of the optimal control is replaced by the computation of its associated extremal. This computation is equivalent to finding the initial covector solution to the shooting function. Let us plot the extremal in the phase space and the shooting function with  the solution.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"<article class=\"docstring\">\n<header>\n    <a class=\"docstring-article-toggle-button fa-solid fa-chevron-right\" href=\"javascript:;\" title=\"Expand docstring\"> </a>\n    <code>pretty_plot</code> — <span class=\"docstring-category\">Function</span>\n</header>\n<section style=\"display: none;\"><div><pre><code class=\"language-julia hljs\">using Plots.PlotMeasures\n\nexp(p0; saveat=[]) = φ((t0, tf), x0, p0, saveat=saveat)\n\nfunction pretty_plot(S, p0; Np0=20, kwargs...)\n\n    times = range(t0, tf, length=2)\n    p0_min = -0.5\n    p0_max = 2\n    p0_sol = p0\n\n    # plot of the flow in phase space\n    plt_flow = plot()\n    p0s = range(p0_min, p0_max, length=Np0)\n    for i ∈ eachindex(p0s)\n        sol = exp(p0s[i])\n        x = [sol.state(t)   for t ∈ sol.times]\n        p = [sol.costate(t) for t ∈ sol.times]\n        label = i==1 ? \"extremals\" : false\n        plot!(plt_flow, x, p, color=:blue, label=label)\n    end\n\n    # plot of wavefronts in phase space\n    p0s = range(p0_min, p0_max, length=200)\n    xs  = zeros(length(p0s), length(times))\n    ps  = zeros(length(p0s), length(times))\n    for i ∈ eachindex(p0s)\n        sol = exp(p0s[i], saveat=times)\n        xs[i, :] .= sol.state.(times)\n        ps[i, :] .= sol.costate.(times)\n    end\n    for j ∈ eachindex(times)\n        label = j==1 ? \"flow at times\" : false\n        plot!(plt_flow, xs[:, j], ps[:, j], color=:green, linewidth=2, label=label)\n    end\n\n    # \n    plot!(plt_flow, xlims=(-1.1, 1), ylims=(p0_min, p0_max))\n    plot!(plt_flow, [0, 0], [p0_min, p0_max], color=:black, xlabel=\"x\", ylabel=\"p\", label=\"x=xf\")\n    \n    # solution\n    sol = exp(p0_sol)\n    x = [sol.state(t)   for t ∈ sol.times]\n    p = [sol.costate(t) for t ∈ sol.times]\n    plot!(plt_flow, x, p, color=:red, linewidth=2, label=\"extremal solution\")\n    plot!(plt_flow, [x[end]], [p[end]], seriestype=:scatter, color=:green, label=false)\n\n    # plot of the shooting function \n    p0s = range(p0_min, p0_max, length=200)\n    plt_shoot = plot(xlims=(p0_min, p0_max), ylims=(-2, 4), xlabel=\"p₀\", ylabel=\"y\")\n    plot!(plt_shoot, p0s, S, linewidth=2, label=\"S(p₀)\", color=:green)\n    plot!(plt_shoot, [p0_min, p0_max], [0, 0], color=:black, label=\"y=0\")\n    plot!(plt_shoot, [p0_sol, p0_sol], [-2, 0], color=:black, label=\"p₀ solution\", linestyle=:dash)\n    plot!(plt_shoot, [p0_sol], [0], seriestype=:scatter, color=:green, label=false)\n\n    # final plot\n    plot(plt_flow, plt_shoot; layout=(1,2), leftmargin=15px, bottommargin=15px, kwargs...)\n\nend</code><button class=\"copy-button fa-solid fa-copy\" aria-label=\"Copy this code ;opblock\" title=\"Copy\"></button></pre></div>\n</section>\n</article>","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using Plots.PlotMeasures # hide\nexp(p0; saveat=[]) = φ((t0, tf), x0, p0, saveat=saveat) # hide\n # hide\nfunction pretty_plot(S, p0; Np0=20, kwargs...) # hide\n # hide\n    times = range(t0, tf, length=2) # hide\n    p0_min = -0.5 # hide\n    p0_max = 2 # hide\n    p0_sol = p0 # hide\n # hide\n    # plot of the flow in phase space # hide\n    plt_flow = plot() # hide\n    p0s = range(p0_min, p0_max, length=Np0) # hide\n    for i ∈ eachindex(p0s) # hide\n        sol = exp(p0s[i]) # hide\n        x = [sol.state(t)   for t ∈ sol.times] # hide\n        p = [sol.costate(t) for t ∈ sol.times] # hide\n        label = i==1 ? \"extremals\" : false # hide\n        plot!(plt_flow, x, p, color=:blue, label=label) # hide\n    end # hide\n # hide\n    # plot of wavefronts in phase space # hide\n    p0s = range(p0_min, p0_max, length=200) # hide\n    xs  = zeros(length(p0s), length(times)) # hide\n    ps  = zeros(length(p0s), length(times)) # hide\n    for i ∈ eachindex(p0s) # hide\n        sol = exp(p0s[i], saveat=times) # hide\n        xs[i, :] .= sol.state.(times) # hide\n        ps[i, :] .= sol.costate.(times) # hide\n    end # hide\n    for j ∈ eachindex(times) # hide\n        label = j==1 ? \"flow at times\" : false # hide\n        plot!(plt_flow, xs[:, j], ps[:, j], color=:green, linewidth=2, label=label) # hide\n    end # hide\n # hide\n    #  # hide\n    plot!(plt_flow, xlims=(-1.1, 1), ylims=(p0_min, p0_max)) # hide\n    plot!(plt_flow, [0, 0], [p0_min, p0_max], color=:black, xlabel=\"x\", ylabel=\"p\", label=\"x=xf\") # hide\n     # hide\n    # solution # hide\n    sol = exp(p0_sol) # hide\n    x = [sol.state(t)   for t ∈ sol.times] # hide\n    p = [sol.costate(t) for t ∈ sol.times] # hide\n    plot!(plt_flow, x, p, color=:red, linewidth=2, label=\"extremal solution\") # hide\n    plot!(plt_flow, [x[end]], [p[end]], seriestype=:scatter, color=:green, label=false) # hide\n # hide\n    # plot of the shooting function  # hide\n    p0s = range(p0_min, p0_max, length=200) # hide\n    plt_shoot = plot(xlims=(p0_min, p0_max), ylims=(-2, 4), xlabel=\"p₀\", ylabel=\"y\") # hide\n    plot!(plt_shoot, p0s, S, linewidth=2, label=\"S(p₀)\", color=:green) # hide\n    plot!(plt_shoot, [p0_min, p0_max], [0, 0], color=:black, label=\"y=0\") # hide\n    plot!(plt_shoot, [p0_sol, p0_sol], [-2, 0], color=:black, label=\"p₀ solution\", linestyle=:dash) # hide\n    plot!(plt_shoot, [p0_sol], [0], seriestype=:scatter, color=:green, label=false) # hide\n # hide\n    # final plot # hide\n    plot(plt_flow, plt_shoot; layout=(1,2), leftmargin=15px, bottommargin=15px, kwargs...) # hide\n # hide\nend # hide\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"pretty_plot(S, p0_sol; size=(800, 450))","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"","category":"page"},{"location":"dev-optimalcontrol.html#dev-optimalcontrol","page":"OptimalControl.jl","title":"OptimalControl.jl private functions","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-optimalcontrol.html#Index","page":"OptimalControl.jl","title":"Index","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Pages   = [\"dev-optimalcontrol.md\"]\nModules = [OptimalControl]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-optimalcontrol.html#Documentation","page":"OptimalControl.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Modules = [OptimalControl]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-optimalcontrol.html#OptimalControl.clean-Tuple{Tuple{Vararg{Symbol}}}","page":"OptimalControl.jl","title":"OptimalControl.clean","text":"clean(d::Tuple{Vararg{Symbol}}) -> Tuple{Vararg{Symbol}}\n\n\nRemove from the description, the Symbol that are specific to OptimalControl.jl and so must not  be passed.\n\n\n\n\n\n","category":"method"},{"location":"dev-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"","category":"page"},{"location":"tutorial-abstract.html#abstract","page":"Abstract syntax","title":"The abstract syntax to define an optimal control problem","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The full grammar of OptimalControl.jl small Domain Specific Language is given below. The idea is to use a syntax that is","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"pure Julia (and, as such, effortlessly analysed by the standard Julia parser),\nas close as possible to the mathematical description of an optimal control problem. ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"While the syntax will be transparent to those users familiar with Julia expressions (Expr's), we provide examples for every case that should be widely understandable. We rely heavily on MLStyle.jl and its pattern matching abilities 👍🏽 for the semantic pass. Abstract definitions use the macro @def.","category":"page"},{"location":"tutorial-abstract.html#variable","page":"Abstract syntax","title":"Variable","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $v ∈ R^$q, variable ) \n:( $v ∈ R   , variable ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"A variable (only one is allowed) is a finite dimensional vector or reals that will be optimised along with state and control values. To define an (almost empty!) optimal control problem, named ocp, having a dimension two variable named v, do the following:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"using OptimalControl #hide\n@def begin\n    v ∈ R², variable\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Aliases v₁, v₂ (and v1, v2) are automatically defined and can be used in subsequent expressions instead of v[1] and v[2]. The user can also define her own aliases for the components (one alias per dimension):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    v = (a, b) ∈ R², variable\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"A one dimensional variable can be declared according to","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    v ∈ R, variable\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"note: Note\nIt is also possible to use the following syntax@def ocp begin\n    v ∈ R, variable\nend\nnothing # hidethat is equivalent toocp = @def begin\n    v ∈ R, variable\nend\nnothing # hide","category":"page"},{"location":"tutorial-abstract.html#Time","page":"Abstract syntax","title":"Time","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $t ∈ [$t0, $tf], time ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The independent variable or time is a scalar bound to a given interval. Its name is arbitrary.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"t0 = 1\ntf = 5\n@def begin\n    t ∈ [t0, tf], time\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"One (or even the two bounds) can be variable, typically for minimum time problems (see Mayer cost section):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    v = (T, λ) ∈ R², variable\n    t ∈ [0, T], time\nend","category":"page"},{"location":"tutorial-abstract.html#state","page":"Abstract syntax","title":"State","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $x ∈ R^$n, state ) \n:( $x ∈ R   , state ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The state declaration defines the name and the dimension of the state:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    x ∈ R⁴, state\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"As for the variable, there are automatic aliases (x₁ and x1 for x[1], etc.) and the user can define her own aliases (one per scalar component of the state):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    x = (q₁, q₂, v₁, v₂) ∈ R⁴, state\nend","category":"page"},{"location":"tutorial-abstract.html#control","page":"Abstract syntax","title":"Control","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $u ∈ R^$m, control ) \n:( $u ∈ R   , control ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The control declaration defines the name and the dimension of the control:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    u ∈ R², control\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"As before, there are automatic aliases (u₁ and u1 for u[1], etc.) and the user can define her own aliases (one per scalar component of the state):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    u = (α, β) ∈ R², control\nend","category":"page"},{"location":"tutorial-abstract.html#dynamics","page":"Abstract syntax","title":"Dynamics","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( ∂($x)($t) == $e1 ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The dynamics is given in the standard vectorial ODE form:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"    dotx(t) = f(t x(t) u(t) v)","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"depending on whether it is autonomous / with a variable or not (the parser will detect time and variable dependences, which entails that time, state and variable must be declared prior to dynamics - an error will be issued otherwise). The symbol ∂, or the dotted state name (ẋ), or the keyword derivative can be used:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    ∂(x)(t) == [x₂(t), u(t)]\nend\nnothing # hide","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"or","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    ẋ(t) == [x₂(t), u(t)]\nend\nnothing # hide","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"or","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    derivative(x)(t) == [x₂(t), u(t)]\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Any Julia code can be used, so the following is also OK: ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"ocp = @def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    ẋ(t) == F₀(x(t)) + u(t) * F₁(x(t))\nend\n\nF₀(x) = [x[2], 0]\nF₁(x) = [0, 1]\nnothing # hide","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"note: Note\nThe vector fields F₀ and F₁ can be defined afterwards, as they only need to be available when the dynamics will be evaluated.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Currently, it is not possible to declare the dynamics component after component, but a simple workaround is to use aliases (check the relevant aliases section below):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    q̇ = v(t)\n    v̇ = u(t) - c(t)\n    ẋ(t) == [q̇, v̇]\nend","category":"page"},{"location":"tutorial-abstract.html#Constraints","page":"Abstract syntax","title":"Constraints","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $e1 == $e2        ) \n:( $e1 ≤  $e2 ≤  $e3 ) \n:(        $e2 ≤  $e3 ) \n:( $e3 ≥  $e2 ≥  $e1 ) \n:( $e2 ≥  $e1        ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Admissible constraints can be","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"five types: boundary, control, state, mixed, variable,\nlinear (ranges) or nonlinear (not ranges),\nequalities or (one or two-sided) inequalities.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Boundary conditions are detected when the expression contains evaluations of the state at initial and / or final time bounds (e.g., x(0)), and may not involve the control. Conversely control, state or mixed constraints will involve control, state or both evaluated at the declared time (e.g., x(t) + u(t)).  Other combinations should be detected as incorrect by the parser 🤞🏾. The variable may be involved in any of the four previous constraints. Constraints involving the variable only are variable constraints, either linear or nonlinear. In the example below, there are","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"two linear boundary constraints,\none linear variable constraint,\none linear state constraint,\none (two-sided) nonlinear control constraint.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(tf) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    tf ≥ 0 \n    x₂(t) ≤ 1\n    u(t)^2 ≤ 1\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"note: Note\nSymbols like <= or >= are also authorised:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(tf) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    tf >= 0 \n    x₂(t) <= 1\n    u(t)^2 <= 1\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"caveat: Caveat\nWrite either u(t)^2 or (u^2)(t), not u^2(t) since in Julia the latter is means u^(2t). Moreover, in the case of equalities or of one-sided inequalities, the control and / or the state must belong to the left-hand side. The following will error:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"using OptimalControl","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    t ∈ [0, 2], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [-1, 0]\n    x(2) == [0, 0]\n    ẋ(t) == [x₂(t), u(t)]\n    1 ≤ x₂(t)\n    -1 ≤ u(t) ≤ 1\nend","category":"page"},{"location":"tutorial-abstract.html#mayer","page":"Abstract syntax","title":"Mayer cost","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $e1 → min ) \n:( $e1 → max ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Mayer costs are defined in a similar way to boundary conditions and follow the same rules. The symbol → is used to denote minimisation or maximisation, the latter being treated by minimising the opposite cost. (The symbol => can also be used.)","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5\n   -2 ≤ v(t) ≤ 3\n    ẋ(t) == [v(t), u(t)]\n    tf → min\nend","category":"page"},{"location":"tutorial-abstract.html#Lagrange-cost","page":"Abstract syntax","title":"Lagrange cost","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":(       ∫($e1) → min ) \n:(     - ∫($e1) → min ) \n:( $e1 * ∫($e2) → min ) \n:(       ∫($e1) → max ) \n:(     - ∫($e1) → max ) \n:( $e1 * ∫($e2) → max ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Lagrange (integral) costs are defined used the symbol ∫, with parentheses. The keyword integral can also be used:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    t ∈ [0, 1], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    0.5∫(q(t) + u(t)^2) → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"or","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    t ∈ [0, 1], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    0.5integrate(q(t) + u(t)^2) → min\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The integration range is implicitly equal to the time range, so the cost above is to be understood as","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"int_0^1 left( q(t) + u^2(t) right) mathrmdt to min","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"As for the dynamics, the parser will detect whether the integrand depends or not on time (autonomous / non-autonomous case).","category":"page"},{"location":"tutorial-abstract.html#Bolza-cost","page":"Abstract syntax","title":"Bolza cost","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $e1 +       ∫($e2)       → min ) \n:( $e1 + $e2 * ∫($e3)       → min ) \n:( $e1 -       ∫($e2)       → min ) \n:( $e1 - $e2 * ∫($e3)       → min ) \n:( $e1 +       ∫($e2)       → max ) \n:( $e1 + $e2 * ∫($e3)       → max ) \n:( $e1 -       ∫($e2)       → max ) \n:( $e1 - $e2 * ∫($e3)       → max ) \n:(             ∫($e2) + $e1 → min ) \n:(       $e2 * ∫($e3) + $e1 → min ) \n:(             ∫($e2) - $e1 → min ) \n:(       $e2 * ∫($e3) - $e1 → min ) \n:(             ∫($e2) + $e1 → max ) \n:(       $e2 * ∫($e3) + $e1 → max ) \n:(             ∫($e2) - $e1 → max ) \n:(       $e2 * ∫($e3) - $e1 → max ) ","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Quite readily, Mayer and Lagrange costs can be combined into general Bolza costs. For instance as follows:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    p = (t0, tf) ∈ R², variable\n    t ∈ [t0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R², control\n    (tf - t0) + 0.5∫(c(t) * u(t)^2) → min\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"caveat: Caveat\nThe expression must be the sum of two terms (plus, possibly, a scalar factor before the integral), not more, so mind the parentheses. For instance, the following errors:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    p = (t0, tf) ∈ R², variable\n    t ∈ [t0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R², control\n    (tf - t0) + q(tf) + 0.5∫( c(t) * u(t)^2 ) → min\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The correct syntax is","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    p = (t0, tf) ∈ R², variable\n    t ∈ [t0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R², control\n    ((tf - t0) + q(tf)) + 0.5∫( c(t) * u(t)^2 ) → min\nend","category":"page"},{"location":"tutorial-abstract.html#aliases","page":"Abstract syntax","title":"Aliases","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":":( $a = $e1 )","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"The single = symbol is used to define not a constraint but an alias, that is a purely syntactic replacement. There are some automatic aliases, e.g. x₁ for x[1] if x is the state, and we have also seen that the user can define her own aliases when declaring the variable, state and control. Arbitrary aliases can be further defined, as below (compare with previous examples in the dynamics section):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def begin\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n    F₀ = [x₂(t), 0]\n    F₁ = [0, 1]\n    ẋ(t) == F₀ + u(t) * F₁\nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"caveat: Caveat\nSuch aliases do not define any additional function and are just replaced textually by the parser. In particular, they cannot be used outside the @def begin ... end block.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"hint: Hint\nYou can rely on a trace mode for the macro @def to look at your code after expansions of the aliases using the @def ocp ... syntax and adding true after your begin ... end block:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    q̇ = v(t)\n    v̇ = u(t) - c(t)\n    ẋ(t) == [q̇, v̇]\nend true;","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"caveat: Caveat\nThe dynamics of an OCP is indeed a particular constraint, be careful to use == and not a single = that would try to define an alias:","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"double_integrator = @def begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    q̇ = v\n    v̇ = u\n    ẋ(t) = [q̇, v̇]\nend","category":"page"},{"location":"tutorial-abstract.html#Misc","page":"Abstract syntax","title":"Misc","text":"","category":"section"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Declarations (of variable - if any -, time, state and control) must be done first. Then, dynamics, constraints and cost can be introduced in an arbitrary order.\nIt is possible to provide numbers / labels (as in math equations) for the constraints to improve readability (this is mostly for future use, typically to retrieve the Lagrange multiplier associated with the discretisation of a given constraint):","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"@def damped_integrator begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    tf ≥ 0, (1)\n    q(0) == 2, (♡)\n    q̇ = v(t)\n    v̇ = u(t) - c(t)\n    ẋ(t) == [q̇, v̇]\n    x(t).^2  ≤ [1, 2], (state_con) \nend","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"Parsing errors should be explicit enough (with line number in the @def begin ... end block indicated) 🤞🏾\nCheck tutorials and applications in the documentation for further use.","category":"page"},{"location":"tutorial-abstract.html","page":"Abstract syntax","title":"Abstract syntax","text":"","category":"page"},{"location":"api-ctbase/parser.html#api-ctbase-parser","page":"Parser","title":"Parser","text":"","category":"section"},{"location":"api-ctbase/parser.html","page":"Parser","title":"Parser","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/parser.html#Index","page":"Parser","title":"Index","text":"","category":"section"},{"location":"api-ctbase/parser.html","page":"Parser","title":"Parser","text":"Pages   = [\"parser.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/parser.html#Documentation","page":"Parser","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/parser.html","page":"Parser","title":"Parser","text":"Modules = [CTBase]\nOrder = [:module, :constant, :macro, :function]\nPages = [\"ctparser_utils.jl\", \"onepass.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/parser.html#CTBase.constraint_type-NTuple{7, Any}","page":"Parser","title":"CTBase.constraint_type","text":"constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n\n\nReturn the type constraint among :initial, :final, :boundary, :control_range, :control_fun, :state_range, :state_fun, :mixed, :variable_range, :variable_fun (:other otherwise), together with the appropriate value (range, updated expression...) Expressions like u(t0) where u is the control and t0 the initial time return :other.\n\nExample\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, 1)\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, 1)\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, 1)\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, 1)\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, 2)\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n:variable_fun\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n:variable_fun\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/parser.html#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}","page":"Parser","title":"CTBase.replace_call","text":"replace_call(e, x::Symbol, t, y) -> Any\n\n\nReplace calls in e of the form (...x...)(t) by (...y...).\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/parser.html#CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","page":"Parser","title":"CTBase.replace_call","text":"replace_call(e, x::Vector{Symbol}, t, y) -> Any\n\n\nReplace calls in e of the form (...x1...x2...)(t) by (...y1...y2...) for all symbols x1, x2... in the vector x.\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/parser.html#CTBase.@def-Tuple{Any}","page":"Parser","title":"CTBase.@def","text":"Define an optimal control problem. One pass parsing of the definition. Can be used writing either ocp = @def begin ... end or @def ocp begin ... end. In the second case, setting log to true will display the parsing steps.\n\nExample\n\nocp = @def begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend\n\n@def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend true # final boolean to show parsing log\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase/parser.html#CTBase.__OCPModel-Tuple","page":"Parser","title":"CTBase.__OCPModel","text":"__OCPModel(args...; kwargs...) -> OptimalControlModel\n\n\nRedirection to Model to avoid confusion with other functions Model from other packages if imported. This function is used by @def.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/parser.html","page":"Parser","title":"Parser","text":"","category":"page"},{"location":"tutorial-solve.html#manual-solve","page":"Solve","title":"The solve function","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"In this tutorial, we explain the solve function from OptimalControl.jl package.","category":"page"},{"location":"tutorial-solve.html#Basic-usage","page":"Solve","title":"Basic usage","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Les us define a basic optimal control problem.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"using OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == [ 0, 0 ]\n\n    ẋ(t)  == [ v(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Let us try to solve the problem:","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"using OptimalControl\nt0 = 0\ntf = 1\nx0 = [-1, 0]\nocp = @def begin\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    x(t0) == x0\n    x(tf) == [ 0, 0 ]\n    ẋ(t)  == [ v(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"julia> solve(ocp)\nERROR: ExtensionError. Please make: julia> using NLPModelsIpopt","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"As you can see, an error occured since we need the package NLPModelsIpopt.jl.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Actually, the default solving method is what we call a  direct method.  In a direct method, the optimal control problem is transcribed to a nonlinear optimization problem (NLP) of the form","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"textminimizequad F(y) quadtextsubject to the constraintsquad g(y)=0 quad h(y)le 0 ","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"OptimalControl.jl package makes the transcription but it needs a package to modelise the NLP problem and  another one to solve it. NLPModelsIpopt.jl package provides an interface to the well-known solver  Ipopt that can be used to solve general nonlinear programming problems.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"using NLPModelsIpopt\n\nsolve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-solve.html#Solvers","page":"Solve","title":"Solvers","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"OptimalControl.jl offers a list of methods to solve your optimal control problem. To get the list of methods, simply call available_methods.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"available_methods()","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Each line is a method. The priority is given from top to bottom. This means that ","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"solve(ocp)","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"is equivalent to ","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"solve(ocp, :direct, :adnlp, :ipopt)","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Let us detail the three symbols. As you can see, there are only direct methods. The symbol :adnlp is for the  choice of modeler. As said before, the NLP problem needs to be modelised in Julia code. We use  ADNLPModels.jl which provides automatic differentiation (AD)-based model implementations that conform to the NLPModels.jl API.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"The last symbol is what distinguish the two available methods. It corresponds to the NLP solver. By default, we use the NLPModelsIpopt.jl package but you can choose MadNLP.jl which is an open-source nonlinear programming solver, purely implemented in Julia and which implements a filter  line-search interior-point algorithm, as used in Ipopt.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Note that you are not compelled to provide the full description of the method to use it. A partial description, if not ambiguous, will work. Just remember that if several full descriptions contain the partial one, then, the  priority is given to first one in the list. Hence, these calls are all equivalent:","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"solve(ocp)\nsolve(ocp, :direct                )\nsolve(ocp,          :adnlp        )\nsolve(ocp,                  :ipopt)\nsolve(ocp, :direct, :adnlp        )\nsolve(ocp, :direct,         :ipopt)\nsolve(ocp, :direct, :adnlp, :ipopt)","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Let us try MadNLP.jl.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"using MadNLP\n\nsolve(ocp, :direct, :adnlp, :madnlp; display=true)\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Again, there are several equivalent manners to use MadNLP.jl.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"solve(ocp,                  :madnlp)\nsolve(ocp, :direct,         :madnlp)\nsolve(ocp,          :adnlp, :madnlp)\nsolve(ocp, :direct, :adnlp, :madnlp)","category":"page"},{"location":"tutorial-solve.html#Options","page":"Solve","title":"Options","text":"","category":"section"},{"location":"tutorial-solve.html#Direct-method","page":"Solve","title":"Direct method","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"The options common to all the direct methods may be seen directly in the  code. There are init, grid_size and time_grid. ","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"The init option can be used to set an initial guess for the solver. See this tutorial. \nThe grid_size option corresponds to the size of the (uniform) time discretization grid. More precisely, it is the number of steps, that is if N = grid_size and if the initial and final times are denoted respectively t0 and tf, then we have:","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Δt = (tf - t0) / N","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"The time_grid option is the grid of times: t0, t1, ..., tf. If the initial and/or the final times are free, then you can provide a normalised grid between 0 and 1. Note that you can set either grid_size or time_grid but not both.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"sol = solve(ocp; grid_size=10, display=false)\nsol.times","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"Or with MadNLP.jl:","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"sol = solve(ocp, :madnlp; grid_size=10, display=false)\nsol.times","category":"page"},{"location":"tutorial-solve.html#NLPModelsIpopt","page":"Solve","title":"NLPModelsIpopt","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"You can provide any option of NLPModelsIpopt.jl or Ipopt with a pair keyword=value. Please check the list of Ipopt options and the  NLPModelsIpopt.jl documentation.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"solve(ocp, :ipopt; max_iter=0)\nnothing # hide","category":"page"},{"location":"tutorial-solve.html#MadNLP","page":"Solve","title":"MadNLP","text":"","category":"section"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"If you use the MadNLP.jl solver, then you can provide any option of it. Please check the MadNLP.jl documentation and the list of  MadNLP.jl options.","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"solve(ocp, :madnlp; max_iter=1, display=true)\nnothing # hide","category":"page"},{"location":"tutorial-solve.html","page":"Solve","title":"Solve","text":"","category":"page"},{"location":"api-optimalcontrol.html#OptimalControl.jl","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"","category":"section"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"The OptimalControl.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"flowchart TD\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctbase.html'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctdirect.html'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctflows.html'>CTFlows</a>)\nF --> B\nD --> B\nstyle O fill:#FBF275","category":"page"},{"location":"api-optimalcontrol.html#Index","page":"OptimalControl.jl","title":"Index","text":"","category":"section"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Pages   = [\"api-optimalcontrol.md\"]\nModules = [OptimalControl]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-optimalcontrol.html#Available-methods","page":"OptimalControl.jl","title":"Available methods","text":"","category":"section"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"using OptimalControl\navailable_methods()","category":"page"},{"location":"api-optimalcontrol.html#Documentation","page":"OptimalControl.jl","title":"Documentation","text":"","category":"section"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"Modules = [OptimalControl]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-optimalcontrol.html#OptimalControl.OptimalControl","page":"OptimalControl.jl","title":"OptimalControl.OptimalControl","text":"OptimalControl module.\n\nLists all the imported modules and packages:\n\nBase\nCTBase\nCTDirect\nCTFlows\nCore\nDocStringExtensions\n\nList of all the exported names:\n\n*\nAutonomous\nFixed\nFlow\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\n@Lie\nLie\nLift\nModel\nNonAutonomous\nNonFixed\nOptimalControlModel\nOptimalControlSolution\nParsingError\nPoisson\nVectorField\n__OCPModel\navailable_methods\nconstraint\nconstraint!\ncontrol!\nct_repl\nct_repl_update_model\n@def\ndirect_transcription\ndynamics!\nexport_ocp_solution\nimport_ocp_solution\nload\nobjective!\nremove_constraint!\nsave\nset_initial_guess\nsolve\nstate!\ntime!\nvariable!\n∂ₜ\n⋅\n\n\n\n\n\n","category":"module"},{"location":"api-optimalcontrol.html#CommonSolve.solve-Tuple{OptimalControlModel, Vararg{Symbol}}","page":"OptimalControl.jl","title":"CommonSolve.solve","text":"solve(\n    ocp::OptimalControlModel,\n    description::Symbol...;\n    kwargs...\n) -> Bool\n\n\nSolve the the optimal control problem ocp by the method given by the (optional) description.\n\nThe (optional) description\n\nYou can pass a partial description. If you give a partial description, then, if several complete descriptions contains the partial one,  then, the method with the highest priority is chosen. The higher in the list,  the higher is the priority. To get the list of available methods, call available_methods().\n\nKeyword arguments: you can pass any other option by a pair keyword=value according to the chosen method.\n\nExamples\n\njulia> sol = solve(ocp)\njulia> sol = solve(ocp, :direct)\njulia> sol = solve(ocp, :direct, :ipopt)\njulia> sol = solve(ocp, :direct, :ipopt, display=false)\njulia> sol = solve(ocp, :direct, :ipopt, display=false, init=sol)\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2],))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5, variable=[1, 2]))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=t->6-12*t))\njulia> sol = solve(ocp, init=(state=t->[-1+t, t*(t-1)], control=0.5))\njulia> sol = solve(ocp, init=(state=t->[-1+t, t*(t-1)], control=t->6-12*t))\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol.html#OptimalControl.available_methods-Tuple{}","page":"OptimalControl.jl","title":"OptimalControl.available_methods","text":"available_methods(\n\n) -> Tuple{Vararg{Tuple{Symbol, Symbol, Symbol}}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api-optimalcontrol.html","page":"OptimalControl.jl","title":"OptimalControl.jl","text":"","category":"page"},{"location":"api-ctbase.html#CTBase.jl","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"The CTBase.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"flowchart TD\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctbase.html'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctdirect.html'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctflows.html'>CTFlows</a>)\nF --> B\nD --> B\nstyle B fill:#FBF275","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"You may find in this package:","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Types: the common types and associated methods if any.\nDescription: tools to manipulate tuples.\nDifferential geometry: tools to compute Lie brackets, Poisson brackets...\nExceptions.\nModel: tools to modelise an optimal control problem in a functional manner.\nParser: tools to modelise an optimal control problem in an abstract manner.\nPlot: the plot function extended from Plots.jl and utils.\nPrint: check how an optimal control problem is displayed.\nRepl: control-toolbox repl.\nUtils: auxiliary methods.","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Here is the list of imported packages and exported functions.","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Modules = [CTBase, Base]\nOrder = [:module]\nPages = [\"CTBase.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase.html#CTBase.CTBase","page":"CTBase.jl","title":"CTBase.CTBase","text":"CTBase module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDataStructures\nDocStringExtensions\nLinearAlgebra\nMLStyle\nParameters\nPrettyTables\nPrintf\nReplMaker\nUnicode\n\nList of all the exported names:\n\nAbstractHamiltonian\nAmbiguousDescription\nAutonomous\nBoundaryConstraint\nCTCallback\nCTCallbacks\nCTException\nControl\nControlConstraint\nControlLaw\nControls\nCostate\nCostates\nDCostate\nDState\nDescription\nDimension\nDynamics\nExtensionError\nFeedbackControl\nFixed\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\nIncorrectArgument\nIncorrectMethod\nIncorrectOutput\nIndex\nLagrange\n@Lie\nLie\nLift\nMayer\nMixedConstraint\nModel\nMultiplier\nNonAutonomous\nNonFixed\nNotImplemented\nOptimalControlInit\nOptimalControlModel\nOptimalControlSolution\nParsingError\nPoisson\nPrintCallback\nState\nStateConstraint\nStates\nStopCallback\nTime\nTimeDependence\nTimes\nTimesDisc\nUnauthorizedCall\nVariable\nVariableConstraint\nVariableDependence\nVectorField\n__OCPModel\nadd\nconstraint\nconstraint!\nconstraint_type\nconstraints_labels\ncontrol!\ncontrol_components_names\ncontrol_dimension\ncontrol_name\ncriterion\nctNumber\nctVector\nct_repl\nct_repl_update_model\nctgradient\nctindices\nctinterpolate\nctjacobian\nctupperscripts\n@def\ndim_boundary_constraints\ndim_control_constraints\ndim_control_range\ndim_mixed_constraints\ndim_path_constraints\ndim_state_constraints\ndim_state_range\ndim_variable_constraints\ndim_variable_range\ndynamics\ndynamics!\nfinal_time\nfinal_time_name\ngetFullDescription\nget_priority_print_callbacks\nget_priority_stop_callbacks\nhas_free_final_time\nhas_free_initial_time\nhas_lagrange_cost\nhas_mayer_cost\ninitial_time\ninitial_time_name\nis_autonomous\nis_fixed\nis_max\nis_min\nis_time_dependent\nis_time_independent\nis_variable_dependent\nis_variable_independent\nlagrange\nmayer\nmodel_expression\nnlp_constraints!\nobjective!\nremove\nremove_constraint!\nreplace_call\nset_AD_backend\nstate!\nstate_components_names\nstate_dimension\nstate_name\ntime!\ntime_name\nvariable!\nvariable_components_names\nvariable_dimension\nvariable_name\n∂ₜ\n⋅\n\n\n\n\n\n","category":"module"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"page"},{"location":"api-ctdirect.html#CTDirect.jl","page":"CTDirect.jl","title":"CTDirect.jl","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"The CTDirect.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"flowchart TD\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctbase.html'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctdirect.html'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctflows.html'>CTFlows</a>)\nF --> B\nD --> B\nstyle D fill:#FBF275","category":"page"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-ctdirect.html#Index","page":"CTDirect.jl","title":"Index","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Pages   = [\"api-ctdirect.md\"]\nModules = [CTDirect]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-ctdirect.html#Documentation","page":"CTDirect.jl","title":"Documentation","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Modules = [CTDirect]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctdirect.html#CTDirect.available_methods-Tuple{}","page":"CTDirect.jl","title":"CTDirect.available_methods","text":"available_methods(\n\n) -> Tuple{Tuple{Symbol, Symbol}, Tuple{Symbol, Symbol}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.direct_solve-Tuple{OptimalControlModel, Vararg{Symbol}}","page":"CTDirect.jl","title":"CTDirect.direct_solve","text":"direct_solve(\n    ocp::OptimalControlModel,\n    description::Symbol...;\n    init,\n    grid_size,\n    time_grid,\n    kwargs...\n)\n\n\nSolve an OCP with a direct method\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.direct_transcription-Tuple{OptimalControlModel, Vararg{Any}}","page":"CTDirect.jl","title":"CTDirect.direct_transcription","text":"direct_transcription(\n    ocp::OptimalControlModel,\n    description...;\n    init,\n    grid_size,\n    time_grid\n) -> Tuple{CTDirect.DOCP, ADNLPModels.ADNLPModel{Float64, Vector{Float64}, Vector{Int64}}}\n\n\nDiscretize an optimal control problem into a nonlinear optimization problem (ie direct transcription)\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.is_solvable-Tuple{Any}","page":"CTDirect.jl","title":"CTDirect.is_solvable","text":"is_solvable(ocp) -> Bool\n\n\nCheck if an OCP is solvable by the method solve.\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.set_initial_guess-Tuple{CTDirect.DOCP, Any, Any}","page":"CTDirect.jl","title":"CTDirect.set_initial_guess","text":"set_initial_guess(docp::CTDirect.DOCP, nlp, init) -> Any\n\n\nSet initial guess in the DOCP\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"","category":"page"},{"location":"api-ctbase/model.html#api-ctbase-model","page":"Model","title":"Model","text":"","category":"section"},{"location":"api-ctbase/model.html","page":"Model","title":"Model","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/model.html#Index","page":"Model","title":"Index","text":"","category":"section"},{"location":"api-ctbase/model.html","page":"Model","title":"Model","text":"Pages   = [\"model.md\"]\nModules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/model.html#Documentation","page":"Model","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/model.html","page":"Model","title":"Model","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]\nPages   = [\"model.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/model.html#CTBase.Model-Tuple{Vararg{DataType}}","page":"Model","title":"CTBase.Model","text":"Model(\n    dependencies::DataType...\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following argument:\n\ndependencies: either Autonomous or NonAutonomous. Default is Autonomous. And either NonFixed or Fixed. Default is Fixed.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(NonAutonomous)\njulia> ocp = Model(Autonomous, NonFixed)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.Model-Tuple{}","page":"Model","title":"CTBase.Model","text":"Model(\n;\n    autonomous,\n    variable\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following optional keyword argument:\n\nautonomous: either true or false. Default is true.\nvariable: either true or false. Default is false.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(autonomous=false)\njulia> ocp = Model(autonomous=false, variable=true)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol;\n    rg,\n    f,\n    lb,\n    ub,\n    val,\n    label\n)\n\n\nAdd a constraint to an optimal control problem, denoted ocp.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe initial and final times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nYou can add an :initial, :final, :control, :state or :variable box constraint (whole range). \n\nRange constraint on the state, control or variable\n\nYou can add an :initial, :final, :control, :state or :variable box constraint on a range of it, that is only on some components. If not range is specified, then the constraint is on the whole range. We denote by x, u and v respectively the state, control and variable. We denote by n, m and q respectively the dimension of the state, control and variable. The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable.\n\nExamples\n\njulia> constraint!(ocp, :initial; rg=1:2:5, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :initial; rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :final; rg=1, lb=0, ub=2)\njulia> constraint!(ocp, :control; rg=1, lb=0, ub=2)\njulia> constraint!(ocp, :state; rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :variable; rg=1:2, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :initial; lb=[ 0, 0, 0 ])                 # [ 0, 0, 0 ] ≤ x(t0),                          dim(x) = 3\njulia> constraint!(ocp, :initial; lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ]) # [ 0, 0, 0 ] ≤ x(t0) ≤ [ 1, 2, 1 ],            dim(x) = 3\njulia> constraint!(ocp, :final; lb=-1, ub=1)                      #          -1 ≤ x(tf) ≤ 1,                      dim(x) = 1\njulia> constraint!(ocp, :control; lb=0, ub=2)                     #           0 ≤ u(t)  ≤ 2,        t ∈ [t0, tf], dim(u) = 1\njulia> constraint!(ocp, :state; lb=[ 0, 0 ], ub=[ 1, 2 ])         #    [ 0, 0 ] ≤ x(t)  ≤ [ 1, 2 ], t ∈ [t0, tf], dim(x) = 2\njulia> constraint!(ocp, :variable; lb=[ 0, 0 ], ub=[ 1, 2 ])      #    [ 0, 0 ] ≤    v  ≤ [ 1, 2 ],               dim(v) = 2\n\nFunctional constraint\n\nYou can add a :boundary, :control, :state, :mixed or :variable box functional constraint.\n\nExamples\n\n# variable independent ocp\njulia> constraint!(ocp, :boundary; f = (x0, xf) -> x0[3]+xf[2], lb=0, ub=1)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary; f = (x0, xf, v) -> x0[3]+xf[2]*v[1], lb=0, ub=1)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control; f = u -> 2u, lb=0, ub=1)\njulia> constraint!(ocp, :state; f = x -> x-1, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (x, u) -> x[1]-u, lb=0, ub=1)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control; f = (t, u) -> 2u, lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (t, x) -> t * x, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (t, x, u) -> x[1]-u, lb=0, ub=1)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control; f = (u, v) -> 2u * v[1], lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (x, v) -> x * v[1], lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (x, u, v) -> x[1]-v[2]*u, lb=0, ub=1)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control; f = (t, u, v) -> 2u+v[2], lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (t, x, v) -> x-t*v[1], lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (t, x, u, v) -> x[1]*v[2]-u, lb=0, ub=1)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.constraint","text":"constraint(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    label::Symbol\n) -> Any\n\n\nRetrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds).\n\nExample\n\njulia> constraint!(ocp, :initial, 0, :c0)\njulia> c = constraint(ocp, :c0)\njulia> c(1)\n1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.constraints_labels-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.constraints_labels","text":"constraints_labels(\n    ocp::OptimalControlModel\n) -> Base.KeySet{Symbol, Dict{Symbol, Tuple}}\n\n\nReturn the labels of the constraints as a Base.keys.\n\nExample\n\njulia> constraints_labels(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.control!","page":"Model","title":"CTBase.control!","text":"control!(ocp::OptimalControlModel, m::Integer)\ncontrol!(ocp::OptimalControlModel, m::Integer, name::String)\ncontrol!(\n    ocp::OptimalControlModel,\n    m::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the control dimension and possibly the names of each coordinate.\n\nnote: Note\nYou must use control! only once to set the control dimension.\n\nExamples\n\njulia> control!(ocp, 1)\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase/model.html#CTBase.control_components_names-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.control_components_names","text":"control_components_names(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Vector{String}}\n\n\nReturn the names of the components of the control of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.control_dimension-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.control_dimension","text":"control_dimension(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimention of the control of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.control_name-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.control_name","text":"control_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the control of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.criterion-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.criterion","text":"criterion(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Symbol}\n\n\nReturn the criterion (:min or :max) of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_boundary_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_boundary_constraints","text":"dim_boundary_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of the boundary constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_control_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_control_constraints","text":"dim_control_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear control constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_control_range-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_control_range","text":"dim_control_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of range constraints on control (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_mixed_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_mixed_constraints","text":"dim_mixed_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear mixed constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_path_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_path_constraints","text":"dim_path_constraints(ocp::OptimalControlModel) -> Any\n\n\nReturn the dimension of nonlinear path (state + control + mixed) constraints (nothing if one of them is not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_state_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_state_constraints","text":"dim_state_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear state constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_state_range-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_state_range","text":"dim_state_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of range constraints on state (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_variable_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_variable_constraints","text":"dim_variable_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear variable constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dim_variable_range-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dim_variable_range","text":"dim_variable_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of range constraints on variable (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.dynamics!","text":"dynamics!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    f::Function\n)\n\n\nSet the dynamics.\n\nnote: Note\nYou can use dynamics! only once to define the dynamics.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> dynamics!(ocp, f)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.dynamics-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.dynamics","text":"dynamics(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Dynamics}\n\n\nReturn the dynamics of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.final_time-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.final_time","text":"final_time(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Index, Real}\n\n\nReturn the final time of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.final_time_name-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.final_time_name","text":"final_time_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the final time of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.has_free_final_time-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.has_free_final_time","text":"has_free_final_time(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with free final time.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.has_free_initial_time-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.has_free_initial_time","text":"has_free_initial_time(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with free initial time.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.has_lagrange_cost-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.has_lagrange_cost","text":"has_lagrange_cost(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with lagrange cost.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.has_mayer_cost-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.has_mayer_cost","text":"has_mayer_cost(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with mayer cost.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.initial_time-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.initial_time","text":"initial_time(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Index, Real}\n\n\nReturn the initial time of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.initial_time_name-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.initial_time_name","text":"initial_time_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the initial time of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_autonomous-Tuple{OptimalControlModel{Autonomous}}","page":"Model","title":"CTBase.is_autonomous","text":"is_autonomous(ocp::OptimalControlModel{Autonomous}) -> Bool\n\n\nReturn true if the model is autonomous.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_fixed-Tuple{OptimalControlModel{<:TimeDependence, Fixed}}","page":"Model","title":"CTBase.is_fixed","text":"is_fixed(\n    ocp::OptimalControlModel{<:TimeDependence, Fixed}\n) -> Bool\n\n\nReturn true if the model is fixed (= has no variable).\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_max-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_max","text":"is_max(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :max.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_min-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_min","text":"is_min(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :min.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_time_dependent-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_time_dependent","text":"is_time_dependent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_time_independent-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_time_independent","text":"is_time_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as time independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_variable_dependent-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_variable_dependent","text":"is_variable_dependent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.is_variable_independent-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_variable_independent","text":"is_variable_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as variable independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.lagrange-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.lagrange","text":"lagrange(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Lagrange}\n\n\nReturn the Lagrange part of the cost of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.mayer-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.mayer","text":"mayer(ocp::OptimalControlModel) -> Union{Nothing, Mayer}\n\n\nReturn the Mayer part of the cost of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.model_expression-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.model_expression","text":"model_expression(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Expr}\n\n\nReturn the model expression of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.nlp_constraints!-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.nlp_constraints!","text":"nlp_constraints!(\n    ocp::OptimalControlModel\n) -> Tuple{Tuple{Any, CTBase.var\"#ξ#94\", Vector{Real}}, Tuple{Any, CTBase.var\"#η#95\", Vector{Real}}, Tuple{Any, CTBase.var\"#ψ#96\", Vector{Real}}, Tuple{Any, CTBase.var\"#ϕ#97\", Vector{Real}}, Tuple{Any, CTBase.var\"#θ#98\", Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}\n\n\nReturn a 6-tuple of tuples:\n\n(ξl, ξ, ξu) are control constraints\n(ηl, η, ηu) are state constraints\n(ψl, ψ, ψu) are mixed constraints\n(ϕl, ϕ, ϕu) are boundary constraints\n(θl, θ, θu) are variable constraints\n(ul, uind, uu) are control linear constraints of a subset of indices\n(xl, xind, xu) are state linear constraints of a subset of indices\n(vl, vind, vu) are variable linear constraints of a subset of indices\n\nand update information about constraints dimensions of  ocp.\n\nnote: Note\nThe dimensions of the state and control must be set before calling nlp_constraints!.\nFor a Fixed problem, dimensions associated with constraints on the variable are set to zero.\n\nExample\n\njulia> (ξl, ξ, ξu), (ηl, η, ηu), (ψl, ψ, ψu), (ϕl, ϕ, ϕu), (θl, θ, θu),\n    (ul, uind, uu), (xl, xind, xu), (vl, vind, vu) = nlp_constraints!(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function g and f⁰. Type can be :bolza. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> objective!(ocp, :bolza, (x0, xf) -> x0[1] + xf[2], (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function f. Type can be :mayer or :lagrange. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\njulia> objective!(ocp, :mayer, (x0, xf) -> x0[1] + xf[2])\njulia> objective!(ocp, :lagrange, (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\nwarning: Warning\nIf you set twice the objective, only the last one will be taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}","page":"Model","title":"CTBase.remove_constraint!","text":"remove_constraint!(ocp::OptimalControlModel, label::Symbol)\n\n\nRemove a labeled constraint.\n\nExample\n\njulia> remove_constraint!(ocp, :con)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.state!","page":"Model","title":"CTBase.state!","text":"state!(ocp::OptimalControlModel, n::Integer)\nstate!(ocp::OptimalControlModel, n::Integer, name::String)\nstate!(\n    ocp::OptimalControlModel,\n    n::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the state dimension and possibly the names of each component.\n\nnote: Note\nYou must use state! only once to set the state dimension.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase/model.html#CTBase.state_components_names-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.state_components_names","text":"state_components_names(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Vector{String}}\n\n\nReturn the names of the components of the state of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.state_dimension-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.state_dimension","text":"state_dimension(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of the state of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.state_name-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.state_name","text":"state_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the state of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.time!-Union{Tuple{OptimalControlModel{<:TimeDependence, VT}}, Tuple{VT}} where VT","page":"Model","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel{<:TimeDependence, VT};\n    t0,\n    tf,\n    ind0,\n    indf,\n    name\n)\n\n\nSet the initial and final times. We denote by t0 the initial time and tf the final time. The optimal control problem is denoted ocp. When a time is free, then one must provide the corresponding index of the ocp variable.\n\nnote: Note\nYou must use time! only once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, t0=0,   tf=1  ) # Fixed t0 and fixed tf\njulia> time!(ocp, t0=0,   indf=2) # Fixed t0 and free  tf\njulia> time!(ocp, ind0=2, tf=1  ) # Free  t0 and fixed tf\njulia> time!(ocp, ind0=2, indf=3) # Free  t0 and free  tf\n\nWhen you plot a solution of an optimal control problem, the name of the time variable appears. By default, the name is \"t\". Consider you want to set the name of the time variable to \"s\".\n\njulia> time!(ocp, t0=0, tf=1, name=\"s\") # name is a String\n# or\njulia> time!(ocp, t0=0, tf=1, name=:s ) # name is a Symbol  \n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.time_name-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.time_name","text":"time_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the time component of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.variable!","page":"Model","title":"CTBase.variable!","text":"variable!(ocp::OptimalControlModel, q::Integer)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String\n)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the variable dimension and possibly the names of each component.\n\nnote: Note\nYou can use variable! once to set the variable dimension when the model is NonFixed.\n\nExamples\n\njulia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"v₁\", \"v₂\" ])\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase/model.html#CTBase.variable_components_names-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.variable_components_names","text":"variable_components_names(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Vector{String}}\n\n\nReturn the names of the components of the variable of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.variable_dimension-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.variable_dimension","text":"variable_dimension(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of the variable of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html#CTBase.variable_name-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.variable_name","text":"variable_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the variable of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/model.html","page":"Model","title":"Model","text":"","category":"page"},{"location":"tutorial-nlp.html#NLP-and-DOCP-manipulations","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"We describe here some more advanced operations related to the discretized optimal control problem. When calling solve(ocp) three steps are performed internally:","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"first, the OCP is discretized into a DOCP (a nonlinear optimization problem) with direct_transcription,\nthen, this DOCP is solved (with the internal function solve_docp),\nfinally, a functional solution of the OCP is rebuilt from the solution of the discretized problem, with OptimalControlSolution.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"These steps can also be done separately, for instance if you want to use your own NLP solver. ","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"Let us load the packages.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"using OptimalControl\nusing Plots","category":"page"},{"location":"tutorial-nlp.html#Definition-of-the-optimal-control-problem","page":"NLP and DOCP manipulations","title":"Definition of the optimal control problem","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"We define a test problem","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"ocp = @def begin\n\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n\n    ẋ(t) == [ x₂(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html#Discretization-and-NLP-problem","page":"NLP and DOCP manipulations","title":"Discretization and NLP problem","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"We discretize the problem.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"docp, nlp = direct_transcription(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"The DOCP contains information related to the transcription, including a copy of the original OCP, and the NLP is the resulting discretized problem, in our case an ADNLPModel.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"We can now use the solver of our choice to solve it.","category":"page"},{"location":"tutorial-nlp.html#Resolution-of-the-NLP-problem","page":"NLP and DOCP manipulations","title":"Resolution of the NLP problem","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"For a first example we use the ipopt solver from NLPModelsIpopt.jl package to solve the NLP problem.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"using NLPModelsIpopt\n\nnlp_sol = ipopt(nlp; print_level=5, mu_strategy=\"adaptive\", tol=1e-8, sb=\"yes\")\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"Then we can rebuild and plot an optimal control problem solution (note that the multipliers are optional, but the OCP costate will not be retrieved if the multipliers are not provided).","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"sol = OptimalControlSolution(docp; primal=nlp_sol.solution, dual=nlp_sol.multipliers)\nplot(sol)","category":"page"},{"location":"tutorial-nlp.html#Change-the-NLP-solver","page":"NLP and DOCP manipulations","title":"Change the NLP solver","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"Alternatively, we can use MadNLP.jl to solve anew the NLP problem:","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"using MadNLP\n\nnlp_sol = madnlp(nlp)","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"Another  possible NLP solver is Percival.jl.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"using Percival\n\nnlp_sol = percival(nlp; verbose=1)","category":"page"},{"location":"tutorial-nlp.html#Initial-guess","page":"NLP and DOCP manipulations","title":"Initial guess","text":"","category":"section"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"An initial guess, including warm start, can be passed to direct_transcription the same way as for solve.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"docp, nlp = direct_transcription(ocp; init=sol)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"It can also be changed after the transcription is done, with  set_initial_guess.","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"set_initial_guess(docp, nlp, sol)\nnothing # hide","category":"page"},{"location":"tutorial-nlp.html","page":"NLP and DOCP manipulations","title":"NLP and DOCP manipulations","text":"","category":"page"},{"location":"tutorial-plot.html#tutorial-plot","page":"Plot a solution","title":"How to plot a solution","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In this tutorial we explain the different ways to plot a solution of an optimal control problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Let us start by importing the package to define the problem and solve it.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using OptimalControl\nusing NLPModelsIpopt","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Then, we define a simple optimal control problem and solve it.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"ocp = @def begin\n\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x(0) == [-1, 0]\n    x(1) == [0, 0]\n\n    ẋ(t) == [x₂(t), u(t)]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\n\nsol = solve(ocp, display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html#First-ways-to-plot","page":"Plot a solution","title":"First ways to plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The simplest way to plot the solution is to use the plot function with only the solution as argument.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: The plot function\nThe plot function on a solution of an optimal control problem is an extension of the plot function from the package Plots.jl. Hence, we need to import this package to plot a solution.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using Plots\nplot(sol)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"As you can see, it produces a grid of subplots. The left column contains the state trajectories, the right column the costate trajectories, and at the bottom we have the control trajectory.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Attributes from Plots.jl can be passed to the plot function:","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In addition to sol you can pass attributes to the full plot, see the attributes plot documentation from Plots.jl for more details. For instance, you can specify the size of the figure.\nYou can also pass attributes to the subplots, see the attributes subplot documentation from Plots.jl for more details. However, it will affect all the subplots. For instance, you can specify the location of the legend.\nIn the same way, you can pass axis attributes to the subplots, see the attributes axis documentation from Plots.jl for more details. It will also affect all the subplots. For instance, you can remove the grid.\nIn the same way, you can pass series attributes to the all the subplots, see the attributes series documentation from Plots.jl for more details. It will also affect all the subplots. For instance, you can set the width of the curves with linewidth.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, size=(700, 450), legend=:bottomright, grid=false, linewidth=2)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To specify series attributes to a specific subplot, you can use the optional keyword arguments state_style, costate_style and control_style which correspond respectively to the state, costate and control trajectories. See the attribute series documentation from Plots.jl for more details. For instance, you can specify the color of the state trajectories and more.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; \n     state_style   = (color=:blue,), \n     costate_style = (color=:black, linestyle=:dash),\n     control_style = (color=:red, linewidth=2))","category":"page"},{"location":"tutorial-plot.html#From-Flow","page":"Plot a solution","title":"From Flow","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The previous resolution of the optimal control problem was done with the solve function. If you use an indirect shooting method and solve shooting equations, you may want to plot the  associated solution. To do so, you need to use the Flow function to  reconstruct the solution. See the Indirect Simple Shooting tutorial for an example. In our example, you must provide the maximising control (x p) mapsto p_2 together with the  optimal control problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"t0 = 0\ntf = 1\nx0 = [ -1, 0 ]\np0 = sol.costate(t0)\nf  = Flow(ocp, (x, p) -> p[2])\nsol_flow = f( (t0, tf), x0, p0 )\nplot(sol_flow)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can notice that the time grid has very few points. To have a better visualisation (the accuracy  won't change), you can give a finer grid.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"sol_flow = f( (t0, tf), x0, p0; saveat=range(t0, tf, 100) )\nplot(sol_flow)","category":"page"},{"location":"tutorial-plot.html#Split-versus-group-layout","page":"Plot a solution","title":"Split versus group layout","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"If you prefer to get a more compact figure, you can use the layout optional keyword argument with :group value. It will group the state, costate and control trajectories in one subplot for each.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; layout=:group, size=(800, 300))","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Default layout value\nThe default layout value is :split which corresponds to the grid of subplots presented above.","category":"page"},{"location":"tutorial-plot.html#Additional-plots","page":"Plot a solution","title":"Additional plots","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can plot the solution of a second optimal control problem on the same figure if it has the same number of states, costates and controls. For instance, consider the same optimal control problem but with a different initial condition.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"ocp = @def begin\n\n    t ∈ [0, 1], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x(0) == [-0.5, -0.5]\n    x(1) == [0, 0]\n\n    ẋ(t) == [x₂(t), u(t)]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nsol2 = solve(ocp; display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We first plot the solution of the first optimal control problem, then, we plot the solution of the second optimal control problem on the same figure, but with dashed lines.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"# first plot\nplt = plot(sol; solution_label=\"(sol1)\", size=(700, 500))\n\n# second plot\nplot!(plt, sol2; solution_label=\"(sol2)\", linestyle=:dash)","category":"page"},{"location":"tutorial-plot.html#Plot-the-norm-of-the-control","page":"Plot a solution","title":"Plot the norm of the control","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"For some problem, it is interesting to plot the norm of the control. You can do it by using the control optional keyword argument with :norm value. The default value is :components.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol; control=:norm, size=(800, 300), layout=:group)","category":"page"},{"location":"tutorial-plot.html#Custom-plot","page":"Plot a solution","title":"Custom plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can of course create your own plots by getting the state, costate and control from the optimal control solution. For instance, let us plot the norm of the control for the orbital transfer problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using LinearAlgebra\nt = sol.times\nx = sol.state\np = sol.costate\nu = sol.control\nplot(t, norm∘u; label=\"‖u‖\") ","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Nota bene\nThe norm function is from LinearAlgebra.jl. \nThe ∘ operator is the composition operator. Hence, norm∘u is the function t -> norm(u(t)). \nThe sol.state, sol.costate and sol.control are functions that return the state, costate and control trajectories at a given time.","category":"page"},{"location":"tutorial-plot.html#Normalized-time","page":"Plot a solution","title":"Normalized time","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We consider a LQR example and solve the problem for different values of the final time tf. Then, we plot the solutions on the same figure considering a normalized time s=(t-t_0)(t_f-t_0), thanks to the keyword argument time=:normalized of the plot function.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"\n# parameters\nx0 = [ 0\n       1 ]\n\nA  = [ 0 1\n      -1 0 ]\n\nB  = [ 0\n       1 ]\n\n# definition\nfunction lqr(tf)\n\n    ocp = @def begin\n        t ∈ [0, tf], time\n        x ∈ R², state\n        u ∈ R, control\n        x(0) == x0\n        ẋ(t) == A * x(t) + B * u(t)\n        ∫( 0.5(x₁(t)^2 + x₂(t)^2 + u(t)^2) ) → min\n    end\n\n    return ocp\nend;\n\n# solve\nsolutions = []\ntfs = [3, 5, 30]\nfor tf ∈ tfs\n    solution = solve(lqr(tf); display=false)\n    push!(solutions, solution)\nend\n\n# create plots\nplt = plot(solutions[1]; time=:normalized)\nfor sol ∈ solutions[2:end]\n    plot!(plt, sol; time=:normalized)\nend\n\n# make a custom plot from created plots: only state and control are plotted\nN = length(tfs)\npx1 = plot(plt[1]; legend=false, xlabel=\"s\", ylabel=\"x₁\")\npx2 = plot(plt[2]; label=reshape([\"tf = $tf\" for tf ∈ tfs], (1, N)), xlabel=\"s\", ylabel=\"x₂\")\npu  = plot(plt[5]; legend=false, xlabel=\"s\", ylabel=\"u\")\n\nusing Plots.PlotMeasures # for leftmargin, bottommargin\nplot(px1, px2, pu; layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"","category":"page"},{"location":"dev-ctdirect.html#dev-ctdirect","page":"CTDirect.jl","title":"CTDirect.jl private functions","text":"","category":"section"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-ctdirect.html#Index","page":"CTDirect.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Pages   = [\"dev-ctdirect.md\"]\nModules = [CTDirect]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctdirect.html#Documentation","page":"CTDirect.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"Modules = [CTDirect]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-ctdirect.html#CTBase.OptimalControlSolution-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(docp, docp_solution) -> Any\n\n\nBuild OCP functional solution from DOCP discrete solution (given as a SolverCore.GenericExecutionStats)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTBase.OptimalControlSolution-Tuple{Any}","page":"CTDirect.jl","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(\n    docp;\n    primal,\n    dual,\n    objective,\n    iterations,\n    constraints_violation,\n    message,\n    mult_LB,\n    mult_UB\n) -> Any\n\n\nBuild OCP functional solution from the DOCP discrete solution, given as a vector. Costate will be retrieved from dual variables (multipliers) if available.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.ArgsAtTimeStep","page":"CTDirect.jl","title":"CTDirect.ArgsAtTimeStep","text":"Useful values at a time step: time, state, control, dynamics...\n\n\n\n\n\n","category":"type"},{"location":"dev-ctdirect.html#CTDirect.DOCP","page":"CTDirect.jl","title":"CTDirect.DOCP","text":"Struct for discretized optimal control problem DOCP\n\nContains:\n\na copy of the original OCP\na NLP formulation of the DOCP\ndata required to link the two problems\n\n\n\n\n\n","category":"type"},{"location":"dev-ctdirect.html#CTDirect.DOCP_constraints!-Tuple{Any, Any, CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.DOCP_constraints!","text":"DOCP_constraints!(c, xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the constraints C for the DOCP problem (modeled as LB <= C(X) <= UB).\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_constraints_check!-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.DOCP_constraints_check!","text":"DOCP_constraints_check!(cb, constraints, docp)\n\n\nCheck the nonlinear constraints violation for the DOCP problem. \n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.DOCP_initial_guess","page":"CTDirect.jl","title":"CTDirect.DOCP_initial_guess","text":"DOCP_initial_guess(docp) -> Any\nDOCP_initial_guess(docp, init::OptimalControlInit) -> Any\n\n\nBuild initial guess for discretized problem\n\n\n\n\n\n","category":"function"},{"location":"dev-ctdirect.html#CTDirect.DOCP_variables_check!-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.DOCP_variables_check!","text":"DOCP_variables_check!(vb, variables, docp)\n\n\nCheck the variables box constraints violation for the DOCP problem. \n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__grid_size-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__grid_size","text":"__grid_size() -> Int64\n\n\nUsed to set the default grid size. The default value is 250.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__ipopt_linear_solver-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__ipopt_linear_solver","text":"__ipopt_linear_solver() -> String\n\n\nUsed to set the default value of the linear solver of Ipopt for the direct method. The default value is mumps.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__ipopt_mu_strategy-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__ipopt_mu_strategy","text":"__ipopt_mu_strategy() -> String\n\n\nUsed to set the default value of the μ strategy of Ipopt for the direct method. The default value is adaptive.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__ipopt_print_level-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__ipopt_print_level","text":"__ipopt_print_level() -> Int64\n\n\nUsed to set the default value of the print level of Ipopt for the direct method. The default value is 5.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__madnlp_linear_solver-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__madnlp_linear_solver","text":"__madnlp_linear_solver() -> String\n\n\nUsed to set the default value of the linear solver of MadNLP for the direct method. The default value is umfpack.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__max_iterations-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__max_iterations","text":"__max_iterations() -> Int64\n\n\nUsed to set the default maximum of iterations. The default value is 1000.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__time_grid-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__time_grid","text":"__time_grid()\n\n\nUsed to set the default time grid. The default value is nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.__tolerance-Tuple{}","page":"CTDirect.jl","title":"CTDirect.__tolerance","text":"__tolerance() -> Float64\n\n\nUsed to set the default tolerance. The default value is 1e-8.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.constraints_bounds!-Tuple{CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.constraints_bounds!","text":"constraints_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP nonlinear constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_final_time-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTDirect.get_final_time","text":"get_final_time(xu, docp) -> Any\n\n\nRetrieve final time for OCP (may be fixed or variable)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_initial_time-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTDirect.get_initial_time","text":"get_initial_time(xu, docp) -> Any\n\n\nRetrieve initial time for OCP (may be fixed or variable)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_single_variable-Tuple{Any, Any, Int64}","page":"CTDirect.jl","title":"CTDirect.get_single_variable","text":"get_single_variable(xu, docp, i::Int64) -> Any\n\n\nRetrieve a single optimization variable (no dim check). Internal layout: [X0,U0, X1,U1, .., XN,UN,V]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_time_at_time_step-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.get_time_at_time_step","text":"get_time_at_time_step(xu, docp, i) -> Any\n\n\nGet actual (un-normalized) time at give time step\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_unnormalized_time-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.get_unnormalized_time","text":"get_unnormalized_time(xu, docp, t_normalized) -> Any\n\n\nGet actual (un-normalized) time value\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.get_variable-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTDirect.get_variable","text":"get_variable(xu, docp) -> Any\n\n\nRetrieve optimization variables from the NLP variables. Internal layout: [X0,U0, X1,U1, .., XN,UN,V]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.parse_DOCP_solution_dual-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.parse_DOCP_solution_dual","text":"parse_DOCP_solution_dual(\n    docp,\n    multipliers,\n    constraints\n) -> Tuple{Any, Tuple{Any, Any, Any, Vector{Float64}, Vector{Float64}}, Tuple{Any, Any, Any, Vector{Float64}, Vector{Float64}}}\n\n\nRecover OCP costate and constraints multipliers from DOCP multipliers\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.parse_DOCP_solution_primal-Tuple{Any, Any}","page":"CTDirect.jl","title":"CTDirect.parse_DOCP_solution_primal","text":"parse_DOCP_solution_primal(\n    docp,\n    solution;\n    mult_LB,\n    mult_UB\n) -> Tuple{Any, Any, Any, Tuple{Tuple{Any, Any}, Tuple{Any, Any}, Tuple{Any, Any}}}\n\n\nRecover OCP primal variables from DOCP solution\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setPathBounds!-Tuple{CTDirect.DOCP, Int64, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setPathBounds!","text":"setPathBounds!(\n    docp::CTDirect.DOCP,\n    index::Int64,\n    lb,\n    ub\n) -> Int64\n\n\nSet bounds for the path constraints at given time step\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setPathConstraints!-Tuple{CTDirect.DOCP, Any, Int64, CTDirect.ArgsAtTimeStep, Any}","page":"CTDirect.jl","title":"CTDirect.setPathConstraints!","text":"setPathConstraints!(\n    docp::CTDirect.DOCP,\n    c,\n    index::Int64,\n    args::CTDirect.ArgsAtTimeStep,\n    v\n) -> Int64\n\n\nSet the path constraints at given time step\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setPointBounds!-Tuple{CTDirect.DOCP, Int64, Any, Any}","page":"CTDirect.jl","title":"CTDirect.setPointBounds!","text":"setPointBounds!(\n    docp::CTDirect.DOCP,\n    index::Int64,\n    lb,\n    ub\n) -> Int64\n\n\nSet bounds for the boundary and variable constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setPointConstraints!-Tuple{CTDirect.DOCP, Any, Int64, CTDirect.ArgsAtTimeStep, CTDirect.ArgsAtTimeStep, Any}","page":"CTDirect.jl","title":"CTDirect.setPointConstraints!","text":"setPointConstraints!(\n    docp::CTDirect.DOCP,\n    c,\n    index::Int64,\n    args_0::CTDirect.ArgsAtTimeStep,\n    args_f::CTDirect.ArgsAtTimeStep,\n    v\n) -> Int64\n\n\nSet the boundary and variable constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.setStateEquation!-Tuple{CTDirect.DOCP, Any, Int64, Any}","page":"CTDirect.jl","title":"CTDirect.setStateEquation!","text":"setStateEquation!(\n    docp::CTDirect.DOCP,\n    c,\n    index::Int64,\n    args_trapeze\n) -> Int64\n\n\nSet the constraints corresponding to the state equation\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_box_block!-NTuple{5, Any}","page":"CTDirect.jl","title":"CTDirect.set_box_block!","text":"set_box_block!(infos, T, mults, keys, dim) -> Any\n\n\nProcess data related to a box type for solution building\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_box_multipliers!-NTuple{5, Any}","page":"CTDirect.jl","title":"CTDirect.set_box_multipliers!","text":"set_box_multipliers!(\n    infos,\n    T,\n    box_multipliers,\n    dim_x,\n    dim_u\n) -> Any\n\n\nProcess data related to box constraints for solution building\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_constraint_block!-NTuple{4, Any}","page":"CTDirect.jl","title":"CTDirect.set_constraint_block!","text":"set_constraint_block!(infos, T, const_mult, keys) -> Any\n\n\nProcess data related to a constraint type for solution building\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_constraints_and_multipliers!-NTuple{4, Any}","page":"CTDirect.jl","title":"CTDirect.set_constraints_and_multipliers!","text":"set_constraints_and_multipliers!(\n    infos,\n    T,\n    constraints_types,\n    constraints_mult\n) -> Any\n\n\nProcess data related to constraints for solution building\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_variable!-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.set_variable!","text":"set_variable!(xu, v_init, docp) -> Any\n\n\nSet optimization variables in the NLP variables (for initial guess)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.set_variables_block!-Tuple{Any, Any, Any}","page":"CTDirect.jl","title":"CTDirect.set_variables_block!","text":"set_variables_block!(infos, vecs, keys) -> Any\n\n\nProcess data related to variables for solution building\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html#CTDirect.variables_bounds!-Tuple{CTDirect.DOCP}","page":"CTDirect.jl","title":"CTDirect.variables_bounds!","text":"variables_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP variable box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctdirect.html","page":"CTDirect.jl","title":"CTDirect.jl","text":"","category":"page"},{"location":"api-ctbase/description.html#api-ctbase-description","page":"Description","title":"Description","text":"","category":"section"},{"location":"api-ctbase/description.html","page":"Description","title":"Description","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/description.html#Index","page":"Description","title":"Index","text":"","category":"section"},{"location":"api-ctbase/description.html","page":"Description","title":"Description","text":"Pages   = [\"description.md\"]\nModules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/description.html#Documentation","page":"Description","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/description.html","page":"Description","title":"Description","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]\nPages   = [\"description.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/description.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nConcatenate the description y to the tuple of descriptions x if x does not contain y and return the new tuple of descriptions. Throw an error if the description y is already contained in x.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> descriptions = add(descriptions, (:b,))\n(:a,)\n(:b,)\njulia> descriptions = add(descriptions, (:b,))\nERROR: IncorrectArgument: the description (:b,) is already in ((:a,), (:b,))\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/description.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> print(descriptions)\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/description.html#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"Description","title":"CTBase.getFullDescription","text":"getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn a complete description from an incomplete description desc and  a list of complete descriptions desc_list. If several complete descriptions are possible,  then the first one is returned.\n\nExample\n\njulia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n(:a, :b)\n(:b, :c)\n(:a, :c)\njulia> getFullDescription((:a,), desc_list)\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/description.html#CTBase.remove-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.remove","text":"remove(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn the difference between the description x and the description y.\n\nExample\n\njulia> remove((:a, :b), (:a,))\n(:b,)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/description.html","page":"Description","title":"Description","text":"","category":"page"},{"location":"tutorial-double-integrator.html#double-int","page":"Time mininimisation","title":"Double integrator: time minimisation (abstract syntax)","text":"","category":"section"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"The problem consists in minimising the final time t_f for the double integrator system","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) quad u(t) in -11","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"and the limit conditions","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"    x(0) = (12) quad x(t_f) = (00)","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"This problem can be interpretated as a simple model for a wagon with constant mass moving along a line without fricton.","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-double-integrator.html#Optimal-control-problem","page":"Time mininimisation","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"Let us define the problem","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"ocp = @def begin\n\n    tf ∈ R,          variable\n    t ∈ [ 0, tf ],   time\n    x = (q, v) ∈ R², state\n    u ∈ R,           control\n\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n\n    q(0)  == 1\n    v(0)  == 2\n    q(tf) == 0\n    v(tf) == 0\n\n    -5 ≤ q(t) ≤ 5,          (1)\n    -3 ≤ v(t) ≤ 3,          (2)\n\n    ẋ(t) == [ v(t), u(t) ]\n\n    tf → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"tip: Convergence\nIn order to ensure convergence of the direct solver, we have added the state constraints labelled (1) and (2):-5 leq q(t) leq 5quad -3 leq v(t) leq 3quad t in  0 t_f ","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"note: Nota bene\nFor a comprehensive introduction to the syntax used above to describe the optimal control problem, check this tutorial. In particular, there are non-unicode alternatives for derivatives, integrals, etc. There is also a non-standard but more classical functional syntax, check this tutorial.","category":"page"},{"location":"tutorial-double-integrator.html#Solve-and-plot","page":"Time mininimisation","title":"Solve and plot","text":"","category":"section"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"Solve it","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"sol = solve(ocp; print_level=4)\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"and plot the solution","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"plot(sol)","category":"page"},{"location":"tutorial-double-integrator.html","page":"Time mininimisation","title":"Time mininimisation","text":"","category":"page"},{"location":"tutorial-continuation.html#Discrete-continuation","page":"Discrete continuation","title":"Discrete continuation","text":"","category":"section"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Using the warm start option, it is easy to implement a basic discrete continuation method, where a sequence of problems is solved using each solution as initial guess for the next problem. This usually gives better and faster convergence than solving each problem with the same initial guess, and is a way to handle problems that require a good initial guess.","category":"page"},{"location":"tutorial-continuation.html#Continuation-on-parametric-OCP","page":"Discrete continuation","title":"Continuation on parametric OCP","text":"","category":"section"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"The most compact syntax to perform a discrete continuation is to use a function that returns the OCP for a given value of the continuation parameter, and solve a sequence of these problems. We illustrate this on a very basic double integrator with increasing fixed final time.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"First we load the required packages","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Printf\nusing Plots","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"and write a function that returns the OCP for a given final time","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"function ocp_T(T)\n    ocp = @def begin\n        t ∈ [0, T], time\n        x ∈ R², state\n        u ∈ R, control\n        q = x₁\n        v = x₂\n        q(0) == 0\n        v(0) == 0\n        q(T) == 1\n        v(T) == 0\n        ẋ(t) == [ v(t), u(t) ]\n        ∫(u(t)^2) → min\n    end\n    return ocp\nend\nnothing # hide","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Then we perform the continuation with a simple for loop, using each solution to initialize the next problem.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"init1 = ()\nfor T=1:5\n    ocp1 = ocp_T(T) \n    sol1 = solve(ocp1; display=false, init=init1)\n    global init1 = sol1\n    @printf(\"T %.2f objective %9.6f iterations %d\\n\", T, sol1.objective, sol1.iterations)\nend","category":"page"},{"location":"tutorial-continuation.html#Continuation-on-global-variable","page":"Discrete continuation","title":"Continuation on global variable","text":"","category":"section"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"As a second example, we show how to avoid redefining a new OCP each time, and modify the original one instead. More precisely we now solve a Goddard problem for a decreasing maximal thrust. If we store the value for Tmax in a global variable, we can simply modify this variable and keep the same OCP problem during the continuation.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Let us first define the Goddard problem (note that the formulation below illustrates all the possible constraints types, and the problem could be defined in a more compact way).","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Cd = 310\nTmax = 3.5\nβ = 500\nb = 2\nfunction F0(x)\n    r, v, m = x\n    D = Cd * v^2 * exp(-β*(r - 1))\n    return [ v, -D/m - 1/r^2, 0 ]\nend\nfunction F1(x)\n    r, v, m = x\n    return [ 0, Tmax/m, -b*Tmax ]\nend\n\nocp = Model(variable=true)\n\nr0 = 1\nv0 = 0\nm0 = 1\nmf = 0.6\nx0=[r0,v0,m0]\n\nvmax = 0.1\n\nstate!(ocp, 3)\ncontrol!(ocp, 1)\nvariable!(ocp, 1)\ntime!(ocp; t0=0, indf=1)\n\nconstraint!(ocp, :initial; lb=x0, ub=x0)\nconstraint!(ocp, :final; rg=3, lb=mf, ub=Inf)\nconstraint!(ocp, :state; lb=[r0,v0,mf], ub=[r0+0.2,vmax,m0])\nconstraint!(ocp, :control; lb=0, ub=1)\nconstraint!(ocp, :variable; lb=0.01, ub=Inf)\n\nobjective!(ocp, :mayer, (x0, xf, v) -> xf[1], :max)\n\ndynamics!(ocp, (x, u, v) -> F0(x) + u*F1(x) )\n\nsol0 = solve(ocp; display=false)\n@printf(\"Objective for reference solution %.6f\\n\", sol0.objective)","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"Then we perform the continuation on the maximal thrust.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"sol       = sol0\nTmax_list = []\nobj_list  = []\nfor Tmax_local=3.5:-0.5:1\n    global Tmax = Tmax_local  \n    global sol = solve(ocp; display=false, init=sol)\n    @printf(\"Tmax %.2f objective %.6f iterations %d\\n\", Tmax, sol.objective, sol.iterations)\n    push!(Tmax_list, Tmax)\n    push!(obj_list, sol.objective)\nend ","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"We plot now the objective w.r.t the maximal thrust, as well as both solutions for Tmax=3.5 and Tmax=1.","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"using Plots.PlotMeasures # for leftmargin\n\nplt_obj = plot(Tmax_list, obj_list;\n    seriestype=:scatter,\n    title=\"Goddard problem\",\n    label=\"r(tf)\", \n    xlabel=\"Maximal thrust (Tmax)\",\n    ylabel=\"Maximal altitude r(tf)\")\n\nplt_sol = plot(sol0; solution_label=\"(Tmax = \"*string(Tmax_list[1])*\")\")\nplot!(plt_sol, sol;  solution_label=\"(Tmax = \"*string(Tmax_list[end])*\")\")\n\nlayout = grid(2, 1, heights=[0.2, 0.8])\nplot(plt_obj, plt_sol; layout=layout, size=(800, 1000), leftmargin=5mm)","category":"page"},{"location":"tutorial-continuation.html","page":"Discrete continuation","title":"Discrete continuation","text":"","category":"page"},{"location":"api-ctbase/plot.html#api-ctbase-plot","page":"Plot","title":"Plot","text":"","category":"section"},{"location":"api-ctbase/plot.html","page":"Plot","title":"Plot","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/plot.html","page":"Plot","title":"Plot","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]\nPages   = [\"plot.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/plot.html","page":"Plot","title":"Plot","text":"","category":"page"},{"location":"api-ctbase/diffgeometry.html#api-ctbase-diffegeometry","page":"Differential geometry","title":"Differential geometry","text":"","category":"section"},{"location":"api-ctbase/diffgeometry.html","page":"Differential geometry","title":"Differential geometry","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/diffgeometry.html#Index","page":"Differential geometry","title":"Index","text":"","category":"section"},{"location":"api-ctbase/diffgeometry.html","page":"Differential geometry","title":"Differential geometry","text":"Pages   = [\"diffgeometry.md\"]\nModules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/diffgeometry.html#Documentation","page":"Differential geometry","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/diffgeometry.html","page":"Differential geometry","title":"Differential geometry","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]\nPages   = [\"differential_geometry.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/diffgeometry.html#CTBase.:⋅-Tuple{Function, Function}","page":"Differential geometry","title":"CTBase.:⋅","text":"⋅(X::Function, f::Function) -> Function\n\n\nLie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.:⋅-Tuple{VectorField{Autonomous, <:VariableDependence}, Function}","page":"Differential geometry","title":"CTBase.:⋅","text":"⋅(\n    X::VectorField{Autonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#108#110\"{VectorField{Autonomous, var\"#s99\"}, <:Function} where var\"#s99\"<:VariableDependence\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in autonomous case\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.:⋅-Tuple{VectorField{NonAutonomous, <:VariableDependence}, Function}","page":"Differential geometry","title":"CTBase.:⋅","text":"⋅(\n    X::VectorField{NonAutonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#112#114\"{VectorField{NonAutonomous, var\"#s99\"}, <:Function} where var\"#s99\"<:VariableDependence\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in nonautonomous case\n\nExample\n\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lie-Tuple{Function, Function, Vararg{DataType}}","page":"Differential geometry","title":"CTBase.Lie","text":"Lie(\n    X::Function,\n    f::Function,\n    dependences::DataType...\n) -> Function\n\n\nLie derivative of a scalar function along a vector field or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, NonAutonomous, NonFixed)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lie-Tuple{Function, Function}","page":"Differential geometry","title":"CTBase.Lie","text":"Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Function\n\n\nLie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lie-Tuple{VectorField, Function}","page":"Differential geometry","title":"CTBase.Lie","text":"Lie(X::VectorField, f::Function) -> Function\n\n\nLie derivative of a scalar function along a vector field.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V<:VariableDependence","page":"Differential geometry","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{Autonomous, V<:VariableDependence},\n    Y::VectorField{Autonomous, V<:VariableDependence}\n) -> VectorField\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case\n\nExample\n\njulia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V<:VariableDependence","page":"Differential geometry","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{NonAutonomous, V<:VariableDependence},\n    Y::VectorField{NonAutonomous, V<:VariableDependence}\n) -> VectorField{NonAutonomous}\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case\n\nExample\n\njulia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lift-Tuple{Function, Vararg{DataType}}","page":"Differential geometry","title":"CTBase.Lift","text":"Lift(X::Function, dependences::DataType...) -> Function\n\n\nReturn the Lift of a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lift-Tuple{Function}","page":"Differential geometry","title":"CTBase.Lift","text":"Lift(X::Function; autonomous, variable) -> Function\n\n\nReturn the Lift of a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Lift-Tuple{VectorField}","page":"Differential geometry","title":"CTBase.Lift","text":"Lift(X::VectorField) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a VectorField.\n\nExample\n\njulia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Tuple{Function, Function, Vararg{DataType}}","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::Function,\n    dependences::DataType...\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Tuple{Function, Function}","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{Autonomous, V}, AbstractHamiltonian{Autonomous, V}}} where V<:VariableDependence","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{Autonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{Autonomous, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{NonAutonomous, V}, AbstractHamiltonian{NonAutonomous, V}}} where V<:VariableDependence","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{NonAutonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{NonAutonomous, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case\n\nExample\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{AbstractHamiltonian{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence},\n    g::Function\n) -> Hamiltonian\n\n\nPoisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{Function, AbstractHamiltonian{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence}\n) -> Hamiltonian\n\n\nPoisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","page":"Differential geometry","title":"CTBase.Poisson","text":"Poisson(\n    f::HamiltonianLift{T<:TimeDependence, V<:VariableDependence},\n    g::HamiltonianLift{T<:TimeDependence, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.∂ₜ-Tuple{Any}","page":"Differential geometry","title":"CTBase.∂ₜ","text":"∂ₜ(f) -> CTBase.var\"#117#119\"\n\n\nPartial derivative wrt time of a function.\n\nExample\n\njulia> ∂ₜ((t,x) -> t*x)(0,8)\n8\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/diffgeometry.html#CTBase.@Lie-Tuple{Expr, Any, Any}","page":"Differential geometry","title":"CTBase.@Lie","text":"Macros for Poisson brackets\n\nExample\n\njulia> H0 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7]) autonomous=true variable=false\n#\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false variable=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) autonomous=true variable=true\n#\njulia> H0 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2) autonomous=false variable=true\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase/diffgeometry.html#CTBase.@Lie-Tuple{Expr, Any}","page":"Differential geometry","title":"CTBase.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) variable=true\n#\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase/diffgeometry.html#CTBase.@Lie-Tuple{Expr}","page":"Differential geometry","title":"CTBase.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\n#\njulia> F0 = VectorField((t, x) -> [t+x[1], x[2], (1-x[3])], autonomous=false)\njulia> F1 = VectorField((t, x) -> [t, -x[3], x[2]], autonomous=false)\njulia> @Lie [F0, F1](1, [1, 2, 3])\n#\njulia> F0 = VectorField((x, v) -> [x[1]+v, x[2], (1-x[3])], variable=true)\njulia> F1 = VectorField((x, v) -> [0, -x[3]-v, x[2]], variable=true)\njulia> @Lie [F0, F1]([1, 2, 3], 2)\n#\njulia> F0 = VectorField((t, x, v) -> [t+x[1]+v, x[2], (1-x[3])], autonomous=false, variable=true)\njulia> F1 = VectorField((t, x, v) -> [t, -x[3]-v, x[2]], autonomous=false, variable=true)\njulia> @Lie [F0, F1](1, [1, 2, 3], 2)\n#\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7])\n3.0\n#\njulia> H0 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2), autonomous=false)\njulia> H1 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2), autonomous=false)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7])\n#\njulia> H0 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), variable=true)\njulia> H1 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), variable=true)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2)\n#\njulia> H0 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), autonomous=false, variable=true)\njulia> H1 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), autonomous=false, variable=true)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2)\n#\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase/diffgeometry.html","page":"Differential geometry","title":"Differential geometry","text":"","category":"page"},{"location":"api-ctbase/exceptions.html#api-ctbase-exceptions","page":"Exceptions","title":"Exceptions","text":"","category":"section"},{"location":"api-ctbase/exceptions.html","page":"Exceptions","title":"Exceptions","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/exceptions.html#Index","page":"Exceptions","title":"Index","text":"","category":"section"},{"location":"api-ctbase/exceptions.html","page":"Exceptions","title":"Exceptions","text":"Pages   = [\"exceptions.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/exceptions.html#Documentation","page":"Exceptions","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/exceptions.html","page":"Exceptions","title":"Exceptions","text":"Modules = [CTBase]\nOrder = [:module, :constant, :function, :macro]\nPages = [\"exception.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/exceptions.html","page":"Exceptions","title":"Exceptions","text":"","category":"page"},{"location":"api-ctbase/print.html#api-ctbase-print","page":"Print","title":"Print","text":"","category":"section"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]\nPages   = [\"print.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/print.html#Examples","page":"Print","title":"Examples","text":"","category":"section"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"An optimal control problem can be described as minimising the cost functional","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"g(t_0 x(t_0) t_f x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"and other constraints such as","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"Let us define the following optimal control problem.","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"using OptimalControl\n\nocp = Model()\n\nstate!(ocp, 2, \"x\", [\"r\", \"v\"]) # dimension of the state with the names of the components\ncontrol!(ocp, 1)           # dimension of the control\ntime!(ocp, t0=0, tf=1, name=\"s\")    # initial and final time, with the name of the variable time\n\nconstraint!(ocp, :initial, lb=[-1, 0], ub=[-1, 0])\nconstraint!(ocp, :final  , lb=[ 0, 0], ub=[ 0, 0])\nA = [ 0 1\n      0 0 ]\nB = [ 0\n      1 ]\ndynamics!(ocp, (x, u) -> A*x + B*u)\n\nobjective!(ocp, :lagrange, (x, u) -> 0.5u^2)","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"Then, we can print the form of this optimal control problem:","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"ocp","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"You can also define the optimal control problem in an abstract form:","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"using OptimalControl\n\n@def ocp begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R^2, state\n    u ∈ R, control\n    x(0) == [ -1, 0 ], (1)\n    x(1) == [  0, 0 ]\n    ẋ(t) == A * x(t) + B * u(t)\n    ∫( 0.5u(t)^2 ) → min\nend\nA = [ 0 1\n      0 0 ]\nB = [ 0\n      1 ]\nnothing #hide","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"Then, you can print this optimal control problem:","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"ocp","category":"page"},{"location":"api-ctbase/print.html","page":"Print","title":"Print","text":"","category":"page"},{"location":"dev-ctbase.html#dev-ctbase","page":"CTBase.jl","title":"CTBase.jl private functions","text":"","category":"section"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-ctbase.html#Index","page":"CTBase.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Pages   = [\"dev-ctbase.md\"]\nModules = [CTBase]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctbase.html#Documentation","page":"CTBase.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-ctbase.html#CTBase.DescVarArg","page":"CTBase.jl","title":"CTBase.DescVarArg","text":"DescVarArg is a Vararg of symbols. DescVarArg is a type alias for a Vararg of symbols.\n\njulia> const DescVarArg = Vararg{Symbol}\n\nSee also: Description.\n\n\n\n\n\n","category":"constant"},{"location":"dev-ctbase.html#CTBase.RangeConstraint","page":"CTBase.jl","title":"CTBase.RangeConstraint","text":"Type alias for an index or range.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.AbstractCTFunction","page":"CTBase.jl","title":"CTBase.AbstractCTFunction","text":"abstract type AbstractCTFunction <: Function\n\nAbstract type for functions.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.AbstractOptimalControlModel","page":"CTBase.jl","title":"CTBase.AbstractOptimalControlModel","text":"abstract type AbstractOptimalControlModel\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.AbstractOptimalControlSolution","page":"CTBase.jl","title":"CTBase.AbstractOptimalControlSolution","text":"abstract type AbstractOptimalControlSolution\n\nAbstract type for optimal control solutions.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.AbstractVectorField","page":"CTBase.jl","title":"CTBase.AbstractVectorField","text":"abstract type AbstractVectorField{time_dependence, variable_dependence}\n\nAbstract type for vectorfields.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.ParsingInfo","page":"CTBase.jl","title":"CTBase.ParsingInfo","text":"mutable struct ParsingInfo\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.PrintCallbacks","page":"CTBase.jl","title":"CTBase.PrintCallbacks","text":"Tuple of print callbacks.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#CTBase.StopCallbacks","page":"CTBase.jl","title":"CTBase.StopCallbacks","text":"Tuple of stop callbacks.\n\n\n\n\n\n","category":"type"},{"location":"dev-ctbase.html#Base.:\\-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Symbol}}}","page":"CTBase.jl","title":"Base.:\\","text":"\\(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn the difference between the description x and the description y.\n\nExample\n\njulia> (:a, :b) \\ (:a,)\n(:b,)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, OptimalControlModel}","page":"CTBase.jl","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::OptimalControlModel\n)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, OptimalControlSolution}","page":"CTBase.jl","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    sol::OptimalControlSolution\n)\n\n\nPrints the solution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"CTBase.jl","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    descriptions::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n)\n\n\nPrint a tuple of descriptions.\n\nExample\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, AmbiguousDescription}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::AmbiguousDescription)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, ExtensionError}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::ExtensionError)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, IncorrectArgument}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectArgument)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, IncorrectMethod}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectMethod)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, IncorrectOutput}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectOutput)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, NotImplemented}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::NotImplemented)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, ParsingError}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::ParsingError)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#Base.showerror-Tuple{IO, UnauthorizedCall}","page":"CTBase.jl","title":"Base.showerror","text":"showerror(io::IO, e::UnauthorizedCall)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.:⅋-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V<:VariableDependence","page":"CTBase.jl","title":"CTBase.:⅋","text":"⅋(\n    X::VectorField{Autonomous, V<:VariableDependence},\n    Y::VectorField{Autonomous, V<:VariableDependence}\n) -> VectorField\n\n\n\"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, autonomous case\n\nExample\n\njulia> X = VectorField(x -> [x[2], -x[1]])\njulia> Y = VectorField(x -> [x[1], x[2]])\njulia> CTBase.:(⅋)(X, Y)([1, 2])\n[2, -1]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.:⅋-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V<:VariableDependence","page":"CTBase.jl","title":"CTBase.:⅋","text":"⅋(\n    X::VectorField{NonAutonomous, V<:VariableDependence},\n    Y::VectorField{NonAutonomous, V<:VariableDependence}\n) -> VectorField{NonAutonomous}\n\n\n\"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, nonautonomous case\n\nExample\n\njulia> X = VectorField((t, x, v) -> [t + v[1] + v[2] + x[2], -x[1]], NonFixed, NonAutonomous)\njulia> Y = VectorField((t, x, v) ->  [v[1] + v[2] + x[1], x[2]], NonFixed, NonAutonomous)\njulia> CTBase.:(⅋)(X, Y)(1, [1, 2], [2, 3])\n[8, -1]\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__OptimalControlSolution-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__OptimalControlSolution","text":"__OptimalControlSolution(\n    ocp::OptimalControlModel;\n    state,\n    control,\n    objective,\n    costate,\n    times,\n    variable,\n    iterations,\n    stopping,\n    message,\n    success,\n    infos\n) -> OptimalControlSolution\n\n\nConstructor from an optimal control problem. Internal.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__callbacks-Tuple{}","page":"CTBase.jl","title":"CTBase.__callbacks","text":"__callbacks() -> Tuple{}\n\n\nUsed to set the default value of the callbacks argument. The default value is (), which means that no additional callback is given.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_all_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__check_all_set","text":"__check_all_set(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Bool}\n\n\nCheck if the parameters of an ocp are set.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_control_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__check_control_set","text":"__check_control_set(ocp::OptimalControlModel) -> Bool\n\n\nThrow UnauthorizedCall exception if the control of an ocp is not set.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_dependencies-Tuple{Tuple{Vararg{DataType}}}","page":"CTBase.jl","title":"CTBase.__check_dependencies","text":"__check_dependencies(\n    dependencies::Tuple{Vararg{DataType}}\n) -> Bool\n\n\nThrow IncorrectArgument exception if dependencies arguments are incorrect.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_is_time_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__check_is_time_set","text":"__check_is_time_set(ocp::OptimalControlModel) -> Bool\n\n\nThrow UnauthorizedCall exception if the time of an ocp is not set.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_state_set-Tuple{OptimalControlModel}","page":"CTBase.jl","title":"CTBase.__check_state_set","text":"__check_state_set(ocp::OptimalControlModel) -> Bool\n\n\nThrow UnauthorizedCall exception if the state of an ocp is not set.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_variable_set-Tuple{OptimalControlModel{<:TimeDependence, Fixed}}","page":"CTBase.jl","title":"CTBase.__check_variable_set","text":"__check_variable_set(\n    ocp::OptimalControlModel{<:TimeDependence, Fixed}\n)\n\n\nDo nothing, no variable for fixed ocp.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__check_variable_set-Tuple{OptimalControlModel{<:TimeDependence, NonFixed}}","page":"CTBase.jl","title":"CTBase.__check_variable_set","text":"__check_variable_set(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed}\n) -> Bool\n\n\nThrow UnauthorizedCall exception if the variable of an ocp is not set.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__constraint_label-Tuple{}","page":"CTBase.jl","title":"CTBase.__constraint_label","text":"__constraint_label() -> Symbol\n\n\nUsed to set the default value of the label of a constraint. A unique value is given to each constraint using the gensym function and prefixing by :unamed.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__control_components_names-Tuple{Integer, String}","page":"CTBase.jl","title":"CTBase.__control_components_names","text":"__control_components_names(m::Integer, name::String) -> Any\n\n\nUsed to set the default value of the names of the controls. The default value is [\"u\"] for a one dimensional control, and [\"u₁\", \"u₂\", ...] for a multi dimensional control.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__control_name-Tuple{}","page":"CTBase.jl","title":"CTBase.__control_name","text":"__control_name() -> String\n\n\nUsed to set the default value of the names of the control. The default value is \"u\".\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__criterion_type-Tuple{}","page":"CTBase.jl","title":"CTBase.__criterion_type","text":"__criterion_type() -> Symbol\n\n\nUsed to set the default value of the type of criterion. Either :min or :max. The default value is :min. The other possible criterion type is :max.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__display-Tuple{}","page":"CTBase.jl","title":"CTBase.__display","text":"__display() -> Bool\n\n\nUsed to set the default value of the display argument. The default value is true, which means that the output is printed during resolution.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__fun_time_dependence-Tuple{}","page":"CTBase.jl","title":"CTBase.__fun_time_dependence","text":"__fun_time_dependence() -> Type{Autonomous}\n\n\nUsed to set the default value of the time dependence of the functions.\n\nThe default value is Autonomous, which means that the functions are considered time independent. The other possible time dependence is NonAutonomous, which means that the functions are considered time dependent.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__fun_variable_dependence-Tuple{}","page":"CTBase.jl","title":"CTBase.__fun_variable_dependence","text":"__fun_variable_dependence() -> Type{Fixed}\n\n\nUsed to set the default value of the variable dependence of the functions.\n\nThe default value is Fixed, which means that the functions are considered variable independent. The other possible variable dependence is NonFixed, which means that the functions are considered variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__get_AD_backend-Tuple{}","page":"CTBase.jl","title":"CTBase.__get_AD_backend","text":"__get_AD_backend(\n\n) -> ADTypes.AutoForwardDiff{nothing, Nothing}\n\n\nUsed to set the default value of Automatic Differentiation backend.\n\nThe default value is AutoForwardDiff(), that is the ForwardDiff package is used by default.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__init_interpolation-Tuple{}","page":"CTBase.jl","title":"CTBase.__init_interpolation","text":"__init_interpolation() -> CTBase.var\"#13#14\"\n\n\nUsed to set the default interpolation function used for initialisation. The default value is Interpolations.linear_interpolation, which means that the initial guess is linearly interpolated.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__matrix_dimension_stock-Tuple{}","page":"CTBase.jl","title":"CTBase.__matrix_dimension_stock","text":"__matrix_dimension_stock() -> Int64\n\n\nUsed to set the default value of the stockage of elements in a matrix. The default value is 1.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__ocp_init-Tuple{}","page":"CTBase.jl","title":"CTBase.__ocp_init","text":"__ocp_init()\n\n\nUsed to set the default initial guess. The default value is nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__ocp_time_dependence-Tuple{}","page":"CTBase.jl","title":"CTBase.__ocp_time_dependence","text":"__ocp_time_dependence() -> Type{Autonomous}\n\n\nUsed to set the default value of the time dependence of the Optimal Control Problem. The default value is Autonomous, which means that the Optimal Control Problem is considered time independent. The other possible time dependence is NonAutonomous, which means that all the functions used to define the  Optimal Control Problem are considered time dependent.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__ocp_variable_dependence-Tuple{}","page":"CTBase.jl","title":"CTBase.__ocp_variable_dependence","text":"__ocp_variable_dependence() -> Type{Fixed}\n\n\nUsed to set the default value of the variable dependence of the Optimal Control Problem. The default value is Fixed, which means that the Optimal Control Problem is considered variable independent. The other possible variable dependence is NonFixed, which means that all the functions used to define the Optimal Control Problem are considered variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__state_components_names-Tuple{Integer, String}","page":"CTBase.jl","title":"CTBase.__state_components_names","text":"__state_components_names(n::Integer, name::String) -> Any\n\n\nUsed to set the default value of the names of the states. The default value is [\"x\"] for a one dimensional state, and [\"x₁\", \"x₂\", ...] for a multi dimensional state.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__state_name-Tuple{}","page":"CTBase.jl","title":"CTBase.__state_name","text":"__state_name() -> String\n\n\nUsed to set the default value of the name of the state. The default value is \"x\".\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__time_name-Tuple{}","page":"CTBase.jl","title":"CTBase.__time_name","text":"__time_name() -> String\n\n\nUsed to set the default value of the name of the time. The default value is t.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__variable_components_names-Tuple{Integer, String}","page":"CTBase.jl","title":"CTBase.__variable_components_names","text":"__variable_components_names(q::Integer, name::String) -> Any\n\n\nUsed to set the default value of the names of the variables. The default value is [\"v\"] for a one dimensional variable, and [\"v₁\", \"v₂\", ...] for a multi dimensional variable.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.__variable_name-Tuple{}","page":"CTBase.jl","title":"CTBase.__variable_name","text":"__variable_name() -> String\n\n\nUsed to set the default value of the names of the variables. The default value is \"v\".\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.buildFunctionalInit-Tuple{Any, Any, Any}","page":"CTBase.jl","title":"CTBase.buildFunctionalInit","text":"buildFunctionalInit(data, time, dim) -> CTBase.var\"#229#230\"\n\n\nBuild functional initialization: general interpolation case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.buildFunctionalInit-Tuple{Function, Any, Any}","page":"CTBase.jl","title":"CTBase.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Function,\n    time,\n    dim\n) -> CTBase.var\"#231#232\"{<:Function}\n\n\nBuild functional initialization: function case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.buildFunctionalInit-Tuple{Nothing, Any, Any}","page":"CTBase.jl","title":"CTBase.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Nothing,\n    time,\n    dim\n) -> CTBase.var\"#229#230\"\n\n\nBuild functional initialization: default case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.buildFunctionalInit-Tuple{Union{Real, AbstractVector{<:Real}}, Any, Any}","page":"CTBase.jl","title":"CTBase.buildFunctionalInit","text":"buildFunctionalInit(\n    data::Union{Real, AbstractVector{<:Real}},\n    time,\n    dim\n) -> Any\n\n\nBuild functional initialization: constant / 1D interpolation\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.buildVectorInit-Tuple{Any, Any}","page":"CTBase.jl","title":"CTBase.buildVectorInit","text":"buildVectorInit(data, dim) -> Any\n\n\nBuild vector initialization: default / vector case\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.checkDim-Tuple{Any, Any}","page":"CTBase.jl","title":"CTBase.checkDim","text":"checkDim(actual_dim, target_dim)\n\n\nCheck if actual dimension is equal to target dimension, error otherwise\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.ctindice-Tuple{Integer}","page":"CTBase.jl","title":"CTBase.ctindice","text":"ctindice(i::Integer) -> Char\n\n\nReturn i ∈ [0, 9] as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.ctupperscript-Tuple{Integer}","page":"CTBase.jl","title":"CTBase.ctupperscript","text":"ctupperscript(i::Integer) -> Char\n\n\nReturn i ∈ [0, 9] as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.expand-Tuple{Matrix{<:Real}}","page":"CTBase.jl","title":"CTBase.expand","text":"expand(x::Matrix{<:Real}) -> Vector{<:Real}\n\n\nReturn expand(matrix2vec(x, 1))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.expand-Tuple{Vector{<:Real}}","page":"CTBase.jl","title":"CTBase.expand","text":"expand(x::Vector{<:Real}) -> Vector{<:Real}\n\n\nReturn x.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.expand-Tuple{Vector{<:Vector{<:Real}}}","page":"CTBase.jl","title":"CTBase.expand","text":"expand(x::Vector{<:Vector{<:Real}}) -> Vector{<:Real}\n\n\nEquivalent to vec2vec(x)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.expr_it-Tuple{Any, Any, Any}","page":"CTBase.jl","title":"CTBase.expr_it","text":"expr_it(e, _Expr, f) -> Any\n\n\nExpr iterator: apply _Expr to nodes and f to leaves of the AST.\n\nExample\n\njulia> id(e) = expr_it(e, Expr, x -> x)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.formatData-Tuple{Any}","page":"CTBase.jl","title":"CTBase.formatData","text":"formatData(data) -> Any\n\n\nConvert matrix to vector of vectors (could be expanded)\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.formatTimeGrid-Tuple{Any}","page":"CTBase.jl","title":"CTBase.formatTimeGrid","text":"formatTimeGrid(time) -> Any\n\n\nConvert matrix time-grid to vector\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.has-Tuple{Any, Any, Any}","page":"CTBase.jl","title":"CTBase.has","text":"has(e, x, t) -> Union{Missing, Bool}\n\n\nReturn true if e contains a (...x...)(t) call.\n\nExample\n\njulia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, :x, :t)\ntrue\n\njulia> has(e, :u, :t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.has-Tuple{Any, Any}","page":"CTBase.jl","title":"CTBase.has","text":"has(e, e1) -> Union{Missing, Bool}\n\n\nReturn true if e contains e1.\n\nExample\n\njulia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, 2)\ntrue\n\njulia> has(e, :x)\ntrue\n\njulia> has(e, :min)\ntrue\n\njulia> has(e, :( x[1](t)^2 ))\ntrue\n\njulia> !has(e, :( x[1](t)^3 ))\ntrue\n\njulia> !has(e, 3)\ntrue\n\njulia> !has(e, :max)\ntrue\n\njulia> has(:x, :x)\ntrue\n\njulia> !has(:x, 2)\ntrue\n\njulia> !has(:x, :y)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.isaVectVect-Tuple{Any}","page":"CTBase.jl","title":"CTBase.isaVectVect","text":"isaVectVect(data) -> Bool\n\n\nReturn true if argument is a vector of vectors\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.matrix2vec","page":"CTBase.jl","title":"CTBase.matrix2vec","text":"matrix2vec(x::Matrix{<:Real}) -> Vector{<:Vector{<:Real}}\nmatrix2vec(\n    x::Matrix{<:Real},\n    dim::Integer\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms x to a Vector{<:Vector{<:ctNumber}}.\n\nNote. dim ∈ {1, 2} is the dimension along which the matrix is transformed.\n\n\n\n\n\n","category":"function"},{"location":"dev-ctbase.html#CTBase.parse!-Tuple{Any, Any, Any}","page":"CTBase.jl","title":"CTBase.parse!","text":"parse!(p, ocp, e; log) -> Union{Expr, LineNumberNode}\n\n\nParse the expression e and update the ParsingInfo structure p.\n\nExample\n\nparse!(p, :ocp, :(v ∈ R, variable))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.subs-Tuple{Any, Union{Real, Symbol}, Any}","page":"CTBase.jl","title":"CTBase.subs","text":"subs(e, e1::Union{Real, Symbol}, e2) -> Any\n\n\nSubstitute expression e1 by expression e2 in expression e.\n\nExamples\n\njulia> e = :( ∫( r(t)^2 + 2u₁(t)) → min )\n:(∫(r(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> subs(e, :r, :( x[1] ))\n:(∫((x[1])(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> e = :( ∫( u₁(t)^2 + 2u₂(t)) → min )\n:(∫(u₁(t) ^ 2 + 2 * u₂(t)) → min)\n\njulia> for i ∈ 1:2\n       e = subs(e, Symbol(:u, Char(8320+i)), :( u[$i] ))\n       end; e\n:(∫((u[1])(t) ^ 2 + 2 * (u[2])(t)) → min)\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); subs(e, :( $x[1]($(t0)) ), :( $x0[1] ))\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.vec2vec-Tuple{Vector{<:Real}, Integer}","page":"CTBase.jl","title":"CTBase.vec2vec","text":"vec2vec(\n    x::Vector{<:Real},\n    n::Integer\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms x to a Vector{<:Vector{<:ctNumber}}.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html#CTBase.vec2vec-Tuple{Vector{<:Vector{<:Real}}}","page":"CTBase.jl","title":"CTBase.vec2vec","text":"vec2vec(x::Vector{<:Vector{<:Real}}) -> Vector{<:Real}\n\n\nTransforms x to a Vector{<:ctNumber}.\n\n\n\n\n\n","category":"method"},{"location":"dev-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"page"},{"location":"tutorial-flow.html#manual-flow","page":"Flow","title":"How to compute flows","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"In this tutorial, we explain the Flow function from OptimalControl.jl package.","category":"page"},{"location":"tutorial-flow.html#Basic-usage","page":"Flow","title":"Basic usage","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Les us define a basic optimal control problem.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"using OptimalControl\n\nt0 = 0\ntf = 1\nx0 = [-1, 0]\n\nocp = @def begin\n\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == [ 0, 0 ]\n\n    ẋ(t)  == [ v(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"The pseudo-Hamiltonian of this problem is","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"    H(x p u) = p_q q + p_v v + p^0 u^2 2","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"where p^0 = -1 since we are in the normal case. From the Pontryagin maximum principle, the maximising control is given in feedback form by","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"u(x p) = p_v","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"since partial^2_uu H = p^0 = - 1  0. ","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"u(x, p) = p[2]\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Actually, if (x u) is a solution of the optimal control problem,  then, the Pontryagin maximum principle tells us that there exists a costate p such that u(t) = u(x(t) p(t)) and such that the pair (x p) satisfies:","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"beginarrayl\n    dotx(t) = displaystylephantom-nabla_p H(x(t) p(t) u(x(t) p(t))) 05em\n    dotp(t) = displaystyle         - nabla_x H(x(t) p(t) u(x(t) p(t)))\nendarray","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"The Flow function aims to compute (x p) from the optimal control problem ocp and the control in  feedback form u(x, p).","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"note: Nota bene\nActually, writing z = (x p), then the pair (x p) is also solution of    dotz(t) = vecmathbfH(z(t))where mathbfH(z) = H(z u(z)) and vecmathbfH = (nabla_p mathbfH -nabla_x mathbfH). This is what is actually computed by Flow.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Let us try to get the associated flow:","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"using OptimalControl\nt0 = 0\ntf = 1\nx0 = [-1, 0]\nocp = @def begin\n    t ∈ [ t0, tf ], time\n    x = (q, v) ∈ R², state\n    u ∈ R, control\n    x(t0) == x0\n    x(tf) == [ 0, 0 ]\n    ẋ(t)  == [ v(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend\nu(x, p) = p[2]","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"f = Flow(ocp, u)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"As you can see, an error occured since we need the package OrdinaryDiffEq.jl. This package provides numerical integrators to compute solutions of the ordinary differential equation  dotz(t) = vecmathbfH(z(t)).","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"note: OrdinaryDiffEq.jl\nThe package OrdinaryDiffEq.jl is part of DifferentialEquations.jl. You can either use one or the other.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"using OrdinaryDiffEq\n\nf = Flow(ocp, u)\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Now we have the flow of the associated Hamiltonian vector field, we can use it. Some simple calculations shows that the initial covector p(0) solution of the Pontryagin maximum principle is 12 6. Let us check that integrating the flow from (t_0 x_0) = (0 -1 0) to the final time t_f we reach the target x_f = 0 0.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"p0 = [12, 6]\nxf, pf = f(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"If you prefer to get the state, costate and control trajectories at any time, you can call the flow:","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"sol = f((t0, tf), x0, p0)\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"In this case, you obtain a data that you can plot exactly like when solving the optimal control problem  with the function solve. See for instance the basic example or the  plot tutorial.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"using Plots\n\nplot(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"You can notice from the graph of v that the integrator has made very few steps:","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"sol.times","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"To have a better visualisation (the accuracy won't change), you can provide a fine grid.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"sol = f((t0, tf), x0, p0; saveat=range(t0, tf, 100))\nplot(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"The argument saveat is an option from OrdinaryDiffEq.jl. Please check the  list of common options. For instance, one can change the integrator with the keyword argument alg or the absolute tolerance with  abstol. Note that you can set an option when declaring the flow or set an option in a particular call of the flow.  In the following example, the integrator will be BS5() and the absolute tolerance will be abstol=1e-8.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"f = Flow(ocp, u; alg=BS5(), abstol=1)   # alg=BS5(), abstol=1\nxf, pf = f(t0, x0, p0, tf; abstol=1e-8) # alg=BS5(), abstol=1e-8","category":"page"},{"location":"tutorial-flow.html#Extremals-and-trajectories","page":"Flow","title":"Extremals and trajectories","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"The pairs (x p) solution of the Hamitonian vector field are called extremals. We can compute some constructing the flow from the optimal control problem and the control in feedback form. Another way to compute extremals is  to define explicitely the Hamiltonian.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"H(x, p, u) = p[1] * x[2] + p[2] * u - 0.5 * u^2     # pseudo-Hamiltonian\nH(x, p) = H(x, p, u(x, p))                          # Hamiltonian\n\nz = Flow(Hamiltonian(H))\nxf, pf = z(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"You can also provide the Hamiltonian vector field.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Hv(x, p) = [x[2], p[2]], [0.0, -p[1]]     # Hamiltonian vector field\n\nz = Flow(HamiltonianVectorField(Hv))\nxf, pf = z(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Note that if you call the flow on tspan=(t0, tf), then you obtain the output solution  from OrdinaryDiffEq.jl.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"sol = z((t0, tf), x0, p0)\nxf, pf = sol(tf)[1:2], sol(tf)[3:4]","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"You can also compute trajectories from the control dynamics (x u) mapsto (v u) and a control law  t mapsto u(t).","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"u(t) = 6-12t\nx = Flow((t, x) -> [x[2], u(t)]; autonomous=false) # the vector field depends on t\nx(t0, x0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Again, giving a tspan you get an output solution from OrdinaryDiffEq.jl.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"sol = x((t0, tf), x0)\nplot(sol)","category":"page"},{"location":"tutorial-flow.html#Variable","page":"Flow","title":"Variable","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Let us consider an optimal control problem with a (decision / optimisation) variable.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"t0 = 0\nx0 = 0\n\nocp = @def begin\n\n    tf ∈ R, variable             # the optimisation variable is tf\n    t ∈ [t0, tf], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == 1\n    \n    ẋ(t) == tf * u(t)\n\n    tf + 0.5∫(u(t)^2) → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"As you can see, the variable is the final time tf. Note that the dynamics depends on tf. From the Pontryagin maximum principle, the solution is given by:","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"tf = (3/2)^(1/4)\np0 = 2tf/3\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"The input arguments of the maximising control are now the state x, the costate p and the variable tf.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"u(x, p, tf) = tf * p\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Let us check that the final condition x(tf) = 1 is satisfied.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"f = Flow(ocp, u)\nxf, pf = f(t0, x0, p0, tf, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"The usage of the flow f is the following: f(t0, x0, p0, tf, v) where v is the variable. If one wants to compute the state at time t1 = 0.5, then, one must write:","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"t1 = 0.5\nx1, p1 = f(t0, x0, p0, t1, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"note: Free times\nIn the particular cases: the initial time t0 is the only variable, the final time tf is the only variable, or the initial and final times t0 and tf are the only variables and are in order v=(t0, tf), the times do not need to be repeated in the call of the flow:xf, pf = f(t0, x0, p0, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Since the variable is the final time, we can make the time-reparameterisation t = t_f  s to normalise the time s in 0 1.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"ocp = @def begin\n\n    tf ∈ R, variable\n    s ∈ [0, 1], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(0) == 0\n    x(1) == 1\n    \n    ẋ(s) == tf^2 * u(s)\n\n    tf + (0.5*tf)*∫(u(s)^2) → min\n\nend\n\nf = Flow(ocp, u)\nxf, pf = f(0, x0, p0, 1, tf)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Another possibility is to add a new state variable t_f(s). The problem has no variable anymore.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"ocp = @def begin\n\n    s ∈ [0, 1], time\n    y = (x, tf) ∈ R², state\n    u ∈ R, control\n\n    x(0) == 0\n    x(1) == 1\n\n    dx = tf(s)^2 * u(s)\n    dtf = 0 * u(s) # 0\n    ẏ(s) == [dx, dtf]\n\n    tf(1) + 0.5∫(tf(s) * u(s)^2) → min\n\nend\n\nu(y, q) = y[2] * q[1]\n\nf = Flow(ocp, u)\nyf, pf = f(0, [x0, tf], [p0, 0], 1)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"danger: Bug\nNote that in the previous optimal control problem, we have dtf = 0 * u(s) instead of dtf = 0. The latter does not work.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"note: Goddard problem\nIn the Goddard problem, you may find other constructions of flows, especially for singular and boundary arcs.","category":"page"},{"location":"tutorial-flow.html#Concatenation-of-arcs","page":"Flow","title":"Concatenation of arcs","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"In this part, we present how to concatenate several flows. Let us consider the following problem.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"t0 =  0\ntf =  1\nx0 = -1\nxf =  0\n\n@def ocp begin\n\n    t ∈ [ t0, tf ], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == xf\n\n    -1 ≤ u(t) ≤ 1\n\n    ẋ(t) == -x(t) + u(t)\n\n    ∫( abs(u(t)) ) → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"From the Pontryagin maximum principle, the optimal control is a concatenation of an off arc (u=0) followed by a  positive bang arc (u=1). The initial costate is ","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"p_0 = frac1x_0 - (x_f-1) e^t_f","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"and the switching time is t_1 = -ln(p_0).","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"p0 = 1/( x0 - (xf-1) * exp(tf) )\nt1 = -log(p0)\nnothing  # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Let us define the two flows and the concatenation. Note that the concatenation of two flows is a flow.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"f0 = Flow(ocp, (x, p) -> 0)     # off arc: u = 0\nf1 = Flow(ocp, (x, p) -> 1)     # positive bang arc: u = 1\n\nf = f0 * (t1, f1)               # f0 followed by f1 whenever t ≥ t1\nnothing # hide","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"Now, we can check that the state reach the target.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"sol = f((t0, tf), x0, p0)\nplot(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"note: Goddard problem\nIn the Goddard problem, you may find more complex concatenations.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"For the moment, this concatenation is not equivalent to an exact concatenation.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"f = Flow(x ->  x)\ng = Flow(x -> -x)\n\nx0 = 1\nφ(t) = (f * (t/2, g))(0, x0, t)\nψ(t) = g(t/2, f(0, x0, t/2), t)\n\nprintln(\"φ(t) = \", abs(φ(1)-x0))\nprintln(\"ψ(t) = \", abs(ψ(1)-x0))\n\nt = range(1, 5e2, 201)\n\nplt = plot(yaxis=:log, legend=:bottomright, title=\"Comparison of concatenations\", xlabel=\"t\")\nplot!(plt, t, t->abs(φ(t)-x0), label=\"OptimalControl\")\nplot!(plt, t, t->abs(ψ(t)-x0), label=\"Classical\")","category":"page"},{"location":"tutorial-flow.html#Callbacks","page":"Flow","title":"Callbacks","text":"","category":"section"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"You can use any callback from OrdinaryDiffEq.jl. For instance, we reproduce the bouncing ball example.","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"function condition(x, t, integrator) # Event when condition(u, t, integrator) == 0\n    x[1]\nend\n\nfunction affect!(integrator)\n    integrator.u[2] = -integrator.u[2] # the state is called u\nend\n\ncb = ContinuousCallback(condition, affect!)\n\ng = 9.81\nV(x) = [x[2], -g]\nf = Flow(V; callback = cb)\n\nt0 = 0\ntf = 15\nx0 = [50, 0]\nsol = f((t0, tf), x0)\nplot(sol)","category":"page"},{"location":"tutorial-flow.html","page":"Flow","title":"Flow","text":"","category":"page"},{"location":"api-ctflows.html#CTFlows.jl","page":"CTFlows.jl","title":"CTFlows.jl","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"The CTFlows.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"flowchart TD\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctbase.html'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctdirect.html'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctflows.html'>CTFlows</a>)\nF --> B\nD --> B\nstyle F fill:#FBF275","category":"page"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-ctflows.html#Index","page":"CTFlows.jl","title":"Index","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Pages   = [\"api-ctflows.md\"]\nModules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-ctflows.html#Documentation","page":"CTFlows.jl","title":"Documentation","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Modules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"","category":"page"},{"location":"tutorial-goddard.html#goddard","page":"Goddard: direct, indirect","title":"Direct and indirect methods for the Goddard problem","text":"","category":"section"},{"location":"tutorial-goddard.html#Introduction","page":"Goddard: direct, indirect","title":"Introduction","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"<img src=\"./assets/Goddard_and_Rocket.jpg\" style=\"float: left; margin: auto 10px;\" width=\"200px\">","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"For this advanced example, we consider the well-known Goddard problem[1] [2] which models the ascent of a rocket through the atmosphere, and we restrict here ourselves to vertical (one dimensional) trajectories. The state variables are the altitude r, speed v and mass m of the rocket during the flight, for a total dimension of 3. The rocket is subject to gravity g, thrust u and drag force D (function of speed and altitude). The final time t_f is free, and the objective is to reach a maximal altitude with a bounded fuel consumption.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We thus want to solve the optimal control problem in Mayer form","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"    r(t_f) to max","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"subject to the controlled dynamics","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"    dotr = v quad\n    dotv = fracT_maxu - D(rv)m - g quad\n    dotm = -u","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"and subject to the control constraint u(t) in 01 and the state constraint v(t) leq v_max. The initial state is fixed while only the final mass is prescribed.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"note: Nota bene\nThe Hamiltonian is affine with respect to the control, so singular arcs may occur, as well as constrained arcs due to the path constraint on the velocity (see below).","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We import the OptimalControl.jl package to define the optimal control problem and NLPModelsIpopt.jl to solve it.  We import the Plots.jl package to plot the solution.  The OrdinaryDiffEq.jl package is used to  define the shooting function for the indirect method and the  NonlinearSolve.jl and  MINPACK.jl packages permit to solve the shooting  equation.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"using OptimalControl  # to define the optimal control problem and more\nusing NLPModelsIpopt  # to solve the problem via a direct method\nusing OrdinaryDiffEq  # to get the Flow function from OptimalControl\nusing NonlinearSolve  # interface to NLE solvers\nusing MINPACK         # NLE solver: use to solve the shooting equation\nusing Plots           # to plot the solution","category":"page"},{"location":"tutorial-goddard.html#Optimal-control-problem","page":"Goddard: direct, indirect","title":"Optimal control problem","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We define the problem","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"t0 = 0      # initial time\nr0 = 1      # initial altitude\nv0 = 0      # initial speed\nm0 = 1      # initial mass\nvmax = 0.1  # maximal authorized speed\nmf = 0.6    # final mass to target\n\nocp = @def begin # definition of the optimal control problem\n\n    tf ∈ R, variable\n    t ∈ [t0, tf], time\n    x = (r, v, m) ∈ R³, state\n    u ∈ R, control\n\n    x(t0) == [ r0, v0, m0 ]\n    m(tf) == mf,         (1)\n    0 ≤ u(t) ≤ 1\n    r(t) ≥ r0\n    0 ≤ v(t) ≤ vmax\n\n    ẋ(t) == F0(x(t)) + u(t) * F1(x(t))\n\n    r(tf) → max\n\nend;\n\n# Dynamics\nconst Cd = 310\nconst Tmax = 3.5\nconst β = 500\nconst b = 2\n\nF0(x) = begin\n    r, v, m = x\n    D = Cd * v^2 * exp(-β*(r - 1)) # Drag force\n    return [ v, -D/m - 1/r^2, 0 ]\nend\n\nF1(x) = begin\n    r, v, m = x\n    return [ 0, Tmax/m, -b*Tmax ]\nend\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html#Direct-method","page":"Goddard: direct, indirect","title":"Direct method","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We then solve it","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"direct_sol = solve(ocp; grid_size=100, linear_solver=\"mumps\")\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"and plot the solution","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"plt = plot(direct_sol, solution_label=\"(direct)\", size=(800, 800))","category":"page"},{"location":"tutorial-goddard.html#goddard-structure","page":"Goddard: direct, indirect","title":"Structure of the solution","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We first determine visually the structure of the optimal solution which is composed of a bang arc with maximal control, followed by a singular arc, then by a boundary arc and the final arc is with zero control. Note that the switching function vanishes along the singular and boundary arcs.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"t = direct_sol.times\nx = direct_sol.state\nu = direct_sol.control\np = direct_sol.costate\n\nH1 = Lift(F1)           # H1(x, p) = p' * F1(x)\nφ(t) = H1(x(t), p(t))   # switching function\ng(x) = vmax - x[2]      # state constraint v ≤ vmax\n\nu_plot  = plot(t, u,     label = \"u(t)\")\nH1_plot = plot(t, φ,     label = \"H₁(x(t), p(t))\")\ng_plot  = plot(t, g ∘ x, label = \"g(x(t))\")\n\nplot(u_plot, H1_plot, g_plot, layout=(3,1), size=(500, 500))","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We are now in position to solve the problem by an indirect shooting method. We first define the four control laws in feedback form and their associated flows. For this we need to compute some Lie derivatives, namely Poisson brackets of Hamiltonians (themselves obtained as lifts to the cotangent bundle of vector fields), or derivatives of functions along a vector field. For instance, the control along the minimal order singular arcs is obtained as the quotient","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"u_s = -fracH_001H_101","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"of length three Poisson brackets:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"H_001 = H_0H_0H_1 quad H_101 = H_1H_0H_1","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"where, for two Hamiltonians H and G,","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"HG = (nabla_p Hnabla_x G) - (nabla_x Hnabla_p G)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"While the Lie derivative of a function f wrt. a vector field X is simply obtained as","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"(X cdot f)(x) = f(x) cdot X(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"and is used to the compute the control along the boundary arc,","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"u_b(x) = -(F_0 cdot g)(x)  (F_1 cdot g)(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"as well as the associated multiplier for the order one state constraint on the velocity:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"mu(x p) = H_01(x p)  (F_1 cdot g)(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"note: Poisson bracket and Lie derivative\nThe Poisson bracket HG is also given by the Lie derivative of G along the Hamiltonian vector field X_H = (nabla_p H -nabla_x H) of H, that is    HG = X_H cdot Gwhich is the reason why we use the @Lie macro to compute Poisson brackets below.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"With the help of the differential geometry primitives from CTBase.jl, these expressions are straightforwardly translated into Julia code:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# Controls\nu0 = 0                                  # off control\nu1 = 1                                  # bang control\n\nH0 = Lift(F0)                           # H0(x, p) = p' * F0(x)\nH01  = @Lie { H0, H1 }\nH001 = @Lie { H0, H01 }\nH101 = @Lie { H1, H01 }\nus(x, p) = -H001(x, p) / H101(x, p)     # singular control\n\nub(x) = -(F0⋅g)(x) / (F1⋅g)(x)          # boundary control\nμ(x, p) = H01(x, p) / (F1⋅g)(x)         # multiplier associated to the state constraint g\n\n# Flows\nf0 = Flow(ocp, (x, p, tf) -> u0)\nf1 = Flow(ocp, (x, p, tf) -> u1)\nfs = Flow(ocp, (x, p, tf) -> us(x, p))\nfb = Flow(ocp, (x, p, tf) -> ub(x), (x, u, tf) -> g(x), (x, p, tf) -> μ(x, p))\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html#Shooting-function","page":"Goddard: direct, indirect","title":"Shooting function","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Then, we define the shooting function according to the optimal structure we have determined, that is a concatenation of four arcs.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"x0 = [ r0, v0, m0 ] # initial state\n\nfunction shoot!(s, p0, t1, t2, t3, tf)\n\n    x1, p1 = f1(t0, x0, p0, t1)\n    x2, p2 = fs(t1, x1, p1, t2)\n    x3, p3 = fb(t2, x2, p2, t3)\n    xf, pf = f0(t3, x3, p3, tf)\n\n    s[1] = constraint(ocp, :eq1)(x0, xf, tf) - mf # final mass constraint (1)\n    s[2:3] = pf[1:2] - [ 1, 0 ]                   # transversality conditions\n    s[4] = H1(x1, p1)                             # H1 = H01 = 0\n    s[5] = H01(x1, p1)                            # at the entrance of the singular arc\n    s[6] = g(x2)                                  # g = 0 when entering the boundary arc\n    s[7] = H0(xf, pf)                             # since tf is free\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html#Initial-guess","page":"Goddard: direct, indirect","title":"Initial guess","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"To solve the problem by an indirect shooting method, we then need a good initial guess, that is a good approximation of the initial costate, the three switching times and the final time.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"η = 1e-3\nt13 = t[ abs.(φ.(t)) .≤ η ]\nt23 = t[ 0 .≤ (g ∘ x).(t) .≤ η ]\np0 = p(t0)\nt1 = min(t13...)\nt2 = min(t23...)\nt3 = max(t23...)\ntf = t[end]\n\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\nusing LinearAlgebra: norm\ns = similar(p0, 7)\nshoot!(s, p0, t1, t2, t3, tf)\nprintln(\"\\nNorm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html#Indirect-shooting","page":"Goddard: direct, indirect","title":"Indirect shooting","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We aggregate the data to define the initial guess vector.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"ξ = [ p0 ; t1 ; t2 ; t3 ; tf ] # initial guess","category":"page"},{"location":"tutorial-goddard.html#NonlinearSolve.jl","page":"Goddard: direct, indirect","title":"NonlinearSolve.jl","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We first use the NonlinearSolve.jl package to solve the shooting equation. Let us define the problem.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# auxiliary function with aggregated inputs\nnle! = (s, ξ, λ) -> shoot!(s, ξ[1:3], ξ[4], ξ[5], ξ[6], ξ[7])\n\n# NLE problem with initial guess\nprob = NonlinearProblem(nle!, ξ)\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Let us do some benchmarking.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"using BenchmarkTools\n@benchmark solve(prob; abstol=1e-8, reltol=1e-8, show_trace=Val(false))","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"For small nonlinear systems, it could be faster to use the  SimpleNewtonRaphson() descent algorithm.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"@benchmark solve(prob, SimpleNewtonRaphson(); abstol=1e-8, reltol=1e-8, show_trace=Val(false))","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Now, let us solve the problem and retrieve the initial costate solution.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# resolution of S(ξ) = 0\nindirect_sol = solve(prob; abstol=1e-8, reltol=1e-8, show_trace=Val(true))\n\n# we retrieve the costate solution together with the times\np0 = indirect_sol.u[1:3]\nt1 = indirect_sol.u[4]\nt2 = indirect_sol.u[5]\nt3 = indirect_sol.u[6]\ntf = indirect_sol.u[7]\n\nprintln(\"\")\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\ns = similar(p0, 7)\nshoot!(s, p0, t1, t2, t3, tf)\nprintln(\"\\nNorm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html#MINPACK.jl","page":"Goddard: direct, indirect","title":"MINPACK.jl","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"using MINPACK\nfunction fsolve(f, j, x; kwargs...)\n    try\n        MINPACK.fsolve(f, j, x; kwargs...)\n    catch e\n        println(\"Erreur using MINPACK\")\n        println(e)\n        println(\"hybrj not supported. Replaced by hybrd even if it is not visible on the doc.\")\n        MINPACK.fsolve(f, x; kwargs...)\n    end\nend","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Instead of the NonlinearSolve.jl package we can use the  MINPACK.jl package to solve  the shooting equation. To compute the Jacobian of the shooting function we use the  DifferentiationInterface.jl package with  ForwardDiff.jl backend.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"using DifferentiationInterface\nimport ForwardDiff\nbackend = AutoForwardDiff()\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Let us define the problem to solve.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# auxiliary function with aggregated inputs\nnle!  = ( s, ξ) -> shoot!(s, ξ[1:3], ξ[4], ξ[5], ξ[6], ξ[7])\n\n # Jacobian of the (auxiliary) shooting function\njnle! = (js, ξ) -> jacobian!(nle!, similar(ξ), js, backend, ξ)\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We are now in position to solve the problem with the hybrj solver from MINPACK.jl through the fsolve  function, providing the Jacobian. Let us do some benchmarking.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"@benchmark fsolve(nle!, jnle!, ξ; show_trace=false) # initial guess given to the solver","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We can also use the preparation step of DifferentiationInterface.jl.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"extras = prepare_jacobian(nle!, similar(ξ), backend, ξ)\njnle_prepared!(js, ξ) = jacobian!(nle!, similar(ξ), js, backend, ξ, extras)\n@benchmark fsolve(nle!, jnle_prepared!, ξ; show_trace=false)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"Now, let us solve the problem and retrieve the initial costate solution.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"# resolution of S(ξ) = 0\nindirect_sol = fsolve(nle!, jnle!, ξ, show_trace=true)\n\n# we retrieve the costate solution together with the times\np0 = indirect_sol.x[1:3]\nt1 = indirect_sol.x[4]\nt2 = indirect_sol.x[5]\nt3 = indirect_sol.x[6]\ntf = indirect_sol.x[7]\n\nprintln(\"\")\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\ns = similar(p0, 7)\nshoot!(s, p0, t1, t2, t3, tf)\nprintln(\"\\nNorm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html#goddard-plot","page":"Goddard: direct, indirect","title":"Plot of the solution","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"We plot the solution of the indirect solution (in red) over the solution of the direct method  (in blue).","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"f = f1 * (t1, fs) * (t2, fb) * (t3, f0) # concatenation of the flows\nflow_sol = f((t0, tf), x0, p0)          # compute the solution: state, costate, control...\n\nplot!(plt, flow_sol, solution_label=\"(indirect)\")","category":"page"},{"location":"tutorial-goddard.html#References","page":"Goddard: direct, indirect","title":"References","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"[1]: R.H. Goddard. A Method of Reaching Extreme Altitudes, volume 71(2) of Smithsonian Miscellaneous Collections. Smithsonian institution, City of Washington, 1919.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"[2]: H. Seywald and E.M. Cliff. Goddard problem in presence of a dynamic pressure limit. Journal of Guidance, Control, and Dynamics, 16(4):776–781, 1993.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard: direct, indirect","title":"Goddard: direct, indirect","text":"","category":"page"},{"location":"dev-ctflows.html#dev-ctflows","page":"CTFlows.jl","title":"CTFlows.jl private functions","text":"","category":"section"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-ctflows.html#Index","page":"CTFlows.jl","title":"Index","text":"","category":"section"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Pages   = [\"dev-ctflows.md\"]\nModules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-ctflows.html#Documentation","page":"CTFlows.jl","title":"Documentation","text":"","category":"section"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"Modules = [CTFlows]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{Dynamics, ControlLaw, Lagrange, Real, Real, MixedConstraint, Multiplier}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::Dynamics,\n    u::ControlLaw,\n    f⁰::Lagrange,\n    p⁰::Real,\n    s::Real,\n    g::MixedConstraint,\n    μ::Multiplier\n) -> CTFlows.var\"#H#22\"{Dynamics{time_dependence, variable_dependence}, ControlLaw{time_dependence1, variable_dependence1}, Lagrange{time_dependence2, variable_dependence2}, var\"#s178\", var\"#s1781\", MixedConstraint{time_dependence3, variable_dependence3}, Multiplier{time_dependence4, variable_dependence4}} where {time_dependence, variable_dependence, time_dependence1, variable_dependence1, time_dependence2, variable_dependence2, var\"#s178\"<:Real, var\"#s1781\"<:Real, time_dependence3, variable_dependence3, time_dependence4, variable_dependence4}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{Dynamics, ControlLaw, Lagrange, Real, Real}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::Dynamics,\n    u::ControlLaw,\n    f⁰::Lagrange,\n    p⁰::Real,\n    s::Real\n) -> CTFlows.var\"#H#20\"{Dynamics{time_dependence, variable_dependence}, ControlLaw{time_dependence1, variable_dependence1}, Lagrange{time_dependence2, variable_dependence2}, <:Real, <:Real} where {time_dependence, variable_dependence, time_dependence1, variable_dependence1, time_dependence2, variable_dependence2}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{Dynamics, ControlLaw, MixedConstraint, Multiplier}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::Dynamics,\n    u::ControlLaw,\n    g::MixedConstraint,\n    μ::Multiplier\n) -> CTFlows.var\"#H#21\"{Dynamics{time_dependence, variable_dependence}, ControlLaw{time_dependence1, variable_dependence1}, MixedConstraint{time_dependence2, variable_dependence2}, Multiplier{time_dependence3, variable_dependence3}} where {time_dependence, variable_dependence, time_dependence1, variable_dependence1, time_dependence2, variable_dependence2, time_dependence3, variable_dependence3}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html#CTFlows.makeH-Tuple{Dynamics, ControlLaw}","page":"CTFlows.jl","title":"CTFlows.makeH","text":"makeH(\n    f::Dynamics,\n    u::ControlLaw\n) -> CTFlows.var\"#18#19\"{Dynamics{time_dependence, variable_dependence}, ControlLaw{time_dependence1, variable_dependence1}} where {time_dependence, variable_dependence, time_dependence1, variable_dependence1}\n\n\nConstructs the Hamiltonian: \n\nH(t, x, p) = p f(t, x, u(t, x, p))\n\n\n\n\n\n","category":"method"},{"location":"dev-ctflows.html","page":"CTFlows.jl","title":"CTFlows.jl","text":"","category":"page"},{"location":"tutorial-functional.html#functional","page":"Functional syntax","title":"The functional syntax to define an optimal control problem","text":"","category":"section"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"There are two syntaxes to define an optimal control problem with OptimalControl.jl:","category":"page"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"the standard way is to use the abstract syntax. See for instance basic example for a start or for a comprehensive introduction to the abstract syntax, check this tutorial.\nthe old-fashioned functional syntax. In this tutorial with give two examples defined with the functional syntax. For more details please check the Model documentation.","category":"page"},{"location":"tutorial-functional.html#Double-integrator:-energy-minimisation","page":"Functional syntax","title":"Double integrator: energy minimisation","text":"","category":"section"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force u. We denote by x = (x_1 x_2) the state of the wagon, that is its position x_1 and its velocity x_2.","category":"page"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"We assume that the mass is constant and unitary and that there is no friction. The dynamics we consider is given by","category":"page"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) quad u(t) in R","category":"page"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"which is simply the double integrator system. Les us consider a transfer starting at time t_0 = 0 and ending at time t_f = 1, for which we want to minimise the transfer energy","category":"page"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"    frac12int_0^1 u^2(t)  mathrmdt","category":"page"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"starting from the condition x(0) = (-1 0) and with the goal to reach the target x(1) = (0 0).","category":"page"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"Let us define the problem with the functional syntax.","category":"page"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"using OptimalControl\n\nocp = Model()                                   # empty optimal control problem\n\ntime!(ocp, t0=0, tf=1)                          # initial and final times\nstate!(ocp, 2)                                  # dimension of the state\ncontrol!(ocp, 1)                                # dimension of the control\n\nconstraint!(ocp, :initial; val=[ -1, 0 ])       # initial condition\nconstraint!(ocp, :final;   val=[  0, 0 ])       # final condition\n\ndynamics!(ocp, (x, u) -> [ x[2], u ])           # dynamics of the double integrator\n\nobjective!(ocp, :lagrange, (x, u) -> 0.5u^2)    # cost in Lagrange form\nnothing # hide","category":"page"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"note: Nota bene\nThis problem is defined with the abstract syntax here.","category":"page"},{"location":"tutorial-functional.html#Double-integrator:-time-minimisation","page":"Functional syntax","title":"Double integrator: time minimisation","text":"","category":"section"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"We consider the same optimal control problem where we replace the cost. Instead of minimisation the L2-norm of the control, we consider the time minimisation problem, that is we minimise the final time t_f.","category":"page"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"ocp = Model(variable=true)                       # variable is true since tf is free\n\nvariable!(ocp, 1, :tf)                           # dimension and name of the variable\ntime!(ocp, t0=0, indf=1)                         # initial time fixed to 0\n                                                 # final time free and corresponds to the\n                                                 # first component of the variable\nstate!(ocp, 2, :x, [:q, :v])                     # dimension of the state with names\ncontrol!(ocp, 1)                                 # dimension of the control\n\nconstraint!(ocp, :variable; lb=0)                # tf ≥ 0\nconstraint!(ocp, :control; lb=-1, ub=1)          # -1 ≤ u(t) ≤ 1\nconstraint!(ocp, :initial; val=[ 1, 2 ])         # initial condition\nconstraint!(ocp, :final;   val=[ 0, 0 ])         # final condition\nconstraint!(ocp, :state; lb=[-5, -3], ub=[5, 3]) # -5 ≤ q(t) ≤ 5, -3 ≤ v(t) ≤ 3\n\ndynamics!(ocp, (x, u, tf) -> [ x[2], u ])        # dynamics of the double integrator\n\nobjective!(ocp, :mayer, (x0, xf, tf) -> tf)      # cost in Mayer form\nnothing # hide","category":"page"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"note: Nota bene\nThis problem is defined with the abstract syntax here.","category":"page"},{"location":"tutorial-functional.html","page":"Functional syntax","title":"Functional syntax","text":"","category":"page"},{"location":"api-ctbase/repl.html#api-ctbase-repl","page":"Repl","title":"Repl","text":"","category":"section"},{"location":"api-ctbase/repl.html","page":"Repl","title":"Repl","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/repl.html#Index","page":"Repl","title":"Index","text":"","category":"section"},{"location":"api-ctbase/repl.html","page":"Repl","title":"Repl","text":"Pages   = [\"repl.md\"]\nModules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/repl.html#Documentation","page":"Repl","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/repl.html","page":"Repl","title":"Repl","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]\nPages   = [\"repl.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/repl.html#CTBase.ct_repl-Tuple{}","page":"Repl","title":"CTBase.ct_repl","text":"ct_repl(; debug, verbose)\n\n\nCreate a ct REPL.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/repl.html#CTBase.ct_repl_update_model-Tuple{Expr}","page":"Repl","title":"CTBase.ct_repl_update_model","text":"ct_repl_update_model(e::Expr)\n\n\nUpdate the model adding the expression e. It must be public since in the ct repl, this function  is quoted each time an expression is parsed and is valid. \n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/repl.html","page":"Repl","title":"Repl","text":"","category":"page"},{"location":"tutorial-initial-guess.html#tutorial-init","page":"Initial guess","title":"Initial guess (or iterate) for the resolution","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"We present in this tutorial the different possibilities to provide an initial guess to solve an  optimal control problem with the OptimalControl.jl package. ","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"First, we need to import the OptimalControl.jl package to define the  optimal control problem and NLPModelsIpopt.jl to solve it.  We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"For the illustrations, we define the following optimal control problem.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"t0 = 0\ntf = 10\nα  = 5\n\nocp = @def begin\n    t ∈ [t0, tf], time\n    v ∈ R, variable\n    x ∈ R², state\n    u ∈ R, control\n    x(t0) == [ -1, 0 ]\n    x(tf) - [ 0, v ] == [0, 0]\n    ẋ(t) == [ x₂(t), x₁(t) + α*x₁(t)^2 + u(t) ]\n    v^2 + ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Default-initial-guess","page":"Initial guess","title":"Default initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"We first solve the problem without giving an initial guess. This will default to initialize all variables to 0.1.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# solve the optimal control problem without initial guess\nsol = solve(ocp; display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Let us plot the solution of the optimal control problem.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"plot(sol; size=(600, 450))","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Note that the following formulations are equivalent to not giving an initial guess.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"sol = solve(ocp; init=nothing, display=false)\nprintln(\"Number of iterations: \", sol.iterations)\n\nsol = solve(ocp; init=(), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"To reduce the number of iterations and improve the convergence, we can give an initial guess to the solver.  This initial guess can be built from constant values, interpolated vectors, functions, or existing solutions. Except when initializing from a solution, the arguments are to be passed as a named tuple init=(state=..., control=..., variable=...) whose fields are optional. Missing fields will revert to default initialization (ie constant 0.1).","category":"page"},{"location":"tutorial-initial-guess.html#Constant-initial-guess","page":"Initial guess","title":"Constant initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"We first illustrate the constant initial guess, using vectors or scalars according to the dimension.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# solve the optimal control problem with initial guess with constant values\nsol = solve(ocp; init=(state=[-0.2, 0.1], control=-0.2, variable=0.05), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Partial initializations are also valid, as shown below. Note the ending comma when a single argument is passed (tuple).","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# initialisation only on the state\nsol = solve(ocp; init=(state=[-0.2, 0.1],), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\n\n# initialisation only on the control\nsol = solve(ocp; init=(control=-0.2,), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\n\n# initialisation only on the state and the variable\nsol = solve(ocp; init=(state=[-0.2, 0.1], variable=0.05), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Functional-initial-guess","page":"Initial guess","title":"Functional initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"For the state and control, we can also provide functions of time as initial guess.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# initial guess as functions of time\nx(t) = [ -0.2t, 0.1t ]\nu(t) = -0.2t\n\nsol = solve(ocp; init=(state=x, control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Vector-initial-guess-(interpolated)","page":"Initial guess","title":"Vector initial guess (interpolated)","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Initialization can also be provided with vectors / matrices to be interpolated along a given time grid.  In this case the time steps must be given through an additional argument time, which can be a vector or line/column matrix. For the values to be interpolated both matrices and vectors of vectors are allowed, but the shape should be number of time steps x variable dimension. Simple vectors are also allowed for variables of dimension 1.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# initial guess as vector of points\nt_vec = LinRange(t0,tf,4)\nx_vec = [[0, 0], [-0.1, 0.3], [-0.15,0.4], [-0.3, 0.5]]\nu_vec = [0, -0.8,  -0.3, 0]\n\nsol = solve(ocp; init=(time=t_vec, state=x_vec, control=u_vec, variable=0.05), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Note: in the free final time case, the given time grid should be consistent with the initial guess provided for the final time (in the optimization variables).","category":"page"},{"location":"tutorial-initial-guess.html#Mixed-initial-guess","page":"Initial guess","title":"Mixed initial guess","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"The constant, functional and vector initializations can be mixed, for instance as","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# we can mix constant values with functions of time\nsol = solve(ocp; init=(state=[-0.2, 0.1], control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\n\n# wa can mix every possibility\nsol = solve(ocp; init=(time=t_vec, state=x_vec, control=u, variable=0.05), display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Solution-as-initial-guess-(warm-start)","page":"Initial guess","title":"Solution as initial guess (warm start)","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Finally, we can use an existing solution to provide the initial guess.  The dimensions of the state, control and optimization variable must coincide. This particular feature allows an easy implementation of discrete continuations.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# generate the initial solution\nsol_init = solve(ocp; display=false)\n\n# solve the problem using solution as initial guess\nsol = solve(ocp; init=sol_init, display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"Note that you can also manually pick and choose which data to reuse from a solution, by recovering the  functions sol.state, sol.control and the values sol.variable. For instance the following formulation is equivalent to the init=sol one.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"# use a previous solution to initialise picking data\nsol = solve(ocp; \n    init = (\n        state    = sol.state, \n        control  = sol.control, \n        variable = sol.variable\n    ), \n    display=false)\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-initial-guess.html#Costate-/-multipliers","page":"Initial guess","title":"Costate / multipliers","text":"","category":"section"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"For the moment we can not provide an initial guess for the costate / multipliers.","category":"page"},{"location":"tutorial-initial-guess.html","page":"Initial guess","title":"Initial guess","text":"","category":"page"},{"location":"api-ctbase/types.html#api-ctbase-types","page":"Types","title":"Types","text":"","category":"section"},{"location":"api-ctbase/types.html","page":"Types","title":"Types","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/types.html#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"api-ctbase/types.html","page":"Types","title":"Types","text":"Pages   = [\"types.md\"]\nModules = [CTBase]\nOrder   = [:type]","category":"page"},{"location":"api-ctbase/types.html#Documentation","page":"Types","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/types.html","page":"Types","title":"Types","text":"Modules = [CTBase]\nOrder   = [:type]\nPrivate = false","category":"page"},{"location":"api-ctbase/types.html#CTBase.AbstractHamiltonian","page":"Types","title":"CTBase.AbstractHamiltonian","text":"abstract type AbstractHamiltonian{time_dependence, variable_dependence}\n\nAbstract type for hamiltonians.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.AmbiguousDescription","page":"Types","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTException\n\nException thrown when the description is ambiguous / incorrect.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Autonomous","page":"Types","title":"CTBase.Autonomous","text":"abstract type Autonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.BoundaryConstraint","page":"Types","title":"CTBase.BoundaryConstraint","text":"struct BoundaryConstraint{variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor BoundaryConstraint returns a BoundaryConstraint of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar. When the constraint is dimension 1, return a scalar.\n\nCall\n\nThe call returns the evaluation of the BoundaryConstraint for given values. If a variable is given for a non variable dependent boundary constraint, it will be ignored.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.BoundaryConstraint-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.BoundaryConstraint","text":"BoundaryConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> BoundaryConstraint{Fixed}\n\n\nReturn a BoundaryConstraint of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.BoundaryConstraint-Tuple{Function}","page":"Types","title":"CTBase.BoundaryConstraint","text":"BoundaryConstraint(\n    f::Function;\n    variable\n) -> BoundaryConstraint{Fixed}\n\n\nReturn a BoundaryConstraint of a function. Dependencies are specified with a boolean, variable, false by default.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.BoundaryConstraint","text":"Return the evaluation of the BoundaryConstraint.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.CTCallback","page":"Types","title":"CTBase.CTCallback","text":"abstract type CTCallback\n\nAbstract type for callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.CTCallbacks","page":"Types","title":"CTBase.CTCallbacks","text":"Tuple of callbacks\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.CTException","page":"Types","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract type for exceptions.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.ControlConstraint","page":"Types","title":"CTBase.ControlConstraint","text":"struct ControlConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlConstraint returns a ControlConstraint of a function. The function must take 1 to 3 arguments, u to (t, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the control is of dimension 1, consider u as a scalar.\n\nCall\n\nThe call returns the evaluation of the ControlConstraint for given values.\n\nExamples\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.ControlConstraint-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> ControlConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlConstraint-Tuple{Function}","page":"Types","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlConstraint{Autonomous, Fixed}\n\n\nReturn the ControlConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.ControlConstraint","text":"Return the value of the ControlConstraint function.\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlLaw","page":"Types","title":"CTBase.ControlLaw","text":"struct ControlLaw{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to Hamiltonian in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlLaw returns a ControlLaw of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the ControlLaw for given values.\n\nExamples\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.ControlLaw-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.ControlLaw","text":"ControlLaw(\n    f::Function,\n    dependencies::DataType...\n) -> ControlLaw{Autonomous, Fixed}\n\n\nReturn the ControlLaw of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlLaw-Tuple{Function}","page":"Types","title":"CTBase.ControlLaw","text":"ControlLaw(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlLaw{Autonomous, Fixed}\n\n\nReturn the ControlLaw of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ControlLaw-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.ControlLaw","text":"Return the value of the ControlLaw function.\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Controls","page":"Types","title":"CTBase.Controls","text":"Type alias for a vector of controls.\n\njulia> const Controls = AbstractVector{<:Control}\n\nSee also: Control, States, Costates.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Costates","page":"Types","title":"CTBase.Costates","text":"Type alias for a vector of costates.\n\njulia> const Costates = AbstractVector{<:Costate}\n\nSee also: Costate, States, Controls.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Description","page":"Types","title":"CTBase.Description","text":"A description is a tuple of symbols. Description is a type alias for a tuple of symbols.\n\njulia> const Description = Tuple{DescVarArg}\n\nSee also: DescVarArg.\n\nExample\n\nBase.show is overloaded for descriptions, that is tuple of descriptions are printed as follows:\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Dimension","page":"Types","title":"CTBase.Dimension","text":"Type alias for a dimension. This is used to define the dimension of the state space,  the costate space, the control space, etc.\n\njulia> const Dimension = Integer\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Dynamics","page":"Types","title":"CTBase.Dynamics","text":"struct Dynamics{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Dynamics returns a Dynamics of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Dynamics for given values.\n\nExamples\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Dynamics-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.Dynamics","text":"Dynamics(\n    f::Function,\n    dependencies::DataType...\n) -> Dynamics{Autonomous, Fixed}\n\n\nReturn the Dynamics of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Dynamics-Tuple{Function}","page":"Types","title":"CTBase.Dynamics","text":"Dynamics(\n    f::Function;\n    autonomous,\n    variable\n) -> Dynamics{Autonomous, Fixed}\n\n\nReturn the Dynamics of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Dynamics-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.Dynamics","text":"Return the value of the Dynamics function.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ExtensionError","page":"Types","title":"CTBase.ExtensionError","text":"mutable struct ExtensionError <: CTException\n\nException thrown when an extension is not loaded but the user tries to call a function of it.\n\nFields\n\nweakdeps::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.FeedbackControl","page":"Types","title":"CTBase.FeedbackControl","text":"struct FeedbackControl{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor FeedbackControl returns a FeedbackControl of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the FeedbackControl for given values.\n\nExamples\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.FeedbackControl-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function,\n    dependencies::DataType...\n) -> FeedbackControl{Autonomous, Fixed}\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.FeedbackControl-Tuple{Function}","page":"Types","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function;\n    autonomous,\n    variable\n) -> FeedbackControl{Autonomous, Fixed}\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.FeedbackControl-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.FeedbackControl","text":"Return the value of the FeedbackControl function.\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Fixed","page":"Types","title":"CTBase.Fixed","text":"abstract type Fixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Hamiltonian","page":"Types","title":"CTBase.Hamiltonian","text":"struct Hamiltonian{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Hamiltonian returns a Hamiltonian of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Hamiltonian for given values.\n\nExamples\n\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Hamiltonian-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function,\n    dependencies::DataType...\n) -> Hamiltonian{Autonomous, Fixed}\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Hamiltonian-Tuple{Function}","page":"Types","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function;\n    autonomous,\n    variable\n) -> Hamiltonian{Autonomous, Fixed}\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Hamiltonian-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.Hamiltonian","text":"Return the value of the Hamiltonian.\n\njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianLift","page":"Types","title":"CTBase.HamiltonianLift","text":"struct HamiltonianLift{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence}\n\nLifts\n\nX::VectorField\n\nThe values for time_dependence and variable_dependence are deternimed by the values of those for the VectorField.\n\nConstructor\n\nThe constructor HamiltonianLift returns a HamiltonianLift of a VectorField.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed))\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianLift for given values.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\nAlternatively, it is possible to construct the HamiltonianLift from a Function being the VectorField.\n\njulia> HL1 = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL2 = HamiltonianLift(VectorField((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true))\njulia> HL1([1, 0], [0, 1], 1) == HL2([1, 0], [0, 1], 1)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.HamiltonianLift-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], Autonomous, Fixed)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], Autonomous, NonFixed)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], NonAutonomous, Fixed)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianLift-Tuple{Function}","page":"Types","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianLift\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], autonomous=false, variable=false)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianLift-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.HamiltonianLift","text":"Return the value of the HamiltonianLift.\n\nExamples\n\njulia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianVectorField","page":"Types","title":"CTBase.HamiltonianVectorField","text":"struct HamiltonianVectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor HamiltonianVectorField returns a HamiltonianVectorField of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianVectorField for given values.\n\nExamples\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.HamiltonianVectorField-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function,\n    dependencies::DataType...\n) -> HamiltonianVectorField{Autonomous, Fixed}\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianVectorField-Tuple{Function}","page":"Types","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianVectorField{Autonomous, Fixed}\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.HamiltonianVectorField-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.HamiltonianVectorField","text":"Return the value of the HamiltonianVectorField.\n\nExamples\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.IncorrectArgument","page":"Types","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTException\n\nException thrown when an argument is inconsistent.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.IncorrectMethod","page":"Types","title":"CTBase.IncorrectMethod","text":"struct IncorrectMethod <: CTException\n\nException thrown when a method is incorrect.\n\nFields\n\nvar::Symbol\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.IncorrectOutput","page":"Types","title":"CTBase.IncorrectOutput","text":"struct IncorrectOutput <: CTException\n\nException thrown when the output is incorrect.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Index","page":"Types","title":"CTBase.Index","text":"mutable struct Index\n\nFields\n\nval::Int64\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Lagrange","page":"Types","title":"CTBase.Lagrange","text":"struct Lagrange{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Lagrange returns a Lagrange cost of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], Autonomous, Fixed)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, Autonomous, Fixed)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], Autonomous, NonFixed)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, Fixed)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Lagrange cost for given values.\n\nExamples\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Lagrange-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.Lagrange","text":"Lagrange(\n    f::Function,\n    dependencies::DataType...\n) -> Lagrange{Autonomous, Fixed}\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Lagrange-Tuple{Function}","page":"Types","title":"CTBase.Lagrange","text":"Lagrange(\n    f::Function;\n    autonomous,\n    variable\n) -> Lagrange{Autonomous, Fixed}\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Lagrange-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.Lagrange","text":"Return the value of the Lagrange function.\n\nExamples\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Mayer","page":"Types","title":"CTBase.Mayer","text":"struct Mayer{variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor Mayer returns a Mayer cost of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar.\n\nCall\n\nThe call returns the evaluation of the Mayer cost for given values. If a variable is given for a non variable dependent Mayer cost, it will be ignored.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1],Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Mayer-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.Mayer","text":"Mayer(\n    f::Function,\n    dependencies::DataType...\n) -> Mayer{Fixed}\n\n\nReturn a Mayer cost of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Mayer-Tuple{Function}","page":"Types","title":"CTBase.Mayer","text":"Mayer(f::Function; variable) -> Mayer{Fixed}\n\n\nReturn a Mayer cost of a function. Dependencies are specified with a boolean, variable, false by default.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Mayer-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.Mayer","text":"Return the evaluation of the Mayer cost.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1], Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.MixedConstraint","page":"Types","title":"CTBase.MixedConstraint","text":"struct MixedConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to Lagrange in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor MixedConstraint returns a MixedConstraint of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the MixedConstraint for given values.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.MixedConstraint-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> MixedConstraint{Autonomous, Fixed}\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.MixedConstraint-Tuple{Function}","page":"Types","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> MixedConstraint{Autonomous, Fixed}\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.MixedConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.MixedConstraint","text":"Return the value of the MixedConstraint function.\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Multiplier","page":"Types","title":"CTBase.Multiplier","text":"struct Multiplier{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to ControlLaw in the usage.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Multiplier returns a Multiplier of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Multiplier for given values.\n\nExamples\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Multiplier-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.Multiplier","text":"Multiplier(\n    f::Function,\n    dependencies::DataType...\n) -> Multiplier{Autonomous, Fixed}\n\n\nReturn the Multiplier of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Multiplier-Tuple{Function}","page":"Types","title":"CTBase.Multiplier","text":"Multiplier(\n    f::Function;\n    autonomous,\n    variable\n) -> Multiplier{Autonomous, Fixed}\n\n\nReturn the Multiplier of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Multiplier-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.Multiplier","text":"Return the value of the Multiplier function.\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.NonAutonomous","page":"Types","title":"CTBase.NonAutonomous","text":"abstract type NonAutonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.NonFixed","page":"Types","title":"CTBase.NonFixed","text":"abstract type NonFixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.NotImplemented","page":"Types","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTException\n\nException thrown when a method is not implemented.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.OptimalControlInit","page":"Types","title":"CTBase.OptimalControlInit","text":"Initial guess for OCP, contains\n\nfunctions of time for the state and control variables\nvector for optimization variables\n\nInitialization data for each field can be left to default or: \n\nvector for optimization variables\nconstant / vector / function for state and control  \nexisting solution ('warm start') for all fields\n\nConstructors:\n\nOptimalControlInit(): default initialization\nOptimalControlInit(state, control, variable, time): constant vector, function handles and / or matrices / vectors interpolated along given time grid\nOptimalControlInit(sol): from existing solution\n\nExamples\n\njulia> init = OptimalControlInit()\njulia> init = OptimalControlInit(state=[0.1, 0.2], control=0.3)\njulia> init = OptimalControlInit(state=[0.1, 0.2], control=0.3, variable=0.5)\njulia> init = OptimalControlInit(state=[0.1, 0.2], controlt=t->sin(t), variable=0.5)\njulia> init = OptimalControlInit(state=[[0, 0], [1, 2], [5, -1]], time=[0, .3, 1.], controlt=t->sin(t))\njulia> init = OptimalControlInit(sol)\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.OptimalControlModel","page":"Types","title":"CTBase.OptimalControlModel","text":"mutable struct OptimalControlModel{time_dependence<:TimeDependence, variable_dependence<:VariableDependence} <: CTBase.AbstractOptimalControlModel\n\nFields\n\nmodel_expression::Union{Nothing, Expr}: Default: nothing\ninitial_time::Union{Nothing, Index, Real}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time::Union{Nothing, Index, Real}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nvariable_dimension::Union{Nothing, Integer}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nlagrange::Union{Nothing, Lagrange}: Default: nothing\nmayer::Union{Nothing, Mayer}: Default: nothing\ncriterion::Union{Nothing, Symbol}: Default: nothing\ndynamics::Union{Nothing, Dynamics}: Default: nothing\nconstraints::Dict{Symbol, Tuple}: Default: Dict{Symbol, Tuple{Vararg{Any}}}()\ndim_control_constraints::Union{Nothing, Integer}: Default: nothing\ndim_state_constraints::Union{Nothing, Integer}: Default: nothing\ndim_mixed_constraints::Union{Nothing, Integer}: Default: nothing\ndim_boundary_constraints::Union{Nothing, Integer}: Default: nothing\ndim_variable_constraints::Union{Nothing, Integer}: Default: nothing\ndim_control_range::Union{Nothing, Integer}: Default: nothing\ndim_state_range::Union{Nothing, Integer}: Default: nothing\ndim_variable_range::Union{Nothing, Integer}: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.OptimalControlSolution","page":"Types","title":"CTBase.OptimalControlSolution","text":"mutable struct OptimalControlSolution <: CTBase.AbstractOptimalControlSolution\n\nType of an optimal control solution.\n\nFields\n\ntimes::Union{Nothing, StepRangeLen, AbstractVector{<:Real}}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\ncontrol::Union{Nothing, Function}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nstate::Union{Nothing, Function}: Default: nothing\nvariable_dimension::Union{Nothing, Integer}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nvariable::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\ncostate::Union{Nothing, Function}: Default: nothing\nobjective::Union{Nothing, Real}: Default: nothing\niterations::Union{Nothing, Integer}: Default: nothing\nstopping::Union{Nothing, Symbol}: Default: nothing\nmessage::Union{Nothing, String}: Default: nothing\nsuccess::Union{Nothing, Bool}: Default: nothing\ninfos::Dict{Symbol, Any}: Default: Dict{Symbol, Any}()\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.OptimalControlSolution-Tuple{OptimalControlModel{<:TimeDependence, Fixed}}","page":"Types","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(\n    ocp::OptimalControlModel{<:TimeDependence, Fixed};\n    state,\n    control,\n    objective,\n    variable,\n    costate,\n    times,\n    iterations,\n    stopping,\n    message,\n    success,\n    infos\n)\n\n\nConstructor from an optimal control problem for a Fixed ocp.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.OptimalControlSolution-Tuple{OptimalControlModel{<:TimeDependence, NonFixed}}","page":"Types","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed};\n    state,\n    control,\n    objective,\n    variable,\n    costate,\n    times,\n    iterations,\n    stopping,\n    message,\n    success,\n    infos\n)\n\n\nConstructor from an optimal control problem for a NonFixed ocp.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ParsingError","page":"Types","title":"CTBase.ParsingError","text":"struct ParsingError <: CTException\n\nException thrown for syntax error during abstract parsing.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.PrintCallback","page":"Types","title":"CTBase.PrintCallback","text":"mutable struct PrintCallback <: CTCallback\n\nCallback for printing.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.PrintCallback-Tuple","page":"Types","title":"CTBase.PrintCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.StateConstraint","page":"Types","title":"CTBase.StateConstraint","text":"struct StateConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor StateConstraint returns a StateConstraint of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the StateConstraint for given values.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.StateConstraint-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> StateConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.StateConstraint-Tuple{Function}","page":"Types","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> StateConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.StateConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.StateConstraint","text":"Return the value of the StateConstraint function.\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.States","page":"Types","title":"CTBase.States","text":"Type alias for a vector of states.\n\njulia> const States = AbstractVector{<:State}\n\nSee also: State, Costates, Controls.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.StopCallback","page":"Types","title":"CTBase.StopCallback","text":"Stopping callback.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.StopCallback-Tuple","page":"Types","title":"CTBase.StopCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.Time","page":"Types","title":"CTBase.Time","text":"Type alias for a time.\n\njulia> const Time = ctNumber\n\nSee also: ctNumber, Times, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.TimeDependence","page":"Types","title":"CTBase.TimeDependence","text":"abstract type TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.Times","page":"Types","title":"CTBase.Times","text":"Type alias for a vector of times.\n\njulia> const Times = AbstractVector{<:Time}\n\nSee also: Time, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.UnauthorizedCall","page":"Types","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTException\n\nException thrown when a call to a function is not authorized.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.VariableConstraint","page":"Types","title":"CTBase.VariableConstraint","text":"struct VariableConstraint\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VariableConstraint returns a VariableConstraint of a function. The function must take 1 argument, v.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\n\nwarning: Warning\nWhen the variable is of dimension 1, consider v as a scalar.\n\nCall\n\nThe call returns the evaluation of the VariableConstraint for given values.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.VariableConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.VariableConstraint","text":"Return the value of the VariableConstraint function.\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.VariableDependence","page":"Types","title":"CTBase.VariableDependence","text":"abstract type VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.VectorField","page":"Types","title":"CTBase.VectorField","text":"struct VectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VectorField returns a VectorField of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the VectorField for given values.\n\nExamples\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html#CTBase.VectorField-Tuple{Function, Vararg{DataType}}","page":"Types","title":"CTBase.VectorField","text":"VectorField(\n    f::Function,\n    dependencies::DataType...\n) -> VectorField{Autonomous, Fixed}\n\n\nReturn a VectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.VectorField-Tuple{Function}","page":"Types","title":"CTBase.VectorField","text":"VectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> VectorField{Autonomous, Fixed}\n\n\nReturn a VectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.VectorField-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"Types","title":"CTBase.VectorField","text":"Return the value of the VectorField.\n\nExamples\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/types.html#CTBase.ctNumber","page":"Types","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\njulia> const ctNumber = Real\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase/types.html","page":"Types","title":"Types","text":"","category":"page"},{"location":"api-ctbase/utils.html#api-ctbase-utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"api-ctbase/utils.html","page":"Utils","title":"Utils","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-ctbase/utils.html#Index","page":"Utils","title":"Index","text":"","category":"section"},{"location":"api-ctbase/utils.html","page":"Utils","title":"Utils","text":"Pages   = [\"utils.md\"]\nModules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]","category":"page"},{"location":"api-ctbase/utils.html#Documentation","page":"Utils","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase/utils.html","page":"Utils","title":"Utils","text":"Modules = [CTBase]\nOrder   = [:module, :constant, :function, :macro]\nPages   = [\"utils.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase/utils.html#CTBase.ctgradient-Tuple{Function, Any}","page":"Utils","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x; backend) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctgradient-Tuple{Function, Real}","page":"Utils","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x::Real; backend) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctgradient-Tuple{VectorField, Any}","page":"Utils","title":"CTBase.ctgradient","text":"ctgradient(X::VectorField, x) -> Any\n\n\nReturn the gradient of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctindices-Tuple{Integer}","page":"Utils","title":"CTBase.ctindices","text":"ctindices(i::Integer) -> String\n\n\nReturn i > 0 as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctinterpolate-Tuple{Any, Any}","page":"Utils","title":"CTBase.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn the interpolation of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctjacobian-Tuple{Function, Any}","page":"Utils","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x; backend) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctjacobian-Tuple{Function, Real}","page":"Utils","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x::Real; backend) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctjacobian-Tuple{VectorField, Any}","page":"Utils","title":"CTBase.ctjacobian","text":"ctjacobian(X::VectorField, x) -> Any\n\n\nReturn the Jacobian of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html#CTBase.ctupperscripts-Tuple{Integer}","page":"Utils","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Integer) -> String\n\n\nReturn i > 0 as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase/utils.html","page":"Utils","title":"Utils","text":"","category":"page"},{"location":"index.html#OptimalControl.jl","page":"Introduction","title":"OptimalControl.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The OptimalControl.jl package aims to provide tools to solve optimal control problems by direct and indirect methods. It is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Install and documentation\nTo install a package from the control-toolbox ecosystem,  please visit the installation page. The documentation is accessible from the main menu.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"A (nonautonomous) optimal control problem with possibly free and final times can be described as minimising the cost functional s","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"g(t_0 x(t_0) t_f x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and other constraints such as","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"See our tutorials to get started solving optimal control problems.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
