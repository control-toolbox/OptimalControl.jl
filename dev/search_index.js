var documenterSearchIndex = {"docs":
[{"location":"tutorial-basic-example.html#basic","page":"Basic example","title":"Basic example","text":"","category":"section"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force u. We denote by x = (x_1 x_2) the state of the wagon, that is its position x_1 and its velocity x_2.","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"We assume that the mass is constant and unitary and that there is no friction. The dynamics we consider is given by","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t)quad u(t) in R","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"which is simply the double integrator system. Les us consider a transfer starting at time t_0 = 0 and ending at time t_f = 1, for which we want to minimise the transfer energy","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"    frac12int_0^1 u^2(t)  mathrmdt","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"starting from the condition x(0) = (-1 0) and with the goal to reach the target x(1) = (0 0).","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"note: Solution and details\nSee the page  Double integrator: energy minimisation  for the analytical solution and details about this problem.","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"First, we need to import the OptimalControl.jl package to define and solve the optimal control problem. We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"Then, we can define the problem","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"@def ocp begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n    ẋ(t) == [ x₂(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"Solve it","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"and plot the solution","category":"page"},{"location":"tutorial-basic-example.html","page":"Basic example","title":"Basic example","text":"plot(sol)","category":"page"},{"location":"tutorial-lqr-basic.html#LQR-example","page":"LQR example","title":"LQR example","text":"","category":"section"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"We consider the following Linear Quadratic Regulator (LQR) problem which consists in minimising","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"    frac12 int_0^t_f left( x_1^2(t) + x_2^2(t) + u^2(t) right)  mathrmdt ","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"subject to the constraints","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = -x_1(t) + u(t) quad u(t) in R","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"and the initial condition","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"    x(0) = (01)","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"We define A and B as","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"    A = beginpmatrix 0  1  -1  0  endpmatrix quad\n    B = beginpmatrix 0  1  endpmatrix","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"in order to get dotx = Ax + Bu and we aim to solve this optimal control problem for different values of t_f. First, we need to import the OptimalControl.jl and Plots.jl packages.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"Then, we can define the problem parameterized by the final time tf.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"x0 = [ 0\n       1 ]\n\nA  = [ 0 1\n      -1 0 ]\n\nB  = [ 0\n       1 ]\n\nfunction lqr(tf)\n\n    @def ocp begin\n        t ∈ [ 0, tf ], time\n        x ∈ R², state\n        u ∈ R, control\n        x(0) == x0\n        ẋ(t) == A * x(t) + B * u(t)\n        ∫( 0.5(x₁(t)^2 + x₂(t)^2 + u(t)^2) ) → min\n    end\n\n    return ocp\nend;\nnothing # hide","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"We solve the problem for t_f in 3 5 30.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"solutions = []   # empty list of solutions\ntfs = [3, 5, 30]\n\nfor tf ∈ tfs\n    solution = solve(lqr(tf), display=false)\n    push!(solutions, solution)\nend\nnothing # hide","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"We plot the state and control variables considering a normalized time s=(t-t_0)(t_f-t_0), thanks to the keyword argument time=:normalized of the plot function.","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"plt = plot(solutions[1], time=:normalized)\nfor sol ∈ solutions[2:end]\n    plot!(plt, sol, time=:normalized)\nend\n\n# we plot only the state and control variables and we add the legend\nN = length(tfs)\npx1 = plot(plt[1], legend=false, xlabel=\"s\", ylabel=\"x₁\")\npx2 = plot(plt[2], label=reshape([\"tf = $tf\" for tf ∈ tfs], (1, N)), xlabel=\"s\", ylabel=\"x₂\")\npu  = plot(plt[5], legend=false, xlabel=\"s\", ylabel=\"u\")\n\nusing Plots.PlotMeasures # for leftmargin, bottommargin\nplot(px1, px2, pu, layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"page"},{"location":"tutorial-lqr-basic.html","page":"LQR example","title":"LQR example","text":"note: Nota bene\nWe can observe that x(t_f) converges to the origin as t_f increases.","category":"page"},{"location":"tutorial-iss.html#Indirect-simple-shooting","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"","category":"section"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"In this tutorial we present the indirect simple shooting method on a simple example.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using Suppressor # to suppress warnings","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us start by importing the necessary packages.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"using OptimalControl\nusing DifferentialEquations # to get the Flow function from OptimalControl\nusing NonlinearSolve        # NLE solver: we get the fsolve function\nusing Plots","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Let us consider the following optimal control problem:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"left \n    beginarrayl\n        min displaystyle frac12 int_t_0^t_f u^2(t)  mathrmd t10em\n        dotx(t)  =  displaystyle -x(t)+alpha x^2(t)+u(t) quad  u(t) in R \n        quad t in t_0 t_f text ae 05em\n        x(t_0) = x_0 quad x(t_f) = x_f\n    endarray\nright","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"with t_0 = 0, t_f = 1, x_0 = -1, x_f = 0, alpha=15 and forall t in t_0 t_f, x(t) in R.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"t0 = 0\ntf = 1\nx0 = -1\nxf = 0\nα  = 1.5\n@def ocp begin\n\n    t ∈ [ t0, tf ], time\n    x ∈ R, state\n    u ∈ R, control\n\n    x(t0) == x0\n    x(tf) == xf\n\n    ẋ(t) == -x(t) + α * x(t)^2 + u(t)\n\n    ∫( 0.5u(t)^2 ) → min\n    \nend;\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"The pseudo-Hamiltonian of this problem is","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    H(xpu) = p  (-x+alpha x^2+u) + p^0 u^2 2","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"where p^0 = -1 since we are in the normal case. From the Pontryagin Maximum Principle, the maximising control is given by","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"u(x p) = p","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"since partial^2_uu H = p^0 = - 1  0. Plugging this control in feedback form into the pseudo-Hamiltonian, and considering the limit conditions, we obtain the following two-points boundary value problem (BVP).","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    left \n        beginarrayl\n            dotx(t)  = phantom- nabla_p Ht = -x(t) + alpha x^2(t) + u(x(t) p(t)) \n            = -x(t) + alpha x^2(t) + p(t) 05em\n            dotp(t)  = -           nabla_x Ht = (1 - 2 alpha x(t)) p(t)    05em\n            x(t_0)        = x_0 quad x(t_f) = x_f\n        endarray\n    right","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"where t=  (x(t)p(t)u(x(t) p(t))).","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"note: Our goal\nOur goal is to solve this (BVP). Solving (BVP) consists in solving the Pontryagin Maximum Principle which provides necessary conditions of optimality.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"To achive our goal, let us first introduce the pseudo-Hamiltonian vector field","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    vecH(zu) = left( nabla_p H(zu) -nabla_x H(zu) right) quad z = (xp)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"and then denote by varphi_t_0 x_0 p_0(cdot) the solution of the following Cauchy problem","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"dotz(t) = vecH(z(t) u(z(t))) quad z(t_0) = (x_0 p_0)","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Our goal becomes to solve","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"pi( varphi_t_0 x_0 p_0(t_f) ) = x_f quad pi(x p) = x","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"To compute varphi with the OptimalControl package, we define the flow of the associated Hamiltonian vector field by:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"u(x, p) = p\nφ = Flow(ocp, u)\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We define also the projection function on the state space.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"π(x, p) = x\nπ(z::Tuple{Number, Number}) = π(z...) # z = (x, p)\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"note: Nota bene\nActually, varphi_t_0 x_0 p_0(cdot) is also solution of    dotz(t) = vecmathbfH(z(t)) quad z(t_0) = (x_0 p_0)where mathbfH(z) = H(z u(z)) and vecmathbfH = (nabla_p mathbfH -nabla_x mathbfH). This is what is actually computed by Flow.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"Now, to solve the (BVP) we introduce the shooting function.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"    beginarrayrlll\n        S colon     R     longrightarrow    R \n                     p_0     longmapsto      S(p_0) = pi( varphi_t_0 x_0 p_0(t_f) ) - x_f\n    endarray","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"At the end, solving (BVP) is equivalent to solve S(p_0) = 0.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"This is what we call the indirect simple shooting method.","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"S(p0) = π( φ(t0, x0, p0, tf) ) - xf;                # shooting function\n\nnle = (s, ξ, λ) -> s[1] = S(ξ[1])                   # auxiliary function\nξ = [ 0.0 ]                                         # initial guess\n\nprob = NonlinearProblem(nle, ξ)\nglobal indirect_sol =      # hide\n@suppress_err begin # hide\nNonlinearSolve.solve(prob)      # hide\nindirect_sol = NonlinearSolve.solve(prob)           # resolution of S(p0) = 0\nend                 # hide\n\np0_sol = indirect_sol.u[1]                          # costate solution\nprintln(\"costate:    p0 = \", p0_sol)\n@suppress_err begin # hide\nprintln(\"shoot: |S(p0)| = \", abs(S(p0_sol)), \"\\n\")\nend # hide\nnothing # hide","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"We get:","category":"page"},{"location":"tutorial-iss.html","page":"Indirect simple shooting","title":"Indirect simple shooting","text":"exp(p0; saveat=[]) = φ((t0, tf), x0, p0, saveat=saveat).ode_sol # hide\ntimes = range(t0, tf, length=2) # hide\np0min = -0.5 # hide\np0max = 2 # hide\nplt_flow = plot() # hide\np0s = range(p0min, p0max, length=20) # hide\nfor i ∈ 1:length(p0s) # hide\n    sol = exp(p0s[i]) # hide\n    x = [sol(t)[1] for t ∈ sol.t] # hide\n    p = [sol(t)[2] for t ∈ sol.t] # hide\n    label = i==1 ? \"extremals\" : false # hide\n    plot!(plt_flow, x, p, color=:blue, label=label) # hide\nend # hide\np0s = range(p0min, p0max, length=200) # hide\nxs  = zeros(length(p0s), length(times)) # hide\nps  = zeros(length(p0s), length(times)) # hide\nfor i ∈ 1:length(p0s) # hide\n    sol = exp(p0s[i], saveat=times) # hide\n    xs[i, :] = [z[1] for z ∈ sol.(times)] # hide\n    ps[i, :] = [z[2] for z ∈ sol.(times)] # hide\nend # hide\nfor j ∈ 1:length(times) # hide\n    label = j==1 ? \"flow at times\" : false # hide\n    plot!(plt_flow, xs[:, j], ps[:, j], color=:green, linewidth=2, label=label) # hide\nend # hide\nplot!(plt_flow, xlims = (-1.1, 1), ylims =  (p0min, p0max)) # hide\nplot!(plt_flow, [0, 0], [p0min, p0max], color=:black, xlabel=\"x\", ylabel=\"p\", label=\"x=xf\") # hide\nsol = exp(p0_sol) # hide\nx = [sol(t)[1] for t ∈ sol.t] # hide\np = [sol(t)[2] for t ∈ sol.t] # hide\nplot!(plt_flow, x, p, color=:red, linewidth=2, label=\"extremal solution\") # hide\nplot!(plt_flow, [x[end]], [p[end]], seriestype=:scatter, color=:green, label=false) # hide\nplt_shoot = plot(xlims=(p0min, p0max), ylims=(-2, 4), xlabel=\"p₀\", ylabel=\"y\") # hide\nplot!(plt_shoot, p0s, S, linewidth=2, label=\"S(p₀)\", color=:green) # hide\nplot!(plt_shoot, [p0min, p0max], [0, 0], color=:black, label=\"y=0\") # hide\nplot!(plt_shoot, [p0_sol, p0_sol], [-2, 0], color=:black, label=\"p₀ solution\", linestyle=:dash) # hide\nplot!(plt_shoot, [p0_sol], [0], seriestype=:scatter, color=:green, label=false) # hide\nplot(plt_flow, plt_shoot, layout=(1,2), size=(800, 450)) # hide","category":"page"},{"location":"tutorial-batch.html#batch","page":"Batch processing","title":"Batch processing","text":"","category":"section"},{"location":"tutorial-batch.html#Introduction","page":"Batch processing","title":"Introduction","text":"","category":"section"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"Let us consider a self-replicator model [1] describing the dynamics of a microbial population growing inside a closed bioreactor. The bacterial culture has a constant volume. At the beginning of the experience, there is an initial mass of substrate S inside the bioreactor, that is gradually consumed by the bacterial population, and transformed into precursor metabolites P. These precursors are intermediate metabolites used to produce proteins—such as ribosomes and enzymes—responsible for specific cellular functions; and metabolites of interest X which are excreted from the cell. The proteins forming bacterial cells are divided into three classes M, R and Q, associated with the following cellular functions:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"class M proteins of the metabolic machinery, responsible for the uptake of nutrients,\nclass S from the medium (substrate),\nthe production of precursor metabolites P,\nand the synthesis of metabolites of interest X.","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"Class R proteins of the gene expression machinery (such as ribosomes) actively involved in protein biosynthesis (i.e. in the production of proteins of classes M, Q and R). Class Q Growth are rate-independent proteins, such as housekeeping proteins responsible for cell maintenance, and ribosomes not involved in protein synthesis. There is an internal control, alpha, accounting for the behaviour of each individual cell that has to decide between two pathways (transforming precursors P into metabolites M or into ribosomes R), and one external control leveraging the production of the product X (for instance using a light induced control of bioengineered cells).","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"<img src=\"./assets/batch.jpg\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"400px\">","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"After some normalisations, a simplified version of the system (not describing the production of metabolite as we will focus on volume maximisation on this example) can be written in terms of the concentrations of the substrate s, precursors p, ribosomes r, and the of the volume V of the bacterial population.[2] Accordingly, the state varphi=(sprV) is four-dimensional, and there is only one control, alpha:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"beginalign*\n  dots = -w_M(s)(1-r)V\n  dotp = w_M(s)(1-r) - w_R(p)r(p+1)\n  dotr = (alpha-r)w_R(p)r\n  dotV = w_R(p)rV\nendalign*","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"where velocities are taken linear in the concentrations, and where Michaelis-Menten kinetics are assumed:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"v_R = V_RV = w_R(p) rquad v_M = V_MV = w_M(s) m","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"with","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"w_R(p) = frack_RpK_r + p quad w_M(s) = frack_m sK_m + scdot","category":"page"},{"location":"tutorial-batch.html#Biomass-maximisation","page":"Batch processing","title":"Biomass maximisation","text":"","category":"section"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"We first import the needed packages.","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"We are interested in maximising the biomass production [3] (final volume of the bacterial population) over a finite time horizon 0t_f. To solve the problem, we first set up the boundary values,","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"t0 = 0      \ntf = 90     \ns0 = 0.1\np0 = 0.001\nr0 = 0.1\nV0 = 0.003\nnothing # hide","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"together with parameters and auxiliary functions definnig the synthesis rates:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"kᵣ = 1.1\nkₘ = 1.2\nKᵣ = 1.3\nKₘ = 1.4\n\nwᵣ(p) = kᵣ * p / (Kᵣ + p)\nwₘ(s) = kₘ * s / (Kₘ + s)\nnothing # hide","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"Then we define the optimal control problem setting time, state, control, boundary conditions, state and control constraints, dynamics and Mayer cost:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"@def batch begin\n\n    t ∈ [ t0, tf ], time\n    φ = (s, p, r, V) ∈ R⁴, state \n    α ∈ R, control\n\n    s(t0) == s0\n    p(t0) == p0\n    r(t0) == r0\n    V(t0) == V0\n    \n    s(t) ≥ 0\n    p(t) ≥ 0\n    0 ≤ r(t) ≤ 1\n    V(t) ≥ 0\n    0 ≤ α(t) ≤ 1\n\n    φ̇(t) == F0(s(t), p(t), r(t), V(t)) + α(t) * F1(s(t), p(t), r(t), V(t))\n\n    V(tf) → max\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"The dynamics is indeed affine in the control, dotvarphi = F_0(varphi) + alpha F_1(varphi), with vector fields","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"F0(s, p, r, V) =\n    [ -wₘ(s) * (1 - r) * V\n       wₘ(s) * (1 - r) - wᵣ(p) * r * (p + 1)\n      -wᵣ(p) * r^2\n       wᵣ(p) * r * V ]\n\nF1(s, p, r, V) = [ 0, 0, wᵣ(p) * r, 0 ]\nnothing # hide","category":"page"},{"location":"tutorial-batch.html#Direct-solve","page":"Batch processing","title":"Direct solve","text":"","category":"section"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"Since the following result holds,[4]","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"Proposition. The Lie bracket F_101 belongs to the span of F_1 and F_01, so singular controls are at least of local order two.","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"one expects singular arcs connected with bang arcs through Fuller phenomenon (accumulation of switching times).","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"We first solve the problem using a uniform discretisation:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"sol0  = solve(batch; grid_size=1000, print_level=0)\nprintln(\"Objective \", sol0.objective, \" after \", sol0.iterations, \" iterations\")","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"Although convergence is obtained, it is actually more efficient to first solve on a raw grid, then use a warm start to solve again on a finer (still uniform) grid:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"sol1 = solve(batch; grid_size=20, print_level=0)\nprintln(\"Objective \", sol1.objective, \" after \", sol1.iterations, \" iterations\")","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"sol2 = solve(batch; grid_size=1000, print_level=0, init=sol1)\nprintln(\"Objective \", sol2.objective, \" after \", sol2.iterations, \" iterations\")","category":"page"},{"location":"tutorial-batch.html#Plotting","page":"Batch processing","title":"Plotting","text":"","category":"section"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"We eventually plot the solutions (raw grid + finer grid) and observe that the control exhibits the expected structure with a Fuller-in arc followed by a singular one, then a Fuller-out arc:","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"plot(sol1; solution_label=\"(N=20)\", size=(800, 1000))     # N is the grid size\nplot!(sol2; solution_label=\"(N=1000)\")","category":"page"},{"location":"tutorial-batch.html#References","page":"Batch processing","title":"References","text":"","category":"section"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"[1]: Giordano, N.; Mairet, F.; Gouzé, J.-L.; Geiselmann, J.; De Jong, H. Dynamical allocation of cellular resources as an optimal control problem: novel insights into microbial growth strategies. PLoS comp. biol. 12 (2016), e1004802. ","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"[2]: Yabo, A. G.; Caillau, J.-B.; Gouzé, J.-L.; de Jong, H.; Mairet, F. Dynamical analysis and optimization of a generalized resource allocation model of microbial growth. SIAM J. Appl. Dyn. Syst. 21 (2022), no. 1, 137-165.","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"[3]: Yabo, A. G.; Caillau, J.-B.; Gouzé, J.-L. Optimal bacterial resource allocation strategies in batch processing. SIAM J. Appl. Dyn. Syst., to appear.","category":"page"},{"location":"tutorial-batch.html","page":"Batch processing","title":"Batch processing","text":"[4]: Astruc, L.; Edery, N. Optimal allocation of bacterial resources in a bioreactor. Project report, Polytech Nice Sophia, Université Côte d'Azur (2023).","category":"page"},{"location":"api-ctbase.html#CTBase-API","page":"CTBase API","title":"CTBase API","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"This is just a dump of CTBase API documentation. For more details about CTBase.jl package, see the documentation.","category":"page"},{"location":"api-ctbase.html#Index","page":"CTBase API","title":"Index","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"Pages   = [\"api-ctbase.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-ctbase.html#Documentation","page":"CTBase API","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctbase.html#CTBase.CTBase","page":"CTBase API","title":"CTBase.CTBase","text":"CTBase module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDataStructures\nDocStringExtensions\nLinearAlgebra\nMLStyle\nParameters\nPrettyTables\nPrintf\nReplMaker\nUnicode\n\nList of all the exported names:\n\nAbstractHamiltonian\nAmbiguousDescription\nAutonomous\nBoundaryConstraint\nCTCallback\nCTCallbacks\nCTException\nControl\nControlConstraint\nControlLaw\nControls\nCostate\nCostates\nDCostate\nDState\nDescription\nDimension\nDynamics\nFeedbackControl\nFixed\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\nIncorrectArgument\nIncorrectMethod\nIncorrectOutput\nIndex\nLagrange\n@Lie\nLie\nLift\nMayer\nMixedConstraint\nModel\nMultiplier\nNonAutonomous\nNonFixed\nNotImplemented\nOptimalControlInit\nOptimalControlModel\nOptimalControlSolution\nParsingError\nPoisson\nPrintCallback\nState\nStateConstraint\nStates\nStopCallback\nTime\nTimeDependence\nTimes\nTimesDisc\nUnauthorizedCall\nVariable\nVariableConstraint\nVariableDependence\nVectorField\n__OCPModel\nadd\nconstraint\nconstraint!\nconstraint_type\nconstraints_labels\ncontrol!\nctNumber\nctVector\nct_repl\nct_repl_update_model\nctgradient\nctindices\nctinterpolate\nctjacobian\nctupperscripts\n@def\ndim_boundary_constraints\ndim_control_constraints\ndim_control_range\ndim_mixed_constraints\ndim_path_constraints\ndim_state_constraints\ndim_state_range\ndim_variable_constraints\ndim_variable_range\ndynamics!\ngetFullDescription\nget_priority_print_callbacks\nget_priority_stop_callbacks\nhas_free_final_time\nhas_free_initial_time\nhas_lagrange_cost\nhas_mayer_cost\nis_autonomous\nis_fixed\nis_max\nis_min\nis_time_dependent\nis_time_independent\nis_variable_dependent\nis_variable_independent\nnlp_constraints!\nobjective!\nremove_constraint!\nreplace_call\nset_AD_backend\nstate!\ntime!\nvariable!\n∂ₜ\n⋅\n\n\n\n\n\n","category":"module"},{"location":"api-ctbase.html#CTBase.Control","page":"CTBase API","title":"CTBase.Control","text":"Type alias for a control in Rᵐ.\n\njulia> const Control = ctVector\n\nSee also: ctVector, State, Costate, Variable.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Costate","page":"CTBase API","title":"CTBase.Costate","text":"Type alias for a costate in Rⁿ.\n\njulia> const Costate = ctVector\n\nSee also: ctVector, State, Control, Variable.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.DCostate","page":"CTBase API","title":"CTBase.DCostate","text":"Type alias for a tangent vector to the costate space.\n\njulia> const DCostate = ctVector\n\nSee also: ctVector, DState.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.DState","page":"CTBase API","title":"CTBase.DState","text":"Type alias for a tangent vector to the state space.\n\njulia> const DState = ctVector\n\nSee also: ctVector, DCostate.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.State","page":"CTBase API","title":"CTBase.State","text":"Type alias for a state in Rⁿ.\n\njulia> const State = ctVector\n\nSee also: ctVector, Costate, Control, Variable.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.TimesDisc","page":"CTBase API","title":"CTBase.TimesDisc","text":"Type alias for a grid of times. This is used to define a discretization of time interval given to solvers.\n\njulia> const TimesDisc = Union{Times, StepRangeLen}\n\nSee also: Time, Times.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Variable","page":"CTBase API","title":"CTBase.Variable","text":"Type alias for a variable in Rᵏ.\n\njulia> const Variable = ctVector\n\nSee also: ctVector, State, Costate, Control.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ctVector","page":"CTBase API","title":"CTBase.ctVector","text":"Type alias for a vector of real numbers.\n\njulia> const ctVector = Union{ctNumber, AbstractVector{<:ctNumber}}\n\nSee also: ctNumber, State, Costate, Control, Variable.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.AbstractHamiltonian","page":"CTBase API","title":"CTBase.AbstractHamiltonian","text":"abstract type AbstractHamiltonian{time_dependence, variable_dependence}\n\nAbstract type for hamiltonians.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.AmbiguousDescription","page":"CTBase API","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTException\n\nException thrown when the description is ambiguous / incorrect.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Autonomous","page":"CTBase API","title":"CTBase.Autonomous","text":"abstract type Autonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"struct BoundaryConstraint{variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor BoundaryConstraint returns a BoundaryConstraint of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar. When the constraint is dimension 1, return a scalar.\n\nCall\n\nThe call returns the evaluation of the BoundaryConstraint for given values. If a variable is given for a non variable dependent boundary constraint, it will be ignored.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"BoundaryConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> BoundaryConstraint{Fixed}\n\n\nReturn a BoundaryConstraint of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"BoundaryConstraint(\n    f::Function;\n    variable\n) -> BoundaryConstraint{Fixed}\n\n\nReturn a BoundaryConstraint of a function. Dependencies are specified with a boolean, variable, false by default.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"Return the evaluation of the BoundaryConstraint.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.CTCallback","page":"CTBase API","title":"CTBase.CTCallback","text":"abstract type CTCallback\n\nAbstract type for callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.CTCallbacks","page":"CTBase API","title":"CTBase.CTCallbacks","text":"Tuple of callbacks\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.CTException","page":"CTBase API","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract type for exceptions.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ControlConstraint","page":"CTBase API","title":"CTBase.ControlConstraint","text":"struct ControlConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlConstraint returns a ControlConstraint of a function. The function must take 1 to 3 arguments, u to (t, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the control is of dimension 1, consider u as a scalar.\n\nCall\n\nThe call returns the evaluation of the ControlConstraint for given values.\n\nExamples\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ControlConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> ControlConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlConstraint{Autonomous, Fixed}\n\n\nReturn the ControlConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.ControlConstraint","text":"Return the value of the ControlConstraint function.\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlLaw","page":"CTBase API","title":"CTBase.ControlLaw","text":"struct ControlLaw{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to Hamiltonian in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlLaw returns a ControlLaw of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the ControlLaw for given values.\n\nExamples\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ControlLaw-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.ControlLaw","text":"ControlLaw(\n    f::Function,\n    dependencies::DataType...\n) -> ControlLaw{Autonomous, Fixed}\n\n\nReturn the ControlLaw of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlLaw-Tuple{Function}","page":"CTBase API","title":"CTBase.ControlLaw","text":"ControlLaw(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlLaw{Autonomous, Fixed}\n\n\nReturn the ControlLaw of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlLaw-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.ControlLaw","text":"Return the value of the ControlLaw function.\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Controls","page":"CTBase API","title":"CTBase.Controls","text":"Type alias for a vector of controls.\n\njulia> const Controls = AbstractVector{<:Control}\n\nSee also: Control, States, Costates.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Costates","page":"CTBase API","title":"CTBase.Costates","text":"Type alias for a vector of costates.\n\njulia> const Costates = AbstractVector{<:Costate}\n\nSee also: Costate, States, Controls.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Description","page":"CTBase API","title":"CTBase.Description","text":"A description is a tuple of symbols. Description is a type alias for a tuple of symbols.\n\njulia> const Description = Tuple{DescVarArg}\n\nSee also: DescVarArg.\n\nExample\n\nBase.show is overloaded for descriptions, that is tuple of descriptions are printed as follows:\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dimension","page":"CTBase API","title":"CTBase.Dimension","text":"Type alias for a dimension. This is used to define the dimension of the state space,  the costate space, the control space, etc.\n\njulia> const Dimension = Integer\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dynamics","page":"CTBase API","title":"CTBase.Dynamics","text":"struct Dynamics{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Dynamics returns a Dynamics of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Dynamics for given values.\n\nExamples\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dynamics-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Dynamics","text":"Dynamics(\n    f::Function,\n    dependencies::DataType...\n) -> Dynamics{Autonomous, Fixed}\n\n\nReturn the Dynamics of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Dynamics-Tuple{Function}","page":"CTBase API","title":"CTBase.Dynamics","text":"Dynamics(\n    f::Function;\n    autonomous,\n    variable\n) -> Dynamics{Autonomous, Fixed}\n\n\nReturn the Dynamics of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Dynamics-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Dynamics","text":"Return the value of the Dynamics function.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.FeedbackControl","page":"CTBase API","title":"CTBase.FeedbackControl","text":"struct FeedbackControl{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor FeedbackControl returns a FeedbackControl of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the FeedbackControl for given values.\n\nExamples\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.FeedbackControl-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function,\n    dependencies::DataType...\n) -> FeedbackControl{Autonomous, Fixed}\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.FeedbackControl-Tuple{Function}","page":"CTBase API","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function;\n    autonomous,\n    variable\n) -> FeedbackControl{Autonomous, Fixed}\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.FeedbackControl-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.FeedbackControl","text":"Return the value of the FeedbackControl function.\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Fixed","page":"CTBase API","title":"CTBase.Fixed","text":"abstract type Fixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Hamiltonian","page":"CTBase API","title":"CTBase.Hamiltonian","text":"struct Hamiltonian{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Hamiltonian returns a Hamiltonian of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Hamiltonian for given values.\n\nExamples\n\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Hamiltonian-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function,\n    dependencies::DataType...\n) -> Hamiltonian{Autonomous, Fixed}\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Hamiltonian-Tuple{Function}","page":"CTBase API","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function;\n    autonomous,\n    variable\n) -> Hamiltonian{Autonomous, Fixed}\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Hamiltonian-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Hamiltonian","text":"Return the value of the Hamiltonian.\n\njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianLift","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"struct HamiltonianLift{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence}\n\nLifts\n\nX::VectorField\n\nThe values for time_dependence and variable_dependence are deternimed by the values of those for the VectorField.\n\nConstructor\n\nThe constructor HamiltonianLift returns a HamiltonianLift of a VectorField.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed))\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianLift for given values.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\nAlternatively, it is possible to construct the HamiltonianLift from a Function being the VectorField.\n\njulia> HL1 = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL2 = HamiltonianLift(VectorField((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true))\njulia> HL1([1, 0], [0, 1], 1) == HL2([1, 0], [0, 1], 1)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.HamiltonianLift-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], Autonomous, Fixed)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], Autonomous, NonFixed)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], NonAutonomous, Fixed)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianLift-Tuple{Function}","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianLift\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], autonomous=false, variable=false)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianLift-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"Return the value of the HamiltonianLift.\n\nExamples\n\njulia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"struct HamiltonianVectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor HamiltonianVectorField returns a HamiltonianVectorField of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianVectorField for given values.\n\nExamples\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function,\n    dependencies::DataType...\n) -> HamiltonianVectorField{Autonomous, Fixed}\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Function}","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianVectorField{Autonomous, Fixed}\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"Return the value of the HamiltonianVectorField.\n\nExamples\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.IncorrectArgument","page":"CTBase API","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTException\n\nException thrown when an argument is inconsistent.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.IncorrectMethod","page":"CTBase API","title":"CTBase.IncorrectMethod","text":"struct IncorrectMethod <: CTException\n\nException thrown when a method is incorrect.\n\nFields\n\nvar::Symbol\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.IncorrectOutput","page":"CTBase API","title":"CTBase.IncorrectOutput","text":"struct IncorrectOutput <: CTException\n\nException thrown when the output is incorrect.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Index","page":"CTBase API","title":"CTBase.Index","text":"mutable struct Index\n\nFields\n\nval::Integer\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Lagrange","page":"CTBase API","title":"CTBase.Lagrange","text":"struct Lagrange{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Lagrange returns a Lagrange cost of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], Autonomous, Fixed)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, Autonomous, Fixed)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], Autonomous, NonFixed)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, Fixed)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Lagrange cost for given values.\n\nExamples\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Lagrange-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Lagrange","text":"Lagrange(\n    f::Function,\n    dependencies::DataType...\n) -> Lagrange{Autonomous, Fixed}\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lagrange-Tuple{Function}","page":"CTBase API","title":"CTBase.Lagrange","text":"Lagrange(\n    f::Function;\n    autonomous,\n    variable\n) -> Lagrange{Autonomous, Fixed}\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lagrange-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Lagrange","text":"Return the value of the Lagrange function.\n\nExamples\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Mayer","page":"CTBase API","title":"CTBase.Mayer","text":"struct Mayer{variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor Mayer returns a Mayer cost of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar.\n\nCall\n\nThe call returns the evaluation of the Mayer cost for given values. If a variable is given for a non variable dependent Mayer cost, it will be ignored.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1],Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Mayer-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Mayer","text":"Mayer(\n    f::Function,\n    dependencies::DataType...\n) -> Mayer{Fixed}\n\n\nReturn a Mayer cost of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Mayer-Tuple{Function}","page":"CTBase API","title":"CTBase.Mayer","text":"Mayer(f::Function; variable) -> Mayer{Fixed}\n\n\nReturn a Mayer cost of a function. Dependencies are specified with a boolean, variable, false by default.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Mayer-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Mayer","text":"Return the evaluation of the Mayer cost.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1], Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.MixedConstraint","page":"CTBase API","title":"CTBase.MixedConstraint","text":"struct MixedConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to Lagrange in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor MixedConstraint returns a MixedConstraint of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the MixedConstraint for given values.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.MixedConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> MixedConstraint{Autonomous, Fixed}\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.MixedConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> MixedConstraint{Autonomous, Fixed}\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.MixedConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.MixedConstraint","text":"Return the value of the MixedConstraint function.\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Multiplier","page":"CTBase API","title":"CTBase.Multiplier","text":"struct Multiplier{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to ControlLaw in the usage.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Multiplier returns a Multiplier of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Multiplier for given values.\n\nExamples\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Multiplier-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Multiplier","text":"Multiplier(\n    f::Function,\n    dependencies::DataType...\n) -> Multiplier{Autonomous, Fixed}\n\n\nReturn the Multiplier of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Multiplier-Tuple{Function}","page":"CTBase API","title":"CTBase.Multiplier","text":"Multiplier(\n    f::Function;\n    autonomous,\n    variable\n) -> Multiplier{Autonomous, Fixed}\n\n\nReturn the Multiplier of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Multiplier-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Multiplier","text":"Return the value of the Multiplier function.\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.NonAutonomous","page":"CTBase API","title":"CTBase.NonAutonomous","text":"abstract type NonAutonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.NonFixed","page":"CTBase API","title":"CTBase.NonFixed","text":"abstract type NonFixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.NotImplemented","page":"CTBase API","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTException\n\nException thrown when a method is not implemented.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.OptimalControlInit","page":"CTBase API","title":"CTBase.OptimalControlInit","text":"Initial guess for OCP, contains\n\nfunctions of time for the state and control variables\nvector for optimization variables\n\nInitialization data for each field can be left to default or: \n\nvector for optimization variables\nconstant / vector / function for state and control  \nexisting solution ('warm start') for all fields\n\nConstructors:\n\nOptimalControlInit(): default initialization\nOptimalControlInit(state, control, variable, time): constant vector, function handles and / or matrices / vectors interpolated along given time grid\nOptimalControlInit(sol): from existing solution\n\nExamples\n\njulia> init = OptimalControlInit()\njulia> init = OptimalControlInit(state=[0.1, 0.2], control=0.3)\njulia> init = OptimalControlInit(state=[0.1, 0.2], control=0.3, variable=0.5)\njulia> init = OptimalControlInit(state=[0.1, 0.2], controlt=t->sin(t), variable=0.5)\njulia> init = OptimalControlInit(state=[[0, 0], [1, 2], [5, -1]], time=[0, .3, 1.], controlt=t->sin(t))\njulia> init = OptimalControlInit(sol)\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.OptimalControlModel","page":"CTBase API","title":"CTBase.OptimalControlModel","text":"mutable struct OptimalControlModel{time_dependence<:TimeDependence, variable_dependence<:VariableDependence} <: CTBase.AbstractOptimalControlModel\n\nFields\n\nmodel_expression::Union{Nothing, Expr}: Default: nothing\ninitial_time::Union{Nothing, Index, Real}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time::Union{Nothing, Index, Real}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nvariable_dimension::Union{Nothing, Integer}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nlagrange::Union{Nothing, Lagrange}: Default: nothing\nmayer::Union{Nothing, Mayer}: Default: nothing\ncriterion::Union{Nothing, Symbol}: Default: nothing\ndynamics::Union{Nothing, Dynamics}: Default: nothing\nconstraints::Dict{Symbol, Tuple}: Default: Dict{Symbol, Tuple{Vararg{Any}}}()\ndim_control_constraints::Union{Nothing, Integer}: Default: nothing\ndim_state_constraints::Union{Nothing, Integer}: Default: nothing\ndim_mixed_constraints::Union{Nothing, Integer}: Default: nothing\ndim_boundary_constraints::Union{Nothing, Integer}: Default: nothing\ndim_variable_constraints::Union{Nothing, Integer}: Default: nothing\ndim_control_range::Union{Nothing, Integer}: Default: nothing\ndim_state_range::Union{Nothing, Integer}: Default: nothing\ndim_variable_range::Union{Nothing, Integer}: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.OptimalControlSolution","page":"CTBase API","title":"CTBase.OptimalControlSolution","text":"mutable struct OptimalControlSolution <: CTBase.AbstractOptimalControlSolution\n\nType of an optimal control solution.\n\nFields\n\ntimes::Union{Nothing, StepRangeLen, AbstractVector{<:Real}}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\ncontrol::Union{Nothing, Function}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nstate::Union{Nothing, Function}: Default: nothing\nvariable_dimension::Union{Nothing, Integer}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nvariable::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\ncostate::Union{Nothing, Function}: Default: nothing\nobjective::Union{Nothing, Real}: Default: nothing\niterations::Union{Nothing, Integer}: Default: nothing\nstopping::Union{Nothing, Symbol}: Default: nothing\nmessage::Union{Nothing, String}: Default: nothing\nsuccess::Union{Nothing, Bool}: Default: nothing\ninfos::Dict{Symbol, Any}: Default: Dict{Symbol, Any}()\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ParsingError","page":"CTBase API","title":"CTBase.ParsingError","text":"struct ParsingError <: CTException\n\nException thrown for syntax error during abstract parsing.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.PrintCallback","page":"CTBase API","title":"CTBase.PrintCallback","text":"mutable struct PrintCallback <: CTCallback\n\nCallback for printing.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.PrintCallback-Tuple","page":"CTBase API","title":"CTBase.PrintCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.StateConstraint","page":"CTBase API","title":"CTBase.StateConstraint","text":"struct StateConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor StateConstraint returns a StateConstraint of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the StateConstraint for given values.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.StateConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> StateConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.StateConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> StateConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.StateConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.StateConstraint","text":"Return the value of the StateConstraint function.\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.States","page":"CTBase API","title":"CTBase.States","text":"Type alias for a vector of states.\n\njulia> const States = AbstractVector{<:State}\n\nSee also: State, Costates, Controls.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.StopCallback","page":"CTBase API","title":"CTBase.StopCallback","text":"Stopping callback.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.StopCallback-Tuple","page":"CTBase API","title":"CTBase.StopCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Time","page":"CTBase API","title":"CTBase.Time","text":"Type alias for a time.\n\njulia> const Time = ctNumber\n\nSee also: ctNumber, Times, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.TimeDependence","page":"CTBase API","title":"CTBase.TimeDependence","text":"abstract type TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Times","page":"CTBase API","title":"CTBase.Times","text":"Type alias for a vector of times.\n\njulia> const Times = AbstractVector{<:Time}\n\nSee also: Time, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.UnauthorizedCall","page":"CTBase API","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTException\n\nException thrown when a call to a function is not authorized.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VariableConstraint","page":"CTBase API","title":"CTBase.VariableConstraint","text":"struct VariableConstraint\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VariableConstraint returns a VariableConstraint of a function. The function must take 1 argument, v.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\n\nwarning: Warning\nWhen the variable is of dimension 1, consider v as a scalar.\n\nCall\n\nThe call returns the evaluation of the VariableConstraint for given values.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VariableConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.VariableConstraint","text":"Return the value of the VariableConstraint function.\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.VariableDependence","page":"CTBase API","title":"CTBase.VariableDependence","text":"abstract type VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VectorField","page":"CTBase API","title":"CTBase.VectorField","text":"struct VectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VectorField returns a VectorField of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the VectorField for given values.\n\nExamples\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VectorField-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.VectorField","text":"VectorField(\n    f::Function,\n    dependencies::DataType...\n) -> VectorField{Autonomous, Fixed}\n\n\nReturn a VectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.VectorField-Tuple{Function}","page":"CTBase API","title":"CTBase.VectorField","text":"VectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> VectorField{Autonomous, Fixed}\n\n\nReturn a VectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.VectorField-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.VectorField","text":"Return the value of the VectorField.\n\nExamples\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctNumber","page":"CTBase API","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\njulia> const ctNumber = Real\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.:⋅-Tuple{Function, Function}","page":"CTBase API","title":"CTBase.:⋅","text":"⋅(X::Function, f::Function) -> Function\n\n\nLie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.:⋅-Tuple{VectorField{Autonomous, <:VariableDependence}, Function}","page":"CTBase API","title":"CTBase.:⋅","text":"⋅(\n    X::VectorField{Autonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#97#99\"{VectorField{Autonomous, var\"#s98\"}, <:Function} where var\"#s98\"<:VariableDependence\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in autonomous case\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.:⋅-Tuple{VectorField{NonAutonomous, <:VariableDependence}, Function}","page":"CTBase API","title":"CTBase.:⋅","text":"⋅(\n    X::VectorField{NonAutonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#101#103\"{VectorField{NonAutonomous, var\"#s98\"}, <:Function} where var\"#s98\"<:VariableDependence\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in nonautonomous case\n\nExample\n\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Tuple{Function, Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::Function,\n    f::Function,\n    dependences::DataType...\n) -> Function\n\n\nLie derivative of a scalar function along a vector field or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, NonAutonomous, NonFixed)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Tuple{Function, Function}","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Function\n\n\nLie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Tuple{VectorField, Function}","page":"CTBase API","title":"CTBase.Lie","text":"Lie(X::VectorField, f::Function) -> Function\n\n\nLie derivative of a scalar function along a vector field.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{Autonomous, V<:VariableDependence},\n    Y::VectorField{Autonomous, V<:VariableDependence}\n) -> VectorField\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case\n\nExample\n\njulia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{NonAutonomous, V<:VariableDependence},\n    Y::VectorField{NonAutonomous, V<:VariableDependence}\n) -> VectorField{NonAutonomous}\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case\n\nExample\n\njulia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lift-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Lift","text":"Lift(\n    X::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a VectorField or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lift-Tuple{Function}","page":"CTBase API","title":"CTBase.Lift","text":"Lift(X::Function; autonomous, variable) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lift-Tuple{VectorField}","page":"CTBase API","title":"CTBase.Lift","text":"Lift(X::VectorField) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a VectorField.\n\nExample\n\njulia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Model-Tuple{Vararg{DataType}}","page":"CTBase API","title":"CTBase.Model","text":"Model(\n    dependencies::DataType...\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following argument:\n\ndependencies: either Autonomous or NonAutonomous. Default is Autonomous. And either NonFixed or Fixed. Default is Fixed.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(NonAutonomous)\njulia> ocp = Model(Autonomous, NonFixed)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Model-Tuple{}","page":"CTBase API","title":"CTBase.Model","text":"Model(\n;\n    autonomous,\n    variable\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following optional keyword argument:\n\nautonomous: either true or false. Default is true.\nvariable: either true or false. Default is false.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(autonomous=false)\njulia> ocp = Model(autonomous=false, variable=true)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Tuple{Function, Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::Function,\n    dependences::DataType...\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Tuple{Function, Function}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{Autonomous, V}, AbstractHamiltonian{Autonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{Autonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{Autonomous, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{NonAutonomous, V}, AbstractHamiltonian{NonAutonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{NonAutonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{NonAutonomous, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case\n\nExample\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{AbstractHamiltonian{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence},\n    g::Function\n) -> Hamiltonian\n\n\nPoisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{Function, AbstractHamiltonian{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence}\n) -> Hamiltonian\n\n\nPoisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::HamiltonianLift{T<:TimeDependence, V<:VariableDependence},\n    g::HamiltonianLift{T<:TimeDependence, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.__OCPModel-Tuple","page":"CTBase API","title":"CTBase.__OCPModel","text":"__OCPModel(args...; kwargs...) -> OptimalControlModel\n\n\nRedirection to Model to avoid confusion with other functions Model from other packages if imported. This function is used by @def.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","page":"CTBase API","title":"CTBase.add","text":"add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nConcatenate the description y to the tuple of descriptions x if x does not contain y and return the new tuple of descriptions. Throw an error if the description y is already contained in x.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> descriptions = add(descriptions, (:b,))\n(:a,)\n(:b,)\njulia> descriptions = add(descriptions, (:b,))\nERROR: IncorrectArgument: the description (:b,) is already in ((:a,), (:b,))\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","page":"CTBase API","title":"CTBase.add","text":"add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> print(descriptions)\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol;\n    rg,\n    f,\n    lb,\n    ub,\n    label\n)\n\n\nAdd a constraint to an optimal control problem, denoted ocp.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe initial and final times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nYou can add an :initial, :final, :control, :state or :variable box constraint (whole range). \n\nRange constraint on the state, control or variable\n\nYou can add an :initial, :final, :control, :state or :variable box constraint on a range of it, that is only on some components. If not range is specified, then the constraint is on the whole range. We denote by x, u and v respectively the state, control and variable. We denote by n, m and q respectively the dimension of the state, control and variable. The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable.\n\nExamples\n\njulia> constraint!(ocp, :initial; rg=1:2:5, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :initial; rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :final; rg=1, lb=0, ub=2)\njulia> constraint!(ocp, :control; rg=1, lb=0, ub=2)\njulia> constraint!(ocp, :state; rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :variable; rg=1:2, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :initial; lb=[ 0, 0, 0 ])                 # [ 0, 0, 0 ] ≤ x(t0),                          dim(x) = 3\njulia> constraint!(ocp, :initial; lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ]) # [ 0, 0, 0 ] ≤ x(t0) ≤ [ 1, 2, 1 ],            dim(x) = 3\njulia> constraint!(ocp, :final; lb=-1, ub=1)                      #          -1 ≤ x(tf) ≤ 1,                      dim(x) = 1\njulia> constraint!(ocp, :control; lb=0, ub=2)                     #           0 ≤ u(t)  ≤ 2,        t ∈ [t0, tf], dim(u) = 1\njulia> constraint!(ocp, :state; lb=[ 0, 0 ], ub=[ 1, 2 ])         #    [ 0, 0 ] ≤ x(t)  ≤ [ 1, 2 ], t ∈ [t0, tf], dim(x) = 2\njulia> constraint!(ocp, :variable; lb=[ 0, 0 ], ub=[ 1, 2 ])      #    [ 0, 0 ] ≤    v  ≤ [ 1, 2 ],               dim(v) = 2\n\nFunctional constraint\n\nYou can add a :boundary, :control, :state, :mixed or :variable box functional constraint.\n\nExamples\n\n# variable independent ocp\njulia> constraint!(ocp, :boundary; f = (x0, xf) -> x0[3]+xf[2], lb=0, ub=1)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary; f = (x0, xf, v) -> x0[3]+xf[2]*v[1], lb=0, ub=1)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control; f = u -> 2u, lb=0, ub=1)\njulia> constraint!(ocp, :state; f = x -> x-1, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (x, u) -> x[1]-u, lb=0, ub=1)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control; f = (t, u) -> 2u, lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (t, x) -> t * x, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (t, x, u) -> x[1]-u, lb=0, ub=1)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control; f = (u, v) -> 2u * v[1], lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (x, v) -> x * v[1], lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (x, u, v) -> x[1]-v[2]*u, lb=0, ub=1)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control; f = (t, u, v) -> 2u+v[2], lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (t, x, v) -> x-t*v[1], lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (t, x, u, v) -> x[1]*v[2]-u, lb=0, ub=1)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.constraint","text":"constraint(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    label::Symbol\n) -> Any\n\n\nRetrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds).\n\nExample\n\njulia> constraint!(ocp, :initial, 0, :c0)\njulia> c = constraint(ocp, :c0)\njulia> c(1)\n1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint_type-NTuple{7, Any}","page":"CTBase API","title":"CTBase.constraint_type","text":"constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n\n\nReturn the type constraint among :initial, :final, :boundary, :control_range, :control_fun, :state_range, :state_fun, :mixed, :variable_range, :variable_fun (:other otherwise), together with the appropriate value (range, updated expression...) Expressions like u(t0) where u is the control and t0 the initial time return :other.\n\nExample\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, 1)\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, 1)\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, 1)\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, 1)\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, 2)\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n:variable_fun\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n:variable_fun\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraints_labels-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.constraints_labels","text":"constraints_labels(\n    ocp::OptimalControlModel\n) -> Base.KeySet{Symbol, Dict{Symbol, Tuple}}\n\n\nReturn the labels of the constraints as a Base.keys.\n\nExample\n\njulia> constraints_labels(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.control!","page":"CTBase API","title":"CTBase.control!","text":"control!(ocp::OptimalControlModel, m::Integer)\ncontrol!(ocp::OptimalControlModel, m::Integer, name::String)\ncontrol!(\n    ocp::OptimalControlModel,\n    m::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the control dimension and possibly the names of each coordinate.\n\nnote: Note\nYou must use control! only once to set the control dimension.\n\nExamples\n\njulia> control!(ocp, 1)\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.ct_repl-Tuple{}","page":"CTBase API","title":"CTBase.ct_repl","text":"ct_repl(; debug, verbose)\n\n\nCreate a ct REPL.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ct_repl_update_model-Tuple{Expr}","page":"CTBase API","title":"CTBase.ct_repl_update_model","text":"ct_repl_update_model(e::Expr)\n\n\nUpdate the model adding the expression e. It must be public since in the ct repl, this function  is quoted each time an expression is parsed and is valid. \n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctgradient-Tuple{Function, Any}","page":"CTBase API","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x; backend) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctgradient-Tuple{Function, Real}","page":"CTBase API","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x::Real; backend) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctgradient-Tuple{VectorField, Any}","page":"CTBase API","title":"CTBase.ctgradient","text":"ctgradient(X::VectorField, x) -> Any\n\n\nReturn the gradient of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctindices-Tuple{Integer}","page":"CTBase API","title":"CTBase.ctindices","text":"ctindices(i::Integer) -> String\n\n\nReturn i > 0 as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctinterpolate-Tuple{Any, Any}","page":"CTBase API","title":"CTBase.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn the interpolation of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctjacobian-Tuple{Function, Any}","page":"CTBase API","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x; backend) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctjacobian-Tuple{Function, Real}","page":"CTBase API","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x::Real; backend) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctjacobian-Tuple{VectorField, Any}","page":"CTBase API","title":"CTBase.ctjacobian","text":"ctjacobian(X::VectorField, x) -> Any\n\n\nReturn the Jacobian of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctupperscripts-Tuple{Integer}","page":"CTBase API","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Integer) -> String\n\n\nReturn i > 0 as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_boundary_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_boundary_constraints","text":"dim_boundary_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of the boundary constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_control_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_control_constraints","text":"dim_control_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear control constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_control_range-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_control_range","text":"dim_control_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of range constraints on control (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_mixed_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_mixed_constraints","text":"dim_mixed_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear mixed constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_path_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_path_constraints","text":"dim_path_constraints(ocp::OptimalControlModel) -> Any\n\n\nReturn the dimension of nonlinear path (state + control + mixed) constraints (nothing if one of them is not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_state_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_state_constraints","text":"dim_state_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear state constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_state_range-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_state_range","text":"dim_state_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of range constraints on state (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_variable_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_variable_constraints","text":"dim_variable_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear variable constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_variable_range-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_variable_range","text":"dim_variable_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of range constraints on variable (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.dynamics!","text":"dynamics!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    f::Function\n)\n\n\nSet the dynamics.\n\nnote: Note\nYou can use dynamics! only once to define the dynamics.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> dynamics!(ocp, f)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"CTBase API","title":"CTBase.getFullDescription","text":"getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn a complete description from an incomplete description desc and  a list of complete descriptions desc_list. If several complete descriptions are possible,  then the first one is returned.\n\nExample\n\njulia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n(:a, :b)\n(:b, :c)\n(:a, :c)\njulia> getFullDescription((:a,), desc_list)\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.get_priority_print_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","page":"CTBase API","title":"CTBase.get_priority_print_callbacks","text":"get_priority_print_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n\n\nGet the highest priority print callbacks.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.get_priority_stop_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","page":"CTBase API","title":"CTBase.get_priority_stop_callbacks","text":"get_priority_stop_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n\n\nGet the highest priority stop callbacks.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.has_free_final_time-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.has_free_final_time","text":"has_free_final_time(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with free final time.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.has_free_initial_time-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.has_free_initial_time","text":"has_free_initial_time(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with free initial time.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.has_lagrange_cost-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.has_lagrange_cost","text":"has_lagrange_cost(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with lagrange cost.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.has_mayer_cost-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.has_mayer_cost","text":"has_mayer_cost(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with mayer cost.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_autonomous-Tuple{OptimalControlModel{Autonomous}}","page":"CTBase API","title":"CTBase.is_autonomous","text":"is_autonomous(ocp::OptimalControlModel{Autonomous}) -> Bool\n\n\nReturn true if the model is autonomous.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_fixed-Tuple{OptimalControlModel{<:TimeDependence, Fixed}}","page":"CTBase API","title":"CTBase.is_fixed","text":"is_fixed(\n    ocp::OptimalControlModel{<:TimeDependence, Fixed}\n) -> Bool\n\n\nReturn true if the model is fixed (= has no variable).\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_max-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_max","text":"is_max(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :max.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_min-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_min","text":"is_min(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :min.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_time_dependent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_time_dependent","text":"is_time_dependent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_time_independent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_time_independent","text":"is_time_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as time independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_variable_dependent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_variable_dependent","text":"is_variable_dependent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_variable_independent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_variable_independent","text":"is_variable_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as variable independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.nlp_constraints!-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.nlp_constraints!","text":"nlp_constraints!(\n    ocp::OptimalControlModel\n) -> Tuple{Tuple{Any, CTBase.var\"#ξ#91\", Vector{Real}}, Tuple{Any, CTBase.var\"#η#92\", Vector{Real}}, Tuple{Any, CTBase.var\"#ψ#93\", Vector{Real}}, Tuple{Any, CTBase.var\"#ϕ#94\", Vector{Real}}, Tuple{Any, CTBase.var\"#θ#95\", Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}\n\n\nReturn a 6-tuple of tuples:\n\n(ξl, ξ, ξu) are control constraints\n(ηl, η, ηu) are state constraints\n(ψl, ψ, ψu) are mixed constraints\n(ϕl, ϕ, ϕu) are boundary constraints\n(θl, θ, θu) are variable constraints\n(ul, uind, uu) are control linear constraints of a subset of indices\n(xl, xind, xu) are state linear constraints of a subset of indices\n(vl, vind, vu) are variable linear constraints of a subset of indices\n\nand update information about constraints dimensions of  ocp.\n\nnote: Note\nThe dimensions of the state and control must be set before calling nlp_constraints!.\nFor a Fixed problem, dimensions associated with constraints on the variable are set to zero.\n\nExample\n\njulia> (ξl, ξ, ξu), (ηl, η, ηu), (ψl, ψ, ψu), (ϕl, ϕ, ϕu), (θl, θ, θu),\n    (ul, uind, uu), (xl, xind, xu), (vl, vind, vu) = nlp_constraints!(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function g and f⁰. Type can be :bolza. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> objective!(ocp, :bolza, (x0, xf) -> x0[1] + xf[2], (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function f. Type can be :mayer or :lagrange. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\njulia> objective!(ocp, :mayer, (x0, xf) -> x0[1] + xf[2])\njulia> objective!(ocp, :lagrange, (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\nwarning: Warning\nIf you set twice the objective, only the last one will be taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}","page":"CTBase API","title":"CTBase.remove_constraint!","text":"remove_constraint!(ocp::OptimalControlModel, label::Symbol)\n\n\nRemove a labeled constraint.\n\nExample\n\njulia> remove_constraint!(ocp, :con)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}","page":"CTBase API","title":"CTBase.replace_call","text":"replace_call(e, x::Symbol, t, y) -> Any\n\n\nReplace calls in e of the form (...x...)(t) by (...y...).\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","page":"CTBase API","title":"CTBase.replace_call","text":"replace_call(e, x::Vector{Symbol}, t, y) -> Any\n\n\nReplace calls in e of the form (...x1...x2...)(t) by (...y1...y2...) for all symbols x1, x2... in the vector x.\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.state!","page":"CTBase API","title":"CTBase.state!","text":"state!(ocp::OptimalControlModel, n::Integer)\nstate!(ocp::OptimalControlModel, n::Integer, name::String)\nstate!(\n    ocp::OptimalControlModel,\n    n::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the state dimension and possibly the names of each component.\n\nnote: Note\nYou must use state! only once to set the state dimension.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.time!-Union{Tuple{OptimalControlModel{<:TimeDependence, VT}}, Tuple{VT}} where VT","page":"CTBase API","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel{<:TimeDependence, VT};\n    t0,\n    tf,\n    ind0,\n    indf,\n    name\n)\n\n\nSet the initial and final times. We denote by t0 the initial time and tf the final time. The optimal control problem is denoted ocp. When a time is free, then one must provide the corresponding index of the ocp variable.\n\nnote: Note\nYou must use time! only once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, t0=0,   tf=1  ) # Fixed t0 and fixed tf\njulia> time!(ocp, t0=0,   indf=2) # Fixed t0 and free  tf\njulia> time!(ocp, ind0=2, tf=1  ) # Free  t0 and fixed tf\njulia> time!(ocp, ind0=2, indf=3) # Free  t0 and free  tf\n\nWhen you plot a solution of an optimal control problem, the name of the time variable appears. By default, the name is \"t\". Consider you want to set the name of the time variable to \"s\".\n\njulia> time!(ocp, t0=0, tf=1, name=\"s\") # name is a String\n# or\njulia> time!(ocp, t0=0, tf=1, name=:s ) # name is a Symbol  \n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.variable!","page":"CTBase API","title":"CTBase.variable!","text":"variable!(ocp::OptimalControlModel, q::Integer)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String\n)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the variable dimension and possibly the names of each component.\n\nnote: Note\nYou can use variable! once to set the variable dimension when the model is NonFixed.\n\nExamples\n\njulia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"v₁\", \"v₂\" ])\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.∂ₜ-Tuple{Any}","page":"CTBase API","title":"CTBase.∂ₜ","text":"∂ₜ(f) -> CTBase.var\"#106#108\"\n\n\nPartial derivative wrt time of a function.\n\nExample\n\njulia> ∂ₜ((t,x) -> t*x)(0,8)\n8\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.@Lie-Tuple{Expr, Any, Any}","page":"CTBase API","title":"CTBase.@Lie","text":"Macros for Poisson brackets\n\nExample\n\njulia> H0 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7]) autonomous=true variable=false\n#\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false variable=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) autonomous=true variable=true\n#\njulia> H0 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2) autonomous=false variable=true\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase.html#CTBase.@Lie-Tuple{Expr, Any}","page":"CTBase API","title":"CTBase.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) variable=true\n#\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase.html#CTBase.@Lie-Tuple{Expr}","page":"CTBase API","title":"CTBase.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\n#\njulia> F0 = VectorField((t, x) -> [t+x[1], x[2], (1-x[3])], autonomous=false)\njulia> F1 = VectorField((t, x) -> [t, -x[3], x[2]], autonomous=false)\njulia> @Lie [F0, F1](1, [1, 2, 3])\n#\njulia> F0 = VectorField((x, v) -> [x[1]+v, x[2], (1-x[3])], variable=true)\njulia> F1 = VectorField((x, v) -> [0, -x[3]-v, x[2]], variable=true)\njulia> @Lie [F0, F1]([1, 2, 3], 2)\n#\njulia> F0 = VectorField((t, x, v) -> [t+x[1]+v, x[2], (1-x[3])], autonomous=false, variable=true)\njulia> F1 = VectorField((t, x, v) -> [t, -x[3]-v, x[2]], autonomous=false, variable=true)\njulia> @Lie [F0, F1](1, [1, 2, 3], 2)\n#\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7])\n3.0\n#\njulia> H0 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2), autonomous=false)\njulia> H1 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2), autonomous=false)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7])\n#\njulia> H0 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), variable=true)\njulia> H1 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), variable=true)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2)\n#\njulia> H0 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), autonomous=false, variable=true)\njulia> H1 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), autonomous=false, variable=true)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2)\n#\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase.html#CTBase.@def","page":"CTBase API","title":"CTBase.@def","text":"Define an optimal control problem. One pass parsing of the definition.\n\nExample\n\n@def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend\n\n\n\n\n\n","category":"macro"},{"location":"api-ctdirect.html#CTDirect-API","page":"CTDirect API","title":"CTDirect API","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect API","title":"CTDirect API","text":"This is just a dump of CTDirect API documentation. For more details about CTDirect.jl package, see the documentation.","category":"page"},{"location":"api-ctdirect.html#Index","page":"CTDirect API","title":"Index","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect API","title":"CTDirect API","text":"Pages   = [\"api-ctdirect.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-ctdirect.html#Documentation","page":"CTDirect API","title":"Documentation","text":"","category":"section"},{"location":"api-ctdirect.html","page":"CTDirect API","title":"CTDirect API","text":"Modules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctdirect.html#CTDirect.DOCP","page":"CTDirect API","title":"CTDirect.DOCP","text":"Struct for discretized optimal control problem DOCP\n\nContains:\n\na copy of the original OCP\na NLP formulation of the DOCP\ndata required to link the two problems\n\n\n\n\n\n","category":"type"},{"location":"api-ctdirect.html#CTDirect.OCPSolutionFromDOCP-Tuple{Any, Any}","page":"CTDirect API","title":"CTDirect.OCPSolutionFromDOCP","text":"OCPSolutionFromDOCP(\n    docp,\n    docp_solution_ipopt\n) -> OptimalControlSolution\n\n\nBuild OCP functional solution from DOCP vector solution (given as a GenericExecutionStats)\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.available_methods-Tuple{}","page":"CTDirect API","title":"CTDirect.available_methods","text":"available_methods() -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.directTranscription-Tuple{OptimalControlModel, Vararg{Any}}","page":"CTDirect API","title":"CTDirect.directTranscription","text":"directTranscription(\n    ocp::OptimalControlModel,\n    description...;\n    init,\n    grid_size,\n    time_grid\n) -> DOCP\n\n\nDiscretize an optimal control problem into a nonlinear optimization problem (ie direct transcription)\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.getNLP-Tuple{DOCP}","page":"CTDirect API","title":"CTDirect.getNLP","text":"getNLP(docp::DOCP) -> Any\n\n\nExtract the NLP problem from the DOCP\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.is_solvable-Tuple{Any}","page":"CTDirect API","title":"CTDirect.is_solvable","text":"is_solvable(ocp) -> Bool\n\n\nCheck if an OCP is solvable by the method solve.\n\n\n\n\n\n","category":"method"},{"location":"api-ctdirect.html#CTDirect.setInitialGuess-Tuple{DOCP, Any}","page":"CTDirect API","title":"CTDirect.setInitialGuess","text":"setInitialGuess(docp::DOCP, init) -> Any\n\n\nSet initial guess in the DOCP\n\n\n\n\n\n","category":"method"},{"location":"tutorial-init.html#Initial-guess-options","page":"Initial guess options","title":"Initial guess options","text":"","category":"section"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"We present in this tutorial the different possibilities to provide an initial guess to solve an optimal control problem using the solve command. For the illustrations, we define the following optimal control problem.","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"t0 = 0\ntf = 10\nα  = 5\n\n@def ocp begin\n    t ∈ [ t0, tf ], time\n    v ∈ R, variable\n    x ∈ R², state\n    u ∈ R, control\n    x(t0) == [ -1, 0 ]\n    x(tf) - [ 0, v ] == [0, 0]\n    ẋ(t) == [ x₂(t), x₁(t) + α*x₁(t)^2 + u(t) ]\n    v^2 + ∫( 0.5u(t)^2 ) → min\nend\nnothing # hide","category":"page"},{"location":"tutorial-init.html#Default-initial-guess","page":"Initial guess options","title":"Default initial guess","text":"","category":"section"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"We first solve the problem without giving an initial guess. This will default to initialize all variables to 0.1.","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"# solve the optimal control problem without initial guess\nsol = solve(ocp, display=false)\n\n# print the number of iterations \nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"Let us plot the solution of the optimal control problem.","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"plot(sol, size=(600, 450))","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"Note that the following formulations are equivalent","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"sol = solve(ocp, display=false, init=nothing)\nprintln(\"Number of iterations: \", sol.iterations)\nsol = solve(ocp, display=false, init=())\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"To reduce the number of iterations and improve the convergence, we can give an initial guess to the solver.  This initial guess can be built from constant values, interpolated vectors, functions, or existing solutions. Except when initializing from a solution, the arguments are to be passed as a named tuple init=(state=..., control=..., variable=...) whose fields are optional. Missing fields will revert to default initialization (ie constant 0.1).","category":"page"},{"location":"tutorial-init.html#Constant-initial-guess","page":"Initial guess options","title":"Constant initial guess","text":"","category":"section"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"We first illustrate the constant initial guess, using vectors or scalars according to the dimension.","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"# solve the optimal control problem with initial guess\nsol = solve(ocp, display=false, init=(state=[-0.2, 0.1], control=-0.2, variable=0.05))\n\n# print the number of iterations\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"Partial initializations are also valid, as shown below. Note the ending comma when a single argument is passed (tuple).","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"sol = solve(ocp, display=false, init=(state=[-0.2, 0.1],))\nprintln(\"Number of iterations: \", sol.iterations)\nsol = solve(ocp, display=false, init=(control=-0.2,))\nprintln(\"Number of iterations: \", sol.iterations)\nsol = solve(ocp, display=false, init=(state=[-0.2, 0.1], variable=0.05))\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-init.html#Functional-initial-guess","page":"Initial guess options","title":"Functional initial guess","text":"","category":"section"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"For the state and control, we can also provide functions of time as initial guess.","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"# initial guess as functions of time\nx(t) = [ -0.2t, 0.1t ]\nu(t) = -0.2t\n\n# solve the optimal control problem with initial guess\nsol = solve(ocp, display=false, init=(state=x, control=u, variable=0.05))\n\n# print the number of iterations\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-init.html#Vector-initial-guess-(interpolated)","page":"Initial guess options","title":"Vector initial guess (interpolated)","text":"","category":"section"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"Initialization can also be provided with vectors / matrices to be interpolated along a given time grid.  In this case the time steps must be given through an additional argument time, which can be a vector or line/column matrix. For the values to be interpolated both matrices and vectors of vectors are allowed, but the shape should be number of time steps x variable dimension. Simple vectors are also allowed for variables of dimension 1.","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"time_vec = LinRange(t0,tf,4)\nx_vec = [[0, 0], [-0.1, 0.3], [-0.15,0.4], [-0.3, 0.5]]\nu_vec = [0, -0.8,  -0.3, 0]\n\nsol = solve(ocp, display=false, init=(time=time_vec, state=x_vec, control=u_vec, variable=0.05))\n\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"Note: in the free final time case, the given time grid should be consistent with the initial guess provided for the final time (in the optimization variables).","category":"page"},{"location":"tutorial-init.html#Mixed-initial-guess","page":"Initial guess options","title":"Mixed initial guess","text":"","category":"section"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"The constant, functional and vector initializations can be mixed, for instance as","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"sol = solve(ocp, display=false, init=(state=[-0.2, 0.1], control=u, variable=0.05))\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide\n\nsol = solve(ocp, display=false, init=(time=time_vec, state=x_vec, control=u, variable=0.05))\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-init.html#Solution-as-initial-guess-(warm-start)","page":"Initial guess options","title":"Solution as initial guess (warm start)","text":"","category":"section"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"Finally, we can use an existing solution to provide the initial guess.  The dimensions of the state, control and optimization variable must coincide. This particular feature allows an easy implementation of discrete continuations.","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"# generate the initial solution\nsol_init = solve(ocp, display=false)\n\n# solve the problem using solution as initial guess\nsol = solve(ocp, init=sol_init, display=false)\n\n# print the number of iterations\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"Note that you can also manually pick and choose which data to reuse from a solution, by recovering the functions sol.state, sol.control and the values sol.variable. For instance the following formulation is equivalent to the init=sol one.","category":"page"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"sol = solve(ocp, display=false, init=(state=sol.state, control=sol.control, variable=sol.variable))\nprintln(\"Number of iterations: \", sol.iterations)\nnothing # hide","category":"page"},{"location":"tutorial-init.html#Costate-/-multipliers","page":"Initial guess options","title":"Costate / multipliers","text":"","category":"section"},{"location":"tutorial-init.html","page":"Initial guess options","title":"Initial guess options","text":"For the moment we can not provide an initial guess for the costate / multipliers.","category":"page"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"<img width=\"800\" alt=\"juliacon\" src=\"./assets/juliacon.jpg\">","category":"page"},{"location":"juliacon2023.html#Solving-optimal-control-problems-with-Julia","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"","category":"section"},{"location":"juliacon2023.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://scholar.google.com/citations?userpkH4An4AAAAJ-and-hlfr),-[Pierre-Martinon](https://www.linkedin.com/in/pierre-martinon-b4603a17),-[Sophia-Sed](https://iww.inria.fr/sed-sophia)","page":"Solving optimal control problems with Julia","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"page"},{"location":"juliacon2023.html#What-it's-about","page":"Solving optimal control problems with Julia","title":"What it's about","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"subject to","category":"page"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"plus boundary, control and state constraints","category":"page"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"juliacon2023.html#Where-it-comes-from","page":"Solving optimal control problems with Julia","title":"Where it comes from","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"BOCOP: the optimal control solver\nHamPath: indirect and Hamiltonian pathfollowing\nCoupling direct and indirect solvers, examples","category":"page"},{"location":"juliacon2023.html#OptimalControl.jl","page":"Solving optimal control problems with Julia","title":"OptimalControl.jl","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Basic example: double integrator\nBasic example: double integrator (cont'ed)\nAdvanced example: Goddard problem","category":"page"},{"location":"juliacon2023.html#Wrap-up","page":"Solving optimal control problems with Julia","title":"Wrap up","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"[X] High level modelling of optimal control problems\n[X] Efficient numerical resolution coupling direct and indirect methods\n[X] Collection of examples ","category":"page"},{"location":"juliacon2023.html#Future","page":"Solving optimal control problems with Julia","title":"Future","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"ct_repl\nAdditional solvers: direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions!\nCTProblems.jl","category":"page"},{"location":"juliacon2023.html#control-toolbox.org","page":"Solving optimal control problems with Julia","title":"control-toolbox.org","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"juliacon2023.html#Credits-(not-exhaustive!)","page":"Solving optimal control problems with Julia","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"juliacon2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"DifferentialEquations.jl\nJuMP, InfiniteOpt.jl, ADNLPModels.jl\nIpopt\nJuliaDiff (FowardDiff.jl, Zygote.jl)\nMLStyle.jl\nREPLMaker.jl","category":"page"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"<img width=\"800\" alt=\"juliaopt2023\" src=\"./assets/juliaopt2023.jpg\">","category":"page"},{"location":"juliaopt2023.html#Solving-optimal-control-problems-with-Julia","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"","category":"section"},{"location":"juliaopt2023.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://scholar.google.com/citations?userpkH4An4AAAAJ-and-hlfr),-[Pierre-Martinon](https://www.linkedin.com/in/pierre-martinon-b4603a17),-[Sophia-Sed](https://iww.inria.fr/sed-sophia)","page":"Solving optimal control problems with Julia","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"page"},{"location":"juliaopt2023.html#What-it's-about","page":"Solving optimal control problems with Julia","title":"What it's about","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"subject to","category":"page"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"plus boundary, control and state constraints","category":"page"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"juliaopt2023.html#Where-it-comes-from","page":"Solving optimal control problems with Julia","title":"Where it comes from","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"BOCOP: the optimal control solver\nHamPath: indirect and Hamiltonian pathfollowing\nCoupling direct and indirect solvers, examples","category":"page"},{"location":"juliaopt2023.html#OptimalControl.jl","page":"Solving optimal control problems with Julia","title":"OptimalControl.jl","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Basic example: double integrator (1/3)\nBasic example: double integrator (2/3)\nBasic example: double integrator (3/3)\nIndirect simple shooting\nAdvanced example: Goddard problem","category":"page"},{"location":"juliaopt2023.html#Wrap-up","page":"Solving optimal control problems with Julia","title":"Wrap up","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"[X] High level modelling of optimal control problems\n[X] Efficient numerical resolution coupling direct and indirect methods\n[X] Collection of examples","category":"page"},{"location":"juliaopt2023.html#Future","page":"Solving optimal control problems with Julia","title":"Future","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"ct_repl\nAdditional solvers: direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions!\nCTProblems.jl","category":"page"},{"location":"juliaopt2023.html#control-toolbox.org","page":"Solving optimal control problems with Julia","title":"control-toolbox.org","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"juliaopt2023.html#Credits-(not-exhaustive!)","page":"Solving optimal control problems with Julia","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"juliaopt2023.html","page":"Solving optimal control problems with Julia","title":"Solving optimal control problems with Julia","text":"DifferentialEquations.jl\nJuMP, InfiniteOpt.jl, ADNLPModels.jl\nIpopt\nJuliaDiff (FowardDiff.jl, Zygote.jl)\nMLStyle.jl\nREPLMaker.jl","category":"page"},{"location":"tutorial-plot.html#Plot-a-solution","page":"Plot a solution","title":"Plot a solution","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In this tutorial we explain the different ways to plot a solution of an optimal control problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Let us start by importing the package to define the problem and solve it.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using OptimalControl\nusing NLPModelsIpopt","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Then, we define a simple optimal control problem and solve it.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"@def ocp begin\n\n    t ∈ [ 0, 1 ], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n\n    ẋ(t) == [ x₂(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\n\nsol = solve(ocp, display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html#First-ways-to-plot","page":"Plot a solution","title":"First ways to plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"The simplest way to plot the solution is to use the plot function with only the solution as argument.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: The plot function\nThe plot function on a solution of an optimal control problem is an extension of the plot function from the package Plots.jl. Hence, we need to import this package to plot a solution.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using Plots\nplot(sol)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"As you can see, it produces a grid of subplots. The left column contains the state trajectories, the right column the costate trajectories, and at the bottom we have the control trajectory.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"Attributes from Plots.jl can be passed to the plot function:","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"In addition to sol you can pass attributes to the full Plot, see the attributes plot documentation from Plots.jl for more details. For instance, you can specify the size of the figure.\nYou can also pass attributes to the subplots, see the attributes subplot documentation from Plots.jl for more details. However, it will affect all the subplots. For instance, you can specify the location of the legend.\nIn the same way, you can pass axis attributes to the subplots, see the attributes axis documentation from Plots.jl for more details. It will also affect all the subplots. For instance, you can remove the grid.\nIn the same way, you can pass series attributes to the all the subplots, see the attributes series documentation from Plots.jl for more details. It will also affect all the subplots. For instance, you can set the width of the curves with linewidth.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, size=(700, 450), legend=:bottomright, grid=false, linewidth=2)","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"To specify series attributes to a specific subplot, you can use the optional keyword arguments state_style, costate_style and control_style which correspond respectively to the state, costate and control trajectories. See the attribute series documentation from Plots.jl for more details. For instance, you can specify the color of the state trajectories and more.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, \n     state_style   = (color=:blue,), \n     costate_style = (color=:black, linestyle=:dash),\n     control_style = (color=:red, linewidth=2))","category":"page"},{"location":"tutorial-plot.html#Split-versus-group-layout","page":"Plot a solution","title":"Split versus group layout","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"If you prefer to get a more compact figure, you can use the layout optional keyword argument with :group value. It will group the state, costate and control trajectories in one subplot for each.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"plot(sol, layout=:group, size=(800, 300))","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Default layout value\nThe default layout value is :split which corresponds to the grid of subplots presented above.","category":"page"},{"location":"tutorial-plot.html#Additional-plots","page":"Plot a solution","title":"Additional plots","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can plot the solution of a second optimal control problem on the same figure if it has the same number of states, costates and controls. For instance, consider the same optimal control problem but with a different initial condition.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"@def ocp begin\n\n    t ∈ [ 0, 1 ], time\n    x ∈ R², state\n    u ∈ R, control\n\n    x(0) == [ -0.5, -0.5 ]\n    x(1) == [ 0, 0 ]\n\n    ẋ(t) == [ x₂(t), u(t) ]\n\n    ∫( 0.5u(t)^2 ) → min\n\nend\nsol2 = solve(ocp, display=false)\nnothing # hide","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We first plot the solution of the first optimal control problem, then, we plot the solution of the second optimal control problem on the same figure, but with dashed lines.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"# first plot\nplt = plot(sol, solution_label=\"(sol1)\", size=(700, 500))\n\n# second plot\nplot!(plt, sol2, solution_label=\"(sol2)\", linestyle=:dash)","category":"page"},{"location":"tutorial-plot.html#Plot-the-norm-of-the-control","page":"Plot a solution","title":"Plot the norm of the control","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"For some problem, it is interesting to plot the norm of the control. You can do it by using the control optional keyword argument with :norm value. The default value is :components. Let us illustrate this on the consumption minimisation orbital transfer problem from CTProlbems.jl.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using CTProblems\nprob = Problem(:orbital_transfert, :consumption)\nplot(prob.solution, control=:norm, size=(800, 300), layout=:group)","category":"page"},{"location":"tutorial-plot.html#Custom-plot","page":"Plot a solution","title":"Custom plot","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"You can of course create your own plots by getting the state, costate and control from the optimal control solution. For instance, let us plot the norm of the control for the orbital transfer problem.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"using LinearAlgebra\nt = sol.times\nx = sol.state\np = sol.costate\nu = sol.control\nplot(t, norm∘u, label=\"‖u‖\") ","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"note: Nota bene\nThe norm function is from LinearAlgebra.jl. \nThe ∘ operator is the composition operator. Hence, norm∘u is the function t -> norm(u(t)). \nThe sol.state, sol.costate and sol.control are functions that return the state, costate and control trajectories at a given time.","category":"page"},{"location":"tutorial-plot.html#Normalized-time","page":"Plot a solution","title":"Normalized time","text":"","category":"section"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"We consider a LQR example and solve the problem for different values of the final time tf. Then, we plot the solutions on the same figure considering a normalized time s=(t-t_0)(t_f-t_0), thanks to the keyword argument time=:normalized of the plot function.","category":"page"},{"location":"tutorial-plot.html","page":"Plot a solution","title":"Plot a solution","text":"\n# parameters\nx0 = [ 0\n       1 ]\n\nA  = [ 0 1\n      -1 0 ]\n\nB  = [ 0\n       1 ]\n\n# definition\nfunction lqr(tf)\n\n    @def ocp begin\n        t ∈ [ 0, tf ], time\n        x ∈ R², state\n        u ∈ R, control\n        x(0) == x0\n        ẋ(t) == A * x(t) + B * u(t)\n        ∫( 0.5(x₁(t)^2 + x₂(t)^2 + u(t)^2) ) → min\n    end\n\n    return ocp\nend;\n\n# solve\nsolutions = []\ntfs = [3, 5, 30]\nfor tf ∈ tfs\n    solution = solve(lqr(tf), display=false)\n    push!(solutions, solution)\nend\n\n# create plots\nplt = plot(solutions[1], time=:normalized)\nfor sol ∈ solutions[2:end]\n    plot!(plt, sol, time=:normalized)\nend\n\n# make a custom plot from created plots: only state and control are plotted\nN = length(tfs)\npx1 = plot(plt[1], legend=false, xlabel=\"s\", ylabel=\"x₁\")\npx2 = plot(plt[2], label=reshape([\"tf = $tf\" for tf ∈ tfs], (1, N)), xlabel=\"s\", ylabel=\"x₂\")\npu  = plot(plt[5], legend=false, xlabel=\"s\", ylabel=\"u\")\n\nusing Plots.PlotMeasures # for leftmargin, bottommargin\nplot(px1, px2, pu, layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)","category":"page"},{"location":"api-ctproblems.html#CTProblems-API","page":"CTProblems API","title":"CTProblems API","text":"","category":"section"},{"location":"api-ctproblems.html","page":"CTProblems API","title":"CTProblems API","text":"This is just a dump of CTProblems API documentation. For more details about CTProblems.jl package, see the documentation.","category":"page"},{"location":"api-ctproblems.html#Index","page":"CTProblems API","title":"Index","text":"","category":"section"},{"location":"api-ctproblems.html","page":"CTProblems API","title":"CTProblems API","text":"Pages   = [\"api-ctproblems.md\"]\nModules = [CTProblems]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-ctproblems.html#Documentation","page":"CTProblems API","title":"Documentation","text":"","category":"section"},{"location":"api-ctproblems.html","page":"CTProblems API","title":"CTProblems API","text":"Modules = [CTProblems]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctproblems.html#CTProblems.CTProblems","page":"CTProblems API","title":"CTProblems.CTProblems","text":"CTProblems module.\n\nLists all the imported modules and packages:\n\nBase\nCTBase\nCTFlows\nCore\nDocStringExtensions\nLinearAlgebra\n\nList of all the exported names:\n\nProblem\n@Problems\nProblems\n@ProblemsDescriptions\nProblemsDescriptions\n\n\n\n\n\n","category":"module"},{"location":"api-ctproblems.html#CTProblems.Problem-Tuple{Vararg{Symbol}}","page":"CTProblems API","title":"CTProblems.Problem","text":"Problem(\n    description::Symbol...\n) -> CTProblems.OptimalControlProblem\n\n\nReturn the optimal control problem described by description.\n\nIf you give a partial description, then, if several complete descriptions contains the partial one, then,  only the problem with the highest priority is returned. The higher in the list, the higher is the priority.\n\nExample\n\njulia> Problem(:integrator, :energy)\n\n\n\n\n\n","category":"method"},{"location":"api-ctproblems.html#CTProblems.Problems-Tuple{Vararg{Symbol}}","page":"CTProblems API","title":"CTProblems.Problems","text":"Problems(\n    description::Symbol...\n) -> Tuple{Vararg{CTProblems.OptimalControlProblem}}\n\n\nReturn the list of optimal control problems consistent with the description.\n\nIf you give a partial description, then, if several complete descriptions contains the partial one, then,  only the problem with the highest priority is returned. The higher in the list, the higher is the priority.\n\nExample\n\njulia> Problems(:integrator, :energy)\n\n\n\n\n\n","category":"method"},{"location":"api-ctproblems.html#CTProblems.ProblemsDescriptions-Tuple{Vararg{Symbol}}","page":"CTProblems API","title":"CTProblems.ProblemsDescriptions","text":"ProblemsDescriptions(\n    description::Symbol...\n) -> Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n\n\nReturn the list of problems descriptions consistent with the description, as a Tuple of Description. \n\nExample\n\njulia> ProblemsDescriptions(:integrator, :energy)\n\n\n\n\n\n","category":"method"},{"location":"api-ctproblems.html#CTProblems.@Problems","page":"CTProblems API","title":"CTProblems.@Problems","text":"Return the list of problems consistent with the description.\n\nExample\n\njulia> @Problems :integrator & :energy\n\nnote: Note\nYou have to define a logical condition with the combination of symbols and the three  operators: !, | and &, respectively for the negation, the disjunction and the conjunction.\n\n\n\n\n\n","category":"macro"},{"location":"api-ctproblems.html#CTProblems.@ProblemsDescriptions","page":"CTProblems API","title":"CTProblems.@ProblemsDescriptions","text":"Return the list of problems descriptions consistent with the expression.\n\nExample\n\njulia> @ProblemsDescriptions :integrator & :energy\n\nnote: Note\nYou have to define a logical condition with the combination of symbols and the three  operators: !, | and &, respectively for the negation, the disjunction and the conjunction.\n\n\n\n\n\n","category":"macro"},{"location":"tutorial-double-integrator.html#double-int","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"","category":"section"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"The problem consists in minimising the final time t_f for the double integrator system","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) quad u(t) in -11","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"and the limit conditions","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"    x(0) = (12) quad x(t_f) = (00)","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"This problem can be interpretated as a simple model for a wagon with constant mass moving along a line without fricton.","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"First, we need to import the OptimalControl.jl package to define and solve the optimal control problem. We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"Then, we can define the problem","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"@def ocp begin\n\n    tf ∈ R,          variable\n    t ∈ [ 0, tf ],   time\n    x = (q, v) ∈ R², state\n    u ∈ R,           control\n\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n\n    q(0)  == 1\n    v(0)  == 2\n    q(tf) == 0\n    v(tf) == 0\n\n     0 ≤ q(t) ≤ 5,          (1)\n    -2 ≤ v(t) ≤ 3,          (2)\n\n    ẋ(t) == [ v(t), u(t) ]\n\n    tf → min\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"note: Nota bene\nIn order to ensure convergence of the direct solver, we have added the state constraints labelled (1) and (2):0 leq q(t) leq 5quad -2 leq v(t) leq 3quad t in  0 t_f ","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"Solve it","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"and plot the solution","category":"page"},{"location":"tutorial-double-integrator.html","page":"Double integrator: time minimisation","title":"Double integrator: time minimisation","text":"plot(sol)","category":"page"},{"location":"api.html#OptimalControl-API","page":"API","title":"OptimalControl API","text":"","category":"section"},{"location":"api.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Pages   = [\"api.md\"]\nModules = [OptimalControl]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api.html#Available-methods","page":"API","title":"Available methods","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"using OptimalControl\navailable_methods()","category":"page"},{"location":"api.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [OptimalControl]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api.html#OptimalControl.OptimalControl","page":"API","title":"OptimalControl.OptimalControl","text":"OptimalControl module.\n\nLists all the imported modules and packages:\n\nBase\nCTBase\nCTDirect\nCTFlows\nCore\nDocStringExtensions\n\nList of all the exported names:\n\n*\nAutonomous\nControlConstraint\nControlLaw\nFeedbackControl\nFixed\nFlow\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\nIndex\n@Lie\nLie\nLift\nMixedConstraint\nModel\nMultiplier\nNonAutonomous\nNonFixed\nParsingError\nPoisson\nStateConstraint\nVectorField\n__OCPModel\navailable_methods\nconstraint\nconstraint!\ncontrol!\nct_repl\n@def\ndynamics!\nis_max\nis_min\nis_time_dependent\nis_time_independent\nis_variable_dependent\nis_variable_independent\nobjective!\nplot\nplot!\nremove_constraint!\nsolve\nstate!\ntime!\nvariable!\n∂ₜ\n⋅\n\n\n\n\n\n","category":"module"},{"location":"api.html#OptimalControl.available_methods-Tuple{}","page":"API","title":"OptimalControl.available_methods","text":"available_methods() -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api.html#OptimalControl.solve-Tuple{OptimalControlModel, Vararg{Symbol}}","page":"API","title":"OptimalControl.solve","text":"solve(\n    ocp::OptimalControlModel,\n    description::Symbol...;\n    display,\n    init,\n    kwargs...\n)\n\n\nSolve the the optimal control problem ocp by the method given by the (optional) description.\n\nThe (optional) description\n\nYou can pass a partial description. If you give a partial description, then, if several complete descriptions contains the partial one,  then, the method with the highest priority is chosen. The higher in the list,  the higher is the priority.\n\nKeyword arguments:\n\ndisplay: print or not information during the resolution\ninit: an initial condition for the solver\n\nwarning: Warning\nThere is only one available method for the moment: a direct method which transforms the optimal control problem into a nonlinear programming problem (NLP) solved by Ipopt, thanks to the package  ADNLPModels. The direct method comes from the  CTDirect package.\n\ntip: Tip\nTo see the list of available methods, simply call available_methods().\nYou can pass any other option by a pair keyword=value according to the chosen method.\n\nExamples\n\njulia> sol = solve(ocp)\njulia> sol = solve(ocp, :direct)\njulia> sol = solve(ocp, :direct, :ipopt)\njulia> sol = solve(ocp, :direct, :ipopt, display=false)\njulia> sol = solve(ocp, :direct, :ipopt, display=false, init=sol)\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2],))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5, variable=[1, 2]))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=t->6-12*t))\njulia> sol = solve(ocp, init=(state=t->[-1+t, t*(t-1)], control=0.5))\njulia> sol = solve(ocp, init=(state=t->[-1+t, t*(t-1)], control=t->6-12*t))\n\n\n\n\n\n","category":"method"},{"location":"api-ctflows.html#CTFlows-API","page":"CTFlows API","title":"CTFlows API","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows API","title":"CTFlows API","text":"This is just a dump of CTFlows API documentation. For more details about CTFlows.jl package, see the documentation.","category":"page"},{"location":"api-ctflows.html#Index","page":"CTFlows API","title":"Index","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows API","title":"CTFlows API","text":"Pages   = [\"api-ctflows.md\"]\nModules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-ctflows.html#Documentation","page":"CTFlows API","title":"Documentation","text":"","category":"section"},{"location":"api-ctflows.html","page":"CTFlows API","title":"CTFlows API","text":"Modules = [CTFlows]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"tutorial-goddard.html#goddard","page":"Goddard problem","title":"Goddard problem","text":"","category":"section"},{"location":"tutorial-goddard.html#Introduction","page":"Goddard problem","title":"Introduction","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"<img src=\"./assets/Goddard_and_Rocket.jpg\" style=\"float: left; margin: auto 10px;\" width=\"200px\">","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"For this advanced example, we consider the well-known Goddard problem[1] [2] which models the ascent of a rocket through the atmosphere, and we restrict here ourselves to vertical (one dimensional) trajectories. The state variables are the altitude r, speed v and mass m of the rocket during the flight, for a total dimension of 3. The rocket is subject to gravity g, thrust u and drag force D (function of speed and altitude). The final time t_f is free, and the objective is to reach a maximal altitude with a bounded fuel consumption.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"We thus want to solve the optimal control problem in Mayer form","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"    r(t_f) to max","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"subject to the controlled dynamics","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"    dotr = v quad\n    dotv = fracT_maxu - D(rv)m - g quad\n    dotm = -u","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"and subject to the control constraint u(t) in 01 and the state constraint v(t) leq v_max. The initial state is fixed while only the final mass is prescribed.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"note: Nota bene\nThe Hamiltonian is affine with respect to the control, so singular arcs may occur, as well as constrained arcs due to the path constraint on the velocity (see below).","category":"page"},{"location":"tutorial-goddard.html#Direct-method","page":"Goddard problem","title":"Direct method","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"using Suppressor # to suppress warnings","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"We import the OptimalControl.jl package to define and solve the optimal control problem. We import the Plots.jl package to plot the solution. The DifferentialEquations.jl package is used to define the shooting function for the indirect method and the MINPACK.jl package permits solve the shooting equation.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"using OptimalControl\nusing NLPModelsIpopt\nusing DifferentialEquations # to get the Flow function\nusing NonlinearSolve        # NLE solver\nusing Plots","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"We define the problem","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"t0 = 0      # initial time\nr0 = 1      # initial altitude\nv0 = 0      # initial speed\nm0 = 1      # initial mass\nvmax = 0.1  # maximal authorized speed\nmf = 0.6    # final mass to target\n\n@def ocp begin # definition of the optimal control problem\n\n    tf ∈ R, variable\n    t ∈ [ t0, tf ], time\n    x = (r, v, m) ∈ R³, state\n    u ∈ R, control\n\n    x(t0) == [ r0, v0, m0 ]\n    m(tf) == mf,         (1)\n    0 ≤ u(t) ≤ 1\n    r(t) ≥ r0\n    0 ≤ v(t) ≤ vmax\n\n    ẋ(t) == F0(x(t)) + u(t) * F1(x(t))\n\n    r(tf) → max\n\nend;\n\n# Dynamics\nconst Cd = 310\nconst Tmax = 3.5\nconst β = 500\nconst b = 2\n\nF0(x) = begin\n    r, v, m = x\n    D = Cd * v^2 * exp(-β*(r - 1)) # Drag force\n    return [ v, -D/m - 1/r^2, 0 ]\nend\n\nF1(x) = begin\n    r, v, m = x\n    return [ 0, Tmax/m, -b*Tmax ]\nend\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"We then solve it","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"direct_sol = OptimalControl.solve(ocp, grid_size=100)\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"and plot the solution","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"plt = plot(direct_sol, solution_label=\"(direct)\", size=(800, 800))","category":"page"},{"location":"tutorial-goddard.html#Indirect-method","page":"Goddard problem","title":"Indirect method","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"We first determine visually the structure of the optimal solution which is composed of a bang arc with maximal control, followed by a singular arc, then by a boundary arc and the final arc is with zero control. Note that the switching function vanishes along the singular and boundary arcs.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"t = direct_sol.times\nx = direct_sol.state\nu = direct_sol.control\np = direct_sol.costate\n\nH1 = Lift(F1)           # H1(x, p) = p' * F1(x)\nφ(t) = H1(x(t), p(t))   # switching function\ng(x) = vmax - x[2]      # state constraint v ≤ vmax\n\nu_plot  = plot(t, u,     label = \"u(t)\")\nH1_plot = plot(t, φ,     label = \"H₁(x(t), p(t))\")\ng_plot  = plot(t, g ∘ x, label = \"g(x(t))\")\n\nplot(u_plot, H1_plot, g_plot, layout=(3,1), size=(500, 500))","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"We are now in position to solve the problem by an indirect shooting method. We first define the four control laws in feedback form and their associated flows. For this we need to compute some Lie derivatives, namely Poisson brackets of Hamiltonians (themselves obtained as lifts to the cotangent bundle of vector fields), or derivatives of functions along a vector field. For instance, the control along the minimal order singular arcs is obtained as the quotient","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"u_s = -fracH_001H_101","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"of length three Poisson brackets:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"H_001 = H_0H_0H_1 quad H_101 = H_1H_0H_1","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"where, for two Hamiltonians H and G,","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"HG = (nabla_p Hnabla_x G) - (nabla_x Hnabla_p G)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"While the Lie derivative of a function f wrt. a vector field X is simply obtained as","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"(X cdot f)(x) = f(x) cdot X(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"and is used to the compute the control along the boundary arc,","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"u_b(x) = -(F_0 cdot g)(x)  (F_1 cdot g)(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"as well as the associated multiplier for the order one state constraint on the velocity:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"mu(x p) = H_01(x p)  (F_1 cdot g)(x)","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"note: Poisson bracket and Lie derivative\nThe Poisson bracket HG is also given by the Lie derivative of G along the Hamiltonian vector field X_H = (nabla_p H -nabla_x H) of H, that is    HG = X_H cdot Gwhich is the reason why we use the @Lie macro to compute Poisson brackets below.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"With the help of the differential geometry primitives from CTBase.jl, these expressions are straightforwardly translated into Julia code:","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"# Controls\nu0 = 0                                  # off control\nu1 = 1                                  # bang control\n\nH0 = Lift(F0)                           # H0(x, p) = p' * F0(x)\nH01  = @Lie { H0, H1 }\nH001 = @Lie { H0, H01 }\nH101 = @Lie { H1, H01 }\nus(x, p) = -H001(x, p) / H101(x, p)     # singular control\n\nub(x) = -(F0⋅g)(x) / (F1⋅g)(x)          # boundary control\nμ(x, p) = H01(x, p) / (F1⋅g)(x)         # multiplier associated to the state constraint g\n\n# Flows\nf0 = Flow(ocp, (x, p, tf) -> u0)\nf1 = Flow(ocp, (x, p, tf) -> u1)\nfs = Flow(ocp, (x, p, tf) -> us(x, p))\nfb = Flow(ocp, (x, p, tf) -> ub(x), (x, u, tf) -> g(x), (x, p, tf) -> μ(x, p))\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"Then, we define the shooting function according to the optimal structure we have determined, that is a concatenation of four arcs.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"x0 = [ r0, v0, m0 ] # initial state\n\nfunction shoot!(s, p0, t1, t2, t3, tf)\n\n    x1, p1 = f1(t0, x0, p0, t1)\n    x2, p2 = fs(t1, x1, p1, t2)\n    x3, p3 = fb(t2, x2, p2, t3)\n    xf, pf = f0(t3, x3, p3, tf)\n\n    s[1] = constraint(ocp, :eq1)(x0, xf, tf) - mf # final mass constraint (1)\n    s[2:3] = pf[1:2] - [ 1, 0 ]                   # transversality conditions\n    s[4] = H1(x1, p1)                             # H1 = H01 = 0\n    s[5] = H01(x1, p1)                            # at the entrance of the singular arc\n    s[6] = g(x2)                                  # g = 0 when entering the boundary arc\n    s[7] = H0(xf, pf)                             # since tf is free\n\nend\nnothing # hide","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"To solve the problem by an indirect shooting method, we then need a good initial guess, that is a good approximation of the initial costate, the three switching times and the final time.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"η = 1e-3\nt13 = t[ abs.(φ.(t)) .≤ η ]\nt23 = t[ 0 .≤ (g ∘ x).(t) .≤ η ]\np0 = p(t0)\nt1 = min(t13...)\nt2 = min(t23...)\nt3 = max(t23...)\ntf = t[end]\n\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\nusing LinearAlgebra: norm\ns = similar(p0, 7)\n@suppress_err begin # hide\nshoot!(s, p0, t1, t2, t3, tf)\nend # hide\nprintln(\"Norm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"Finally, we can solve the shooting equations thanks to the MINPACK solver.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"nle = (s, ξ, λ) -> shoot!(s, ξ[1:3], ξ[4], ξ[5], ξ[6], ξ[7])   # auxiliary function\n                                                               # with aggregated inputs\nξ = [ p0 ; t1 ; t2 ; t3 ; tf ]                                 # initial guess\n\nprob = NonlinearProblem(nle, ξ)\nglobal indirect_sol =      # hide\n@suppress_err begin # hide\nNonlinearSolve.solve(prob)      # hide\nindirect_sol = NonlinearSolve.solve(prob)                       # resolution of S(p0) = 0\nend                 # hide\n\n# we retrieve the costate solution together with the times\np0 = indirect_sol.u[1:3]\nt1 = indirect_sol.u[4]\nt2 = indirect_sol.u[5]\nt3 = indirect_sol.u[6]\ntf = indirect_sol.u[7]\n\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\ns = similar(p0, 7)\n@suppress_err begin # hide\nshoot!(s, p0, t1, t2, t3, tf)\nend # hide\nprintln(\"Norm of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"We plot the solution of the indirect solution (in red) over the solution of the direct method (in blue).","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"f = f1 * (t1, fs) * (t2, fb) * (t3, f0) # concatenation of the flows\nflow_sol = f((t0, tf), x0, p0)          # compute the solution: state, costate, control...\n\nplot!(plt, flow_sol, solution_label=\"(indirect)\")","category":"page"},{"location":"tutorial-goddard.html#References","page":"Goddard problem","title":"References","text":"","category":"section"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"[1]: R.H. Goddard. A Method of Reaching Extreme Altitudes, volume 71(2) of Smithsonian Miscellaneous Collections. Smithsonian institution, City of Washington, 1919.","category":"page"},{"location":"tutorial-goddard.html","page":"Goddard problem","title":"Goddard problem","text":"[2]: H. Seywald and E.M. Cliff. Goddard problem in presence of a dynamic pressure limit. Journal of Guidance, Control, and Dynamics, 16(4):776–781, 1993.","category":"page"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"<img width=\"800\" alt=\"juliaopt2023\" src=\"./assets/fgs-2024.jpg\">","category":"page"},{"location":"fgs-2024.html#control-toolbox:-solving-optimal-control-problems-within-Julia","page":"FGS 2024","title":"control-toolbox: solving optimal control problems within Julia","text":"","category":"section"},{"location":"fgs-2024.html#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://scholar.google.com/citations?userpkH4An4AAAAJ-and-hlfr),-[Pierre-Martinon](https://www.linkedin.com/in/pierre-martinon-b4603a17),-[Sophia-Sed](https://iww.inria.fr/sed-sophia)","page":"FGS 2024","title":"Jean-Baptiste Caillau, Olivier Cots, Joseph Gergaud, Pierre Martinon, Sophia Sed","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"<img width=\"800\" alt=\"affiliations\" src=\"./assets/affil.jpg\">","category":"page"},{"location":"fgs-2024.html#What-it's-about","page":"FGS 2024","title":"What it's about","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"Nonlinear optimal control of ODEs:","category":"page"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"g(x(t_0)x(t_f)) + int_t_0^t_f f^0(x(t) u(t)) mathrmdt to min","category":"page"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"subject to","category":"page"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"dotx(t) = f(x(t) u(t))quad t in t_0 t_f","category":"page"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"plus boundary, control and state constraints","category":"page"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"Our core interests: numerical & geometrical methods in control, applications","category":"page"},{"location":"fgs-2024.html#Where-it-comes-from","page":"FGS 2024","title":"Where it comes from","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"BOCOP: the optimal control solver\nHamPath: indirect and Hamiltonian pathfollowing\nCoupling direct and indirect solvers, examples","category":"page"},{"location":"fgs-2024.html#OptimalControl.jl","page":"FGS 2024","title":"OptimalControl.jl","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"Double integrator\nBatch processing\nGoddard problem","category":"page"},{"location":"fgs-2024.html#Wrap-up","page":"FGS 2024","title":"Wrap up","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"High level modelling of optimal control problems\nEfficient numerical resolution coupling direct and indirect methods\nCollection of examples","category":"page"},{"location":"fgs-2024.html#Future","page":"FGS 2024","title":"Future","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"New applications (biology, space mechanics, quantum mechanics and more)\nAdditional solvers: direct shooting, collocation for BVP, Hamiltonian pathfollowing...\n... and open to contributions!\nCTProblems.jl","category":"page"},{"location":"fgs-2024.html#control-toolbox.org","page":"FGS 2024","title":"control-toolbox.org","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"Open toolbox\nCollection of Julia Packages rooted at OptimalControl.jl","category":"page"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"<a href=\"https://control-toolbox.org\"><img width=\"800\" alt=\"control-toolbox.org\" src=\"./assets/control-toolbox.jpg\"></a>","category":"page"},{"location":"fgs-2024.html#Credits-(not-exhaustive!)","page":"FGS 2024","title":"Credits (not exhaustive!)","text":"","category":"section"},{"location":"fgs-2024.html","page":"FGS 2024","title":"FGS 2024","text":"ADNLPModels.jl\nDifferentiationInterface.jl\nDifferentialEquations.jl\nMLStyle.jl","category":"page"},{"location":"tutorial-basic-example-f.html#basic-f","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"","category":"section"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force u. We denote by x = (x_1 x_2) the state of the wagon, that is its position x_1 and its velocity x_2.","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"<img src=\"./assets/chariot.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"300px\">","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"We assume that the mass is constant and unitary and that there is no friction. The dynamics we consider is given by","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"    dot x_1(t) = x_2(t) quad dot x_2(t) = u(t) quad u(t) in R","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"which is simply the double integrator system. Les us consider a transfer starting at time t_0 = 0 and ending at time t_f = 1, for which we want to minimise the transfer energy","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"    frac12int_0^1 u^2(t)  mathrmdt","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"starting from the condition x(0) = (-1 0) and with the goal to reach the target x(1) = (0 0).","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"note: Solution and details\nSee the page  Double integrator: energy minimisation  for the analytical solution and details about this problem.","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"First, we need to import the OptimalControl.jl package to define and solve the optimal control problem. We also need to import the Plots.jl package to plot the solution.","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"using OptimalControl\nusing NLPModelsIpopt\nusing Plots","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"Then, we can define the problem","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"ocp = Model()                                   # empty optimal control problem\n\ntime!(ocp, t0=0, tf=1)                          # initial and final times\nstate!(ocp, 2)                                  # dimension of the state\ncontrol!(ocp, 1)                                # dimension of the control\n\nconstraint!(ocp, :initial; lb=[ -1, 0 ], ub=[ -1, 0 ]) # initial condition\nconstraint!(ocp, :final;   lb=[  0, 0 ], ub=[  0, 0 ]) # final condition\n\ndynamics!(ocp, (x, u) -> [ x[2], u ])           # dynamics of the double integrator\n\nobjective!(ocp, :lagrange, (x, u) -> 0.5u^2)    # cost in Lagrange form\nnothing # hide","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"note: Nota bene\nThere are two ways to define an optimal control problem:using functions like in this example, see also the Model documentation for more details.\nusing an abstract formulation, see for instance basic example to compare.","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"Solve it","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"sol = solve(ocp)\nnothing # hide","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"and plot the solution","category":"page"},{"location":"tutorial-basic-example-f.html","page":"Basic example (functional version)","title":"Basic example (functional version)","text":"plot(sol)","category":"page"},{"location":"index.html#OptimalControl.jl","page":"Introduction","title":"OptimalControl.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule =  OptimalControl","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The OptimalControl.jl package aims to provide tools to solve optimal control problems by direct and indirect methods. It is part of the control-toolbox ecosystem:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"<img src=\"./assets/diagram.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"320px\">","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Install and documentation\nTo install a package from the control-toolbox ecosystem,  please visit the installation page. The documentation is accessible from the main menu.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"An optimal control problem with fixed initial and final times can be described as minimising the cost functional","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"g(x(t_0) x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and other constraints such as","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"See our tutorials to get started solving optimal control problems.","category":"page"}]
}
