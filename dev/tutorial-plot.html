<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Plot a solution · OptimalControl.jl</title><meta name="title" content="Plot a solution · OptimalControl.jl"/><meta property="og:title" content="Plot a solution · OptimalControl.jl"/><meta property="twitter:title" content="Plot a solution · OptimalControl.jl"/><meta name="description" content="Documentation for OptimalControl.jl."/><meta property="og:description" content="Documentation for OptimalControl.jl."/><meta property="twitter:description" content="Documentation for OptimalControl.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://control-toolbox.org/assets/css/documentation.css" rel="stylesheet" type="text/css"/><script src="https://control-toolbox.org/assets/js/documentation.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">OptimalControl.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Getting Started</a></li><li><span class="tocitem">Basic Examples</span><ul><li><a class="tocitem" href="tutorial-double-integrator-energy.html">Energy minimisation</a></li><li><a class="tocitem" href="tutorial-double-integrator-time.html">Time mininimisation</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="tutorial-abstract.html">Define a problem</a></li><li><a class="tocitem" href="tutorial-initial-guess.html">Set an initial guess</a></li><li><a class="tocitem" href="tutorial-solve.html">Solve a problem</a></li><li class="is-active"><a class="tocitem" href="tutorial-plot.html">Plot a solution</a><ul class="internal"><li><a class="tocitem" href="#The-problem-and-the-solution"><span>The problem and the solution</span></a></li><li><a class="tocitem" href="#tutorial-plot-basic"><span>Basic concepts</span></a></li><li><a class="tocitem" href="#tutorial-plot-flow"><span>From Flow</span></a></li><li><a class="tocitem" href="#tutorial-plot-layout"><span>Split versus group layout</span></a></li><li><a class="tocitem" href="#tutorial-plot-add"><span>Add a plot</span></a></li><li><a class="tocitem" href="#tutorial-plot-control"><span>Plot the norm of the control</span></a></li><li><a class="tocitem" href="#tutorial-plot-custom"><span>Custom plot</span></a></li><li><a class="tocitem" href="#tutorial-plot-time"><span>Normalised time</span></a></li></ul></li><li><a class="tocitem" href="tutorial-flow.html">Compute flows</a></li></ul></li><li><span class="tocitem">Tutorials and Advanced Features</span><ul><li><a class="tocitem" href="tutorial-continuation.html">Discrete continuation</a></li><li><a class="tocitem" href="tutorial-discretisation.html">Discretisation methods</a></li><li><a class="tocitem" href="tutorial-nlp.html">NLP manipulations</a></li><li><a class="tocitem" href="tutorial-iss.html">Indirect simple shooting</a></li><li><a class="tocitem" href="tutorial-goddard.html">Goddard: direct, indirect</a></li><li><a class="tocitem" href="tutorial-lqr-basic.html">Linear–quadratic regulator</a></li><li><a class="tocitem" href="tutorial-mam.html">Minimal action</a></li></ul></li><li><span class="tocitem">Developers</span><ul><li><a class="tocitem" href="dev-optimalcontrol.html">OptimalControl.jl</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Subpackages</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="dev-ctbase.html">CTBase.jl</a></li><li><a class="tocitem" href="dev-ctdirect.html">CTDirect.jl</a></li><li><a class="tocitem" href="dev-ctflows.html">CTFlows.jl</a></li><li><a class="tocitem" href="dev-ctmodels.html">CTModels.jl</a></li><li><a class="tocitem" href="dev-ctparser.html">CTParser.jl</a></li></ul></li></ul></li><li><a class="tocitem" href="zhejiang-2025.html">Zhejiang 2025</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href="tutorial-plot.html">Plot a solution</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tutorial-plot.html">Plot a solution</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/control-toolbox/OptimalControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/control-toolbox/OptimalControl.jl/blob/main/docs/src/tutorial-plot.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial-plot"><a class="docs-heading-anchor" href="#tutorial-plot">How to plot a solution</a><a id="tutorial-plot-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial-plot" title="Permalink"></a></h1><p>In this tutorial, we explain the different options for plotting the solution of an optimal control problem using the <code>plot</code> and <code>plot!</code> functions, which are extensions of the <a href="https://docs.juliaplots.org">Plots.jl</a> package. Use <code>plot</code> to create a new plot object, and <code>plot!</code> to add to an existing one:</p><pre><code class="language-julia hljs">plot(args...; kw...)           # creates a new Plot, and set it to be the `current`
plot!(args...; kw...)          # modifies Plot `current()`
plot!(plt, args...; kw...)     # modifies Plot `plt`</code></pre><p>More precisely, the signature of <code>plot</code> is as follows.</p><pre><code class="language-julia hljs">function plot(
    sol;            # optimal control solution
    layout,         # layout of the subplots
    control,        # plot the norm or components of the control
    time,           # normalise the time or not
    size,           # size of the figure
    solution_label, # suffix for the labels
    state_style,    # style for the state trajectory
    costate_style,  # style for the costate trajectory
    control_style,  # style for the control trajectory
    kwargs...,      # attributes from Plots
)</code></pre><p>In the following, we detail the roles of the arguments.</p><table><tr><th style="text-align: left">Section</th><th style="text-align: left">Arguments</th></tr><tr><td style="text-align: left"><a href="tutorial-plot.html#tutorial-plot-basic">Basic concepts</a></td><td style="text-align: left"><code>size</code>, <code>state_style</code>, <code>costate_style</code>, <code>control_style</code>, <code>kwargs...</code></td></tr><tr><td style="text-align: left"><a href="tutorial-plot.html#tutorial-plot-layout">Split versus group layout</a></td><td style="text-align: left"><code>layout</code></td></tr><tr><td style="text-align: left"><a href="tutorial-plot.html#tutorial-plot-control">Plot the norm of the control</a></td><td style="text-align: left"><code>control</code></td></tr><tr><td style="text-align: left"><a href="tutorial-plot.html#tutorial-plot-time">Normalised time</a></td><td style="text-align: left"><code>time</code></td></tr><tr><td style="text-align: left"><a href="tutorial-plot.html#tutorial-plot-add">Add a plot</a></td><td style="text-align: left"><code>solution_label</code></td></tr></table><p>You can plot a solution obtained from the <code>solve</code> function, as well as from the flow computed using an optimal control problem and a control law. See, respectively, <a href="tutorial-plot.html#tutorial-plot-basic">Basic Concepts</a> and <a href="tutorial-plot.html#tutorial-plot-flow">From Flow</a> sections for more details.</p><p>You can also retrieve the state, the costate and the control to create your own plots, see <a href="tutorial-plot.html#tutorial-plot-custom">Custom plot</a> section.</p><h2 id="The-problem-and-the-solution"><a class="docs-heading-anchor" href="#The-problem-and-the-solution">The problem and the solution</a><a id="The-problem-and-the-solution-1"></a><a class="docs-heading-anchor-permalink" href="#The-problem-and-the-solution" title="Permalink"></a></h2><p>Let us start by importing the packages needed to define and solve the problem.</p><pre><code class="language-julia hljs">using OptimalControl
using NLPModelsIpopt</code></pre><p>We consider the simple optimal control problem from the <a href="tutorial-double-integrator-energy.html#tutorial-double-integrator-energy">basic example tutorial</a>.</p><pre><code class="language-julia hljs">const t0 = 0            # initial time
const tf = 1            # final time
const x0 = [ -1, 0 ]    # initial condition
const xf = [  0, 0 ]    # final condition

ocp = @def begin

    t ∈ [t0, tf], time
    x ∈ R², state
    u ∈ R, control

    x(t0) == x0
    x(tf) == xf

    ẋ(t) == [x₂(t), u(t)]

    ∫( 0.5u(t)^2 ) → min

end

sol = solve(ocp, display=false)</code></pre><h2 id="tutorial-plot-basic"><a class="docs-heading-anchor" href="#tutorial-plot-basic">Basic concepts</a><a id="tutorial-plot-basic-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial-plot-basic" title="Permalink"></a></h2><p>The simplest way to plot the solution is to use the <code>plot</code> function with the solution as the only argument.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>plot</code> function for a solution of an optimal control problem extends the <code>plot</code> function from Plots. Therefore, you need to import this package in order to plot a solution.</p></div></div><pre><code class="language-julia hljs">using Plots
plot(sol)</code></pre><img src="tutorial-plot-bc2fad0e.svg" alt="Example block output"/><p>In the figure above, we have a grid of subplots: the left column displays the state component trajectories, the right column shows the costate component trajectories, and the bottom row contains the control component trajectories.</p><p>As in Plots, input data is passed positionally (for example, <code>sol</code> in <code>plot(sol)</code>), and attributes are passed as keyword arguments (for example, <code>plot(sol; color = :blue)</code>). After executing <code>using Plots</code> in the REPL, you can use the <code>plotattr()</code> function to print a list of all available attributes for series, plots, subplots, or axes.</p><pre><code class="language-julia hljs"># Valid Operations
plotattr(:Plot)
plotattr(:Series)
plotattr(:Subplot)
plotattr(:Axis)</code></pre><p>Once you have the list of attributes, you can either use the aliases of a specific attribute or inspect a specific attribute to display its aliases and description.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; plotattr(&quot;color&quot;) # Specific Attribute Example</code><code class="nohighlight hljs ansi" style="display:block;">:seriescolor

The base color for this series. `:auto` (the default) will select a color from the subplot&#39;s `color_palette`, based on the order it was added to the subplot. Also describes the colormap for surfaces.

Aliases: (:c, :cmap, :color, :colormap, :colour, :seriescolors).

Type: Union{Integer, Symbol, ColorSchemes.ColorScheme, ColorTypes.Colorant}.

`Series` attribute, defaults to `auto`.</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Some attributes have different default values in OptimalControl compared to Plots. For instance, the default figure size is 600x400 in Plots, while in OptimalControl, it depends on the number of states and controls.</p></div></div><p>You can also visit the Plot documentation online to get the descriptions of the attributes:</p><ul><li>To pass attributes to the plot, see the <a href="https://docs.juliaplots.org/latest/generated/attributes_plot/">attributes plot</a> documentation. For instance, you can specify the size of the figure.</li><li>You can pass attributes to all subplots at once by referring to the <a href="https://docs.juliaplots.org/latest/generated/attributes_subplot/">attributes subplot</a> documentation. For example, you can specify the location of the legends.</li><li>Similarly, you can pass axis attributes to all subplots. See the <a href="https://docs.juliaplots.org/latest/generated/attributes_axis/">attributes axis</a> documentation. For example, you can remove the grid from every subplot.</li><li>Finally, you can pass series attributes to all subplots. Refer to the <a href="https://docs.juliaplots.org/latest/generated/attributes_series/">attributes series</a> documentation. For instance, you can set the width of the curves using <code>linewidth</code>.</li></ul><pre><code class="language-julia hljs">plot(sol, size=(700, 450), legend=:bottomright, grid=false, linewidth=2)</code></pre><img src="tutorial-plot-b6073287.svg" alt="Example block output"/><p>To specify series attributes for a specific group of subplots (state, costate or control), you can use the optional keyword arguments <code>state_style</code>, <code>costate_style</code>, and <code>control_style</code>, which correspond to the state, costate, and control trajectories, respectively.</p><pre><code class="language-julia hljs">plot(sol;
     state_style   = (color=:blue,),                    # style of the state trajectory
     costate_style = (color=:black, linestyle=:dash),   # style of the costate trajectory
     control_style = (color=:red, linewidth=2))         # style of the control trajectory</code></pre><img src="tutorial-plot-832bcde6.svg" alt="Example block output"/><h2 id="tutorial-plot-flow"><a class="docs-heading-anchor" href="#tutorial-plot-flow">From Flow</a><a id="tutorial-plot-flow-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial-plot-flow" title="Permalink"></a></h2><p>The previous solution of the optimal control problem was obtained using the <code>solve</code> function. If you prefer using an indirect shooting method and solving shooting equations, you may also want to plot the associated solution. To do this, you need to use the <code>Flow</code> function to reconstruct the solution. See the manual on <a href="tutorial-flow.html#manual-flow">how to compute flows</a> for more details. In our case, you must provide the maximizing control <span>$(x, p) \mapsto p_2$</span> along with the optimal control problem. For an introduction to simple indirect shooting, see the <a href="tutorial-iss.html#tutorial-indirect-simple-shooting">indirect simple shooting</a> tutorial for an example.</p><div class="admonition is-success"><header class="admonition-header">Interactions with an optimal control solution</header><div class="admonition-body"><p>Please check <a href="dev-ctmodels.html#CTModels.state-Union{Tuple{CTModels.Solution{&lt;:CTModels.AbstractTimeGridModel, &lt;:CTModels.AbstractTimesModel, &lt;:CTModels.StateModelSolution{TS}}}, Tuple{TS}} where TS&lt;:Function"><code>state</code></a>, <a href="dev-ctmodels.html#CTModels.costate-Union{Tuple{CTModels.Solution{&lt;:CTModels.AbstractTimeGridModel, &lt;:CTModels.AbstractTimesModel, &lt;:CTModels.AbstractStateModel, &lt;:CTModels.AbstractControlModel, &lt;:CTModels.AbstractVariableModel, Co}}, Tuple{Co}} where Co&lt;:Function"><code>costate</code></a>, <a href="dev-ctmodels.html#CTModels.control-Union{Tuple{CTModels.Solution{&lt;:CTModels.AbstractTimeGridModel, &lt;:CTModels.AbstractTimesModel, &lt;:CTModels.AbstractStateModel, &lt;:CTModels.ControlModelSolution{TS}}}, Tuple{TS}} where TS&lt;:Function"><code>control</code></a>, and <a href="dev-ctmodels.html#CTModels.variable-Union{Tuple{CTModels.Solution{&lt;:CTModels.AbstractTimeGridModel, &lt;:CTModels.AbstractTimesModel, &lt;:CTModels.AbstractStateModel, &lt;:CTModels.AbstractControlModel, &lt;:CTModels.VariableModelSolution{TS}}}, Tuple{TS}} where TS&lt;:Union{Real, AbstractVector{&lt;:Real}}"><code>variable</code></a> to retrieve data from the solution. The functions <code>state</code>, <code>costate</code>, and <code>control</code> return functions of time, while <code>variable</code> returns a vector.</p></div></div><pre><code class="language-julia hljs">using OrdinaryDiffEq

p  = costate(sol)                # costate as a function of time
p0 = p(t0)                       # costate solution at the initial time
f  = Flow(ocp, (x, p) -&gt; p[2])   # flow from an ocp and a control law

sol_flow = f( (t0, tf), x0, p0 ) # compute the solution
plot(sol_flow)                   # plot the solution from a flow</code></pre><img src="tutorial-plot-91343f69.svg" alt="Example block output"/><p>We may notice that the time grid contains very few points. This is evident from the subplot of <span>$x_2$</span>, or by retrieving the time grid directly from the solution.</p><pre><code class="language-julia hljs">time_grid(sol_flow)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Float64}:
 0.0
 0.002765360243588406
 0.023631266188700685
 0.12877324251759437
 0.5279162676838509
 1.0</code></pre><p>To improve visualization (without changing the accuracy), you can provide a finer grid.</p><pre><code class="language-julia hljs">fine_grid = range(t0, tf, 100)
sol_flow = f( (t0, tf), x0, p0; saveat=fine_grid )
plot(sol_flow)</code></pre><img src="tutorial-plot-59176a89.svg" alt="Example block output"/><h2 id="tutorial-plot-layout"><a class="docs-heading-anchor" href="#tutorial-plot-layout">Split versus group layout</a><a id="tutorial-plot-layout-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial-plot-layout" title="Permalink"></a></h2><p>If you prefer to get a more compact figure, you can use the <code>layout</code> optional keyword argument with <code>:group</code> value. It will group the state, costate and control trajectories in one subplot for each.</p><pre><code class="language-julia hljs">plot(sol; layout=:group, size=(800, 300))</code></pre><img src="tutorial-plot-aa1e0565.svg" alt="Example block output"/><p>The default layout value is <code>:split</code> which corresponds to the grid of subplots presented above.</p><pre><code class="language-julia hljs">plot(sol; layout=:split)</code></pre><img src="tutorial-plot-1bb6083c.svg" alt="Example block output"/><h2 id="tutorial-plot-add"><a class="docs-heading-anchor" href="#tutorial-plot-add">Add a plot</a><a id="tutorial-plot-add-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial-plot-add" title="Permalink"></a></h2><p>You can plot the solution of a second optimal control problem on the same figure if it has the same number of states, costates and controls. For instance, consider the same optimal control problem but with a different initial condition.</p><pre><code class="language-julia hljs">ocp = @def begin

    t ∈ [t0, tf], time
    x ∈ R², state
    u ∈ R, control

    x(t0) == [-0.5, -0.5]
    x(tf) == xf

    ẋ(t) == [x₂(t), u(t)]

    ∫( 0.5u(t)^2 ) → min

end
sol2 = solve(ocp; display=false)</code></pre><p>We first plot the solution of the first optimal control problem, then, we plot the solution of the second optimal control problem on the same figure, but with dashed lines.</p><pre><code class="language-julia hljs">plt = plot(sol; solution_label=&quot;(sol1)&quot;, size=(700, 500))
plot!(plt, sol2; solution_label=&quot;(sol2)&quot;, linestyle=:dash)</code></pre><img src="tutorial-plot-65ab60b3.svg" alt="Example block output"/><h2 id="tutorial-plot-control"><a class="docs-heading-anchor" href="#tutorial-plot-control">Plot the norm of the control</a><a id="tutorial-plot-control-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial-plot-control" title="Permalink"></a></h2><p>For some problem, it is interesting to plot the (Euclidean) norm of the control. You can do it by using the <code>control</code> optional keyword argument with <code>:norm</code> value.</p><pre><code class="language-julia hljs">plot(sol; control=:norm, size=(800, 300), layout=:group)</code></pre><img src="tutorial-plot-edde9ed0.svg" alt="Example block output"/><p>The default value is <code>:components</code>.</p><pre><code class="language-julia hljs">plot(sol; control=:components, size=(800, 300), layout=:group)</code></pre><img src="tutorial-plot-3b24b57c.svg" alt="Example block output"/><h2 id="tutorial-plot-custom"><a class="docs-heading-anchor" href="#tutorial-plot-custom">Custom plot</a><a id="tutorial-plot-custom-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial-plot-custom" title="Permalink"></a></h2><p>You can, of course, create your own plots by extracting the <code>state</code>, <code>costate</code>, and <code>control</code> from the optimal control solution. For instance, let us plot the norm of the control.</p><pre><code class="language-julia hljs">using LinearAlgebra
t = time_grid(sol)
x = state(sol)
p = costate(sol)
u = control(sol)
plot(t, norm∘u; label=&quot;‖u‖&quot;)</code></pre><img src="tutorial-plot-97300f3c.svg" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Nota bene</header><div class="admonition-body"><ul><li>The <code>norm</code> function is from <code>LinearAlgebra.jl</code>. </li><li>The <code>∘</code> operator is the composition operator. Hence, <code>norm∘u</code> is the function <code>t -&gt; norm(u(t))</code>. </li></ul></div></div><h2 id="tutorial-plot-time"><a class="docs-heading-anchor" href="#tutorial-plot-time">Normalised time</a><a id="tutorial-plot-time-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial-plot-time" title="Permalink"></a></h2><p>We consider a <a href="@ref">LQR example</a> and solve the problem for different values of the final time <code>tf</code>. Then, we plot the solutions on the same figure using a normalized time <span>$s = (t - t_0) / (t_f - t_0)$</span>, enabled by the keyword argument <code>time = :normalize</code> (or <code>:normalise</code>) in the <code>plot</code> function.</p><pre><code class="language-julia hljs"># definition of the problem, parameterised by the final time
function lqr(tf)

    ocp = @def begin
        t ∈ [0, tf], time
        x ∈ R², state
        u ∈ R, control
        x(0) == [0, 1]
        ẋ(t) == [x₂(t), - x₁(t) + u(t)]
        ∫( 0.5(x₁(t)^2 + x₂(t)^2 + u(t)^2) ) → min
    end

    return ocp
end;

# solve the problems and store them
solutions = []
tfs = [3, 5, 30]
for tf ∈ tfs
    solution = solve(lqr(tf); display=false)
    push!(solutions, solution)
end

# create plots
plt = plot(solutions[1]; time=:normalize)
for sol ∈ solutions[2:end]
    plot!(plt, sol; time=:normalize)
end

# make a custom plot: keep only state and control
N = length(tfs)
px1 = plot(plt[1]; legend=false, xlabel=&quot;s&quot;, ylabel=&quot;x₁&quot;)
px2 = plot(plt[2]; label=reshape([&quot;tf = $tf&quot; for tf ∈ tfs], (1, N)), xlabel=&quot;s&quot;, ylabel=&quot;x₂&quot;)
pu  = plot(plt[5]; legend=false, xlabel=&quot;s&quot;, ylabel=&quot;u&quot;)

using Plots.PlotMeasures # for leftmargin, bottommargin
plot(px1, px2, pu; layout=(1, 3), size=(800, 300), leftmargin=5mm, bottommargin=5mm)</code></pre><img src="tutorial-plot-a9edeef3.svg" alt="Example block output"/><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="tutorial-solve.html">« Solve a problem</a><a class="docs-footer-nextpage" href="tutorial-flow.html">Compute flows »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Wednesday 30 April 2025 16:47">Wednesday 30 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
